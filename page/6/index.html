<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.1',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  
  <meta name="keywords" content="Hexo, NexT">


<meta name="description" content="this is description">
<meta property="og:type" content="website">
<meta property="og:title" content="Little H title">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Little H title">
<meta property="og:description" content="this is description">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Little H title">
<meta name="twitter:description" content="this is description">






  <link rel="canonical" href="http://yoursite.com/page/6/">


  <title>Little H title</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Little H title</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">this is subtitle</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益404</a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/07/视频格式基础知识/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/视频格式基础知识/" itemprop="url">视频格式基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T19:47:30+08:00">2018-02-07</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/多媒体/" itemprop="url" rel="index"><span itemprop="name">多媒体</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="看连接内容好了-我只是存个档"><a href="#看连接内容好了-我只是存个档" class="headerlink" title="看连接内容好了,我只是存个档"></a>看连接内容好了,我只是存个档</h1><p><a href="https://vcb-s.com/archives/2726" target="_blank" rel="noopener">[VCB-Studio 科普教程 3] 视频格式基础知识</a></p>
<h1 id="VCB-Studio-科普教程-3-视频格式基础知识"><a href="#VCB-Studio-科普教程-3-视频格式基础知识" class="headerlink" title="[VCB-Studio 科普教程 3] 视频格式基础知识"></a>[VCB-Studio 科普教程 3] 视频格式基础知识</h1><p>这本来是群内写给队友做入门知识学习的，然后觉得挺适合改改贴出来向大家科普，所以就有了这篇教程。之前的两篇播放器教程可以算 1 和 2 吧。</p>
<p>本教程意在讲述一些视频音频制作的基础知识和术语，适合不了解压片原理的收片党们自学。它可以比较详细地回答以下常见的问题：</p>
<ul>
<li><p>MP4/MKV 这些格式有什么区别？哪个画质好？</p>
</li>
<li><p>视频的码率是怎么算的？为什么同样是 1080p 的视频，有些体积大有些体积小？</p>
</li>
<li><p>视频储存的图像信息是什么格式的？跟显示器一样的红绿蓝么？</p>
</li>
<li><p>8-bit/10-bit 到底指的什么？为什么说 8-bit 显示器还有必要看 10-bit 视频？</p>
</li>
<li><p>YUV420/444 这些标示到底什么意思？哪个好？</p>
</li>
<li><p>线条，平面，纹理这些到底是什么意思？视频为啥还有高频低频？</p>
</li>
<li><p>码率越高的视频画质越好么？</p>
</li>
</ul>
<h2 id="本教程将分以下模块详细叙述："><a href="#本教程将分以下模块详细叙述：" class="headerlink" title="本教程将分以下模块详细叙述："></a>本教程将分以下模块详细叙述：</h2><ol>
<li><p>封装格式（MP4/MKV…）vs 媒体格式（H.264/FLAC/AAC…）</p>
</li>
<li><p>视频的基础参数：分辨率、帧率和码率</p>
</li>
<li><p>图像的表示方法：RGB 模型 vs YUV 模型</p>
</li>
<li><p>色深</p>
</li>
<li><p>色度半采样</p>
</li>
<li><p>空间上的低频与高频：平面、纹理和线条</p>
</li>
<li><p>时间上的低频与高频：动态</p>
</li>
<li><p>清晰度与画质简述</p>
</li>
</ol>
<h3 id="1、封装格式-MP4-MKV…-vs-媒体格式-H-264-FLAC-AAC…"><a href="#1、封装格式-MP4-MKV…-vs-媒体格式-H-264-FLAC-AAC…" class="headerlink" title="1、封装格式(MP4/MKV…)  vs 媒体格式(H.264/FLAC/AAC…)"></a>1、封装格式(MP4/MKV…)  vs 媒体格式(H.264/FLAC/AAC…)</h3><p>MP4+MKV是你下载的视频文件最常见的种类。这些文件其实类似一个<strong>包裹</strong>，它的后缀则是包裹的包装方式。这些包裹里面，<strong>包含了视频（只有图像），音频（只有声音），字幕等</strong>。当播放器在播放的时候，首先对这个包裹进行拆包（专业术语叫做<strong>分离</strong>/splitting）,把其中的视频、音频等拿出来，再进行播放。</p>
<p>既然它们只是一个包裹，就意味着这个后缀不能保证里面的东西是啥，也不能保证到底有多少东西。包裹里面的每一件物品，我们称之为<strong>轨道(track)</strong>，一般有这么些：</p>
<p><strong>视频(Video)</strong>: 一般来说肯定都有，但是也有例外，比如mka格式的外挂音轨，其实就是没视频的mkv。<strong>注意我们说到视频的时候，是不包括声音的</strong>。</p>
<p><strong>音频(audio)</strong>：一般来说也肯定有，但是有些情况是静音的，就没必要带了。</p>
<p><strong>章节(Chapter)</strong>: 蓝光原盘中自带的分段信息。如果文件带上了，那么你可以在播放器中看到带章节的效果：</p>
<ul>
<li><p>potplayer右键画面，选项-播放-在进度条上显示书签/章节标记</p>
</li>
<li><p>mpc-hc 右键画面，选项-调节-在进度条显示章节标记</p>
</li>
</ul>
<p><strong>字幕(Subtitles)</strong>：有些时候文件自带字幕，并且字幕并非是直接整合于视频的硬字幕，那么就是一起被打包在封装容器中。</p>
<p>其他可能还有附件等，不一一列举。每个类型也不一定只有一条轨道，比如经常见到带多音轨的MKV。</p>
<p><strong>每个轨道，都有自己的格式。</strong>比如大家常说的，视频是H.264，音频是AAC，这些就是每个轨道的格式。</p>
<p>视频的格式，常见的有H.264(可以细分为8bit/10bit)，H.265(当前也有8bit/10bit之分)，RealVideo(常见于早期rm/rmvb)，VC-1(微软主导的，常见于wmv)。基本上，H.264=AVC=AVC1, H.265=HEVC。</p>
<p>音频的格式，常见的有 FLAC/ALAC/TrueHD/DTS-HD MA这<strong>四种无损</strong>，和AAC/MP3/AC3/DTS(Core)这<strong>四种有损</strong>。</p>
<p><strong>MKV vs MP4，主要的区别在于：</strong></p>
<ol>
<li>MKV支持封装FLAC作为音频，MP4则不支持。但是MP4也可以封装无损音轨(比如说ALAC，虽然普遍认为ALAC的效率不如FLAC优秀)</li>
<li>MKV支持封装ASS/SSA格式的字幕，MP4则不支持。一般字幕组制作的字幕是ASS格式，所以内封字幕多见于MKV格式</li>
<li>MP4作为工业标准，在视频编辑软件和播放设备上的<strong>兼容性</strong>一般好于MKV。这也是vcb-s那些为<strong>移动设备</strong>优化的视频基本上选择MP4封装的原因。<br>除此之外，这两个格式很大程度上可以互相代替。比如它们都支持封装AVC和HEVC，包括8bit/10bit的精度。<strong>所以MP4画质不如MKV好，这种论断是非常无知的——它们完全可以封装一样的视频</strong>。</li>
</ol>
<p>为什么会有这样的分歧，就是历史原因了。MKV是民间研发，<strong>为了代替古老的AVI</strong>，从而更好地支持H264，它开发和修改的灵活度使得它可以兼容flac/ass这类非工业标准的格式；而MP4则是出生豪门，作为工业标准，<strong>替代更古老的MPG</strong>，作为新一代视频/音频封装服务的。</p>
<h3 id="2、视频的基础参数：分辨率，帧率和码率。"><a href="#2、视频的基础参数：分辨率，帧率和码率。" class="headerlink" title="2、视频的基础参数：分辨率，帧率和码率。"></a>2、视频的基础参数：分辨率，帧率和码率。</h3><p>视频是由连续的图像构成的。<strong>每一张图像，我们称为一帧(frame)</strong>。图像则是由像素(pixel)构成的。<strong>一张图像有多少像素，称为这个图像的分辨率</strong>。比如说1920×1080的图像，说明它是由横纵1920×1080个像素点构成。视频的分辨率就是每一帧图像的分辨率。</p>
<p>一个视频，<strong>每一秒由多少图像构成，称为这个视频的帧率(frame-rate)</strong>。常见的帧率有24000/1001=23.976, 30000/1001=29.970, 60000/1001=59.940, 25.000, 50.000等等。这个数字是一秒钟内闪过的图像的数量。比如23.976，就是1001秒内，有24000张图像。视频的<strong>帧率是可以是恒定的</strong>(cfr, Const Frame-Rate)，<strong>也可以是变化的</strong>(vfr, Variable Frame-Rate)</p>
<p><strong>码率</strong>的定义是视频文件体积除以时间。单位一般是Kbps(Kbit/s)或者Mbps(Mbit/s)。注意1B(Byte)=8b(bit)。所以一个24分钟，900MB的视频：</p>
<p>体积：900MB = 900MByte = 7200Mbit</p>
<p>时间：24min = 1440s</p>
<p>码率：7200/1440  = 5000 Kbps = 5Mbps</p>
<p>当视频文件的时间基本相同的时候（比如现在一集番大概是24分钟），码率和体积基本上是等价的，<strong>都是用来描述视频大小的参数</strong>。长度分辨率都相同的文件，体积不同，实际上就是码率不同。</p>
<p><strong>码率也可以解读为单位时间内，用来记录视频的数据总量。码率越高的视频，意味着用来记录视频的数据量越多，潜在的解读就是视频可以拥有更好的质量</strong>。（注意，<strong>仅仅是潜在</strong>，后文我们会分析为什么高码率不一定等于高画质）</p>
<h3 id="3、图像的表示方法：RGB模型-vs-YUV模型"><a href="#3、图像的表示方法：RGB模型-vs-YUV模型" class="headerlink" title="3、图像的表示方法：RGB模型 vs YUV模型"></a>3、图像的表示方法：RGB模型 vs YUV模型</h3><p>光的三原色是红(Red)、绿(Green)、蓝(Blue)。现代的显示器技术就是通过组合不同强度的三原色，来达成几乎任何一种可见光的颜色。图像储存中，通过记录每个像素<strong>红绿蓝强度</strong>，来记录图像的方法，称为RGB模型 (RGB Model)</p>
<p>常见的图片格式中，<strong>PNG和BMP</strong>这两种就是基于RGB模型的。</p>
<p>比如说原图：<br><img src="1111.jpg" alt="1111"><br>分别只显示R G B通道的强度，效果如下：<br><img src="111.jpg" alt="111"><br><img src="1112.jpg" alt="1112"><br><img src="1113.jpg" alt="1113"><br>三个通道下，信息量和细节程度不一定是均匀分布的。比如说可以注意南小鸟脸上的红晕，在3个平面上的区分程度就不同——红色平面下几乎无从区分，造成区别的主要是绿色和蓝色的平面。外围白色的脸颊，三色都近乎饱和；但是红晕部分，只有红色饱和，绿色和蓝色不饱和。这是造成红色凸显的原因。</p>
<p>除了RGB模型，还有一种广泛采用的模型，称为<strong>YUV模型</strong>，又被称为<strong>亮度-色度模型（Luma-Chroma）</strong>。它是通过数学转换，将RGB三个通道，转换为一个代表亮度的通道(Y,又称为Luma)，和两个代表色度的通道(UV，并成为Chroma)。</p>
<p>举个形象点的例子：一家养殖场饲养猪和牛，一种记数方式是：（猪的数量，牛的数量）</p>
<p>但是也可以这么记录：（总数量=猪的数量+牛的数量，相差=猪的数量-牛的数量）。两种方法之间有数学公式可以互转。</p>
<p>YUV模型干的是类似的事儿。通过对RGB数据的合理转换，得到另一种表示方式。YUV模型下，还有不同的实现方式。举个用的比较多的YCbCr模型：它把RGB转换成一个亮度(Y)，和 蓝色色度(Cb) 以及 红色色度(Cr)。转换背后复杂的公式大家不需要了解，只需要看看效果：</p>
<p>只有亮度通道：<br><img src="1114.jpg" alt="1114"><br>只有蓝色色度：<br><img src="1115.jpg" alt="1115"><br>只有红色色度：<br><img src="1116.jpg" alt="1116"><br>在图像视频的加工与储存中，YUV格式一般更受欢迎，理由如下：</p>
<p>1、人眼对亮度的敏感度远高于色度，因此人眼看到的有效信息主要来自于亮度。YUV模型可以将绝大多数的有效信息分配到Y通道。UV通道相对记录的信息少的多。相对于RGB模型较为平均的分配，YUV模型将多数有效信息集中在Y通道，不但减少了冗余信息量，还为压缩提供了便利</p>
<p>2、保持了对黑白显示设备的向下兼容</p>
<p>3、图像编辑中，调节亮度和颜色饱和度，在YUV模型下更方便。</p>
<p><strong>几乎所有的视频格式，以及广泛使用的JPEG图像格式，都是基于YCbCr模型的。播放的时候，播放器需要将YCbCr的信息，通过计算，转换为RGB。这个步骤称为渲染（Rendering）</strong></p>
<p>每个通道的记录，通常是用整数来表示。比如RGB24，就是RGB各8个bit，用0~255 (8bit的二进制数范围)来表示某个颜色的强弱。YUV模型也不例外，也是用整数来表示每个通道的高低。</p>
<h3 id="4、色深"><a href="#4、色深" class="headerlink" title="4、色深"></a>4、色深</h3><p><strong>色深(bit-depth)</strong>，就是我们通常说的<strong>8bit和10bit</strong>，是指每个通道的精度。8bit就是每个通道用一个8bit整数(0~255)代表，10bit就是用10bit整数(0~1023)来显示。16bit则是0~65535</p>
<p>(注意，上文的表述是不严谨的，视频在编码的时候，并非一定能用到0~255的所有范围，而是可能有所保留，只用到一部分，比如16~235。这我们就不详细展开了)</p>
<p>你的显示器是8bit的，代表它能显示RGB每个通道0~255所有强度。但是视频的色深是YUV的色深，播放的时候，YUV需要通过计算转换到RGB。因此，<strong>10bit的高精度是间接的</strong>，它使得运算过程中精度增加，以让最后的颜色更细腻。</p>
<h4 id="如何理解8bit显示器，播放10bit是有必要的呢："><a href="#如何理解8bit显示器，播放10bit是有必要的呢：" class="headerlink" title="如何理解8bit显示器，播放10bit是有必要的呢："></a>如何理解8bit显示器，播放10bit是有必要的呢：</h4><p>一个圆的半径是12.33m, 求它的面积，保留两位小数。</p>
<p>半径的精度给定两位小数，结果也要求两位小数，那么圆周率精度需要给多高呢？也只要两位小数么？<br>取pi=3.14, 面积算出来是477.37平方米<br>取pi=3.1416，面积算出来是477.61平方米<br>取pi精度足够高，面积算出来是477.61平方米。所以取pi=3.1416是足够的，但是3.14就不够了。</p>
<p>换言之，即便最终输出的精度要求较低，也不意味着参与运算的数字，以及运算过程，可以保持较低的精度。在最终输出是8bit RGB的前提下，10bit YUV比起8bit YUV依旧具有精度优势的原因就在这里。<strong>事实上，8bit YUV转换后，覆盖的精度大概相当于8bit RGB的26%，而10bit转换后的精度大约可以覆盖97%——你想让你家8bit显示器发挥97%的细腻度么？看10bit吧。</strong></p>
<p>8bit精度不足，主要表现在亮度较低的区域，容易形成色带：<br><img src="logo11.png" alt="logo11.png"><br>注意这图右边那一圈圈跟波浪一样的效果。这就是颜色精度不足的表现。</p>
<p>10bit的优势不只在于显示精度的提高，在提高视频压缩率，减少失真方面，相对8bit也有优势。这方面就不展开了。</p>
<h3 id="5、色度半采样"><a href="#5、色度半采样" class="headerlink" title="5、色度半采样"></a>5、色度半采样</h3><p>在YUV模型的应用中，<strong>Y和UV的重要性是不等同的</strong>。图像视频的实际储存和传输中，通常将<strong>Y以全分辨率记录，UV以减半甚至1/4的分辨率记录</strong>。这个手段被称为<strong>色度半采样(Chroma Sub-Sampling)</strong>。色度半采样可以有效减少传输带宽，和加大UV平面的压缩率，但是不可避免的会损失UV平面的有效信息。</p>
<p>我们平常的视频，<strong>最常见的是420采样</strong>。配合YUV格式，常常被写作yuv420。这种采样是Y保留全部，UV只以(1/2) x (1/2)的分辨率记录。比如说1920×1080的视频，其实只有亮度平面是1920×1080。两个色度平面都只有960×540的分辨率。</p>
<p>当然了，你也可以选择不做缩减。这种称为<strong>444采样，或者yuv444</strong>。YUV三个平面全是满分辨率。</p>
<p>在做YUV-&gt;RGB的时候，首先需要将缩水的UV分辨率拉升到Y的分辨率（madVR中允许自定义算法，在Chroma Upscaling当中），然后再转换到RGB。做RGB-&gt;YUV的转换，也是先转换到444（YUV的分辨率相同），再将UV分辨率降低。</p>
<p><strong>一般能拿到的片源，包括所有蓝光原盘，都是420采样的</strong>。所以成品一般也保留420采样。所以yuv420就表示这个视频是420采样的yuv格式。</p>
<p>将420做成444格式，需要自己手动将UV分辨率拉升2×2倍。在今天madVR等渲染器可以很好地拉升UV平面的情况下，这种做法无异于毫无必要的拉升DVD做成伪高清。</p>
<p>当然了，<strong>有时候也需要在444/RGB平面下做处理和修复，常见的比如视频本身RGB平面不重叠</strong>（比如摩卡少女樱），这种修复过程首先要将UV分辨率拉升，然后转RGB，做完修复再转回YUV。修复后的结果相当于全新构图，这种情况下保留444格式就是有理由，有必要的。</p>
<p>H264格式编码444格式，需要High 4:4:4 Predictive Profile（简称Hi444pp）。<strong>所以看到Hi444pp/yuv444 之类的标示，你就需要去找压制者的陈述，为什么他要做这么个拉升。如果找不到有效的理由，你应该默认作者是在瞎做</strong>。</p>
<h3 id="6、空间上的低频与高频：平面，纹理和线条"><a href="#6、空间上的低频与高频：平面，纹理和线条" class="headerlink" title="6、空间上的低频与高频：平面，纹理和线条"></a>6、空间上的低频与高频：平面，纹理和线条</h3><p>在视频处理中，<strong>空间(spatial)</strong>的概念指的是一帧图片以内（你可以认为就是一张图所呈现的二维空间/平面）。跟<strong>时间(temporal)</strong>相对；时间的概念就强调帧与帧之间的变换。</p>
<p>于是我们重新来看这张亮度的图：<br><img src="1117.jpg" alt="1117"></p>
<p><strong>亮度变化较快，变动幅度大的区域</strong>，我们称之为<strong>高频区域</strong>。否则，亮度变化缓慢且不明显的区域，我们称为低频区域。</p>
<p>图中的<strong>蓝圈</strong>就是一块典型的<strong>低频</strong>区域，或者就叫做<strong>平面</strong>（平坦的部分）。亮度几乎没有变化</p>
<p><strong>绿圈</strong>中，亮度呈现跳跃式的突变，这种<strong>高频</strong>区域我们称之为<strong>线条</strong>。</p>
<p><strong>红圈</strong>中，亮度频繁变化，幅度有高有低，这种高频区域我们称为<strong>纹理</strong>。</p>
<p>有时候，线条和纹理（高频区域）统称为线条，平面（低频区域）又叫做非线条。</p>
<p>这是亮度平面。色度平面，高频低频，线条等概念也同样适用，就是描述色度变化的快慢轻重。<strong>一般我们所谓的“细节”，就是指图像中的高频信息。</strong></p>
<p>一般来说，<strong>一张图的高频信息越多，意味着这张图信息量越大，所需要记录的数据量就越多，编码所需要的运算量也越大</strong>。如果一个视频包含的空间性高频信息很多（通俗点说就是每一帧内细节很多），意味着这个视频的空间复杂度很高。</p>
<p>记录一张图片，编码器需要决定给怎样的部分多少码率。码率在一张图内不同部分的分配，叫做<strong>码率的空间分配</strong>。分配较好的时候，往往整幅图目视观感比较统一；分配不好常见的后果，就是线条纹理尚可，背景平面区域出现大量色带色块（码率被过分的分配给线条）；或者背景颜色过渡自然，纹理模糊，线条烂掉（码率被过分的分配给非线条）。</p>
<h3 id="7、时间上的低频与高频：动态"><a href="#7、时间上的低频与高频：动态" class="headerlink" title="7、时间上的低频与高频：动态"></a>7、时间上的低频与高频：动态</h3><p>在视频处理中，时间(temporal)的概念强调帧与帧之间的变换。跟空间(spatial)相对。</p>
<p>动态的概念无需多解释；就是<strong>帧与帧之间图像变化的强弱</strong>，变化频率的高低。一段视频如果动态很高，变化剧烈，我们称为时间复杂度较高，时域上的高频信息多。否则如果视频本身舒缓多静态，我们称为时间复杂度低，时域上的低频信息多。</p>
<p>一般来说，一段视频的时域高频信息多，动态的信息量就大，所需要记录的数据量就越多，编码所需要的运算量也越大。但是另一方面，<strong>人眼对高速变化的场景，敏感度不如静态的图片来的高（你没有时间去仔细观察细节），所以动态场景的优先度可以低于静态场景。</strong>如何权衡以上两点去分配码率，被称为<strong>码率的时间分配</strong>。分配较好的时候，看视频无论动态还是静态效果都较好；分配不好的时候往往是静态部分看着还行，动态部分糊烂掉；或者动态部分效果过分的好，浪费了大量码率，造成静态部分欠码，瑕疵明显。</p>
<p><strong>很多人喜欢看静止的截图对比，来判断视频的画质。从观看的角度，这种做法其实并不完全科学</strong>——如果你觉得比较烂的一帧其实是取自高动态场景，那么这一帧稍微烂点无可厚非，反正观看的时候你注意不到，将码率省下来给静态部分会更好。</p>
<h3 id="8、清晰度与画质简述"><a href="#8、清晰度与画质简述" class="headerlink" title="8、清晰度与画质简述"></a>8、清晰度与画质简述</h3><p>我们经常讨论，一个视频清晰度如何，画质好不好。但是如何给这两个术语做定义呢？</p>
<p>经常看到的说法：“<strong>这个视频清晰度是1080p的</strong>”。其实看过上文你就应该知道，<strong>1080p只是视频的分辨率</strong>，它不能直接代表清晰度——比如说，我可以把一个480p的dvd视频拉升到1080p，那又怎样呢？它的清晰度难道就提高了么？</p>
<p>一个比较接近清晰度的概念，是上文所讲述的，<strong>空间高频信息量，就是一帧内的细节。一张图，一个视频的细节多，它的清晰度就高</strong>。分辨率决定了高频信息量的上限；就是它最清晰能到什么地步。1080p之所以比480p好，是因为它可以允许图像记录的高频信息多。这个说法看样子很靠谱，但是，有反例：<br><img src="oversharped.png" alt="oversharped.png"><br>右图的高频信息远比左图多——它的线条很锐利，有大量致密的噪点（注意噪点完全符合高频信息的定义；它使得图像变化的非常快）<br>但是你真的觉得右图清晰度高么？<br>事实上，右图完全是通过左图加工而来。通过过度锐化+强噪点，人为的增加无效的高频信息。</p>
<p><strong>所以清晰度的定义我更倾向于这样一个说法：图像或视频中，原生、有效的高频信息。</strong><br>原生，强调这种清晰度是非人工添加的；有效；强调细节本身有意义，而不是毫无意义的噪点特效。</p>
<p>值得一提的是，人为增加的高频信息不见得完全没有帮助。有的时候适度锐化的确能够起到不错的目视效果：<br><img src="finesharped.png" alt="finesharped.png"></p>
<p>这是一幅适度锐化后的效果。如果有人觉得右图更好，至少某些部分更好，相信我，你不是一个人。所以适度锐化依旧是视频和图像处理中，可以接受的一种主观调整的手段，一定的场合下，它确实有助于提高目视效果。</p>
<p>以上是清晰度的概述。注意，清晰度只是空间方面（就是一帧以内）。如果再考虑到动态效果的优秀与否（视频是不是那种一动起来就糊成一团的，或者动起来感觉卡顿明显的，常见于早起RMVB），空间和时间上优秀的观看效果共同定义了画质。所以我们说madVR/svp那些倍帧效果有助于提高画质，实际上它们增强了时间上的观看效果。</p>
<p>好的画质，是制作者和观众共同追求的。怎么样的视频会有好的画质呢？是不是码率越高的视频画质越好呢？真不见得。<strong>视频的画质，是由以下几点共同决定的：</strong></p>
<p>1、源的画质。<br>俗话说的好，上梁不正下梁歪。如果源的画质本身很差，那么再如何折腾都别指望画质好到哪去。所以压制者往往会选择更好的源进行压制——举个栗子，BDRip一般都比TVRip来的好，哪怕是720p。蓝光也分销售地区，一般日本销售的日版，画质上比美版、台版、港版啥的都来得好，所以同样是BDRip，选取更好的源，就能做到画质上优先一步。</p>
<p>2、播放条件。<br>观众是否用了足矣支持高画质播放的硬件和软件。这就是为啥我们在发布Rip的同时大力普及好的播放器；有时候一个好的播放器胜过多少在制作方面的精力投入。 </p>
<p>3、码率投入vs编码复杂度。<br>视频的时间和空间复杂度，并称为编码复杂度。编码复杂度高的视频，往往细节多，动态高（比如《魔法少女小圆剧场版 叛逆的物语》），这样的视频天生需要较高的码率去维持一个优秀的观看效果。<br>相反，有些视频编码复杂度低（比如《请问今天要来点兔子么》，动态少，线条细节柔和），这种视频就是比较节省码率的。</p>
<p>4、码率分配的效率和合理度。<br>同样多的码率，能起到怎样好的效果，被称为效率。比如H264就比之前的RealVideo效率高；10bit比8bit效率高；编码器先进，参数设置的比较合理，编码器各种高端参数全开（通常以编码时间作为代价），码率效率就高。<br>合理度就是码率在时空分配方面合理与否，合理的分配，给观众的观看效果就比较统一协调。 码率分配的效率和合理度，是对制作者的要求，要求制作者对片源分析，参数设置有比较到位的理解。</p>
<p>码率分配和合理度做的好，就常常能做出低码率高画质的良心作品。</p>
<p>这里再多提一句，至少在这个时间点，也就是此文发布的2014年年底，HEVC相对于AVC可以提高50%的效率，依旧是一个纸面上的理论值。实际操作中，因为HEVC编码器的成熟度远不及经过了十几年发展的AVC编码器，导致现在HEVC的潜力远没有能发挥出来，特别是高画质下甚至不如。<br>对于目前主流的，定位收藏画质的BDRip，同样码率下x265的画质相对于x264没有优势；所以在近期，大家不用优先的去下载HEVC版作为收藏目的，更不必迷信什么“码率降低一半”。再强调一次，这个时间点；如果一年后以上陈述被不断进步的HEVC编码器推翻，我毫不惊讶。</p>
<p>5、编码前的预处理。预处理分三种：</p>
<p>①，客观修复。强调修复片源固有的瑕疵，比如锯齿，色带，晕轮等等。<br>②，主观调整，强调将片源调整的更适合人眼观看，比如适度的锐化，调色（有时候你是可以通过科学方法判定片源的颜色有问题，然后针对的做修复的）。<br>③，移除无效高频信息，比如降噪，避免码率浪费在无效的噪点上</p>
<p>预处理做的好，往往能达到画质上超越片源，或是在几乎不牺牲清晰度的前提下，节省码率开销。</p>
<p>但是预处理是一把双刃剑，优化的同时，可能引入副效果。降噪、抗锯齿、去晕轮等操作会不可避免的损失一些有效细节（或多或少，取决于制作者水准）；主观调整很可能会引入副效果（比如过度锐化会导致锯齿和晕轮），或是变成了作者的自我满足，形成对观众的欺骗。</p>
<p>综上，一个优秀的画质，是由片源、制作者、观看者共同决定的；码率高低也只是部分因素，并非决定性的效果。</p>
<p>于是这篇教程就写到这里吧。它最初的目的是给学习视频制作入门的人而写，也不知道对于一般的观众，能让大家理解多少。有啥需要交流讨论提问的就在下文回复吧。如果反响较好，以后我们还会发布更多这样科普教学类的文章。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/06/chrome的console功能/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/06/chrome的console功能/" itemprop="url">chrome的console功能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-06T18:35:57+08:00">2018-02-06</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="chrome的console功能"><a href="#chrome的console功能" class="headerlink" title="chrome的console功能"></a>chrome的console功能</h1><p>Console的9种用法，<br>1 显示信息的命令</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">'信息'</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">'错误'</span>);</span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">'警告'</span>);</span><br></pre></td></tr></table></figure>
<p>2 占位符(格式输出)<br>console上述的集中度支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;%d年%d月%d日&quot;,2018,2,2);</span><br></pre></td></tr></table></figure>
<p>3 信息分组(嵌套)</p>
<p>group是嵌套，groupEnd是结束一层嵌套</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.group(<span class="string">"第一组信息"</span>);    　　　　</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"第一组第一条"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"第一组第二条"</span>);</span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br><span class="line"><span class="built_in">console</span>.group(<span class="string">"第二组信息"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"第二组第一条"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"第二组第二条"</span>);</span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br></pre></td></tr></table></figure>
<p>4 查看对象信息</p>
<p>console.dir(obj)可以显示一个对象所有的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'Bob'</span>,</span><br><span class="line">    age: <span class="number">30</span>,</span><br><span class="line">    message: <span class="string">"hello world"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.dir(obj);</span><br></pre></td></tr></table></figure>
<p>5 显示某个节点的内容</p>
<p>console.dirxml(id)用来显示网页的某个节点（node）所包含的html/xml代码。</p>
<p>6 判断变量是否是真<br>console.assert(expression, object[, object…])</p>
<p>接收至少两个参数，第一个参数的值或返回值为false的时候，将会在控制台上输出后续参数的值。例如：<br>用来判断一个表达式或变量是否为真。如果结果为否，则在控制台输出一条相应信息，并且抛出一个异常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.assert(<span class="number">1</span> == <span class="number">1</span>, object); <span class="comment">// 无输出，返回 undefined</span></span><br><span class="line"><span class="built_in">console</span>.assert(<span class="number">1</span> == <span class="number">2</span>, object); <span class="comment">// 输出 object</span></span><br></pre></td></tr></table></figure>
<p>7 追踪函数的调用轨迹<br>console.trace()用来追踪函数的调用过程。在大型项目尤其是框架开发中，函数的调用轨迹可以十分复杂，console.trace()方法可以将函数的被调用过程清楚地输出到控制台上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tracer</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bar(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tracer(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="string">'tracer'</span>);</span><br></pre></td></tr></table></figure>
<p>8 计时功能<br>计时器，可以将成对的console.time()和console.timeEnd()之间代码的运行时间输出到控制台上，name参数可作为标签名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'计时器'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'计时器'</span>);</span><br></pre></td></tr></table></figure>
<p>9 console.profile()的性能分析<br>性能分析（Profiler）就是分析程序各个部分的运行时间，找出瓶颈所在，使用的方法是console.profile()</p>
<p>这是个挺高大上的东西，可用于性能分析。在 JS 开发中，我们常常要评估段代码或是某个函数的性能。在函数中手动打印时间固然可以，但显得不够灵活而且有误差。借助控制台以及console.profile()方法我们可以很方便地监控运行性能。</p>
<p>例如下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">  for (var i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">    childA()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function childA(j) &#123;</span><br><span class="line">  for (var i = 0; i &lt; j; i++) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.profile(&apos;性能分析&apos;);</span><br><span class="line">parent();</span><br><span class="line">console.profileEnd();</span><br></pre></td></tr></table></figure>
<p>10 输出执行到该行的次数</p>
<p>console.count([label])</p>
<p>输出执行到该行的次数，可选参数 label 可以输出在次数之前，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.count(<span class="string">'count'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// count: 1</span></span><br><span class="line"><span class="comment">// count: 2</span></span><br><span class="line"><span class="comment">// count: 3</span></span><br><span class="line"><span class="comment">// count: 4</span></span><br><span class="line"><span class="comment">// count: 5</span></span><br></pre></td></tr></table></figure>
<p>11 可将传入的对象或数组以表格形式输出<br>console.table()</p>
<p>可将传入的对象，或数组以表格形式输出，相比传统树形输出，这种输出方案更适合内部元素排列整齐的对象或数组，不然可能会出现很多的 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    name: <span class="string">'foo'</span>,</span><br><span class="line">    age: <span class="string">'33'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  bar: &#123;</span><br><span class="line">    name: <span class="string">'bar'</span>,</span><br><span class="line">    age: <span class="string">'45'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="string">'33'</span>],</span><br><span class="line">  [<span class="string">'bar'</span>, <span class="string">'45'</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(obj);</span><br><span class="line"><span class="built_in">console</span>.table(arr);</span><br></pre></td></tr></table></figure>
<p><a href="https://segmentfault.com/a/1190000000481884" target="_blank" rel="noopener">你真的了解 console 吗</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/05/axios使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/05/axios使用/" itemprop="url">axios使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-05T11:15:13+08:00">2018-02-05</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Axios-是一个基于-promise-的-HTTP-库，可以用在浏览器和-node-js-中。"><a href="#Axios-是一个基于-promise-的-HTTP-库，可以用在浏览器和-node-js-中。" class="headerlink" title="Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。"></a>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</h1><p>5种<br><a href="https://www.oschina.net/translate/top-javascript-libraries-for-making-ajax-calls?from=20180204" target="_blank" rel="noopener">用于进行 AJAX 调用的顶级 JavaScript 库</a></p>
<p><strong>Fetch API</strong><br>Fetch API 是 XMLHttpRequest 的现代替代方法，用于从服务器检索资源</p>
<p><strong>Axios</strong><br>Axios 是一个基于 XMLHttpRequest 构建的现代 JavaScript 库，用于进行 AJAX 调用</p>
<p><strong>jQuery</strong><br>jQuery 曾经是 JavaScript 的一线类库，涵盖从 AJAX 调用到操作 DOM 的内容。</p>
<p><strong>SuperAgent</strong><br>SuperAgent 是一个轻量级和渐进式 AJAX 库，更侧重于可读性和灵活性。</p>
<p><strong>Request - 一个简单的 HTTP 客户端</strong><br>这个 Request 库是进行 HTTP 调用最简单的方法之一。</p>
<p>我个人喜欢的是 Axios ，因为就我个人而言感觉它更具可读性和友好（easy on the eyes）。你也可以使用 Fetch ，因为它有良好的文档记录和标准化的解决方案。</p>
<h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/04/vuex使用总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/04/vuex使用总结/" itemprop="url">vuex使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-04T17:50:05+08:00">2018-02-04</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vuex总结-这个也是插件哦"><a href="#vuex总结-这个也是插件哦" class="headerlink" title="vuex总结(这个也是插件哦)"></a>vuex总结(这个也是插件哦)</h1><p><a href="https://vuex.vuejs.org/zh-cn/intro.html" target="_blank" rel="noopener">vuex官网</a></p>
<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用<strong>集中式存储</strong>管理应用的<strong>所有组件的状态</strong>，并以相应的规则保证状态以一种<strong>可预测的方式</strong>发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>
<h2 id="什么是“状态管理模式”？-这个例子别和后面的搞混了"><a href="#什么是“状态管理模式”？-这个例子别和后面的搞混了" class="headerlink" title="什么是“状态管理模式”？(这个例子别和后面的搞混了)"></a><strong>什么是“状态管理模式”？</strong>(这个例子别和后面的搞混了)</h2><p>让我们从一个简单的 Vue <strong>计数应用</strong>开始：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  // state</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // view</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `,</span><br><span class="line">  // actions</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment () &#123;</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意看上面的注释</strong><br>这个状态自管理应用包含以下3个部分：</p>
<ul>
<li>state，驱动应用的数据源；</li>
<li>view，以声明方式将 state 映射到视图；</li>
<li>actions，响应在 view 上的用户输入导致的状态变化。</li>
</ul>
<p>以下是一个表示“<strong>单向</strong>数据流”理念的极简示意：</p>
<p><img src="flow.png" alt="单向数据流"></p>
<p>但是，当我们的应用遇到<strong>多个组件共享状态</strong>时，单向数据流的简洁性很容易被破坏：</p>
<ul>
<li>多个视图依赖于同一状态。</li>
<li>来自不同视图的行为需要变更同一状态。</li>
</ul>
<p>对于问题一，传参的方法<strong>对于多层嵌套的组件将会非常繁琐</strong>，并且对于<strong>兄弟组件间的状态传递无能为力</strong>。<br>对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</p>
<p>因此，我们为什么不把组件的<strong>共享状态抽取出来</strong>，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！</p>
<p>另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。</p>
<p>这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。</p>
<p><img src="vuex.png" alt="vuex"></p>
<h2 id="什么情况下我应该使用-Vuex？"><a href="#什么情况下我应该使用-Vuex？" class="headerlink" title="什么情况下我应该使用 Vuex？"></a>什么情况下我应该使用 Vuex？</h2><p>虽然 Vuex 可以帮助我们管理共享状态，<strong>但也附带了更多的概念和框架</strong>。这需要对短期和长期效益进行权衡。</p>
<p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——<strong>如果您的应用够简单，您最好不要使用 Vuex</strong>。一个简单的 <strong>global event bus</strong> 就足够您所需了。但是，如果您需要构建是一个<strong>中大型单页应用</strong>，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：</p>
<p>Flux 架构就像眼镜：您自会知道什么时候需要它。</p>
<h1 id="开始-这里开始才是重头戏"><a href="#开始-这里开始才是重头戏" class="headerlink" title="开始(这里开始才是重头戏)"></a>开始(这里开始才是重头戏)</h1><p>每一个 Vuex 应用的<strong>核心就是 store（仓库）</strong>。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同：</p>
<ol>
<li>Vuex 的状态存储是<strong>响应式</strong>的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>你<strong>不能直接改变</strong> store 中的状态。改变 store 中的状态的<strong>唯一途径</strong>就是<strong>显式地提交 (commit) mutation</strong>。这样使得我们可以方便地<strong>跟踪</strong>每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>
</ol>
<h2 id="最简单的-Store"><a href="#最简单的-Store" class="headerlink" title="最简单的 Store"></a>最简单的 Store</h2><p>安装 Vuex 之后，让我们来创建一个 store。创建过程直截了当——仅需要提供一个初始 state 对象和一些 mutation(这个当成类actions好了)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在，你可以通过 <strong>store.state 来获取状态对象(后面用computed来返回)</strong>，以及通过 <strong>store.commit 方法触发状态变更</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//commit一个increment到mutations触发，然后这个mutations会mutate一个state</span><br><span class="line">store.commit('increment')</span><br><span class="line"></span><br><span class="line">console.log(store.state.count) // -&gt; 1</span><br></pre></td></tr></table></figure>
<p><strong>再次强调</strong>，我们<strong>通过提交 mutation</strong> 的方式，而<strong>非直接改变</strong> store.state.count，是因为我们想要更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。有了它，我们甚至可以实现如时间穿梭般的调试体验。</p>
<p>由于 store 中的<strong>状态是响应式</strong>的，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。<strong>触发变化</strong>也仅仅是在组件的 methods 中提交 mutation。</p>
<p>这是一个最基本的 Vuex 记数应用示例。</p>
<p>接下来，我们将会更深入地探讨一些核心概念。让我们先从 State 概念开始</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>在这一章，我们将会学到 Vue 的这些核心概念。他们是：</p>
<ul>
<li>State</li>
<li>Getter</li>
<li>Mutation</li>
<li>Action</li>
<li>Module</li>
</ul>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p><strong>单一状态树</strong><br>Vuex 使用单一状态树——是的，<strong>用一个对象就包含了全部的应用层级状态</strong>。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，<strong>每个应用将仅仅包含一个 store 实例</strong>。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p>
<p><strong>单状态树和模块化并不冲突</strong>——在后面的章节里我们会讨论如何将状态和状态变更事件分布到各个子模块中。</p>
<p><strong>那么我们如何在 Vue 组件中展示状态呢</strong>？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态<strong>最简单的方法</strong>就是在<strong>计算属性</strong>中返回某个状态：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 Counter 组件</span><br><span class="line">const Counter = &#123;</span><br><span class="line">  template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span><br><span class="line">  computed: &#123;   //稳得一比，前面console.log只是打印</span><br><span class="line">    count () &#123;</span><br><span class="line">      return store.state.count      //下面的例子会改下这里，从store变为this.$store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。</p>
<p>然而，<strong>这种模式导致组件依赖全局状态单例</strong>。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。</p>
<p>Vuex 通过 store 选项，<strong>提供了一种机制将状态从根组件“注入”到每一个子组件中</strong>（需调用 Vue.use(Vuex)）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: '#app',</span><br><span class="line">  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件(多个了store，和router一样用法)</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过在<strong>根实例中注册 store 选项</strong>，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 <strong>this.$store</strong> 访问到。让我们更新下 Counter 的实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Counter = &#123;</span><br><span class="line">  template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      return this.$store.state.count     //这里从store变为this.$store(从vue实例)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h4><p>当<strong>一个组件需要获取多个状态时候</strong>，将这些状态都声明为计算属性(<strong>这个函数还是在computed中用哦</strong>)会有些重复和冗余。为了解决这个问题，我们可以使用 mapState <strong>辅助函数帮助我们生成计算属性</strong>，让你少按几次键：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 在单独构建的版本中辅助函数为 Vuex.mapState</span><br><span class="line">import &#123; mapState &#125; from 'vuex'</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: mapState(&#123;      //还是computed中用</span><br><span class="line">    // 箭头函数可使代码更简练</span><br><span class="line">    count: state =&gt; state.count,</span><br><span class="line"></span><br><span class="line">    // 传字符串参数 'count' 等同于 `state =&gt; state.count`</span><br><span class="line">    countAlias: 'count',</span><br><span class="line"></span><br><span class="line">    // 为了能够使用 `this` 获取局部状态，必须使用常规函数</span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      return state.count + this.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当映射的<strong>计算属性的名称</strong>与 <strong>state 的子节点名称相同</strong>时，我们也可以给 mapState 传一个<strong>字符串数组</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  // 映射 this.count 为 store.state.count</span><br><span class="line">  'count'</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h4 id="对象展开运算符-…"><a href="#对象展开运算符-…" class="headerlink" title="对象展开运算符(…)"></a>对象展开运算符(…)</h4><p><strong>mapState 函数返回的是一个对象</strong>。我们<strong>如何将它与局部计算属性混合使用呢</strong>？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。但是自从有了对象展开运算符（现处于 ECMASCript 提案 stage-3 阶段），我们可以极大地简化写法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; /* ... */ &#125;,</span><br><span class="line">  // 使用对象展开运算符将此对象混入到外部对象中,上面算完后，这里获取</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组件仍然保有局部状态"><a href="#组件仍然保有局部状态" class="headerlink" title="组件仍然保有局部状态"></a>组件仍然保有局部状态</h4><p>使用 Vuex <strong>并不意味着你需要将所有的状态放入 Vuex。</strong>虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。</p>
<h3 id="Getter-在state基础上，可以认为是-store-的计算属性"><a href="#Getter-在state基础上，可以认为是-store-的计算属性" class="headerlink" title="Getter(在state基础上，可以认为是 store 的计算属性)"></a>Getter(在state基础上，可以认为是 store 的计算属性)</h3><p>有时候我们需要<strong>从 store 中的 state 中派生出一些状态</strong>，例如对列表进行过滤并计数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">      //在state中的todos进行过滤</span><br><span class="line">    return this.$store.state.todos.filter(todo =&gt; todo.done).length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——<strong>无论哪种方式都不是很理想</strong>。</p>
<p>Vuex 允许我们在 store 中定义“getter”（<strong>可以认为是 store 的计算属性</strong>）。就像计算属性一样，getter 的返回值会根据它的依赖被<strong>缓存</strong>起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<p><strong>Getter 接受 state 作为其第一个参数(废话，在state的基础上啊，然后也有mapGetters的)</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; id: 1, text: '...', done: true &#125;,</span><br><span class="line">      &#123; id: 2, text: '...', done: false &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">      //这就直接上了，这里就一个参数</span><br><span class="line">    doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>Getter 会暴露为 store.getters 对象(废话了，和state调用一样)</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.doneTodos // -&gt; [&#123; id: 1, text: '...', done: true &#125;]</span><br></pre></td></tr></table></figure>
<p>Getter 也可以接受其他 getter 作为<strong>第二个参数</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  // 话说第二个参数就是自己么</span><br><span class="line">  doneTodosCount: (state, getters) =&gt; &#123;</span><br><span class="line">    return getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.getters.doneTodosCount // -&gt; 1</span><br></pre></td></tr></table></figure>
<p>我们可以很容易地在任何组件中使用它：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    return this.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以通过让 getter <strong>返回一个函数</strong>，来实现给 getter 传参。在你<strong>对 store 里的数组进行查询时非常有用</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  // 这还两个箭头了</span><br><span class="line">  getTodoById: (state) =&gt; (id) =&gt; &#123;</span><br><span class="line">    return state.todos.find(todo =&gt; todo.id === id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.getters.getTodoById(2) // -&gt; &#123; id: 2, text: '...', done: false &#125;</span><br></pre></td></tr></table></figure>
<h4 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h4><p>mapGetters 辅助函数仅仅是将 store 中的 getter <strong>映射到局部计算属性</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from 'vuex'</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: &#123;</span><br><span class="line">  // 使用对象展开运算符将 getter 混入 computed 对象中,也是多个getters</span><br><span class="line">    ...mapGetters([</span><br><span class="line">      'doneTodosCount',</span><br><span class="line">      'anotherGetter',</span><br><span class="line">      // ...</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">如果你想将一个 getter 属性另取一个名字，使用对象形式：</span><br><span class="line"></span><br><span class="line">mapGetters(&#123;</span><br><span class="line">  // 映射 `this.doneCount` 为 `store.getters.doneTodosCount`</span><br><span class="line">  doneCount: 'doneTodosCount'</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Mutation-mutation-都是同步事务"><a href="#Mutation-mutation-都是同步事务" class="headerlink" title="Mutation(mutation 都是同步事务)"></a>Mutation(mutation 都是同步事务)</h3><p><strong>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</strong>。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个<strong>回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数(毕竟要改state)</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//还是那个计数的例子</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      // 变更状态</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>你<strong>不能直接调用一个 mutation handler</strong>。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit('increment')</span><br></pre></td></tr></table></figure>
<h4 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h4><p>你可以向 store.commit <strong>传入额外的参数</strong>，即 mutation 的 载荷（payload）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 这个n就是payload</span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//当然相应的</span><br><span class="line">store.commit('increment', 10)</span><br></pre></td></tr></table></figure>
<p>在大多数情况下，<strong>载荷应该是一个对象</strong>，这样可以包含多个字段并且记录的 mutation 会<strong>更易读</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit('increment', &#123;</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h4><p>提交 mutation 的<strong>另一种方式是直接使用包含 type 属性的对象</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: 'increment',</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 <strong>handler 保持不变</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Mutation-需遵守-Vue-的响应规则"><a href="#Mutation-需遵守-Vue-的响应规则" class="headerlink" title="Mutation 需遵守 Vue 的响应规则"></a>Mutation 需遵守 Vue 的响应规则</h4><p>既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p>
<ol>
<li><p>最好<strong>提前</strong>在你的 store 中<strong>初始化</strong>好所有所需属性(响应式都这样)。</p>
</li>
<li><p>当需要在<strong>对象上添加新属性(这不就和v-for那个一样么，用set)</strong>时，你应该</p>
<ul>
<li><p>使用 Vue.set(obj, ‘newProp’, 123), 或者</p>
</li>
<li><p>以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：</p>
<p><code>state.obj = { ...state.obj, newProp: 123 }</code></p>
</li>
</ul>
</li>
</ol>
<h4 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h4><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// mutation-types.js    这些大写的就是啦</span><br><span class="line">export const SOME_MUTATION = 'SOME_MUTATION'</span><br><span class="line">// store.js</span><br><span class="line">import Vuex from 'vuex'</span><br><span class="line">import &#123; SOME_MUTATION &#125; from './mutation-types'</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名，还有这操作</span><br><span class="line">    [SOME_MUTATION] (state) &#123;</span><br><span class="line">      // mutate state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做</p>
<h4 id="Mutation-必须是同步函数"><a href="#Mutation-必须是同步函数" class="headerlink" title="Mutation 必须是同步函数"></a>Mutation 必须是同步函数</h4><p>一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  someMutation (state) &#123;</span><br><span class="line">    api.callAsyncMethod(() =&gt; &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p>
<h4 id="在组件中提交-Mutation"><a href="#在组件中提交-Mutation" class="headerlink" title="在组件中提交 Mutation"></a>在组件中提交 Mutation</h4><p>你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from 'vuex'</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span><br><span class="line"></span><br><span class="line">      // `mapMutations` 也支持载荷：</span><br><span class="line">      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下一步：Action"><a href="#下一步：Action" class="headerlink" title="下一步：Action"></a>下一步：Action</h4><p>在 mutation 中混合异步调用会导致你的程序很难调试。例如，当你能调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念。<strong>在 Vuex 中，mutation 都是同步事务</strong>：</p>
<p><code>store.commit(&#39;increment&#39;)</code><br>// 任何由 “increment” 导致的状态变更都应该在此刻完成。<br><strong>为了处理异步操作，让我们来看一看 Action</strong>。</p>
<h3 id="Action-为了处理异步操作"><a href="#Action-为了处理异步操作" class="headerlink" title="Action(为了处理异步操作)"></a>Action(为了处理异步操作)</h3><p><strong>Action 类似于 mutation，不同在于</strong>：</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。</li>
</ul>
<p>让我们来注册一个简单的 action：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  //就是这个了，看图是mutation之前的一个</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit('increment')</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Action 函数接受一个<strong>与 store 实例具有相同方法和属性的 context 对象</strong>，因此你可以调用 <strong>context.commit</strong> 提交一个 mutation，或者通过 <strong>context.state</strong> 和 <strong>context.getters</strong> 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 <strong>context 对象为什么不是 store 实例本身</strong>了。</p>
<p>实践中，我们会经常用到 ES2015 的 <strong>参数解构</strong> 来简化代码（特别是我们需要调用 commit 很多次的时候）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment (&#123; commit &#125;) &#123;</span><br><span class="line">    commit('increment')</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h4><p>Action 通过 <strong>store.dispatch</strong> 方法触发：</p>
<p><code>store.dispatch(&#39;increment&#39;)</code><br>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，<strong>还记得 mutation 必须同步执行这个限制么</strong>？Action 就不受约束！我们可以在 action 内部执行异步操作：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      commit('increment')</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Actions 支持同样的载荷方式和对象方式进行分发：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 以载荷形式分发</span><br><span class="line">store.dispatch('incrementAsync', &#123;</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 以对象形式分发</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: 'incrementAsync',</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>来看一个更加实际的购物车示例，<strong>涉及到调用异步 API 和分发多重 mutation：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line">    // 把当前购物车的物品备份起来</span><br><span class="line">    const savedCartItems = [...state.cart.added]</span><br><span class="line">    // 发出结账请求，然后乐观地清空购物车</span><br><span class="line">    commit(types.CHECKOUT_REQUEST)</span><br><span class="line">    // 购物 API 接受一个成功回调和一个失败回调</span><br><span class="line">    shop.buyProducts(</span><br><span class="line">      products,</span><br><span class="line">      // 成功操作</span><br><span class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class="line">      // 失败操作</span><br><span class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们正在进行一系列的<strong>异步</strong>操作，并且通<strong>过提交 mutation 来记录 action 产生的副作用</strong>（即状态变更）。</p>
<h4 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h4><p>你在组件中使用 <strong>this.$store.dispatch(‘xxx’)</strong> 分发 action，或者使用 <strong>mapActions</strong> 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapActions &#125; from 'vuex'</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span><br><span class="line"></span><br><span class="line">      // `mapActions` 也支持载荷：</span><br><span class="line">      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h4><p>Action 通常是异步的，那么如何知道 <strong>action 什么时候结束呢</strong>？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>
<p>首先，你需要明白 <strong>store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise</strong>，并且 <strong>store.dispatch 仍旧返回 Promise：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        commit('someMutation')</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你可以：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch('actionA').then(() =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在另外一个 action 中也可以：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  // ...</span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    return dispatch('actionA').then(() =&gt; &#123;</span><br><span class="line">      commit('someOtherMutation')</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，如果我们利用 async / await，我们可以如下组合 action：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 假设 getData() 和 getOtherData() 返回的是 Promise</span><br><span class="line">actions: &#123;</span><br><span class="line">  async actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit('gotData', await getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  async actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    await dispatch('actionA') // 等待 actionA 完成</span><br><span class="line">    commit('gotOtherData', await getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>由于使用单一状态树，应用的<strong>所有状态会集中到一个比较大的对象</strong>。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>
<p>为了解决以上问题，Vuex 允许我们<strong>将 store 分割成模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure>
<h4 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h4><p>对于模块内部的 mutation 和 getter，接收的<strong>第一个参数是模块的局部状态对象</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; count: 0 &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      // 这里的 `state` 对象是模块的局部状态</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount (state) &#123;</span><br><span class="line">      return state.count * 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，对于模块内部的 action，局部状态通过<strong> context.state</strong> 暴露出来，<strong>根节点状态则为 context.rootState</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  actions: &#123;</span><br><span class="line">      //这有3个参数了，第3个参数是根节点的状态</span><br><span class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</span><br><span class="line">      if ((state.count + rootState.count) % 2 === 1) &#123;</span><br><span class="line">        commit('increment')</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  getters: &#123;</span><br><span class="line">    sumWithRootCount (state, getters, rootState) &#123;</span><br><span class="line">      return state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="命名空间-暂不懂"><a href="#命名空间-暂不懂" class="headerlink" title="命名空间(暂不懂)"></a>命名空间(暂不懂)</h4><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>
<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <strong>namespaced: true</strong> 的方式使其成为命名空间模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="在命名空间模块内访问全局内容（Global-Assets）"><a href="#在命名空间模块内访问全局内容（Global-Assets）" class="headerlink" title="在命名空间模块内访问全局内容（Global Assets）"></a>在命名空间模块内访问全局内容（Global Assets）</h4><h4 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="headerlink" title="带命名空间的绑定函数"></a>带命名空间的绑定函数</h4><h4 id="给插件开发者的注意事项"><a href="#给插件开发者的注意事项" class="headerlink" title="给插件开发者的注意事项"></a>给插件开发者的注意事项</h4><h4 id="模块动态注册"><a href="#模块动态注册" class="headerlink" title="模块动态注册"></a>模块动态注册</h4><h4 id="模块重用"><a href="#模块重用" class="headerlink" title="模块重用"></a>模块重用</h4><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：</p>
<ol>
<li><p>应用层级的状态应该集中到单个 store 对象中。</p>
</li>
<li><p>提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。</p>
</li>
<li><p>异步逻辑都应该封装到 action 里面。</p>
</li>
</ol>
<p>只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。</p>
<p>对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... # 抽取出API请求</span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          # 我们组装模块并导出 store 的地方</span><br><span class="line">    ├── actions.js        # 根级别的 action</span><br><span class="line">    ├── mutations.js      # 根级别的 mutation</span><br><span class="line">    └── modules</span><br><span class="line">        ├── cart.js       # 购物车模块</span><br><span class="line">        └── products.js   # 产品模块</span><br></pre></td></tr></table></figure>
<h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>开启严格模式，仅需在创建 store 的时候传入 strict: true：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  strict: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p>
<p><strong>开发环境与发布环境</strong><br><strong>不要在发布环境下启用严格模式</strong>！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。</p>
<p>类似于插件，我们可以让构建工具来处理这种情况：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  strict: process.env.NODE_ENV !== 'production'</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/03/vue-router使用总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/03/vue-router使用总结/" itemprop="url">vue-router使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T14:48:00+08:00">2018-02-03</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vue-route-这货是个插件"><a href="#vue-route-这货是个插件" class="headerlink" title="vue-route(这货是个插件)"></a>vue-route(这货是个插件)</h1><p>主要想整理的是这个配合v-for一起用</p>
<p><a href="https://router.vuejs.org/zh-cn/essentials/getting-started.html" target="_blank" rel="noopener">vue-router官网的介绍</a></p>
<p><strong>使用vue-cli来构建路由</strong></p>
<p>先说下3个基本概念：route, routes, router<br><a href="http://www.jb51.net/article/111499.htm" target="_blank" rel="noopener">详解vue-router基本使用</a></p>
<p>1， route，它是一条路由，是单数。<br>Home按钮  =&gt; home内容， 这是一条route,<br>about按钮 =&gt; about 内容， 这是另一条路由。</p>
<p>2， routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。<br>[<br>    {home 按钮 =&gt;home内容 }，<br>    { about按钮 =&gt; about 内容}<br>]</p>
<p>3， router 是一个机制，相当于一个<strong>管理者</strong>，它来管理路由。<br>因为routes 只是定义了一组路由放在那里，是静止的，当有请求时，怎么找到对应的那条route呢？ 比如当用户点击home 按钮的时候，怎么知道跳转到home页面？这时router 就起作用了，它到routes 中去查找，去找到对应的route(home页面)，所以页面中就显示了home 内容。</p>
<p>4，客户端中的路由，实际上就是dom 元素的显示和隐藏。当页面中显示home 内容的时候，about 中的内容全部隐藏，反之也是一样。<br>客户端路由有两种实现方式：基于hash 和基于html5 history api.</p>
<h2 id="基本的路由-静态路由"><a href="#基本的路由-静态路由" class="headerlink" title="基本的路由(静态路由)"></a>基本的路由(静态路由)</h2><p><strong>下面开始</strong><br>官网一个基本的例子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue-router/dist/vue-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 router-link 组件来导航. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当 &lt;router-link&gt; 对应的路由匹配成功，将自动设置 class 属性值 .router-link-active --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/bar"</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">JavaScript</span><br><span class="line">// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">// 1. 定义（路由）组件。</span><br><span class="line">// 可以从其他文件 import 进来</span><br><span class="line">const Foo = &#123; template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span>' &#125;</span><br><span class="line">const Bar = &#123; template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">div</span>&gt;</span>' &#125;</span><br><span class="line"></span><br><span class="line">// 2. 定义路由</span><br><span class="line">// 每个路由应该映射一个组件。 其中"component" 可以是</span><br><span class="line">// 通过 Vue.extend() 创建的组件构造器，</span><br><span class="line">// 或者，只是一个组件配置对象。</span><br><span class="line">// 我们晚点再讨论嵌套路由(就是放在children中)。</span><br><span class="line">const routes = [</span><br><span class="line">  &#123; path: '/foo', component: Foo &#125;,</span><br><span class="line">  &#123; path: '/bar', component: Bar &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 3. 创建 router 实例，然后传 `routes` 配置</span><br><span class="line">// 你还可以传别的配置参数, 不过先这么简单着吧。</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes // （缩写）相当于 routes: routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 4. 创建和挂载根实例。</span><br><span class="line">// 记得要通过 router 配置参数注入路由，</span><br><span class="line">// 从而让整个应用都有路由功能</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount('#app')</span><br><span class="line"></span><br><span class="line">// 现在，应用已经启动了！</span><br></pre></td></tr></table></figure>
<p>可以看到html中只用了2个标签<br><code>&lt;router-link&gt;</code> <code>&lt;router-view&gt;</code></p>
<p><code>&lt;router-view&gt;</code>反正是显示路由内容的，<br>功能都在<code>&lt;router-link&gt;</code>，它定义了to那个路由 。</p>
<p>javascript页面<br>可以简单的理解为就是定义了一组routers，然后通过vue的vuerouter来管理</p>
<h2 id="动态路由（也就是把routers中的path改了-多对一，传参而已。另外注意watch和beforeRouteUpdate）"><a href="#动态路由（也就是把routers中的path改了-多对一，传参而已。另外注意watch和beforeRouteUpdate）" class="headerlink" title="动态路由（也就是把routers中的path改了: 多对一，传参而已。另外注意watch和beforeRouteUpdate）"></a>动态路由（也就是把routers中的path改了: 多对一，传参而已。另外注意watch和beforeRouteUpdate）</h2><p><strong>除了这个传参，还有url 这个query传参</strong><br><strong>上面的例子中router里面都是静态的,一一对应</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/bar"</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">const routes = [</span><br><span class="line">  &#123; path: '/foo', component: Foo &#125;,</span><br><span class="line">  &#123; path: '/bar', component: Bar &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>我们来看下动态路由，然后比较他们的区别</strong></p>
<p>我们经常需要把某种模式匹配到的所有路由，<strong>全都映射到同个组件(组件复用)</strong>。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用『动态路径参数』（dynamic segment）来达到这个效果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//这还是原来的User组件</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">//动态路由下复用这个User组件，改为</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    // 动态路径参数 以冒号开头</span><br><span class="line">    &#123; path: '/user/:id', component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性，<strong>使用 props</strong> 将组件和路由解耦，<strong>详见路由组件传参</strong></p>
</blockquote>
<p>现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。</p>
<p>一个『路径参数』使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。于是，我们可以更新 User 的模板，输出当前用户的 ID：</p>
<p>这里如果你看<code>&lt;router-link&gt;</code>这个to还是不动的，该foo该bar。只是routes和组件内变化(毕竟动态)</p>
<blockquote>
<p>把这个当做函数的传参记，比如<code>&lt;router-link to=&quot;/ser/foo&quot;&gt;</code>这个to中传过来一个foo,(这里的话还是和静态一样，只是routes变了，组件复用当然也给改，就是拿出参数问题)<br>然后再routers中的{ path: ‘/user/:id’, component: User } 匹配到了这个id，成了这么一个对象{id：foo}<br>最后去User组件中用$route.params这个对象可以拿出来用，毕竟就是传过来用的<br>还有就是beforeRouteUpdate的用处</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:center">匹配路径</th>
<th style="text-align:center">$route.params</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/user/:username</td>
<td style="text-align:center">/user/evan</td>
<td style="text-align:center">{ username: ‘evan’ }</td>
</tr>
<tr>
<td style="text-align:left">/user/:username/post/:post_id</td>
<td style="text-align:center">/user/evan/post/123</td>
<td style="text-align:center">{ username: ‘evan’, post_id: 123 }</td>
</tr>
</tbody>
</table>
</div>
<p><strong>响应路由参数的变化</strong><br>提醒一下，当使用路由参数时，例如从 /user/foo 导航到 /user/bar，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会再被调用</strong>。</p>
<p>复用组件时，想对路由参数的变化作出响应的话，你可以简单地 <strong>watch（监测变化） $route 对象</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: '...',</span><br><span class="line">  watch: &#123;</span><br><span class="line">    '$route' (to, from) &#123;</span><br><span class="line">      // 对路由变化作出响应...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者使用 2.2 中引入的 beforeRouteUpdate 守卫：</span><br><span class="line"></span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '...',</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    // react to route changes...</span><br><span class="line">    // don't forget to call next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>匹配优先级</strong><br>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p>
<h2 id="嵌套路由-就是一个套一个，在-lt-router-view-gt-中套，在routes中套children-同级的呢，命名看命名视图"><a href="#嵌套路由-就是一个套一个，在-lt-router-view-gt-中套，在routes中套children-同级的呢，命名看命名视图" class="headerlink" title="嵌套路由 (就是一个套一个，在&lt;router-view&gt;中套，在routes中套children)(同级的呢，命名看命名视图)"></a>嵌套路由 (就是一个套一个，在<code>&lt;router-view&gt;</code>中套，在routes中套children)(同级的呢，命名看命名视图)</h2><p>前面的例子并没有嵌套，现在搞下嵌套</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//这个是默认app挂在的地方，看到app了么</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//这是User组件</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">//配置哦</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: '/user/:id', component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在app中的 <code>&lt;router-view&gt;</code>是最顶层的出口，渲染最高级路由匹配到的组件。同样地，一个被渲染组件同样可以包含自己的嵌套 <router-view>。例如，在 User 组件的模板添加一个 <router-view>：</router-view></router-view></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//这是User组件，现在就有两层了</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//要在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置(上面嵌套了2层，**想一下再往下呢，就是再放一个children咯**)：</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: '/user/:id', component: User,</span><br><span class="line">      children: [   //要再嵌套可以在放一个children</span><br><span class="line">        &#123;</span><br><span class="line">          // 当 /user/:id/profile 匹配成功，</span><br><span class="line">          // UserProfile 会被渲染在 User 的 <span class="tag">&lt;<span class="name">router-view</span>&gt;</span> 中</span><br><span class="line">          path: 'profile',    //可以注意这里是相对路径哦</span><br><span class="line">          component: UserProfile</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          // 当 /user/:id/posts 匹配成功</span><br><span class="line">          // UserPosts 会被渲染在 User 的 <span class="tag">&lt;<span class="name">router-view</span>&gt;</span> 中</span><br><span class="line">          path: 'posts',</span><br><span class="line">          component: UserPosts</span><br><span class="line">        &#125;,</span><br><span class="line">        // 这是一个当做默认路由的，空路由</span><br><span class="line">        // 当 /user/:id 匹配成功，</span><br><span class="line">        // UserHome 会被渲染在 User 的 <span class="tag">&lt;<span class="name">router-view</span>&gt;</span> 中</span><br><span class="line">        &#123; path: '', component: UserHome &#125;,</span><br><span class="line"></span><br><span class="line">        // ...其他子路由</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>问题</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//嵌套不是这样嵌套，</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//也不是这样哦。  嵌套是一对一啊，这个user套在app去，同理 你要多层的嵌套就再导入一个组件呗，在那个组件里写router-view</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span> <span class="comment">&lt;!-- 不报错，不过反正是丢弃 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//还有既然这样不行，那么直接在router-view写东西怎么样，和slot一回事么</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span></span><br><span class="line">    在这写东西怎么处理的？<span class="comment">&lt;!-- 这个直接丢弃了 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>有时候，通过一个<strong>名称来标识(name)</strong>一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。(只要先记住name好了，下面的编程式路由接着往下看)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: '/user/:userId',</span><br><span class="line">      name: 'user',   //就多了这个name</span><br><span class="line">      component: User</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>要链接到一个命名路由，可以给 <code>&lt;router-link&gt;</code>的 <strong>to 属性</strong>传一个<strong>对象</strong>：(这块往下看)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这跟代码调用 router.push() 是一回事(就是编程式路由一回事)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>这两种方式都会把路由导航到 /user/123 路径。</p>
<h2 id="编程式的导航-借助-router-的实例方法，通过编写代码来实现，重要的是学to的参数用法"><a href="#编程式的导航-借助-router-的实例方法，通过编写代码来实现，重要的是学to的参数用法" class="headerlink" title="编程式的导航(借助 router 的实例方法，通过编写代码来实现，重要的是学to的参数用法)"></a>编程式的导航(借助 router 的<strong>实例方法</strong>，通过编写代码来实现，重要的是学to的参数用法)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.push(location, onComplete?, onAbort?)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 2.2.0+，可选的在 router.push 或 router.replace 中提供 onComplete 和 onAbort 回调作为第二个和第三个参数。这些回调将会在导航<strong>成功完成</strong> (在所有的异步钩子被解析之后) 或<strong>终止</strong> (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。</p>
<p>注意：如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 /users/1 -&gt; /users/2)，你需要使用 <strong>beforeRouteUpdate</strong> 来响应这个变化 (比如抓取用户信息) (就是前面的动态路由 组件复用)。</p>
</blockquote>
<p>注意：在 <strong>Vue 实例内部</strong>，你可以通过 $router 访问路由实例。因此你可以调用 <strong>this.$router.push</strong>。</p>
<p>想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p>
<p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code>(看到这个用了v-bind哦动态) 等同于调用 router.push(…)。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">声明式</th>
<th style="text-align:center">编程式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>
<td style="text-align:center">router.push(…)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>上面没啥，下面重要来了，to的参数</strong><br><strong>同样的规则也适用于 router-link 组件的 to 属性。</strong></p>
<p>该方法的参数可以是一个<strong>字符串路径</strong>，或者一个描述地址的<strong>对象</strong>。例如：</p>
<p><strong>(3种传参，[path]/[name params]/[path/name+query])</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">router.push('home')</span><br><span class="line"></span><br><span class="line">// 对象</span><br><span class="line">router.push(&#123; path: 'home' &#125;)</span><br><span class="line"></span><br><span class="line">// 命名的路由</span><br><span class="line">router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;)</span><br><span class="line"></span><br><span class="line">// 带查询参数，变成 /register?plan=private</span><br><span class="line">router.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Get请求传参, 看最后一个带查询参数<br>这个明明实在不好形容啊。不过真的是和Get请求一样。你完全可以在链接后加上?进行传参。<br>样例：<a href="http://localhost:8080/linkParamsQuestion?age=18" target="_blank" rel="noopener">http://localhost:8080/linkParamsQuestion?age=18</a><br>项目里获取：<br><code>let age = this.$route.query.age;</code> //问号后面参数会被封装进 this.$route.query;</p>
</blockquote>
<p>注意：<strong>如果提供了 path，params 会被忽略(毕竟路径就代表参数)</strong>，上述例子中的 <strong>query 并不属于这种情况</strong>。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const userId = 123</span><br><span class="line">router.push(&#123; name: 'user', params: &#123; userId &#125;&#125;) // -&gt; /user/123</span><br><span class="line">router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123  es6写法</span><br><span class="line">// 这里的 params 不生效</span><br><span class="line">router.push(&#123; path: '/user', params: &#123; userId &#125;&#125;) // -&gt; /user</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>router.replace(location, onComplete?, onAbort?)</strong></p>
<p>跟 router.push 很像，唯一的不同就是，<strong>它不会向 history 添加新记录</strong>，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">声明式</th>
<th style="text-align:center">编程式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>
<td style="text-align:center">router.replace(…)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>router.go(n)</strong><br>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。</p>
<p>例子<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在浏览器记录中前进一步，等同于 history.forward()</span><br><span class="line">router.go(1)</span><br><span class="line"></span><br><span class="line">// 后退一步记录，等同于 history.back()</span><br><span class="line">router.go(-1)</span><br><span class="line"></span><br><span class="line">// 前进 3 步记录</span><br><span class="line">router.go(3)</span><br><span class="line"></span><br><span class="line">// 如果 history 记录不够用，那就默默地失败呗</span><br><span class="line">router.go(-100)</span><br><span class="line">router.go(100)</span><br></pre></td></tr></table></figure></p>
<p><strong>操作 History(我怎么觉得这东西都不用了)</strong><br>你也许注意到 router.push、 router.replace 和 router.go 跟 window.history.pushState、 window.history.replaceState 和 window.history.go好像， 实际上它们确实是效仿 window.history API 的。</p>
<p>因此，如果你已经熟悉 Browser History APIs，那么在 vue-router 中操作 history 就是超级简单的。</p>
<p>还有值得提及的，vue-router 的导航方法 （push、 replace、 go） 在各类路由模式（history、 hash 和 abstract）下表现一致。</p>
<h2 id="命名视图-同级的视图view，前面讲过嵌套的"><a href="#命名视图-同级的视图view，前面讲过嵌套的" class="headerlink" title="命名视图(同级的视图view，前面讲过嵌套的)"></a>命名视图(同级的视图view，前面讲过嵌套的)</h2><p>有时候想同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 <strong>sidebar（侧导航） 和 main（主内容） 两个视图</strong>，这个时候命名视图就派上用场了。你可以在界面中<strong>拥有多个单独命名的视图</strong>，而不是只有一个单独的出口。如果 router-view <strong>没有设置名字</strong>，那么<strong>默认为 default</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view one"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view two"</span> <span class="attr">name</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view three"</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个视图使用一个组件渲染，因此对于同个路由，<strong>多个视图就需要多个组件</strong>。确保正确使用 <strong>components 配置（带上 s）</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: '/',</span><br><span class="line">      components: &#123;</span><br><span class="line">        default: Foo,</span><br><span class="line">        a: Bar,</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>嵌套命名视图(厉害了，嵌套，同级的合在一起)</strong></p>
<p>重点记住这个就好了<br>我们也有可能使用命名视图创建嵌套视图的复杂布局。这时你也需要命名用到的嵌套 router-view 组件。我们以一个设置面板为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/settings/emails                                       /settings/profile</span><br><span class="line">+-----------------------------------+                  +------------------------------+</span><br><span class="line">| UserSettings                      |                  | UserSettings                 |</span><br><span class="line">| +-----+-------------------------+ |                  | +-----+--------------------+ |</span><br><span class="line">| | Nav | UserEmailsSubscriptions | |  +------------&gt;  | | Nav | UserProfile        | |</span><br><span class="line">| |     +-------------------------+ |                  | |     +--------------------+ |</span><br><span class="line">| |     |                         | |                  | |     | UserProfilePreview | |</span><br><span class="line">| +-----+-------------------------+ |                  | +-----+--------------------+ |</span><br><span class="line">+-----------------------------------+                  +------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>UserSettings 是一个视图组件。</li>
<li>Nav 只是一个常规组件。</li>
<li>UserEmailsSubscriptions、UserProfile、UserProfilePreview 是嵌套的视图组件。</li>
</ul>
<p>就是UserSettings下有左右两块，右边那块又有嵌套。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- UserSettings.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>User Settings<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">NavBar</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"helper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  path: '/settings',</span><br><span class="line">  // 你也可以在顶级路由就配置命名视图</span><br><span class="line">  component: UserSettings,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    path: 'emails',</span><br><span class="line">    component: UserEmailsSubscriptions</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: 'profile',</span><br><span class="line">    components: &#123;</span><br><span class="line">      default: UserProfile,</span><br><span class="line">      helper: UserProfilePreview</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重定向-和-别名"><a href="#重定向-和-别名" class="headerlink" title="重定向 和 别名"></a>重定向 和 别名</h2><p><strong>重定向(一对一，有3种: ‘’, name, =&gt;)</strong></p>
<p>重定向也是通过 <strong>routes 配置</strong>来完成，下面例子是从 /a 重定向到 /b：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/a',</span><br><span class="line">      redirect: '/b'  //就加了这么一条redirect</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>重定向的目标也可以是一个<strong>命名的路由(和编程式to的 name写法一样)</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/a', </span><br><span class="line">      redirect: &#123; name: 'foo' &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>甚至是一个<strong>方法(es6的箭头函数)</strong>，动态返回重定向目标：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/a', </span><br><span class="line">      redirect: to =&gt; &#123;</span><br><span class="line">      // 方法接收 目标路由 作为参数</span><br><span class="line">      // return 重定向的 字符串路径/路径对象</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意<strong>导航守卫并没有应用在跳转路由上</strong>，而仅仅应用在其目标上。在下面这个例子中，为 /a 路由添加一个 beforeEach 或 beforeLeave 守卫并不会有任何效果。</p>
<p><strong>别名(一对多)</strong><br>『<strong>重定向</strong>』的意思是，当用户访问 /a时，URL 将会被<strong>替换成 /b</strong>，然后匹配路由为 /b，那么『别名』又是什么呢？</p>
<p>/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。</p>
<p>上面对应的路由配置为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/a', </span><br><span class="line">      component: A, </span><br><span class="line">      alias: '/b' </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>『别名』的功能让你可以自由地将 UI 结构<strong>映射到任意的 URL</strong>，而<strong>不是受限于配置的嵌套路由结构</strong>。</p>
<h2 id="路由组件传参-props-也有3种模式-布尔，对象，函数"><a href="#路由组件传参-props-也有3种模式-布尔，对象，函数" class="headerlink" title="路由组件传参(props 也有3种模式: 布尔，对象，函数)"></a>路由组件传参(props 也有3种模式: 布尔，对象，函数)</h2><p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。</p>
<p><strong>使用 props 将组件和路由解耦，取代与 $route 的耦合</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//这是动态路由那块的东西</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: '/user/:id', component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>通过 props 解耦</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  props: ['id'],</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User &#123;&#123; id &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: '/user/:id', component: User, props: true &#125;,</span><br><span class="line"></span><br><span class="line">    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span><br><span class="line">    &#123;</span><br><span class="line">      path: '/user/:id',</span><br><span class="line">      components: &#123; default: User, sidebar: Sidebar &#125;,</span><br><span class="line">      props: &#123; default: true, sidebar: false &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>布尔模式</strong><br>如果 props 被设置为 true，route.params 将会被设置为组件属性。</p>
<p><strong>对象模式</strong><br>如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/promotion/from-newsletter', </span><br><span class="line">      component: Promotion, </span><br><span class="line">      props: &#123; newsletterPopup: false &#125; <span class="comment">&lt;!-- 这个newsletterPopup是name么？和布尔模式啥区别，就是同级的用命名视图解耦用么？ --&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>函数模式</strong><br>你可以创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/search', </span><br><span class="line">      component: SearchUser, </span><br><span class="line">      props: (route) =&gt; (&#123; query: route.query.q &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>URL /search?q=vue 会将 {query: ‘vue’} 作为属性传递给 SearchUser 组件。</p>
<p><strong>请尽可能保持 props 函数为无状态的</strong>，因为它只会在路由发生变化时起作用。如果你需要状态来定义 props，请使用包装组件，这样 Vue 才可以对状态变化做出反应。</p>
<h2 id="HTML5-History-模式-暂时不知道"><a href="#HTML5-History-模式-暂时不知道" class="headerlink" title="HTML5 History 模式(暂时不知道)"></a>HTML5 History 模式(暂时不知道)</h2><hr>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="导航守卫（『导航』表示路由正在发生改变。暂时用全局的）"><a href="#导航守卫（『导航』表示路由正在发生改变。暂时用全局的）" class="headerlink" title="导航守卫（『导航』表示路由正在发生改变。暂时用全局的）"></a>导航守卫（『导航』表示路由正在发生改变。暂时用全局的）</h2><p><strong>(做登录拦截 或 loading)</strong></p>
<p>正如其名，vue-router 提供的导航守卫主要用来<strong>通过跳转或取消的方式守卫导航</strong>。有多种机会植入路由导航过程中：<strong>全局的, 单个路由独享的, 或者组件级的。</strong><br>记住<strong>参数或查询的改变并不会触发进入/离开的导航守卫</strong>。你可以通过观察(watch) $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。</p>
<h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><p>你可以使用 <strong>router.beforeEach</strong> 注册一个全局前置守卫：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当一个导航触发时，全局前置守卫<strong>按照创建顺序调用</strong>。守卫是<strong>异步</strong>解析执行，此时导航在所有守卫 <strong>resolve 完之前一直处于 等待</strong>中。</p>
<p>每个守卫方法接收<strong>三个参数</strong>：</p>
<p>to: Route: 即将要进入的目标 路由对象</p>
<p>from: Route: 当前导航正要离开的路由</p>
<p>next: Function: 一定要<strong>调用该方法来 resolve</strong> 这个钩子。执行<strong>效果依赖 next 方法</strong>的调用参数。</p>
<ul>
<li><p>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。</p>
</li>
<li><p>next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。</p>
</li>
<li><p>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。</p>
</li>
<li><p>next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</p>
</li>
</ul>
<p><strong>确保要调用 next 方法，否则钩子就不会被 resolved。</strong></p>
<h3 id="全局解析守卫（router-beforeResolve）"><a href="#全局解析守卫（router-beforeResolve）" class="headerlink" title="全局解析守卫（router.beforeResolve）"></a>全局解析守卫（router.beforeResolve）</h3><p>2.5.0 新增</p>
<p>在 2.5.0+ 你可以用 <strong>router.beforeResolve</strong> 注册一个<strong>全局守卫</strong>。这和 router.beforeEach 类似，<strong>区别</strong>是在导航被确认之前，<strong>同时</strong>在<strong>所有</strong>组件内守卫和异步路由组件<strong>被解析之后</strong>，解析守卫就被调用。</p>
<h3 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h3><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子<strong>不会接受 next 函数也不会改变导航本身</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="组件内的守卫-3个"><a href="#组件内的守卫-3个" class="headerlink" title="组件内的守卫(3个)"></a>组件内的守卫(3个)</h3><p>最后，你可以在路由组件内直接定义以下路由导航守卫：</p>
<p>beforeRouteEnter<br>beforeRouteUpdate (2.2 新增)<br>beforeRouteLeave</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const Foo = &#123;</span><br><span class="line">  template: `...`,</span><br><span class="line">  beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">    // 不！能！获取组件实例 `this`</span><br><span class="line">    // 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br><span class="line">    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">    // 可以访问组件实例 `this`</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">    // 导航离开该组件的对应路由时调用</span><br><span class="line">    // 可以访问组件实例 `this`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>beforeRouteEnter 守卫 <strong>不能访问 this</strong>，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</p>
<p>不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">  next(vm =&gt; &#123;</span><br><span class="line">    // 通过 `vm` 访问组件实例</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 beforeRouteEnter <strong>是支持给 next 传递回调的唯一守卫</strong>。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">  // just use `this`</span><br><span class="line">  this.name = to.params.name</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave (to, from , next) &#123;</span><br><span class="line">  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')</span><br><span class="line">  if (answer) &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next(false)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ol>
<h2 id="路由元信息-可以用来搞允许登录页面"><a href="#路由元信息-可以用来搞允许登录页面" class="headerlink" title="路由元信息(可以用来搞允许登录页面)"></a>路由元信息(可以用来搞允许登录页面)</h2><p>定义路由的时候可以配置 meta 字段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: '/foo',</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: 'bar',</span><br><span class="line">          component: Bar,</span><br><span class="line">          // a meta field 和props挺像的啊</span><br><span class="line">          //设置一个允不允许登录的标志</span><br><span class="line">          meta: &#123; requiresAuth: true &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>那么<strong>如何访问</strong>这个 meta 字段呢？</p>
<p><strong>用处</strong></p>
<p>首先，我们称呼 routes 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录</p>
<p>例如，根据上面的路由配置，/foo/bar 这个 URL 将会<strong>匹配父路由记录以及子路由记录</strong>。</p>
<p>一个路由匹配到的所有路由记录会暴露为 $route 对象（还有在导航守卫中的路由对象）的 <strong>$route.matched</strong> 数组。因此，我们需要遍历 $route.matched 来检查路由记录中的 meta 字段。</p>
<p>下面例子展示在<strong>全局导航守卫中检查</strong>元字段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//全局导航守卫</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  //这个就难懂了</span><br><span class="line">  if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123;</span><br><span class="line">    // this route requires auth, check if logged in</span><br><span class="line">    // if not, redirect to login page 登录页.</span><br><span class="line">    //这个auth.loggedIn 方法是外部引入的，你可以先写好一个校验是否登录的方法，再import进 router.js中去判断</span><br><span class="line">    if (!auth.loggedIn()) &#123;</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: '/login',</span><br><span class="line">        query: &#123; redirect: to.fullPath &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next() // 确保一定要调用 next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="过渡效果-暂时不管"><a href="#过渡效果-暂时不管" class="headerlink" title="过渡效果(暂时不管)"></a>过渡效果(暂时不管)</h2><h2 id="数据获取（这里有渲染导航，还有获取数据两块的）"><a href="#数据获取（这里有渲染导航，还有获取数据两块的）" class="headerlink" title="数据获取（这里有渲染导航，还有获取数据两块的）"></a>数据获取（这里有渲染导航，还有获取数据两块的）</h2><p>有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：</p>
<ul>
<li><p><strong>导航完成之后</strong>获取：先完成导航，然后在接下来的<strong>组件生命周期钩子</strong>中获取数据。在<strong>数据获取期间显示『加载中』之类</strong>的指示。</p>
</li>
<li><p>导航完成<strong>之前</strong>获取：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。</p>
</li>
</ul>
<p>从技术角度讲，两种方式都不错(我喜欢之后的) —— 就看你想要的用户体验是哪种。</p>
<h3 id="导航完成后获取数据"><a href="#导航完成后获取数据" class="headerlink" title="导航完成后获取数据"></a>导航完成后获取数据</h3><p>当你使用这种方式时，我们会<strong>马上导航和渲染组件</strong>，然后在组件的<strong>created 钩子中获取数据</strong>。这让我们有机会在数据获取期间展示<strong>一个 loading 状态</strong>，还可以在<strong>不同视图间展示不同的 loading</strong> 状态。</p>
<p>假设我们有一个 Post 组件，需要基于 $route.params.id 获取文章数据：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading"</span> <span class="attr">v-if</span>=<span class="string">"loading"</span>&gt;</span></span><br><span class="line">      Loading...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"error"</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line">      &#123;&#123; error &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"post"</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; post.title &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; post.body &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      loading: false,</span><br><span class="line">      post: null,</span><br><span class="line">      error: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    // 组件创建完后获取数据，</span><br><span class="line">    // 此时 data 已经被 observed 了</span><br><span class="line">    this.fetchData()</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    // 如果路由有变化，会再次执行该方法</span><br><span class="line">    '$route': 'fetchData'</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fetchData () &#123;</span><br><span class="line">      this.error = this.post = null</span><br><span class="line">      this.loading = true</span><br><span class="line">      // replace getPost with your data fetching util / API wrapper</span><br><span class="line">      getPost(this.$route.params.id, (err, post) =&gt; &#123;</span><br><span class="line">        this.loading = false</span><br><span class="line">        if (err) &#123;</span><br><span class="line">          this.error = err.toString()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.post = post</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在导航完成前获取数据"><a href="#在导航完成前获取数据" class="headerlink" title="在导航完成前获取数据"></a>在导航完成前获取数据</h3><p>通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 <strong>beforeRouteEnter</strong> 守卫中获取数据，当数据获取成功后只调用 next 方法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      post: null,</span><br><span class="line">      error: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class="line">      next(vm =&gt; vm.setData(err, post))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 路由改变前，组件就已经渲染完了</span><br><span class="line">  // 逻辑稍稍不同</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    this.post = null</span><br><span class="line">    getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class="line">      this.setData(err, post)</span><br><span class="line">      next()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    setData (err, post) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        this.error = err.toString()</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.post = post</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，<strong>显示一些进度条或者别的指示</strong>。如果数据获取失败，同样有必要展示一些全局的错误提醒。</p>
<h3 id="滚动行为-就是跳转后滚动条位置确定-用scrollBehavior方法"><a href="#滚动行为-就是跳转后滚动条位置确定-用scrollBehavior方法" class="headerlink" title="滚动行为(就是跳转后滚动条位置确定, 用scrollBehavior方法)"></a>滚动行为(就是跳转后滚动条位置确定, 用scrollBehavior方法)</h3><p>使用前端路由，当<strong>切换到新路由</strong>时，想要页面滚到<strong>顶部</strong>，或者是保持<strong>原先</strong>的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p>
<p><strong>注意: 这个功能只在支持 history.pushState 的浏览器中可用。</strong></p>
<p>当创建一个 Router 实例，你可以提供一个 <strong>scrollBehavior</strong> 方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [...],</span><br><span class="line">  scrollBehavior (to, from, savedPosition) &#123;  </span><br><span class="line">    // return 期望滚动到哪个的位置</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>scrollBehavior 方法<strong>接收 to 和 from 路由对象</strong>。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。</p>
<p>这个方法返回滚动位置的对象信息，长这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; x: number, y: number &#125;</span><br><span class="line">&#123; selector: string, offset? : &#123; x: number, y: number &#125;&#125; (offset 只在 2.6.0+ 支持)</span><br></pre></td></tr></table></figure>
<p>如果返回一个 falsy (译者注：falsy 不是 false，参考这里)的值，或者是一个空对象，那么不会发生滚动。</p>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">  return &#123; x: 0, y: 0 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于所有路由导航，简单地让页面滚动到顶部<br>返回 savedPosition，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">  if (savedPosition) &#123;</span><br><span class="line">    return savedPosition</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &#123; x: 0, y: 0 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你要模拟『<strong>滚动到锚点</strong>』的行为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">  if (to.hash) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      selector: to.hash</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="路由懒加载-路由不用变，变的是webpack配置，和我想的有点不一样"><a href="#路由懒加载-路由不用变，变的是webpack配置，和我想的有点不一样" class="headerlink" title="路由懒加载(路由不用变，变的是webpack配置，和我想的有点不一样)"></a>路由懒加载(路由不用变，变的是webpack配置，和我想的有点不一样)</h3><h2 id="Router-构造配置"><a href="#Router-构造配置" class="headerlink" title="Router 构造配置"></a>Router 构造配置</h2><p><strong>routes</strong>(<strong>一看感觉都见过了，确实</strong>)<br>类型: Array<routeconfig></routeconfig></p>
<p>RouteConfig 的类型定义：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">declare type RouteConfig = &#123;</span><br><span class="line">  path: string;</span><br><span class="line">  component?: Component;</span><br><span class="line">  name?: string; // 命名路由</span><br><span class="line">  components?: &#123; [name: string]: Component &#125;; // 命名视图组件</span><br><span class="line">  redirect?: string | Location | Function;</span><br><span class="line">  props?: boolean | string | Function;</span><br><span class="line">  alias?: string | Array<span class="tag">&lt;<span class="name">string</span>&gt;</span>;</span><br><span class="line">  children?: Array<span class="tag">&lt;<span class="name">RouteConfig</span>&gt;</span>; // 嵌套路由</span><br><span class="line">  beforeEnter?: (to: Route, from: Route, next: Function) =&gt; void;</span><br><span class="line">  meta?: any;</span><br><span class="line"></span><br><span class="line">  // 2.6.0+</span><br><span class="line">  caseSensitive?: boolean; // 匹配规则是否大小写敏感？(默认值：false)</span><br><span class="line">  pathToRegexpOptions?: Object; // 编译正则的选项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>mode(一种hash， 一种history)</strong><br>类型: string</p>
<p>默认值: “hash” (浏览器环境) | “abstract” (Node.js 环境)</p>
<p>可选值: “hash” | “history” | “abstract”</p>
<p>配置路由模式:</p>
<p>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。</p>
<p>history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</p>
<p>abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。</p>
<p><strong>base</strong><br>类型: string</p>
<p>默认值: “/“</p>
<p><strong>应用的基路径</strong>。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 “/app/“。<br>一般写成 <strong>__dirname</strong>，在<strong>webpack</strong>中有配置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/31/vue2getstart/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/31/vue2getstart/" itemprop="url">vue2getstart</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-31T16:31:50+08:00">2018-01-31</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vue2的入门"><a href="#vue2的入门" class="headerlink" title="vue2的入门"></a>vue2的入门</h1><p>开始梳理一下vue2的入门，主要还是一些模块的使用，反正vue2就是路由和模块</p>
<h2 id="vue2-getstart-vue实例"><a href="#vue2-getstart-vue实例" class="headerlink" title="vue2 getstart vue实例"></a>vue2 getstart vue实例</h2><p>通过下面语句可以动态查看data</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;&#123;$data | json&#125;&#125; <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你也可以自定义一个json的filters ，方法同methods<br>有时候删除不一定要定义methods 也可以用filters</p>
<p>老外的那个例子来讲些vue基础</p>
<p>主要讲解用到了</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v-bind</span><br><span class="line"></span><br><span class="line">v-text &#123;&#123;&#125;&#125; v-if v-show v-for v-on ref v-model .prevant</span><br><span class="line"></span><br><span class="line">el data methdos computed filters mounted</span><br></pre></td></tr></table></figure>
<p>过滤器|只用在mustache和v-bind表达式中，在v-for中用的话写一个computed</p>
<p>做一个，todolist的例子，实现增删改功能。<br>上面部分是tasks，下面部分是完成打钩的tasks。</p>
<p><img src="getstart.png" alt="getstart"></p>
<hr>
<h2 id="创建一个-Vue-实例以及数据与方法"><a href="#创建一个-Vue-实例以及数据与方法" class="headerlink" title="创建一个 Vue 实例以及数据与方法"></a>创建一个 Vue 实例以及数据与方法</h2><p>v-bind和v-model都是双向绑定，但v-model特别的用在表单中就好了，v-bind也可以用在表单，用来动态绑定value</p>
<p>当一个 Vue 实例被创建时，它向 Vue 的<strong>响应式</strong>系统中加入了其 data 对象中能找到的所有的属性。<br>只有当实例被创建时 <strong>data 中存在的属性</strong>才是响应式的，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;meg&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">      msg: <span class="string">''</span>       <span class="comment">//这个msg是响应的,name不是响应式的，也可以说在vue实例中没name这个东西，不存在给name响应式。</span></span><br><span class="line">      <span class="comment">//name: '' 所以给暂时没用到的可以设置为空值就好了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般实例就</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>关于使用<strong>Object.freeze(obj)</strong>来阻止响应式，如果这个data是放在vue的data中该怎么freeze？<br>比如上面的msg，我总不能也在vue实例外面var一个吧，然后freeze。</p>
<p>官网的例子是可以freeze的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data () &#123;     <span class="comment">//看到这里和上面的写法不一样，是因为这个是按组件的写法，data写成一个函数，防止复用组件时作用域混了</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      obj</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>除了数据属性，<strong>Vue 实例</strong>还暴露了一些有用的<strong>实例属性与方法</strong>，它们都有<strong>前缀 $</strong>，以便与用户定义的属性区分开来</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例属性</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>) <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//嵌套对象的增添</span></span><br><span class="line">vm.$set(<span class="keyword">this</span>.userProfile, <span class="string">'age'</span>, <span class="number">27</span>)</span><br><span class="line"></span><br><span class="line">对于</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//$el,$data</span></span><br><span class="line">$el === <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>) <span class="comment">// =&gt; true</span></span><br><span class="line">$data === data <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">$watch</span><br><span class="line"></span><br><span class="line">比如用来看数据</span><br><span class="line">&lt;pre&gt; &#123;&#123;$data | json&#125;&#125; &lt;<span class="regexp">/pre&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="vue-lifecycle"><a href="#vue-lifecycle" class="headerlink" title="vue lifecycle"></a>vue lifecycle</h2><pre><code>可以通过例子vuelifecycyle.html来观察
</code></pre><p>beforecreate : 可以在这加个loading事件<br>created ：在这结束loading，还做一些初始化，实现函数自执行<br>mounted ： 在这发起axios请求，拿回数据，配合路由钩子做一些事情<br>beforeDestory： destoryed ：当前组件已被删除，清空相关内容</p>
<p><a href="https://segmentfault.com/a/1190000008010666" target="_blank" rel="noopener">Vue2.0 探索之路——生命周期和钩子函数的一些理解</a></p>
<hr>
<h2 id="模板语法-去HTML中了"><a href="#模板语法-去HTML中了" class="headerlink" title="模板语法 去HTML中了"></a>模板语法 去HTML中了</h2><h3 id="插值-Mustache-和-v-bind-一个用在文本，一个用在属性"><a href="#插值-Mustache-和-v-bind-一个用在文本，一个用在属性" class="headerlink" title="插值 Mustache 和 v-bind(:) (一个用在文本，一个用在属性)"></a>插值 Mustache 和 v-bind(:) (一个用在文本，一个用在属性)</h3><p>常见的数据绑定就是使用“Mustache”语法 (双大括号) 的<strong>文本</strong>插值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br><span class="line">//v-text效果一样，但不好用</span><br><span class="line">&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">//加了v-once表示执行一次性地插值，只执行一次哦</span><br><span class="line">&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br><span class="line">//v-html输出真正的 HTML，暂时不用，防止被xss攻击</span><br></pre></td></tr></table></figure>
<p>上面Mustache 语法用在文本上，不能作用在 HTML 特性（属性）上，遇到这种情况应该使用 v-bind 指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>上面两者都只能使用单个js表达式，事实上所有v-指令除了v-for都是。<br>指令么暂时 v-if v-show v-for v-on(@)<br><strong>参数</strong><br>再说下布尔值 truthy和falsy。falsy有5种：0，false，undefined， null， ‘’<br>还有别的参数，就当变量好了：串，函数</p>
<p><strong>修饰符</strong> <strong>缩写</strong></p>
<hr>
<h2 id="又回到vue实例中：计算属性和观察者"><a href="#又回到vue实例中：计算属性和观察者" class="headerlink" title="又回到vue实例中：计算属性和观察者"></a>又回到vue实例中：计算属性和观察者</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span></span><br><span class="line">    data: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>从刚开始的 el data<br>后面还有 filters<br>现在加上 <strong>computed methods watch</strong>  三者区别看<a href="https://juejin.im/post/58d8806bac502e0058d778a1" target="_blank" rel="noopener">史上最详细 VUE2.0 全套 demo 讲解 基础3（计算属性）</a></p>
<p>一.computed前面说了是适用于对多数据变动进行监听，然后来维护一个状态，就是返回一个状态<br>二.watch是对一个数据监听，在数据变化时，会返回两个值 ，一个是value(当前值)，二个是oldvalue是变化前的值，我们可以通过这些变化也可以去维护一个状态，但是不符合场景，主要用于什么地方呢？主要用于监听一个数据来进行复杂的逻辑操作,如图片加载完ajax，开销大的</p>
<p>当然别忘了lifecycle的 created mounted updated destroyed 以及他们对应的before</p>
<h3 id="在模板中（mustache），对于任何复杂逻辑，你都应当使用计算属性"><a href="#在模板中（mustache），对于任何复杂逻辑，你都应当使用计算属性" class="headerlink" title="在模板中（mustache），对于任何复杂逻辑，你都应当使用计算属性"></a>在模板中（mustache），对于任何复杂逻辑，你都应当使用计算属性</h3><p>官网例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"example"</span>&gt;</span><br><span class="line">  &#123;&#123; message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) &#125;&#125;       <span class="comment">//太多了</span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/改写为</span></span><br><span class="line"><span class="regexp">&lt;div id="example"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;Original message: "&#123;&#123; message &#125;&#125;"&lt;/</span>p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: <span class="string">"&#123;&#123; reversedMessage &#125;&#125;"</span>&lt;<span class="regexp">/p&gt;     /</span><span class="regexp">/这就清楚多了</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>计算属性的 setter</strong><br>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的写法和默认只有get的写法稍有不同</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;       <span class="comment">//here</span></span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">//这里看到了吗</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>计算属性缓存 vs 方法</strong></p>
<p>计算属性(computed)是基于它们的依赖进行<strong>缓存</strong>的。计算属性只有在它的相关依赖发生改变时才会重新求值。<br>方法(mtehods)：每当触发重新渲染时，调用方法将总会再次执行函数</p>
<p><strong>计算属性 vs 侦听属性</strong><br>侦听属性:当你有一些数据需要随着其它数据变动而变动时.通常更好的做法是使用计算属性而不是命令式的 watch 回调.<strong>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的</strong></p>
<p>官网例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"watch-example"</span>&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    &lt;input v-model=<span class="string">"question"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/cdn.jsdelivr.net/</span>npm/axios@<span class="number">0.12</span><span class="number">.0</span>/dist/axios.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>https:<span class="comment">//cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#watch-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    question: <span class="string">''</span>,</span><br><span class="line">    answer: <span class="string">'I cannot give you an answer until you ask a question!'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="line">    question: <span class="function"><span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.answer = <span class="string">'Waiting for you to stop typing...'</span></span><br><span class="line">      <span class="keyword">this</span>.getAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span><br><span class="line">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span><br><span class="line">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span><br><span class="line">    <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span><br><span class="line">    <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span><br><span class="line">    getAnswer: _.debounce(</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.question.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.answer = <span class="string">'Questions usually contain a question mark. ;-)'</span></span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.answer = <span class="string">'Thinking...'</span></span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">        axios.get(<span class="string">'https://yesno.wtf/api'</span>)</span><br><span class="line">          .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            vm.answer = <span class="string">'Error! Could not reach the API. '</span> + error</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 这是我们为判定用户停止输入等待的毫秒数</span></span><br><span class="line">      <span class="number">500</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="Class-与-Style-绑定-又回到模板中"><a href="#Class-与-Style-绑定-又回到模板中" class="headerlink" title="Class 与 Style 绑定 又回到模板中"></a>Class 与 Style 绑定 <strong>又回到模板中</strong></h2><p>都是属性啊，所以用v-bind，而且表达式结果的类型除了字符串之外，还可以是对象或数组<br>注意对象是key:value  数组时value 反正就是看对value就行</p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p><strong>对象</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这就是对象了 =&#123;&#125; key:value  本来是字符串=""</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive &#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多个</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"static"</span></span><br><span class="line">     v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">data: &#123;</span></span><br><span class="line"><span class="regexp">  isActive: true,</span></span><br><span class="line"><span class="regexp">  hasError: false</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/当然也可以直接就写个对象名</span></span><br><span class="line"><span class="regexp">&lt;div v-bind:class="classObject"&gt;&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'text-danger'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常用的还有写成computed的</span></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">'text-danger'</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">'fatal'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组 =[]    稍微和对象不一样哦这里只有value</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[activeClass, errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: <span class="string">'active'</span>,</span><br><span class="line">  errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组中也有对象哦，可以当做有个默认值</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[&#123; active: isActive &#125;, errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="style-会自动添加浏览器前缀"><a href="#style-会自动添加浏览器前缀" class="headerlink" title="style (会自动添加浏览器前缀)"></a>style (会自动添加浏览器前缀)</h3><p><strong>对象</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名，不推荐</span></span><br><span class="line">&lt;div v-bind:style=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: <span class="string">'red'</span>,</span><br><span class="line">  fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接绑定到一个样式对象通常更好，这会让模板更清晰：</span></span><br><span class="line">&lt;div v-bind:style=<span class="string">"styleObject"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="string">'13px'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同样的，对象语法常常结合返回对象的计算属性使用</span></span><br></pre></td></tr></table></figure></p>
<p><strong>数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上：</span></span><br><span class="line"></span><br><span class="line">&lt;div v-bind:style=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>当然他们还有在组件中应用，暂时不说</strong></p>
<hr>
<h2 id="接着说指令了，开始v-if-v-show-v-for-v-on"><a href="#接着说指令了，开始v-if-v-show-v-for-v-on" class="headerlink" title="接着说指令了，开始v-if v-show v-for -v-on"></a>接着说指令了，开始v-if v-show v-for -v-on</h2><h3 id="条件渲染-先说v-if-v-show"><a href="#条件渲染-先说v-if-v-show" class="headerlink" title="条件渲染 先说v-if v-show"></a>条件渲染 先说<strong>v-if v-show</strong></h3><p>看代码就明白了 <strong>v-if</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对一个元素 v-if v-else-if v-else 一个表示就一个根节点</span></span><br><span class="line">&lt;div v-<span class="keyword">if</span>=<span class="string">"type === 'A'"</span>&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div v-else-if="type === 'B'"&gt;</span></span><br><span class="line"><span class="regexp">  B</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;div v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"type === 'C'"</span>&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div v-else&gt;</span></span><br><span class="line"><span class="regexp">  Not A/</span>B/C</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/多个元素就要加上&lt;template&gt;，这个表示同级的(没有根节点，比如在表单中就不会用到嵌套,用的是同级的)，当然你直接在父元素上加也行啊(这就是嵌套)</span></span><br><span class="line"><span class="regexp">&lt;template v-if="ok"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;h1&gt;Title&lt;/</span>h1&gt;</span><br><span class="line">  &lt;p&gt;Paragraph <span class="number">1</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;Paragraph 2&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure>
<p>再说下key，上面的没加key是会复用的，所以会发生不会清除用户已经输入内容的情况<br>key表示”这两个元素是完全独立的，不要复用它们”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-<span class="keyword">if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/key加在了这里哦</span></span><br><span class="line"><span class="regexp">  &lt;input placeholder="Enter your username" key="username-input"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;template v-<span class="keyword">else</span>&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/还有这里</span></span><br><span class="line"><span class="regexp">  &lt;input placeholder="Enter your email address" key="email-input"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure>
<p><strong>v-show</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//只有一种形式，不多对于多个的只需要在父节点处用v-show就行了，反正不用同级的</span><br><span class="line">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>v-if vs v-show</strong><br>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>
<p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换display:none。</p>
<p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>
<p><strong>v-if 与 v-for 一起使用</strong><br>当 v-if 与 v-for 一起使用时，<strong>v-for</strong> 具有比 v-if 更高的<strong>优先级</strong></p>
<hr>
<h2 id="列表渲染-也就是v-for-优先级比v-if高"><a href="#列表渲染-也就是v-for-优先级比v-if高" class="headerlink" title="列表渲染 也就是v-for 优先级比v-if高"></a>列表渲染 也就是v-for 优先级比v-if高</h2><p>当然这个使用在对数组[] 以及对象的 \{\}</p>
<h3 id="用-v-for-把一个数组对应为一组元素"><a href="#用-v-for-把一个数组对应为一组元素" class="headerlink" title="用 v-for 把一个数组对应为一组元素"></a>用 v-for 把一个数组对应为一组元素</h3><p>在 v-for 块中，我们拥有对父作用域属性的完全访问权限<br>2种方式。一个是v-for=”item in items”   items 是源数据数组并且 item 是数组元素迭代的别名<br>一个是v-for=”(item, index) in items”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种只有value</span></span><br><span class="line">&lt;ul id=<span class="string">"example-1"</span>&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">"item in items"</span>&gt;</span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种有value和index</span></span><br><span class="line">&lt;ul id=<span class="string">"example-2"</span>&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">"(item, index) in items"</span>&gt;</span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMessage: <span class="string">'Parent'</span>,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="一个对象对应为一组元素"><a href="#一个对象对应为一组元素" class="headerlink" title="一个对象对应为一组元素"></a>一个对象对应为一组元素</h3><p>这就有3种了 毕竟对象有key: value  不过这里按 value key index 理由当然也是先拿value咯,不过还是<strong>按key的顺序</strong>哦<br>在遍历对象时，是按<strong> Object.keys()</strong> 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。<br>第1种是v-for=”value in object”<br>第2种是v-for=”(value, key) in object”<br>第3种是v-for=”(value, key, index) in object”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">&lt;ul id=<span class="string">"v-for-object"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">"value in object"</span>&gt;</span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#v-for-object'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      firstName: <span class="string">'John'</span>,</span><br><span class="line">      lastName: <span class="string">'Doe'</span>,</span><br><span class="line">      age: <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供第二个的参数为键名：</span></span><br><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">"(value, key) in object"</span>&gt;</span><br><span class="line">  &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/第三个参数为索引：</span></span><br><span class="line"><span class="regexp">&lt;div v-for="(value, key, index) in object"&gt;</span></span><br><span class="line"><span class="regexp">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="key，当然表示唯一咯，同v-if啦"><a href="#key，当然表示唯一咯，同v-if啦" class="headerlink" title="key，当然表示唯一咯，同v-if啦"></a>key，当然表示唯一咯，同v-if啦</h3><p><strong>建议尽可能在使用 v-for 时提供 key</strong><br>理想的 key 值是每项都有的且唯一的 id，它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值。<br>一般在数组或对象中提供了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">"item in items"</span> :key=<span class="string">"item.id"</span>&gt;</span><br><span class="line">  &lt;!-- 内容 --&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>它是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途，我们将在后面的指南中看到其他用途</strong></p>
<h3 id="数组更新检测-其实不用管这个，v-for还是会触发视图更新"><a href="#数组更新检测-其实不用管这个，v-for还是会触发视图更新" class="headerlink" title="数组更新检测(其实不用管这个，v-for还是会触发视图更新)"></a>数组更新检测(其实不用管这个，v-for还是会触发视图更新)</h3><p><strong>变异方法</strong> 就是改变原数组咯</p>
<ul>
<li>push()</li>
<li>pop()</li>
<li>unshift()</li>
<li>shift()</li>
<li>reverse()</li>
<li>sort()</li>
<li>splice()</li>
<li>clear()</li>
</ul>
<p><strong>替换数组</strong> 就是返回一个新数组咯</p>
<p>filter(), concat() 和 slice() map()</p>
<h2 id="有2种情况下数组检测不到更新-因为js的限制，要换方法使用"><a href="#有2种情况下数组检测不到更新-因为js的限制，要换方法使用" class="headerlink" title="有2种情况下数组检测不到更新(因为js的限制，要换方法使用)"></a>有2种情况下数组检测不到更新(因为js的限制，要换方法使用)</h2><ol>
<li>当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue</li>
<li>当你修改数组的长度时，例如：vm.items.length = newLength</li>
</ol>
<p><strong>看下面 我觉得统一下 用splice好了</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新：</span><br><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(example1.items, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">example1.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br><span class="line"></span><br><span class="line">为了解决第二类问题，你可以使用 splice：</span><br><span class="line">example1.items.splice(newLength)</span><br></pre></td></tr></table></figure></p>
<h3 id="上面是数组的增删，可以检测到，但对象属性的增删-又由于JS限制，检测不到。增加一个属性或多个属性"><a href="#上面是数组的增删，可以检测到，但对象属性的增删-又由于JS限制，检测不到。增加一个属性或多个属性" class="headerlink" title="上面是数组的增删，可以检测到，但对象属性的增删(又由于JS限制，检测不到。增加一个属性或多个属性)"></a>上面是数组的增删，可以检测到，但对象属性的增删(又由于JS限制，检测不到。增加一个属性或多个属性)</h3><p>就是不对<strong>根级别</strong>添加，而是对<strong>根里面嵌套的对象</strong>的添加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// `vm.a` 现在是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 不是响应式的</span></span><br></pre></td></tr></table></figure>
<p>对于已经创建的实例，Vue 不能动态添加<strong>根级别</strong>的响应式属性。但是，可以使用 Vue.set(object, key, value) 方法向<strong>嵌套对象</strong>添加响应式属性。例如，对于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userProfile: &#123;      <span class="comment">//看这里，嵌套哦</span></span><br><span class="line">      name: <span class="string">'Anika'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">你可以添加一个新的 age 属性到嵌套的 userProfile 对象：</span><br><span class="line"></span><br><span class="line">Vue.set(vm.userProfile, <span class="string">'age'</span>, <span class="number">27</span>)</span><br><span class="line"></span><br><span class="line">你还可以使用 vm.$set 实例方法，它只是上面全局 Vue.set 的别名：</span><br><span class="line"></span><br><span class="line">vm.$set(<span class="keyword">this</span>.userProfile, <span class="string">'age'</span>, <span class="number">27</span>)</span><br></pre></td></tr></table></figure>
<p>有时你可能需要为已有对象赋予<strong>多个新属性</strong>，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(<span class="keyword">this</span>.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br><span class="line">你应该这样做：</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.userProfile = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="v-for-显示过滤-排序结果-这个用不来filters，用computed，methods"><a href="#v-for-显示过滤-排序结果-这个用不来filters，用computed，methods" class="headerlink" title="v-for 显示过滤/排序结果(这个用不来filters，用computed，methods)"></a>v-for 显示过滤/排序结果(这个用不来filters，用computed，methods)</h3><p><strong>数组</strong><br>有时，我们想要显示一个<strong>数组</strong>的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的<strong>计算属性</strong>。</p>
<p>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">"n in evenNumbers"</span>&gt;&#123;&#123; n &#125;&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">data: &#123;</span></span><br><span class="line"><span class="regexp">  numbers: [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">computed: &#123;</span></span><br><span class="line"><span class="regexp">  evenNumbers: function () &#123;</span></span><br><span class="line"><span class="regexp">    return this.numbers.filter(function (number) &#123;</span></span><br><span class="line"><span class="regexp">      return number % 2 === 0</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>在计算属性不适用的情况下 (例如，<strong>在嵌套 v-for 循环中</strong>) 你可以使用一个 method 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">"n in even(numbers)"</span>&gt;&#123;&#123; n &#125;&#125;&lt;<span class="regexp">/li&gt;     /</span><span class="regexp">/可以看到这里不同</span></span><br><span class="line"><span class="regexp">data: &#123;</span></span><br><span class="line"><span class="regexp">  numbers: [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">methods: &#123;</span></span><br><span class="line"><span class="regexp">  even: function (numbers) &#123;</span></span><br><span class="line"><span class="regexp">    return numbers.filter(function (number) &#123;</span></span><br><span class="line"><span class="regexp">      return number % 2 === 0</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>一段取值范围的 v-for 整数</strong><br>v-for 也可以取整数。在这种情况下，它将重复多次模板。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"n in 10"</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>v-for on a <code>&lt;template&gt;</code>  多个同级，上面是一个根元素</strong><br>类似于 v-if，你也可以利用带有 v-for 的 <template> 渲染多个元素。比如：</template></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;template v-<span class="keyword">for</span>=<span class="string">"item in items"</span>&gt;</span><br><span class="line">    &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li class="divider"&gt;&lt;/</span>li&gt;</span><br><span class="line">  &lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>
<p><strong>v-for with v-if 前面说的优先级问题，在同一个标签上v-for高</strong><br>当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你想为<strong>仅有的一些项渲染节点</strong>时，这种优先级的机制会十分有用，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span> <span class="attr">v-if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span></span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码只传递了未完成的 todos。</p>
<p>而如果你的目的是<strong>有条件地跳过循环的执行</strong>，那么可以将 v-if 置于外层元素 (或 <template>)上。如：</template></p>
<p>这里没啥优先级而言，都不在一个元素标签上</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"todos.length"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No todos left!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="组件的v-for-（看完组件那块再回来体会）"><a href="#组件的v-for-（看完组件那块再回来体会）" class="headerlink" title="组件的v-for  （看完组件那块再回来体会）"></a>组件的v-for  （看完组件那块再回来体会）</h3><p>在自定义组件里，你可以像任何普通元素一样用 v-for 。用法不变,key一定要加 （但是这种做法错误的哦）。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>重点</strong></p>
<p>因为任何数据都<strong>不会被自动</strong>传递到组件里，因为组件有自己<strong>独立的作用域</strong>。为了把迭代数据传递到组件里，我们要用<strong> props</strong> ：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//上面的要改为这样写</span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:item</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>不自动</strong>将 item <strong>注入</strong>到组件里的<strong>原因</strong>是，这会使得组件与 v-for 的运作紧密<strong>耦合</strong>。明确组件数据的来源能够使组件在其他场合重复使用</p>
<p>下面是一个简单的 todo list 的完整例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"todo-list-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"newTodoText"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:keyup.enter</span>=<span class="string">"addNewTodo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">placeholder</span>=<span class="string">"Add a todo"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line">      is="todo-item"        //这里不是&lt;todo-item&gt; &lt;/todo-item&gt;</span><br><span class="line">      v-for="(todo, index) in todos"</span><br><span class="line">      v-bind:key="todo.id"</span><br><span class="line">      v-bind:title="todo.title"     //这里title 在组件中的props中绑定，todo.title才是变量名</span><br><span class="line">      v-on:remove="todos.splice(index, 1)"</span><br><span class="line">    &gt;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意这里的 is=”todo-item” 属性。这种做法在使用 DOM 模板时是十分必要的，<strong>因为在 <code>&lt;ul&gt;</code> 元素内只有 <code>&lt;li&gt;</code> 元素会被看作有效内容</strong>。这样做实现的效果与 <todo-item> 相同，但是可以避开一些潜在的浏览器解析错误</todo-item></p>
<p>类似的还有在<code>&lt;ul&gt;、&lt;ol&gt;、&lt;table&gt;、&lt;select&gt;</code></p>
<p><strong>当然有办法不这么麻烦 最简单的就是使用vue-cli咯</strong></p>
<p>如果使用来自以下来源之一的字符串模板，则没有这些限制：</p>
<ul>
<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>
<li>JavaScript 内联模板字符串</li>
<li>.vue 组件</li>
</ul>
<p>因此，请尽可能使用字符串模板。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  template: <span class="string">'\</span></span><br><span class="line"><span class="string">    &lt;li&gt;\</span></span><br><span class="line"><span class="string">      &#123;&#123; title &#125;&#125;\</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="$emit(\'remove\')"&gt;X&lt;/button&gt;\</span></span><br><span class="line"><span class="string">    &lt;/li&gt;\</span></span><br><span class="line"><span class="string">  '</span>,</span><br><span class="line">  props: [<span class="string">'title'</span>]      <span class="comment">//这是属性哦，title是属性名，不是变量名</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#todo-list-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    newTodoText: <span class="string">''</span>,</span><br><span class="line">    todos: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        title: <span class="string">'Do the dishes'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        title: <span class="string">'Take out the trash'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">3</span>,</span><br><span class="line">        title: <span class="string">'Mow the lawn'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    nextTodoId: <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addNewTodo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line">        id: <span class="keyword">this</span>.nextTodoId++,</span><br><span class="line">        title: <span class="keyword">this</span>.newTodoText</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.newTodoText = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="事件处理-（到v-on了-这个是监听事件，不是触发）"><a href="#事件处理-（到v-on了-这个是监听事件，不是触发）" class="headerlink" title="事件处理 （到v-on了 @ 这个是监听事件，不是触发）"></a>事件处理 （到v-on了 @ 这个是监听事件，不是触发）</h2><p><a href="https://juejin.im/post/58de6807da2f60005fc1a9bb" target="_blank" rel="noopener">Vue2.0进阶组件篇1 教你秒撸（短信倒计时组件）</a></p>
<p>可以用 v-on 指令<strong>监听(on) DOM 事件</strong>，并<strong>在触发时(emit)</strong>运行一些 JavaScript 代码。</p>
<p>示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"counter += 1"</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span>      //这里把方法直接写在""内了</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">var example1 = new Vue(&#123;</span><br><span class="line">  el: '#example-1',</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>更常见的，直接写一个方法名称</strong></p>
<p>然而许多事件处理逻辑会更为<strong>复杂</strong>，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的<strong>方法名称</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"greet"</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">var example2 = new Vue(&#123;</span><br><span class="line">  el: '#example-2',</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: 'Vue.js'</span><br><span class="line">  &#125;,</span><br><span class="line">  // 在 `methods` 对象中定义方法</span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: function (event) &#123;</span><br><span class="line">      // `this` 在方法里指向当前 Vue 实例</span><br><span class="line">      alert('Hello ' + this.name + '!')</span><br><span class="line">      // `event` 是原生 DOM 事件</span><br><span class="line">      if (event) &#123;</span><br><span class="line">        alert(event.target.tagName)     //这里还会弹出个'BUTTON'</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// F12也可以用 JavaScript 直接调用方法</span><br><span class="line">example2.greet() // =&gt; 'Hello Vue.js!' 没有'BUTTON'了</span><br></pre></td></tr></table></figure>
<p>除了直接绑定到一个方法，也可以在<strong>内联 JavaScript 语句中调用方法(传入参数就用好了)</strong>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('hi')"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span>    <span class="comment">&lt;!-- 直接传入参数用了 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('what')"</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-3',</span><br><span class="line">  methods: &#123;</span><br><span class="line">    say: function (message) &#123;</span><br><span class="line">      alert(message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>有时也需要在内联语句处理器中访问<strong>原始的 DOM 事件(这里是button)</strong>。可以用特殊变量 <strong>$event</strong> 把它传入方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"warn('Form cannot be submitted yet.', $event)"</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">// ...</span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: function (message, event) &#123;</span><br><span class="line">    // 现在我们可以访问原生事件对象 不懂这个什么意思</span><br><span class="line">    if (event) event.preventDefault()</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个小例子说明event.preventDefault()来阻止默认事件的发生，event.stopPropagation()阻止事件的冒泡<br>比如<code>&lt;a&gt;</code>点击它会发生跳转，用了preventDefault()之后就不跳转了,但会向上冒泡。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong><br>1.event.stopPropagation()方法<br>这是<strong>阻止事件的冒泡</strong>方法，不让事件向documen上蔓延，<strong>但是默认事件仍然会执行</strong>，当你掉用这个方法的时候，如果点击一个连接，这个连接仍然会被打开，</p>
<p>2.event.preventDefault()方法<br>这是<strong>阻止默认事件</strong>的方法，调用此方法是，连接不会被打开，<strong>但是会发生冒泡</strong>，冒泡会传递到上一层的父元素；</p>
<p>3.return false  ；<br>这个方法比较暴力，他会<strong>同时阻止事件冒泡也会阻止默认事件</strong>；写上此代码，连接不会被打开，事件也不会传递到上一层的父元素；可以理解为return false就等于同时调用了event.stopPropagation()和event.preventDefault()</p>
<p>不懂event.preventDefault()可以看下这个链接<br><a href="http://blog.csdn.net/wxl1555/article/details/53128966" target="_blank" rel="noopener">阻止事件冒泡，阻止默认事件，event.stopPropagation()和event.preventDefault()，return false的区别</a><br><a href="http://blog.csdn.net/zhangluo123__/article/details/72179543" target="_blank" rel="noopener">浅谈js中事件preventDefault()和addEventListener()</a></p>
<h4 id="v-on事件修饰符（接着上面的event-preventDefault-和event-stopPropagation-）"><a href="#v-on事件修饰符（接着上面的event-preventDefault-和event-stopPropagation-）" class="headerlink" title="v-on事件修饰符（接着上面的event.preventDefault()和event.stopPropagation()）"></a>v-on事件修饰符（接着上面的event.preventDefault()和event.stopPropagation()）</h4><p>在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是<strong>非常常见的需求</strong>。尽管我们可以在方法中轻松实现这点，<strong>但更好的方式是</strong>：方法<strong>只有纯粹的数据逻辑</strong>，而不是去处理 DOM 事件细节。</p>
<p>修饰符是由点开头的指令后缀来表示的，记5个</p>
<ul>
<li>stop      (event.stopPropagation())</li>
<li>prevent   (event.preventDefault())</li>
<li>capture</li>
<li>self</li>
<li>once      (这个和前面介绍过的v-once一样，都只一次)</li>
<li>passive   (尤其能够提升移动端的性能。对应 addEventListener 中的 passive 选项)</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 就是event.stopPropagation()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 就是event.preventDefault()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 注意次序很重要--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 (先自己，在内部，这什么操作，冒泡呢)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 (不是冒泡过来的，是自身div)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">"onScroll"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><p>记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>全部的按键别名：</p>
<ul>
<li>enter</li>
<li>tab</li>
<li>delete (捕获“删除”和“退格”键)</li>
<li>esc</li>
<li>space</li>
<li>up</li>
<li>down</li>
<li>left</li>
<li>right</li>
</ul>
<p>可以通过全局 config.keyCodes 对象自定义按键修饰符别名：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 可以使用 `v-on:keyup.f1`</span><br><span class="line">Vue.config.keyCodes.f1 = 112</span><br></pre></td></tr></table></figure>
<h4 id="系统修饰键-这个只要有一个按下了就行，模糊，要精准加-exact修饰符"><a href="#系统修饰键-这个只要有一个按下了就行，模糊，要精准加-exact修饰符" class="headerlink" title="系统修饰键(这个只要有一个按下了就行，模糊，要精准加.exact修饰符)"></a>系统修饰键(这个只要有一个按下了就行，模糊，要精准加.exact修饰符)</h4><p>请注意修饰键与常规按键不同，在<strong>和 keyup 事件一起用</strong>时，事件触发时修饰键<strong>必须处于按下状态</strong>。换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。</p>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>
<ul>
<li>ctrl</li>
<li>alt</li>
<li>shift</li>
<li>meta      (在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞))</li>
</ul>
<p><strong>.exact 修饰符</strong></p>
<p>.exact 修饰符允许你控制由<strong>精确</strong>的系统修饰符组合触发的事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">"onCtrlClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h4><ul>
<li>left</li>
<li>right</li>
<li>middle</li>
</ul>
<p>这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p>
<hr>
<h2 id="表单输入绑定v-model"><a href="#表单输入绑定v-model" class="headerlink" title="表单输入绑定v-model"></a>表单输入绑定v-model</h2><p><strong>也就单行 多行，单选 多选 下拉 5个</strong></p>
<p>用 v-model 指令在表单 <code>&lt;input&gt;</code> 及 <code>&lt;textarea&gt;</code> 元素上创建双向数据绑定。</p>
<p>v-model 会<strong>忽略所有表单元素</strong>的 value、checked、selected 特性的<strong>初始值</strong>而<strong>总是将 Vue 实例的数据作为数据来源</strong>。你应该通过 JavaScript 在组件的 <strong>data 选项</strong>中声明初始值。</p>
<h4 id="文本和多行文本"><a href="#文本和多行文本" class="headerlink" title="文本和多行文本"></a>文本和多行文本</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文本</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">多行文本</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"white-space: pre-line;"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"add multiple lines"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">单选按钮    看下面单选多选，一组的 只要v-model绑定的名字一样就是一组的 不用写key，render后也没有key</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"One"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"Two"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-4',</span><br><span class="line">  data: &#123;</span><br><span class="line">    picked: ''</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="复选"><a href="#复选" class="headerlink" title="复选"></a>复选</h4><p><strong>注意，这5种就这个复选除了静态的字符串，还有个布尔值，其他4种静态的只有字符串。后面v-bind解放一切</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">单个复选框，绑定到布尔值：显示的是boolean值 false 和 true，</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">多个复选框，绑定到同一个数组：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'example-3'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"mike"</span> <span class="attr">value</span>=<span class="string">"Mike"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mike"</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>    //这里显示初始值是空的，而value值是点击选中后才有的</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-3',</span><br><span class="line">  data: &#123;</span><br><span class="line">      checked: false,</span><br><span class="line">      checkedNames: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="选择框"><a href="#选择框" class="headerlink" title="选择框"></a>选择框</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">单选时：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span>  <span class="comment">&lt;!-- 提供一个值为空的禁用选项，防止无法选中第一个 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"DD"</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span>       <span class="comment">&lt;!-- 没有value时选内容，有value就value --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '...',</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: ''</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">多选时 (绑定到一个数组)：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-6"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span> <span class="attr">multiple</span> <span class="attr">style</span>=<span class="string">"width: 50px;"</span>&gt;</span> <span class="comment">&lt;!-- 多了个multiple --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-6',</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: []    <span class="comment">&lt;!-- 换成数组 --&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果 v-model 表达式的初始值未能匹配任何选项，<code>&lt;select&gt;</code> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样<strong>提供一个值为空的禁用选项</strong>。</p>
<hr>
<p>上面该讲的讲好了，下面做一些补充</p>
<p>用 v-for 渲染的动态选项：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">"option in options"</span> <span class="attr">v-bind:value</span>=<span class="string">"option.value"</span>&gt;</span></span><br><span class="line">    &#123;&#123; option.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '...',</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: 'A',</span><br><span class="line">    options: [</span><br><span class="line">      &#123; text: 'One', value: 'A' &#125;,</span><br><span class="line">      &#123; text: 'Two', value: 'B' &#125;,</span><br><span class="line">      &#123; text: 'Three', value: 'C' &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="值绑定-v-bind稳的一笔"><a href="#值绑定-v-bind稳的一笔" class="headerlink" title="值绑定 v-bind稳的一笔"></a>值绑定 v-bind稳的一笔</h3><p>对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是<strong>静态字符串</strong> (对于复选框也可以是<strong>布尔值</strong>)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当选中时，`picked` 为字符串 "a" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span> <span class="attr">value</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `toggle` 为 true 或 false --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"toggle"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当选中时，`selected` 为字符串 "abc" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"abc"</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是有时我们可能想把值绑定到 Vue 实例的一个动态属性上，这时可以用 <strong>v-bind</strong> 实现，<strong>并且这个属性的值可以不是字符串</strong>。</p>
<p>例子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">单选按钮</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"pick"</span> <span class="attr">v-bind:value</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">// 当选中时</span><br><span class="line">vm.pick === vm.a</span><br><span class="line"></span><br><span class="line">复选框</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"checkbox"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"toggle"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">true-value</span>=<span class="string">"yes"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">false-value</span>=<span class="string">"no"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">// 当选中时</span><br><span class="line">vm.toggle === 'yes'</span><br><span class="line">// 当没有选中时</span><br><span class="line">vm.toggle === 'no'</span><br><span class="line">这里的 true-value 和 false-value 特性并不会影响输入控件的 value 特性，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(比如“yes”或“no”)，请换用单选按钮。</span><br><span class="line"></span><br><span class="line">选择框的选项</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内联对象字面量 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-bind:value</span>=<span class="string">"&#123; number: 123 &#125;"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">// 当选中时</span><br><span class="line">typeof vm.selected // =&gt; 'object'</span><br><span class="line">vm.selected.number // =&gt; 123</span><br></pre></td></tr></table></figure>
<h3 id="修饰符-3个-lazy-number-trim"><a href="#修饰符-3个-lazy-number-trim" class="headerlink" title="修饰符 3个(.lazy, .number, .trim)"></a>修饰符 3个(.lazy, .number, .trim)</h3><p><strong>.lazy</strong><br>在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一输入就变化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"msg"</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新 比如回车后才变化 或则失去焦点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">"msg"</span> &gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>.number</strong><br>如果想自动将用户的<strong>输入值转为数值类型(因为这5种绑定的默认都是静态的字符串啊)</strong>，可以给 v-model 添加 number 修饰符：<br>也会自动去除不是数字的内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"number"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这通常很有用，<strong>因为即使在 type=”number” 时</strong>，HTML 输入元素的值也总会返回字符串。</p>
<p><strong>.trim</strong><br>如果要自动过滤用户输入的<strong>首尾空白字符</strong>，可以给 v-model 添加 trim 修饰符：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"msg"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>哈哈哈 3个一起用 顺序没关系</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy.number.trim</span>=<span class="string">"msg"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>参考<br><a href="https://www.w3cplus.com/vue/v-model.html" target="_blank" rel="noopener">Vue 2.0学习笔记：v-model</a></p>
<p><a href="https://juejin.im/post/58d4a19e5c497d0057e9afc0" target="_blank" rel="noopener">史上最详细VUE2.0全套demo讲解 基础1（模板语法）</a></p>
<hr>
<h2 id="路由就是使用-vue-router"><a href="#路由就是使用-vue-router" class="headerlink" title="路由就是使用 vue-router"></a>路由就是使用 vue-router</h2><h2 id="vuex-状态保存"><a href="#vuex-状态保存" class="headerlink" title="vuex 状态保存"></a>vuex 状态保存</h2><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><h2 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/27/vscode常用快捷键/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/27/vscode常用快捷键/" itemprop="url">vscode常用快捷键</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-27T13:29:05+08:00">2018-01-27</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="vscode常用快捷键"><a href="#vscode常用快捷键" class="headerlink" title="vscode常用快捷键"></a>vscode常用快捷键</h3><p>按按键个数分<br><code>ctrl+o</code> 单一<br><code>ctrl+shift+o</code> 组合<br><code>ctrl+k, ctrl+o</code> 依赖一个键<br><code>ctrl+k, o</code>先依赖一个,再单个<br><code>alt 鼠标</code> 键盘+鼠标点击<br><code>ctrl 鼠标拖动</code> 键盘+ 鼠标拖动</p>
<p>按 ctrl+k ctrl+s 可以查看键盘快捷方式</p>
<p>jj {</p>
<p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/24/PAT乙级/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/24/PAT乙级/" itemprop="url">PAT乙级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-24T13:59:32+08:00">2018-01-24</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PAT乙级-一共80题"><a href="#PAT乙级-一共80题" class="headerlink" title="PAT乙级(一共80题)"></a>PAT乙级(一共80题)</h1><h2 id="1001-害死人不偿命的-3n-1-猜想-15"><a href="#1001-害死人不偿命的-3n-1-猜想-15" class="headerlink" title="1001. 害死人不偿命的(3n+1)猜想 (15)"></a>1001. 害死人不偿命的(3n+1)猜想 (15)</h2><p>卡拉兹(Callatz)猜想：</p>
<p>对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p>
<p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？<br>·<br>输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。</p>
<p>输出格式：输出从n计算到1需要的步数。</p>
<p>输入样例：<br>3<br>输出样例：<br>5</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>读入题目给定的n，之后用while做循环，反复判断n是否为1</p>
<ol>
<li>如果n==1,则退出循环，</li>
<li>如果n!=1,则判断n是否是偶数，是则n除以2；否则n为(3*n+1)除以2.之后令计数器step加1<br>程序执行完后，step就是答案</li>
</ol>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, step = <span class="number">0</span>;    <span class="comment">//要初始化，不然vs2008输入数字是终止</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)&#123;    <span class="comment">//也可以用(n&amp;1) == 0  但是判断奇偶是不能用 n%2 !=0</span></span><br><span class="line">            n = n / <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            n = (<span class="number">3</span>*n + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, step);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1009-说反话-20"><a href="#1009-说反话-20" class="headerlink" title="1009. 说反话 (20)"></a>1009. 说反话 (20)</h2><p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p>
<p>输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。</p>
<p>输出格式：每个测试用例的输出占一行，输出倒序后的句子。</p>
<p>输入样例：<br>Hello World Here I Come<br>输出样例：<br>Come I Here World Hello</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用gets函数读入一整行，从左至右枚举每一个字符，以空格为分隔符对单词进行划分，并按顺序存放到二维字符数组中，最后按单词输入顺序的逆序来输出所有单词。</p>
<h3 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ans[<span class="number">90</span>][<span class="number">90</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>, ans[num]) != EOF) &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = num <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, ans[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">90</span>] = &#123;&#125;;</span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str), r = <span class="number">0</span>, h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ans[<span class="number">90</span>][<span class="number">90</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] != <span class="string">' '</span>) &#123;         <span class="comment">//还没到空格就存入</span></span><br><span class="line">            ans[r][h++] = str[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;             </span><br><span class="line">            ans[r][h] = <span class="string">'\0'</span>;   <span class="comment">//是空格就在末尾加\0 控制%s输出</span></span><br><span class="line">            r++;</span><br><span class="line">            h = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, ans[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1022-D进制的A-B-20"><a href="#1022-D进制的A-B-20" class="headerlink" title="1022. D进制的A+B (20)"></a>1022. D进制的A+B (20)</h2><p>输入两个非负10进制整数A和B(&lt;=230-1)，输出A+B的D (1 &lt; D &lt;= 10)进制数。</p>
<p>输入格式：</p>
<p>输入在一行中依次给出3个整数A、B和D。</p>
<p>输出格式：</p>
<p>输出A+B的D进制数。</p>
<p>输入样例：<br>123 456 8<br>输出样例：<br>1103</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>先计算A+B的按10进制，然后把结果转成D进制，除基取余法。</p>
<h3 id="代码参考-1"><a href="#代码参考-1" class="headerlink" title="代码参考"></a>代码参考</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;d);</span><br><span class="line">    <span class="keyword">int</span> sum = a + b;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">31</span>], num = <span class="number">0</span>;       <span class="comment">//存放D进制每一位 31表示以2进制表示最多31个位置就够了</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ans[num++] = sum % d;</span><br><span class="line">        sum /= d;</span><br><span class="line">    &#125;<span class="keyword">while</span>(sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = num<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;    <span class="comment">//逆序输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1032-挖掘机技术哪家强-20"><a href="#1032-挖掘机技术哪家强-20" class="headerlink" title="1032. 挖掘机技术哪家强(20)"></a>1032. 挖掘机技术哪家强(20)</h2><p>为了用事实说明挖掘机技术到底哪家强，PAT组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。</p>
<p>输入格式：</p>
<p>输入在第1行给出不超过105的正整数N，即参赛人数。随后N行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从1开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。</p>
<p>输出格式：</p>
<p>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。</p>
<p>输入样例：<br>6<br>3 65<br>2 80<br>1 100<br>2 70<br>3 40<br>3 0<br>输出样例：<br>2 150</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul>
<li>用一个数组school[maxn]，下标表示学校，内容表示分数，初始为0。对于每读入一个学校的schID和分数score，相应school[schID]+=score;</li>
<li>令变量k记录最高总分学校编号，变量MAX记录最高总分，初值-1.由于学校是连续编号的从1开始，因此枚举编号1~N， 不断更新k和MAX值就好</li>
</ul>
<h3 id="代码参考-2"><a href="#代码参考-2" class="headerlink" title="代码参考"></a>代码参考</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100001</span>;</span><br><span class="line">    <span class="keyword">int</span> school[maxn] = &#123;<span class="number">0</span>&#125;;     <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, schID = <span class="number">0</span>, score = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);            <span class="comment">//不判断n是否合法，因为给定就是在10^5内</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;schID, &amp;score);</span><br><span class="line">        school[schID] += score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k =<span class="number">1</span>, MAX = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(school[i] &gt; MAX)&#123;</span><br><span class="line">            MAX = school[i];</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, k, MAX);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1036-跟奥巴马一起编程-15"><a href="#1036-跟奥巴马一起编程-15" class="headerlink" title="1036. 跟奥巴马一起编程(15)"></a>1036. 跟奥巴马一起编程(15)</h2><p>美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！</p>
<p>输入格式：</p>
<p>输入在一行中给出正方形边长N（3&lt;=N&lt;=20）和组成正方形边的某种字符C，间隔一个空格。</p>
<p>输出格式：</p>
<p>输出由给定字符C画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的50%（四舍五入取整）。</p>
<p>输入样例：<br>10 a<br>输出样例：<br>aaaaaaaaaa<br>a        a<br>a        a<br>a        a<br>aaaaaaaaaa</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>看到上面正方形是9*10的。在看有字母的，行数是列数的50%(四舍五入)。</p>
<p>第1行和最后一行全输出n个a，2~row-1行奇数行不输出，偶数行就头尾有a</p>
<h3 id="代码参考-3"><a href="#代码参考-3" class="headerlink" title="代码参考"></a>代码参考</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %c"</span>, &amp;col, &amp;c);   <span class="comment">//输入列数和使用字符</span></span><br><span class="line">    <span class="keyword">if</span>(col % <span class="number">2</span> == <span class="number">1</span>) &#123;          <span class="comment">//四舍五入得row</span></span><br><span class="line">        row = col / <span class="number">2</span> +<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        row = col / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//frist row 1 这里就是从1开始 row表示数量，不用当做数组看，col还是按从0开始看</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= col<span class="number">-1</span>; i++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);               <span class="comment">//第一行后的空行 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2~row-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= row<span class="number">-1</span>; i++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, c);        <span class="comment">//第一个c</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);        <span class="comment">//输出col-2个空格</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, c);        <span class="comment">//最后一个c</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一行 row</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/22/markdown常用语法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/22/markdown常用语法/" itemprop="url">markdown常用语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-22T21:25:55+08:00">2018-01-22</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="直接贴一段用markdown写好的文章，两边对照的那种看好了"><a href="#直接贴一段用markdown写好的文章，两边对照的那种看好了" class="headerlink" title="直接贴一段用markdown写好的文章，两边对照的那种看好了"></a>直接贴一段用markdown写好的文章，两边对照的那种看好了</h1><p>用stackEdit</p>
<h2 id="目前用的是vscodve"><a href="#目前用的是vscodve" class="headerlink" title="目前用的是vscodve"></a>目前用的是vscodve</h2><p>虽然vscode本身有markdown的预览，不过并不支持LaTeX。推v荐两款插件markdown all in one和Markdown Preview Enhanced。不仅支持LaTex还有导出pdf这种功能，画路程图<br>markdownlint</p>
<h3 id="3款插件功能"><a href="#3款插件功能" class="headerlink" title="3款插件功能"></a>3款插件功能</h3><ul>
<li>markdown all in one</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:center">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标题</td>
<td style="text-align:center">自动生成目录</td>
<td style="text-align:center">引用</td>
</tr>
<tr>
<td style="text-align:center"><code>ctrl + shift + [/]</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">删除</td>
<td style="text-align:center">强调</td>
<td style="text-align:center">斜体</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><code>ctrl + b</code></td>
<td style="text-align:center"><code>ctrl + i</code></td>
<td><code>&lt;u&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">无序列表</td>
<td style="text-align:center">有序列表</td>
<td style="text-align:center">列表项</td>
</tr>
<tr>
<td style="text-align:center">tab / backsapce</td>
</tr>
<tr>
<td style="text-align:center">链接</td>
<td style="text-align:center">图片</td>
<td style="text-align:center">索引链接</td>
</tr>
<tr>
<td style="text-align:center">[]()</td>
<td style="text-align:center">![]()</td>
<td style="text-align:center">[][]</td>
</tr>
<tr>
<td style="text-align:center">代码,代码块</td>
<td style="text-align:center">高亮</td>
</tr>
<tr>
<td style="text-align:center">```</td>
<td style="text-align:center">```c++</td>
</tr>
<tr>
<td style="text-align:center">表格</td>
</tr>
</tbody>
</table>
</div>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">标题 段落 引用</span><br><span class="line">#</span><br><span class="line">删除 强调 斜体</span><br><span class="line"></span><br><span class="line">列表</span><br><span class="line"></span><br><span class="line">链接 图片</span><br><span class="line"></span><br><span class="line">代码</span><br><span class="line"></span><br><span class="line">表格</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:center">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标题</td>
<td style="text-align:center">自动生成目录</td>
<td style="text-align:center">引用</td>
</tr>
<tr>
<td style="text-align:center"># heading</td>
<td style="text-align:center">[toc]</td>
<td style="text-align:center">></td>
</tr>
<tr>
<td style="text-align:center">删除</td>
<td style="text-align:center">强调</td>
<td style="text-align:center">斜体</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">~~del~~</td>
<td style="text-align:center">**strong**</td>
<td style="text-align:center">*em*</td>
<td><code>&lt;u&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">无序列表</td>
<td style="text-align:center">有序列表</td>
<td style="text-align:center">列表项</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">1.</td>
<td style="text-align:center">- [x]</td>
</tr>
<tr>
<td style="text-align:center">链接</td>
<td style="text-align:center">图片</td>
<td style="text-align:center">索引链接</td>
</tr>
<tr>
<td style="text-align:center">[]()</td>
<td style="text-align:center">![]()</td>
<td style="text-align:center">[][]</td>
</tr>
<tr>
<td style="text-align:center">代码,代码块</td>
<td style="text-align:center">高亮</td>
</tr>
<tr>
<td style="text-align:center">```</td>
<td style="text-align:center">```c++</td>
</tr>
<tr>
<td style="text-align:center">表格</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="标题（有2种方式）"><a href="#标题（有2种方式）" class="headerlink" title="标题（有2种方式）"></a>标题（有2种方式）</h2><h3 id="Setext方式"><a href="#Setext方式" class="headerlink" title="Setext方式"></a>Setext方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">大标题         &lt;h1&gt;</span><br><span class="line">===</span><br><span class="line">小标题         &lt;h2&gt;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h1 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h1><h2 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h2><h3 id="ATX方式"><a href="#ATX方式" class="headerlink" title="ATX方式"></a>ATX方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题          &lt;h1&gt;</span><br><span class="line">## 二级标题         &lt;h2&gt;</span><br><span class="line">### 三级标题        &lt;h3&gt;</span><br><span class="line">#### 四级标题       &lt;h4&gt;</span><br><span class="line">##### 五级标题      &lt;h5&gt;</span><br><span class="line">###### 六级标题     &lt;h6&gt;</span><br></pre></td></tr></table></figure>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>使用><br>加不加空格都行，推荐加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world   &lt;blockquote&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>hello world</p>
</blockquote>
<p>嵌套的引用<br>注意前面加一个或多个空格或tab，还有要2个>><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello</span><br><span class="line"> &gt;&gt; world</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>hello</p>
<blockquote>
<p>world</p>
</blockquote>
</blockquote>
<h2 id="删除-强调-斜体"><a href="#删除-强调-斜体" class="headerlink" title="删除 强调 斜体"></a>删除 强调 斜体</h2><p>使用2个~号包上的表示删除，没有单个~的用法哦<br>使用2个*号或者2个_包上的表示强调<br>单个*或者_包上的表示斜体</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">//删除线   <span class="xml"><span class="tag">&lt;<span class="name">del</span>&gt;</span></span></span><br><span class="line">~~hello world~~</span><br><span class="line">//强调    <span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="strong">**hello world**</span></span><br><span class="line"><span class="strong">__hello world__</span></span><br><span class="line">//斜体    <span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="emphasis">*hello world*</span></span><br><span class="line"><span class="emphasis">_hello world_</span></span><br><span class="line">//也存在只需要\<span class="emphasis">*或\_开头或结尾有就行，但不推荐,因为你不知道什么时候会和前面的\*</span>发生闭合</span><br><span class="line">*hello world</span><br><span class="line">hello world*</span><br><span class="line">_hello world</span><br><span class="line">hello world_</span><br></pre></td></tr></table></figure>
<p>hello world<br>//删除线<br><del>hello world</del><br>//强调<br><strong>hello world</strong><br><strong>hello world</strong><br>//斜体<br><em>hello world</em><br>_hello world_<br>//不推荐<br><em>hello world<br>hello world</em><br>_hello world<br>hello world_</p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>用___下划线及更多就好了,注意不是-减号，这是小标题，虽然有些用减号来作为分割，比如cmdmarkdown<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">---</span><br><span class="line">world</span><br></pre></td></tr></table></figure></p>
<p>hello</p>
<hr>
<p>world</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>用*或+或-都可以（仍然推荐用* 注意加空格,虽然可以混用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt; &lt;li&gt;</span><br><span class="line">* h</span><br><span class="line">+ hi</span><br><span class="line">- hello</span><br></pre></td></tr></table></figure>
<ul>
<li>h</li>
</ul>
<ul>
<li>hi</li>
</ul>
<ul>
<li>hello</li>
</ul>
<p>嵌套</p>
<p>就是加tab，不建议只加1个空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* h</span><br><span class="line"> * hi</span><br><span class="line">    * hello</span><br></pre></td></tr></table></figure>
<ul>
<li>h<ul>
<li>hi<ul>
<li>hello</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>所有的都要注意加空格，然后就是第一个起始的为参考基准，后面的数字打乱其实没关系，但不建议打乱写。</p>
<p>还有就是怎么重新建立一个新开始的有序列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt; &lt;li&gt;</span><br><span class="line">1. h</span><br><span class="line">2. hi</span><br><span class="line">3. hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. h</span><br><span class="line">2. hi</span><br><span class="line">3. hello</span><br></pre></td></tr></table></figure></p>
<ol>
<li>h</li>
<li>hi</li>
<li><p>hello </p>
</li>
<li><p>h</p>
</li>
<li>hi</li>
<li>hello</li>
</ol>
<p>嵌套</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. h</span><br><span class="line">    2. hi</span><br><span class="line">        3. hello</span><br></pre></td></tr></table></figure>
<ol>
<li>h<ol>
<li>hi<ol>
<li>hello</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="todo-list"><a href="#todo-list" class="headerlink" title="todo list"></a>todo list</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- [ ] 支持以 PDF 格式导出文稿</span><br><span class="line">- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</span><br><span class="line">- [x] 新增 Todo 列表功能</span><br><span class="line">- [x] 修复 LaTex 公式渲染问题</span><br><span class="line">- [x] 新增 LaTex 公式编号功能</span><br></pre></td></tr></table></figure>
<ul>
<li>[ ] 支持以 PDF 格式导出文稿</li>
<li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li>[x] 新增 Todo 列表功能</li>
<li>[x] 修复 LaTex 公式渲染问题</li>
<li>[x] 新增 LaTex 公式编号功能</li>
</ul>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;a&gt;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">[www.github.com](www.github.com)</span><br></pre></td></tr></table></figure>
<p><a href="www.github.com">www.github.com</a></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>比超链接多一个!<br>但图片怎么设置大小呢<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;img&gt;&lt;/p&gt;</span><br><span class="line">![GitHub Mark](http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png &quot;GitHub Mark&quot;)</span><br></pre></td></tr></table></figure></p>
<p><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png" alt="GitHub Mark" title="GitHub Mark"></p>
<h2 id="索引链接"><a href="#索引链接" class="headerlink" title="索引链接"></a>索引链接</h2><p>同超链接但是用两个[]，也适用于图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[github][1]</span><br><span class="line">![octocat][2]</span><br><span class="line"></span><br><span class="line">[1]: www.github.com</span><br><span class="line">[2]: http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png</span><br></pre></td></tr></table></figure>
<p><a href="www.github.com">github</a><br><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png" alt="octocat"></p>
<h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><p>用&lt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;www.github.com&gt;</span><br></pre></td></tr></table></figure>
<www.github.com>


<h2 id="代码-用"><a href="#代码-用" class="headerlink" title="代码(用`)"></a>代码(用`)</h2><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><p>1个`</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;</span><br><span class="line">`hello`</span><br></pre></td></tr></table></figure>
<p><code>hello</code></p>
<h3 id="段落代码"><a href="#段落代码" class="headerlink" title="段落代码"></a>段落代码</h3><p>2个``</p>
<p><code>hello
world</code></p>
<p>3个`带序号的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<h3 id="3-高亮一段代码code"><a href="#3-高亮一段代码code" class="headerlink" title="3. 高亮一段代码code"></a>3. 高亮一段代码<sup><a href="#fn_code" id="reffn_code">code</a></sup></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># A comment</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure>
<h2 id="转义字符-加"><a href="#转义字符-加" class="headerlink" title="转义字符(加\)"></a>转义字符(加\)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- | :-----------: | ----: |</span><br><span class="line">| col 3 is      | right-aligned | $1600 |</span><br><span class="line">| col 2 is      | centered      | $12   |</span><br><span class="line">| zebra stripes | are neat      | $1    |</span><br><span class="line"></span><br><span class="line">tips:</span><br><span class="line"></span><br><span class="line">:---:居中</span><br><span class="line">:---左对齐 --- 也是</span><br><span class="line">---:右对齐</span><br><span class="line">-至少有一个,否则默认左对齐;例如::(建议也放3个)</span><br><span class="line"></span><br><span class="line">就是怎么设置几行或几列合一，并没有这功能，所以用html写？</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td style="text-align:left">col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td style="text-align:left">zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><h3 id="2-书写一个质能守恒公式LaTeX"><a href="#2-书写一个质能守恒公式LaTeX" class="headerlink" title="2. 书写一个质能守恒公式LaTeX"></a>2. 书写一个质能守恒公式<sup><a href="#fn_LaTeX" id="reffn_LaTeX">LaTeX</a></sup></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$E=mc^2$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">E=mc^2</script><h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="noopener">序列图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure>
<h3 id="6-高效绘制-甘特图"><a href="#6-高效绘制-甘特图" class="headerlink" title="6. 高效绘制 甘特图"></a>6. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图" target="_blank" rel="noopener">甘特图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在使用hexo中 如果你写表格用的是html这种，那么部署完hexo后会出现很多行空行br，这是因为hexo本身的问题，所以要么压缩下，写一行，但这么不就更麻烦了么。要么还是用markdown的语法</p>
</www.github.com>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/22/PAT刷题前的准备/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/22/PAT刷题前的准备/" itemprop="url">PAT刷题前的准备</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-22T20:50:10+08:00">2018-01-22</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-C-快速入门"><a href="#C-C-快速入门" class="headerlink" title="C/C++快速入门"></a>C/C++快速入门</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个基本的C++程序模板，当然主要是注意头文件，和c语言的<code>&lt;stdio.h&gt;</code>不一样的,这里是<code>&lt;cstdio&gt;</code><br>常用的头文件还有<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;     //字符串</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;       //数学函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     //cin cout</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="基本数据类型-不用markdown，用html，但br换行"><a href="#基本数据类型-不用markdown，用html，但br换行" class="headerlink" title="基本数据类型  不用markdown，用html，但br换行"></a>基本数据类型  不用markdown，用html，但br换行</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">类型</th>
<th style="text-align:center">大致范围</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整型</td>
<td style="text-align:center">int</td>
<td style="text-align:center">正负2*10^9用</td>
<td>%d</td>
<td>%d</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">long long</td>
<td style="text-align:center">9*10^18 超过了用这个 LL</td>
<td>%lld</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">浮点型</td>
<td style="text-align:center">float</td>
<td style="text-align:center">精度6-7位</td>
<td>%f</td>
<td>%f</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">double</td>
<td style="text-align:center">精度15-16位</td>
<td>%lf</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">字符型</td>
<td style="text-align:center">char</td>
<td style="text-align:center">-128~127 用0~127  ‘’</td>
<td>%c</td>
<td>%c</td>
</tr>
<tr>
<td style="text-align:center">字符串</td>
<td style="text-align:center"></td>
<td style="text-align:center">就是字符数组         “”</td>
<td>%s</td>
</tr>
<tr>
<td style="text-align:center">布尔型</td>
<td style="text-align:center">bool</td>
<td style="text-align:center">正负整数为true，0为false，存储按1和0</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%m.nf</span><br><span class="line">这个m表示最少输出m位，包括.  右对齐。前面补空格 %0md表示前面补0</span><br><span class="line">n表示小数输出n位，不存在四舍五入</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scanf  printf  getchar putchar gets puts  sscanf sprintf 4对</span><br><span class="line"></span><br><span class="line">scanf是用空白符作为结束(包括tab 空格 回车。\f \r \n \t \v一般输入也就空格，tab，回车)，</span><br><span class="line">这个要特别注意%d和%c混用，并且用空格来分割两个整数的情况,读取字符串&quot;hi&quot;时和gets一样末尾自动加&apos;\0&apos;。再说下字符数组&#123;&apos;h&apos;, &apos;i&apos;&#125;因为这样初始化后，后面的元素为0，也就是ascii 0 \0</span><br><span class="line">&amp;只有字符串不加，其他加。</span><br><span class="line">getchar是用来输入字符(这个可以接受上面说的结束符，但上面scanf虽然接受了但用来做结束的)</span><br><span class="line">gets输入字符串的，末尾和scanf一样自动加`\0`，getchar不加。这个gets以\n回车为结束</span><br><span class="line">puts输出字符串，自动在末尾加\n</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从<span class="built_in">scanf</span>和<span class="built_in">printf</span>到<span class="built_in">sscanf</span>和<span class="built_in">sprintf</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); 到 <span class="built_in">scanf</span>(screen, <span class="string">"%d"</span>, &amp;n); 所以<span class="built_in">sscanf</span>(str, <span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, n); 到 <span class="built_in">printf</span>(screen, <span class="string">"%d"</span>, n); 所以<span class="built_in">sprintf</span>(str, <span class="string">"%d"</span>, &amp;n);</span><br><span class="line">不过<span class="built_in">sscanf</span>和<span class="built_in">sprintf</span>虽然读入的是串，但可以规定按别的格式读入串。同理输出。可以和<span class="built_in">printf</span>混用，输出到屏幕</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">强制转换(新类型名)变量名</span><br></pre></td></tr></table></figure>
<p>符号常量和const常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define     const 推荐用const</span><br></pre></td></tr></table></figure>
<p>注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//  /**/</span><br></pre></td></tr></table></figure>
<p>运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.算数</span><br><span class="line">+ - * / % ++ --</span><br><span class="line">2.关系</span><br><span class="line">&gt; &lt; &gt;= &lt;= == !=</span><br><span class="line">3.逻辑</span><br><span class="line">&amp;&amp; || !</span><br><span class="line">4.条件</span><br><span class="line">? :</span><br><span class="line">5.位</span><br><span class="line">&amp; | !</span><br></pre></td></tr></table></figure>
<h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><h2 id="常用数学函数-加math-h"><a href="#常用数学函数-加math-h" class="headerlink" title="常用数学函数 (加math.h)"></a>常用数学函数 (加math.h)</h2><ol>
<li>fabs(double x)</li>
<li>floor(double x) ceil(double x)</li>
<li>round(double x)和java不一样</li>
<li>pow(double r, double p)</li>
<li>sqrt(double x)</li>
<li>log(double x)</li>
<li>sin(double x) cos(double x) tan(double x)</li>
<li>asin(double x) acos(double x) atan(double x)</li>
</ol>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if  else</span><br><span class="line">switch case break</span><br><span class="line"></span><br><span class="line">在使用if的过程中如果条件是</span><br><span class="line">n!=0, 可以直接写if(n)  非空</span><br><span class="line">n==0, 写if(!n)        这个不是非空，而是空</span><br></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while do-while</span><br><span class="line">for(int i = 0; i &lt; n; i++) c++可以这么写。c不行</span><br><span class="line"></span><br><span class="line">break continue</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>一维数组 大小固定 const N<br>下标0~n-1</p>
<p>初始化的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">但不能</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];  <span class="comment">//这里就不是0，而是随机数</span></span><br><span class="line"></span><br><span class="line">用<span class="built_in">memset</span>来对数组元素全设为<span class="number">0</span>或<span class="number">-1</span>，其他的用fill函数</span><br></pre></td></tr></table></figure>
<p>二维数组</p>
<p>int a[5][6] = { {}, {}, {} }；</p>
<p>若定义的数组大于10^6，则放在main函数外，不然栈中放不下，静态存储区可以放得下。</p>
<p>字符数组 char</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">15</span>] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">15</span>] = <span class="string">"hello"</span>;    <span class="comment">//也可以用字符串，但仅在初始化可以用</span></span><br><span class="line"></span><br><span class="line">一维数组当字符串，二维的当字符串数组，这里上面两种方式不同，第二种末尾自动加`\<span class="number">0</span>`，第一种没有。</span><br><span class="line">不过说串就是字符数组啊，末尾自动加<span class="string">'\0'</span>。还有就是%s读取用<span class="built_in">scanf</span>和gets，会在末尾自动加\<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>//例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//通过vs调试可以看到</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">15</span>] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;    <span class="comment">//这里都输出hello，因为str[5]及以后被初始化0，就是字符串的结束符</span></span><br><span class="line">	<span class="keyword">char</span> str2[<span class="number">15</span>] = <span class="string">"hello"</span>; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str );</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str2 );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="char1.png" alt="char1"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">5</span>] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;    <span class="comment">//这个字符数组是不会自动加\0，这个没有溢出</span></span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">5</span>] = <span class="string">"hello"</span>;     <span class="comment">//运行时这里报错，溢出，说明字符串是默认后面加个\0，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">5</span>] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;   <span class="comment">// 用%s格式可以输出，但因为末尾没有0，%s所以末尾会输出乱码</span></span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">6</span>] = <span class="string">"hello"</span>; <span class="comment">//%s输出hello</span></span><br></pre></td></tr></table></figure>
<p><img src="char2.png" alt="char2"><br><img src="char3.png" alt="char3"></p>
<h2 id="string-h头文件"><a href="#string-h头文件" class="headerlink" title="string.h头文件"></a>string.h头文件</h2><p>4个常用的</p>
<ol>
<li>strlen(str)<br>可以得到字符数组中第一个\0前的字符个数</li>
<li>strcmp(str1, str2)<br>按ASCII大小比较，按编辑器不同，返回正数，0，负数。</li>
<li>strcpy(str1, str2)<br>str2复制给str1，包括str2的\0，不然怎么结束</li>
<li>kstrcat(str1, str2)<br>str1接上str2</li>
</ol>
<p>sscanf和spritf</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>一个地址表示存有1个字节，通过数据类型知道要读多少个字节。</p>
<p>&amp;取地址 是个unsigned整型。</p>
<p>定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, p2;    <span class="comment">//一个是指针，一个是整型</span></span><br><span class="line"><span class="keyword">int</span> *p1, *p2;   <span class="comment">//两个指针</span></span><br></pre></td></tr></table></figure></p>
<p>指针加减法</p>
<p>加法表示跳过n个<strong>此种类型的距离</strong>。<br>减法表示以此种类型为<strong>基准</strong>，相差n个距离。</p>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>数组名就是个指针，当数组首地址使用，表示整个数组。</p>
<h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>对引用变量的操作就是对原变量的操作。<br>当你不想通过传地址，可以通过引用来实现交换数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span> <span class="params">(<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    change(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是在函数的参数中，&amp;。<br><strong>注意参数变量得是变量，不能是const常量</strong></p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> major[<span class="number">20</span>];</span><br><span class="line">&#125;Alice, Bob, stu[<span class="number">1000</span>];</span><br></pre></td></tr></table></figure>
<p>上面的定义中，studentInfo是结构体名字，Alice Bob是结构体变量，stu[1000]是数组。<br>上面studentInfo中不能出现studentInfo类型的，但可以出现定义自身类型的指针变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    node n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问结构体内元素"><a href="#访问结构体内元素" class="headerlink" title="访问结构体内元素"></a>访问结构体内元素</h3><p>要么用. 要么-&gt;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    studentInfo *next;</span><br><span class="line">&#125;stu, *p</span><br></pre></td></tr></table></figure>
<p>可以<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu.id stu.name stu.next</span><br><span class="line">(*p).id (*p).name (*p).next</span><br><span class="line">p-&gt;id p-&gt;name p-&gt;next</span><br></pre></td></tr></table></figure></p>
<h3 id="结构体初始化-利用构造函数"><a href="#结构体初始化-利用构造函数" class="headerlink" title="结构体初始化(利用构造函数)"></a>结构体初始化(利用构造函数)</h3><p>同java 没有返回类型，名字同结构体名<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> gender;</span><br><span class="line">    studentInfo()&#123;&#125;;</span><br><span class="line">    studentInfo(<span class="keyword">char</span> x)&#123;</span><br><span class="line">        gender = x;</span><br><span class="line">    &#125;;</span><br><span class="line">    studentInfo(<span class="keyword">int</span> x, <span class="keyword">char</span> y)&#123;</span><br><span class="line">        id = x;</span><br><span class="line">        gender = y;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="cin和cout"><a href="#cin和cout" class="headerlink" title="cin和cout"></a>cin和cout</h3><p>加头文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure></p>
<p>不需要指定格式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt;db &gt;&gt; c &gt;&gt; str;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一整行用getline</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(str, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//string容器</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">getling(<span class="built_in">cin</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//换行可以加\n或者endl</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt;<span class="string">""</span> &lt;&lt; c &lt;&lt;<span class="string">"\n"</span> &lt;&lt;<span class="built_in">endl</span></span><br></pre></td></tr></table></figure>
<h3 id="浮点数比较大小"><a href="#浮点数比较大小" class="headerlink" title="浮点数比较大小"></a>浮点数比较大小</h3><p>利用一个eps 10^-8</p>
<p>大于，小于 大于等于， 小于等于<br>这些都画个图就知道了</p>
<p>(b-eps,b+eps) a<br>a &gt; b+eps<br>即a-b &gt; eps<br>同理</p>
<p>cos(π) = -1 所以 π = acos(-1.0)</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度一般为10^7~10^8次,所以O(n^2) n=1000可以接受<br>空间复杂度也不要超过10^7 <code>A[10000][10000]</code>的就不要</p>
<h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>单点测试 PAT</p>
<p>多点测试<br>3种</p>
<ol>
<li>while……EOF   题目没有说明有多少数据需要输入时</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>while……break 题目要求输入的数据满足某个条件时停止输入</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改为更简洁的</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), a || b) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>while(T—)   题目给出测试数据的组数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 正常输出</span><br><span class="line"><span class="number">2.</span> 每行输出后带一个空行</span><br><span class="line"><span class="number">3.</span> 最后一行不输出空行，就是加个判断，当T&gt;<span class="number">0</span>才输出空行。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatarMogu.jpg" alt="Henry x">
            
              <p class="site-author-name" itemprop="name">Henry x</p>
              <p class="site-description motion-element" itemprop="description">this is description</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">65</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="weibo" target="_blank">weibo</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Henry x</span>

  

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.1"></script>



  



	





  





  










  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  

</body>
</html>
