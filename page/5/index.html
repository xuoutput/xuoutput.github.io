<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.1',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  
  <meta name="keywords" content="Hexo, NexT">


<meta name="description" content="this is description">
<meta property="og:type" content="website">
<meta property="og:title" content="Little H title">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Little H title">
<meta property="og:description" content="this is description">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Little H title">
<meta name="twitter:description" content="this is description">






  <link rel="canonical" href="http://yoursite.com/page/5/">


  <title>Little H title</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Little H title</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">this is subtitle</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益404</a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/17/js立即执行函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/17/js立即执行函数/" itemprop="url">js立即执行函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T16:52:02+08:00">2019-02-17</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="js立即执行函数表达式"><a href="#js立即执行函数表达式" class="headerlink" title="js立即执行函数表达式"></a>js立即执行函数表达式</h1><p>IIFE（ 立即调用函数表达式）是一个<strong>在定义时就会立即执行的</strong>  <code>JavaScript</code> 函数。</p>
<p>这是一个被称为 <code>自执行匿名函数</code> 的<strong>设计模式</strong>，主要包含两部分。<br>第一部分是包围在 <code>圆括号运算符()</code> 里的<strong>一个匿名函数</strong>，这个匿名函数<strong>拥有独立的词法作用域</strong>。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</p>
<p>第二部分<strong>再一次使用</strong> <code>()</code> 创建了一个<strong>立即执行函数表达式</strong>，JavaScript 引擎到此<strong>将直接执行函数</strong>。</p>
<p><strong>当函数变成立即执行的函数表达式时</strong>，表达式中的变量不能从外部访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Barry"</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 外部不能访问变量 name</span></span><br><span class="line">name <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Barry"</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// IIFE 执行后返回的结果：</span></span><br><span class="line">result; <span class="comment">// "Barry"</span></span><br></pre></td></tr></table></figure>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>立即执行函数通常有下面两种写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">   ...</span><br><span class="line">&#125;)();</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>在Javascript中，一对圆括号“<code>()</code>”是一种运算符，跟在函数名之后，表示调用该函数。比如，<code>print()</code>就表示调用<code>print函数</code>。</p>
<p>这个写法和我们想象的写法不一样（知道的人当然已经习以为常）<br>很多人刚开始理解<strong>立即执行函数</strong>的时候，觉得应该是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; ... &#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fName</span>(<span class="params"></span>)</span>&#123; ... &#125;();</span><br></pre></td></tr></table></figure>
<p>然而事实却是这样：<code>SyntaxError: Unexpected token (</code>。这是为什么呢？</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>要理解立即执行函数，需要先理解一些<strong>函数的基本概念</strong>：<code>函数声明</code>、<code>函数表达式</code>,因为我们定义一个函数通常都是通过这两种方式</p>
<p><strong>函数声明 (function 语句)</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">[param[, param[, ... param]]]</span>) </span>&#123;</span><br><span class="line">   statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>name</code>：函数名；<br><code>param</code>：被传入函数的参数的名称,一个函数最多可以有255个参数；<br><code>statements</code>：这些语句组成了函数的函数体。</p>
<p><strong>函数表达式 (function expression)</strong>:</p>
<p>函数表达式和函数声明非常类似,它们甚至有相同的语法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function [name]([param] [, param] [..., param]) &#123;</span><br><span class="line">   statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>name</code>：函数名,可以省略,<strong>省略函数名的话,该函数就成为了匿名函数</strong>；<br><code>param</code>：被传入函数的参数的名称,一个函数最多可以有255个参数；<br><code>statements</code>：这些语句组成了函数的函数体。</p>
<p>下面我们给出一些栗子说明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明函数f1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"f1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过()来调用此函数</span></span><br><span class="line">f1();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个匿名函数的函数表达式，被赋值给变量f2:</span></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"f2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过()来调用此函数</span></span><br><span class="line">f2();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个命名为f3的函数的函数表达式(这里的函数名可以随意命名，可以不必和变量f3重名)，被赋值给变量f3:</span></span><br><span class="line"><span class="keyword">var</span> f3 = <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"f3"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过()来调用此函数</span></span><br><span class="line">f3();</span><br></pre></td></tr></table></figure>
<p>上面所起的作用都差不多，但还是有一些<strong>差别</strong></p>
<p>1、<strong>函数名和函数的变量存在着差别</strong>。函数名不能被改变，但函数的变量却能够被再分配。函数名只能在函数体内使用。倘若在函数体外使用函数名将会导致错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">alert(x); <span class="comment">// throws an erro</span></span><br></pre></td></tr></table></figure>
<p>2、函数声明定义的函数可以在它被声明之前使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// alerts FOO!</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   alert(<span class="string">'FOO!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>但函数声明非常容易（经常是意外地）转换为函数表达式</strong>。当它不再是一个函数声明：</p>
<ol>
<li><strong>成为<code>表达式</code>的一部分</strong>, 不单单是用()括号, 还有其他操作符和一些语句中.</li>
<li>不在是函数或者script自身的“源元素” （source element）。在script或者函数体内“源元素”并非是内嵌的语句（statement）<strong>有点难懂</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;               <span class="comment">// source element</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) &#123;            <span class="comment">// source element</span></span><br><span class="line">   x = <span class="number">10</span>;               <span class="comment">// 非source element</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;&#125;     <span class="comment">// 非 source element</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;         <span class="comment">// source element</span></span><br><span class="line">   <span class="keyword">var</span> y = <span class="number">20</span>;           <span class="comment">// source element</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;     <span class="comment">// source element</span></span><br><span class="line">   <span class="keyword">while</span> (y == <span class="number">10</span>) &#123;     <span class="comment">// source element</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">blah</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 非 source element</span></span><br><span class="line">      y++;               <span class="comment">//非source element</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>🌰栗子:</p>
<blockquote>
<p>简单点看就判断是不是<code>function</code>开头</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式, 在括号中</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式, 赋值语句</span></span><br><span class="line">x = <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在逻辑语句中</span></span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">   <span class="comment">// 函数表达式</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">world</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 函数声明</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//函数表达式</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们来解释上面的<code>SyntaxError: Unexpected token (</code>：</p>
<p><strong>产生这个错误的原因</strong>是，Javascript引擎看到<code>function</code>关键字之后，认为后面跟的是函数定义语句，不应该以圆括号结尾。<br><strong>解决方法</strong>就是让引擎知道，圆括号前面的部分不是函数定义语句，而是一个表达式，可以对此进行运算。所以应该这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;());   <span class="comment">// 这个是第二种吧</span></span><br></pre></td></tr></table></figure>
<p>这两种写法<strong>都是以圆括号开头</strong>，引擎就会认为后面跟的<strong>是一个表示式，而不是函数定义</strong>，所以就避免了错误。这就叫做“立即调用的函数表达式”（<code>Immediately-Invoked Function Expression</code>），简称IIFE。</p>
<blockquote>
<p>注意，上面的两种写法的结尾，都必须加上分号。</p>
</blockquote>
<p>推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;();</span><br><span class="line"></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>
<p>甚至像这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"></span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"></span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>
<p>new关键字也能达到这个效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;() <span class="comment">// 只有传递参数时，才需要最后那个圆括号。</span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>那我们通常为什么使用函数立即表达式呢，以及我如何使用呢？</p>
<p><strong>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”</strong>。<br>它的目的有两个：</p>
<ul>
<li>一是不必为函数命名，避免了污染全局变量；</li>
<li>二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> tmp = newData;</span><br><span class="line">processData(tmp);</span><br><span class="line">storeData(tmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = newData;</span><br><span class="line">  processData(tmp);</span><br><span class="line">  storeData(tmp);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong>写法二比写法一更好，因为完全避免了污染全局变量</strong>。</p>
<p>最后在举一个真实的栗子：在JavaScript的<code>OOP</code>中，我们可以通过IIFE来实现一个单例(关于单例的优化不再此处讨论)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个立即调用的匿名函数表达式</span></span><br><span class="line"><span class="comment">// return一个变量，其中这个变量里包含你要暴露的东西</span></span><br><span class="line"><span class="comment">// 返回的这个变量将赋值给counter，而不是外面声明的function自身</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">            i = val;</span><br><span class="line">        &#125;,</span><br><span class="line">        increment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; ());</span><br><span class="line"></span><br><span class="line"><span class="comment">// counter是一个带有多个属性的对象，上面的代码对于属性的体现其实是方法</span></span><br><span class="line"></span><br><span class="line">counter.get(); <span class="comment">// 0</span></span><br><span class="line">counter.set(<span class="number">3</span>);</span><br><span class="line">counter.increment(); <span class="comment">// 4</span></span><br><span class="line">counter.increment(); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">counter.i; <span class="comment">// undefined 因为i不是返回对象的属性</span></span><br><span class="line">i; <span class="comment">// 引用错误: i 没有定义（因为i只存在于闭包）</span></span><br></pre></td></tr></table></figure>
<h2 id="圆括号运算符"><a href="#圆括号运算符" class="headerlink" title="圆括号运算符"></a>圆括号运算符</h2><p><a href="https://segmentfault.com/a/1190000015644558" target="_blank" rel="noopener">进击的 JavaScript（五） 之 立即执行函数与闭包 666</a></p>
<p>圆括号运算符也叫<strong>分组运算符</strong>，它有两种用法：如果表达式放在圆括号中，作用是<strong>求值</strong>；如果跟在函数后面，作用是<strong>调用函数</strong></p>
<p>把表达式放在圆括号之中，将返回表达式的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>+<span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><strong>将函数放在圆括号中，会返回函数本身</strong>。如果圆括号紧跟在函数的后面，就表示调用函数，即对函数求值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span> <span class="title">testa</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">666</span>;&#125;));</span><br><span class="line"><span class="comment">// function testa()&#123;return 666;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> <span class="title">testa</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">666</span>;&#125;());</span><br><span class="line"><span class="comment">// 666</span></span><br></pre></td></tr></table></figure>
<p>注意:圆括号运算符<strong>不能为空</strong>，否则会报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">();<span class="comment">//SyntaxError: Unexpected token )</span></span><br></pre></td></tr></table></figure>
<p>由于圆括号的作用是求值，如果将语句放在圆括号之中，就会报错，因为语句没有返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">666</span>&#125;);</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token var</span></span><br></pre></td></tr></table></figure>
<h2 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h2><p>在 Javascript 中，圆括号<code>()</code>是一种<strong>运算符</strong>，跟在函数名之后，表示调用该函数。比如，<code>print()</code>就表示调用<code>print函数</code>。</p>
<p>有时，我们<strong>需要在定义函数之后，立即调用该函数</strong>。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token (</span></span><br></pre></td></tr></table></figure>
<p>产生这个<strong>错误的原因</strong>是，<code>function</code>这个关键字<strong>既可以当作语句，也可以当作表达式</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>为了<strong>避免解析上的歧义</strong>，JavaScript 引擎规定，如果<code>function关键字</code>出现在<strong>行首</strong>，<strong>一律解释成语句</strong>。因此，JavaScript引擎看到行首是<code>function关键字</code>之后，认为这一段都是函数的定义，不应该以圆括号结尾，<strong>所以就报错了</strong>。</p>
<p><strong>解决方法</strong>就是不要让<code>function</code>出现在行首，让引擎将其理解成一个表达式。<strong>最简单的处理</strong>，就是将其放在一个圆括号里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;());</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure>
<p>上面两种写法都是以<code>圆括号</code>开头，引擎就会认为后面跟的<strong>是一个表示式，而不是函数定义语句</strong>，所以就避免了错误。这就叫做“立即调用的函数表达式”（<code>Immediately-Invoked Function Expression</code>），简称 <code>IIFE</code>。</p>
<p>注意，上面两种写法最后的<strong>分号都是必须</strong>的。如果省略分号，遇到连着两个 IIFE，可能就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;())</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;())</span><br></pre></td></tr></table></figure>
<p>上面代码的两行之间没有分号，<code>JavaScript</code> 会将它们<strong>连在一起解释，将第二行解释为第一行的参数</strong>。</p>
<p><strong>推而广之</strong>，任何让解释器以<strong>表达式</strong>来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;();</span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>
<h2 id="自执行匿名函数和立即执行的函数表达式区别"><a href="#自执行匿名函数和立即执行的函数表达式区别" class="headerlink" title="自执行匿名函数和立即执行的函数表达式区别"></a>自执行匿名函数和立即执行的函数表达式区别</h2><p><a href="https://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html" target="_blank" rel="noopener">深入理解JavaScript系列（4）：立即调用的函数表达式 6666</a></p>
<p>在这篇帖子里，我们一直叫<strong>自执行函数</strong>，确切的说是<code>自执行匿名函数</code>（<code>Self-executing anonymous function</code>），但英文原文作者一直倡议使用立即调用的函数表达式（<code>Immediately-Invoked Function Expression</code>）这一名称，作者又举了一堆例子来解释，好吧，我们来看看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个自执行的函数，函数内部执行自身，递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; foo(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个自执行的匿名函数，因为没有标示名称</span></span><br><span class="line"><span class="comment">// 必须使用arguments.callee属性来执行自己</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">arguments</span>.callee(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这可能也是一个自执行的匿名函数，仅仅是foo标示名称引用它自身</span></span><br><span class="line"><span class="comment">// 如果你将foo改变成其它的，你将得到一个used-to-self-execute匿名函数</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; foo(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有些人叫这个是自执行的匿名函数（即便它不是），因为它没有调用自身，它只是立即执行而已。</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为函数表达式添加一个标示名称，可以方便Debug</span></span><br><span class="line"><span class="comment">// 但一定命名了，这个函数就不再是匿名的了</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即调用的函数表达式（IIFE）也可以自执行，不过可能不常用罢了</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">arguments</span>.callee(); &#125; ());</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; foo(); &#125; ());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，下面的代码在黑莓5里执行会出错，因为在一个命名的函数表达式里，他的名称是undefined</span></span><br><span class="line"><span class="comment">// 呵呵，奇怪</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; foo(); &#125; ());</span><br></pre></td></tr></table></figure>
<p>希望这里的一些例子，可以让大家明白，什么叫<strong>自执行</strong>，什么叫<strong>立即调用</strong>。</p>
<blockquote>
<p>注：<code>arguments.callee</code>在<code>ECMAScript 5 strict mode</code>里<strong>被废弃了</strong>，所以在这个模式下，其实是不能用的。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">IIFE</a><br><a href="https://segmentfault.com/a/1190000003902899" target="_blank" rel="noopener">JavaScript中的立即执行函数 666</a><br><a href="http://javascript.ruanyifeng.com/grammar/function.html#toc23" target="_blank" rel="noopener">阮一峰 IIFE 666666</a><br><a href="https://segmentfault.com/a/1190000003985390" target="_blank" rel="noopener">[译] JavaScript：立即执行函数表达式（IIFE）666</a><br><a href="https://segmentfault.com/a/1190000015644558" target="_blank" rel="noopener">进击的 JavaScript（五） 之 立即执行函数与闭包 666</a><br><a href="https://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html" target="_blank" rel="noopener">深入理解JavaScript系列（4）：立即调用的函数表达式 6666</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/再谈js作用域/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/再谈js作用域/" itemprop="url">再谈js作用域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T19:19:09+08:00">2019-02-12</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="再谈js作用域"><a href="#再谈js作用域" class="headerlink" title="再谈js作用域"></a>再谈js作用域</h1><p>在上一篇<a href="/2019/01/10/js作用域链和闭包/" title="js作用域链和闭包">js作用域链和闭包</a>中讲的有点没头绪, 重新梳理下</p>
<h2 id="scope-scope-chain-execution-context-context-的区别"><a href="#scope-scope-chain-execution-context-context-的区别" class="headerlink" title="scope, scope chain, execution context, context 的区别"></a>scope, scope chain, execution context, context 的区别</h2><h3 id="先解释下函数和作用域的关系"><a href="#先解释下函数和作用域的关系" class="headerlink" title="先解释下函数和作用域的关系"></a>先解释下函数和作用域的关系</h3><p>每一个<code>JavaScript</code>函数都被表示为<code>object</code>,进一步, as an instance of <code>Function</code>, 函数对象和其他对象一样, 拥有你可以编程访问的属性, 和一系列不能被访问, 但仅供<code>JavaScript</code>引擎使用的内部属性. 其中一个内部属性就是<code>[[scope]]</code>.</p>
<p>这个内部属性<code>[[scope]]</code>包含一个代表作用域<code>scope</code>的对象集合, 这个集合是在函数被创建时产生的. 这个集合叫函数的<code>作用域链</code>, 他决定了函数能访问哪些数据. 这个集合中的每个对象叫做可变对象<code>variable object</code>. 当一个函数被创建后, 他的作用域链就有这些对象.</p>
<blockquote>
<p>上面的创建指写好代码, 只是定义哦, 还没运行呢.</p>
</blockquote>
<h3 id="作用域scope"><a href="#作用域scope" class="headerlink" title="作用域scope"></a>作用域scope</h3><p>作用域是你的代码在<strong>运行时(不运行时的预处理阶段也是可以产生的静态作用域链, 是非自己部分的哦)</strong>，各个变量、函数和对象的可访问性。换句话说，作用域决定了你的代码里的变量和其他资源在各个区域中的可见性。</p>
<p>js有3种作用域, 全局作用域(<code>Global context： window/global</code>), 局部作用域(<code>Local Scope</code> , 又称为函数作用域 <code>Function context</code>), 块级作用域<code>{}</code>和<code>const let</code></p>
<h3 id="上下文-context"><a href="#上下文-context" class="headerlink" title="上下文 context"></a>上下文 context</h3><p>上下文指的是在<strong>相同的作用域</strong>中的<code>this</code>的值, 这里<code>this</code>是在调用时确定的(本函数的<code>this</code>值), 而作用域<code>scope</code>也是运行时才有的. 所以没错.</p>
<h2 id="例子add"><a href="#例子add" class="headerlink" title="例子add()"></a>例子add()</h2><p>主要是看这个链接<br><a href="https://www.css88.com/archives/7262" target="_blank" rel="noopener">JavaScript 核心概念之作用域和闭包 666</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Scope-Chain（作用域链）"><a href="#Scope-Chain（作用域链）" class="headerlink" title="Scope Chain（作用域链）"></a>Scope Chain（作用域链）</h3><blockquote>
<p>作用域链的<strong>非自己部分</strong>在函数对象被建立（<strong>函数声明、函数表达式</strong>）的时候建立，<strong>而不需要等到执行</strong>，这部分<strong>作用域链是静态</strong>的；当函数执行时，<strong>建立一个自己当次执行的作用域</strong>，然后把这个作用域与前面的作用域链关联起来</p>
</blockquote>
<p>所以, 当<strong>定义</strong> <code>add</code> 函数后，其<strong>作用域链就创建了</strong>。函数所在的全局作用域的全局对象被放置到 <code>add</code> 函数作用域链（<code>[[scope]</code>] 属性）中。我们可以从下图中看到作用域链的第一个对象保存的是全局对象，全局对象中保存了诸如 <code>this</code> , <code>window</code> , <code>document</code> 以及全局对象中的 <code>add</code> 函数，也就是他自己。这也就是我们可以在全局作用域下的函数中访问 <code>window(this)</code>，访问全局变量，访问函数自身的原因。<br>作用域链在稍后的执行函数时使用。当然还有函数作用域不是全局的情况，等会儿我们再讨论。</p>
<p><img src="scope1.jpg" alt="scope1.jpg"></p>
<p><a href="https://www.css88.com/archives/7300" target="_blank" rel="noopener">实例分析 JavaScript 作用域</a></p>
<p>上面这个链接讲了 <strong>JavaScript 的词法作用域</strong></p>
<h3 id="Execution-Context（执行期上下文）"><a href="#Execution-Context（执行期上下文）" class="headerlink" title="Execution Context（执行期上下文）"></a>Execution Context（执行期上下文）</h3><blockquote>
<p>也分<strong>全局执行期上下文</strong>和<strong>函数执行期上下文</strong></p>
</blockquote>
<p>假设我们<strong>运行</strong>以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = add(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>执行该函数创建一个<strong>内部对象</strong>，称为 <code>Execution Context</code>（执行期上下文）。执行期上下文<strong>定义了一个函数<code>正在执行时</code>的作用域环境</strong>。</p>
<blockquote>
<p>特别注意，执行期上下文和我们平常说的上下文不同，<code>执行期上下文</code>指的是作用域<code>scope</code>。平常说的上下文是<code>this</code>的取值指向。</p>
</blockquote>
<p>执行期上下文和函数创建时的作用域链对象<code>[[scope]]</code>区分，这是<strong>两个不同的作用域链对象</strong>。分开的原因很简单，函数定义时的作用域链对象 <code>[[scope]]</code> 是固定的，而 <code>执行期上下文</code> 会根据不同的运行时环境变化。而且该函数每执行一次，都会创建单独的 <code>执行期上下文</code>，因此对同一函数调用多次，会导致创建多个执行期上下文。一旦函数执行完成，执行期上下文将被销毁。</p>
<blockquote>
<p>函数定义时函数对象的属性是 <code>[[scope]]</code> ,而<code>Execution Context</code>（执行期上下文）的属性是<code>scope chain</code></p>
</blockquote>
<p><code>执行期上下文对象</code>有自己的作用域链，当创建执期行上下文时，其作用域链将<strong>使用</strong>执行函数<code>[[scope]]</code>属性所包含的对象（即，函数<strong>定义时</strong>的作用域链对象）进行<strong>初始化</strong>。这些值按照它们在函数中出现的顺序复制到执行期上下文作用域链中。</p>
<h3 id="Activation-Object（激活对象）"><a href="#Activation-Object（激活对象）" class="headerlink" title="Activation Object（激活对象）"></a>Activation Object（激活对象）</h3><p>随后，在执行其上下文<strong>中</strong>创建一个名为 <code>Activation Object</code>（激活对象）的<code>新对象</code>。 这个<code>激活对象AO</code>保存了函数中的<code>所有形参，实参，局部变量，this 指针等</code>函数执行时函数内部的数据情况。然后将这个激活对象推送到执行其上下文作用域链的<strong>顶部</strong>。</p>
<p><code>激活对象AO</code>是一个<strong>可变对象</strong>，里面的数据随着函数执行时的数据的变化而变化，当函数执行结束之后，执行期上下文将被销毁。也就会销毁<code>Execution Context</code>的作用域链，激活对象也同样被销毁。<strong>但如果存在闭包</strong>，激活对象就会以另外一种方式存在，这也是<strong>闭包产生的真正原因</strong>，具体的我们稍后讨论。下图显示了执行上下文及其作用域链：</p>
<p><img src="scope_execution.jpg" alt="scope_execution.jpg"></p>
<p>从左往右看，<strong>第一部分</strong>是函数<strong>执行时</strong>创建的<code>执行期上下文</code>，它有自己的作用域链，第二部分是作用域链中的对象，<code>索引为1</code>的对象是从<code>[[scope]]</code>作用域链中<strong>复制</strong>过来的，<code>索引为0</code>的对象是在<strong>函数执行时</strong>创建的<code>激活对象AO</code>，第三部分是作用域链中的对象的内容<code>Activation Object</code>(激活对象)和<code>Global Object</code>(全局对象)。</p>
<p>函数在执行时，每遇到一个变量，都会去执行期上下文的作用域链的顶部，执行函数的激活对象开始向下<strong>搜索</strong>，如果在第一个作用域链（即，<code>Activation Object</code> 激活对象）中找到了，那么就返回这个变量。如果没有找到，那么继续向下查找，直到找到为止。如果在整个执行期上下文中都没有找到这个变量，在这种情况下，该变量被认为是<strong>未定义</strong>的。这也就是为什么函数可以访问全局变量，当局部变量和全局变量同名时，会使用局部变量而不使用全局变量，以及 JavaScript 中各种看似怪异的、有趣的作用域问题的答案。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>尤其是注意闭包的定义哦, 要使用到父函数的变量</p>
</blockquote>
<p>这个看<a href="/2019/01/10/js作用域链和闭包/" title="js作用域链和闭包">js作用域链和闭包</a>中的闭包</p>
<p>再说下一道经典的题啊, <strong>涉及闭包, 作用域, 内核线程, 事件队列</strong>, 进一步还可以考<code>this</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">20</span>,</span><br><span class="line">    getA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">1</span> ; i &lt; <span class="number">5</span>; i++) &#123;    <span class="comment">// let变为var的话是4个5</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i)</span><br><span class="line">        &#125;, <span class="number">1000</span>*i)    <span class="comment">// 注意这里不是1000, 改成1000的话会一秒后直接输出4个5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getA();</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这道题我觉得应该首先看<a href="/2018/12/28/从输入URL到页面加载发生了什么/" title="从输入URL到页面加载发生了什么">从输入URL到页面加载发生了什么</a> 中多<strong>进程浏览器</strong>,和<strong>多线程内核</strong>, <code>event loop</code>. <a href="/2019/02/17/js立即执行函数/" title="js立即执行函数">js立即执行函数</a>(来形成作用域块)</p>
<p>尤其是内核和<code>event loop</code>, js引擎和计时器是不同的线程, js引擎是单线程的哦. 这样你就懂了为啥会这么输出.</p>
<p>在4个循环下, 在js栈中就会触发4次计时器, 等同步的执行完, 再会执行事件队列中的, 而各个计时器线程又不打扰. 所以栈中for执行完后, 等事件队列, 事件队列都是1秒后执行完. 然而这时的i就是5, 所以大家都输出5</p>
<p>解法是用<br><a href="https://blog.csdn.net/X_Jagger/article/details/64584335" target="_blank" rel="noopener">setTimeout 循环闭包的经典面试题 解法与探究</a></p>
<p><a href="https://www.jianshu.com/p/e5225ba4a025" target="_blank" rel="noopener">setTimeout函数之循环和闭包 6还可以</a><br><a href="https://www.jianshu.com/p/9b4a54a98660" target="_blank" rel="noopener">图例详解那道setTimeout与循环闭包的经典面试题 666</a><br><a href="https://www.jeffjade.com/2016/01/10/2016-01-10-javacript-setTimeout/#2-setTimeout%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">你所不知道的setTimeout</a></p>
<h2 id="JavaScript-的词法作用域"><a href="#JavaScript-的词法作用域" class="headerlink" title="JavaScript 的词法作用域"></a>JavaScript 的词法作用域</h2><p>看完闭包后要看这个链接巩固, 在整体回顾.</p>
<p><a href="https://www.css88.com/archives/7300" target="_blank" rel="noopener">实例分析 JavaScript 作用域</a></p>
<p>上面这个链接讲了 <strong>JavaScript 的词法作用域</strong></p>
<p>简要说下:</p>
<p>如果一个文档流中包含多个script代码段（用script标签分隔的js代码或引入的js文件），它们的运行顺序是：</p>
<ol>
<li>读入第一个代码段（js执行引擎并非一行一行地分析程序，而是一段一段地分析执行的）</li>
<li>做<strong>词法分析</strong>，有错则报语法错误（比如括号不匹配等），并跳转到步骤5</li>
<li>对<code>var</code>变量和<code>function</code>定义做“<strong>预解析</strong>“（永远不会报错的，因为只解析正确的声明）</li>
<li>执行代码段，有错则报错（比如变量未定义）</li>
<li>如果还有下一个代码段，则读入下一个代码段，重复步骤2</li>
<li>完成</li>
</ol>
<h3 id="JavaScript-解析过程"><a href="#JavaScript-解析过程" class="headerlink" title="JavaScript 解析过程"></a>JavaScript 解析过程</h3><blockquote>
<p>从前面的<strong>例子add()</strong>回顾下</p>
</blockquote>
<p><code>JavaScript</code> 中每个函数都都表示为一个函数对象（函数实例），函数对象有一个仅供 <code>JavaScript</code> 引擎使用的<code>[[scope]]</code> 属性。<strong>通过语法分析和预解析</strong>，将<code>[[scope]]</code> 属性指向<strong>函数定义时</strong>作用域中的所有对象集合。这个集合被称为函数的作用域链（<code>scope chain</code>），包含函数<strong>定义时</strong>作用域中所有可访问的数据。</p>
<p>对应的图是:</p>
<p><img src="scope1.jpg" alt="scope1.jpg"></p>
<h3 id="JavaScript-执行过程"><a href="#JavaScript-执行过程" class="headerlink" title="JavaScript 执行过程"></a>JavaScript 执行过程</h3><p><strong>执行</strong>具体的某个函数时，JS引擎在执行每个函数实例时，都会创建一个<code>执行期上下文（Execution Context</code>）和<code>激活对象（active Object</code>）（它们<strong>属于<code>宿主对象</code></strong>，与函数实例执行的生命周期保持一致，也就是函数执行完成，这些对象也就被销毁了，闭包例外。）</p>
<p>执行期上下文（<code>Execution Context</code>）定义了一个函数<strong>正在执行时</strong>的作用域环境。它使用函数<code>[[scope]]</code>属性进行<strong>初始化</strong>。</p>
<p>随后，执行期上下文 <code>顶部</code> 的会创建一个<code>激活对象（active Object）</code>，这个激活对象保存了函数中的<code>所有形参</code>，<code>实参</code>，<code>局部变量</code>，<code>this</code> 指针等函数执行时<strong>函数内部</strong>的数据情况。这个时候激活对象中的那些属性<strong>并没有被赋值</strong>，执行函数内的赋值语句，这才会对变量集合中的变量进行赋值处理。也就是说 激活对象是一个<strong>可变对象</strong>，里面的数据随着函数执行时的数据变化而变化。</p>
<p>🌰<br>考虑一下下图中的代码：</p>
<p><img src="lizi.png" alt="lizi.png"></p>
<p>分析过程：</p>
<ul>
<li>作用域1 (绿色) ：即全局作用域，包含变量<code>foo</code>;</li>
<li>作用域2 (黄色) ：<code>foo</code>函数的作用域，包含变量<code>a</code>,<code>bar</code>,<code>b</code></li>
<li>作用域3 (蓝色) ：<code>bar</code>函数的作用域，包含变量<code>c</code></li>
</ul>
<p><code>bar</code> 作用域里完整的包含了 <code>foo</code> 的作用域, 因为 <code>bar</code> 是定义在 <code>foo</code> 中的，产生<strong>嵌套作用域</strong>。值得注意的是，一个函数作用域只有可能存在于一个父级作用域中，不会同时存在两个父级作用域。还有诸如<code>this</code> , <code>window</code> , <code>document</code>等全局对象这里就不说了，避免混乱。</p>
<p>执行过程：</p>
<ul>
<li>语句<code>console.log</code>寻找变量<code>a</code>,<code>b</code>,<code>c</code>;</li>
<li>其中<code>c</code>在自己的作用域中找到，</li>
<li><code>a</code>，<code>b</code>在自己的作用域中找不到，于是向上级作用域中查找，在<code>foo</code>的作用域中找到，并且调用。</li>
</ul>
<p><strong>函数在执行时</strong>，每遇到一个变量，都会去<strong>执行期上下文</strong>的作用域链的顶部，也就是<strong>执行函数</strong>的<strong>激活对象</strong>开始搜索，如果在第一个作用域链（即，<code>Activation Object</code> 激活对象）中找到了，那么就返回这个变量。如果没有找到，那么继续向下查找，直到找到为止。如果在整个执行期上下文中都没有找到这个变量，在这种情况下，该变量被认为是未定义的。也就是说如果<code>foo</code>的作用域中也定义了<code>c</code>，但<code>bar</code>函数只调用自己作用域里的<code>c</code>。这就是我们说的变量取值。</p>
<h4 id="关于形参-实参-同名局部变量的关系"><a href="#关于形参-实参-同名局部变量的关系" class="headerlink" title="关于形参, 实参, 同名局部变量的关系"></a>关于形参, 实参, 同名局部变量的关系</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params">a,b,c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(one.length);<span class="comment">//形参数量  3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params">a,b,c,d,e,f,g</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);<span class="comment">//实参数量  1</span></span><br><span class="line">&#125;</span><br><span class="line">one(<span class="number">1</span>)</span><br><span class="line">two(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoSomething</span>(<span class="params">a</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">DoSomething( <span class="number">1</span> );</span><br></pre></td></tr></table></figure>
<p>打印的结果是<code>1,1,2,2</code>。从上面的代码可以看到，参数<code>a</code>和局部变量<code>a</code>值是<strong>完全相同</strong>的，即使是局部变量<code>a</code>重新定义和赋值之后。这样就好理解了，<strong>参数和同名变量</strong>之间是 “<strong>引用</strong>” 关系，也就是说 <code>JavaScript</code> 引擎的处理参数和同名局部变量是都引用同一个内存地址。所以示例5中修改局部变量会影响到<code>arguments</code>的情况出现。</p>
<h2 id="再展开-execution-context中有什么"><a href="#再展开-execution-context中有什么" class="headerlink" title="再展开, execution context中有什么"></a>再展开, execution context中有什么</h2><p>看这个链接中的东西<br><a href="https://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/" target="_blank" rel="noopener">了解JavaScript的执行上下文</a><br><a href="https://juejin.im/post/5a5ee28f6fb9a01cbe655860" target="_blank" rel="noopener">由变量提升谈谈 JavaScript Execution Context</a></p>
<h3 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h3><p>让我们将术语<code>执行上下文</code>想象为当前被执行代码的<code>环境/作用域</code>。说的够多了，现在让我们看一个包含<strong>全局<code>global context</code>和函数上下文<code>execution context</code></strong>的代码例子</p>
<p><img src="global_context.jpg" alt="global_context.jpg"></p>
<p>很简单的例子，我们有一个被<strong>紫色边框圈</strong>起来的<strong>全局上下文</strong>和三个分别被<strong>绿色，蓝色和橘色</strong>框起来的<strong>不同函数执行上下文</strong>。只有全局上下文（的变量）能被其他任何上下文访问。</p>
<p>你可以有任意多个函数上下文，<strong>每次调用函数创建一个新的上下文</strong>，会创建一个<strong>私有作用域</strong>，函数内部声明的任何变量都不能在当前函数作用域外部直接访问。在上面的例子中，函数能访问当前上下文外面的变量声明，但在外部上下文不能访问内部的变量/函数声明。</p>
<h3 id="执行上下文堆栈-这个看链接-也可以看那个event-loop"><a href="#执行上下文堆栈-这个看链接-也可以看那个event-loop" class="headerlink" title="执行上下文堆栈 这个看链接, 也可以看那个event loop"></a>执行上下文堆栈 这个看链接, 也可以看那个event loop</h3><p><strong>浏览器</strong>里的<code>JavaScript</code>解释器被实现为<strong>单线程</strong>。这意味着同一时间只能发生一件事情，其他的行文或事件将会被放在叫做执行栈里面排队。下面的图是单线程栈的抽象视图：</p>
<p><img src="stack1.jpg" alt="stack1.jpg"></p>
<p>有5个需要记住的关键点，<strong>关于执行栈（调用栈）</strong>：</p>
<ul>
<li>单线程。</li>
<li>同步执行。</li>
<li>一个全局上下文。</li>
<li>无限制函数上下文。</li>
<li>每次函数被调用创建新的执行上下文，包括调用自己。</li>
</ul>
<h3 id="执行上下文的细节"><a href="#执行上下文的细节" class="headerlink" title="执行上下文的细节"></a>执行上下文的细节</h3><p>我们现在已经知道每次调用函数，都会创建新的执行上下文。然而，在JavaScript解释器内部，每次调用执行上下文，分为两个阶段：</p>
<ol>
<li><strong>创建阶段</strong>【当函数被调用，但未执行任何其内部代码之前】：<ul>
<li>创建作用域链（<code>Scope Chain</code>）</li>
<li>创建变量对象<code>VO</code>，内对应的variables, functions和arguments。</li>
<li>求”<code>this</code>“的值。 <a href="/2018/11/26/javascript中this指向由函数调用方式决定/" title="javascript中this指向由函数调用方式决定">javascript中this指向由函数调用方式决定</a></li>
</ul>
</li>
<li>激活/<strong>代码执行</strong>阶段：<ul>
<li>重新扫描一次代码，给变量赋值，然后执行代码。。</li>
</ul>
</li>
</ol>
<p>可以将每个执行上下文抽象为一个对象并有三个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">executionContextObj = &#123;</span><br><span class="line">    <span class="string">'scopeChain'</span>: &#123; <span class="comment">/* variableObject + all parent execution context's variableObject */</span> &#125;,</span><br><span class="line">    <span class="string">'variableObject'</span>: &#123; <span class="comment">/* function arguments / parameters(函数实参/形参), inner variable and function declarations */</span> &#125;,</span><br><span class="line">    <span class="string">'this'</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>executionContextObj</code>由函数<strong>调用时运行前</strong>创建，<strong>创建阶段</strong><code>arguments</code>的参数会直接传入，函数<strong>内部定义的变量</strong>会初始化为<code>undefined</code>。<strong>执行阶段</strong>重新扫描一次代码，给变量赋值，然后执行代码。</p>
<h4 id="下面是执行上下文期间JS引擎执行伪代码"><a href="#下面是执行上下文期间JS引擎执行伪代码" class="headerlink" title="下面是执行上下文期间JS引擎执行伪代码"></a>下面是执行上下文期间JS引擎执行伪代码</h4><blockquote>
<p>这里和定义时(预处理时)的函数对象的属性<code>[[scope]]</code>不同哦</p>
</blockquote>
<ol>
<li>找到调用函数</li>
<li>执行函数代码前，创建<code>execution context</code></li>
<li>进行<strong>创建阶段</strong>：<ul>
<li>初始化作用域链 <code>Scope Chain</code></li>
<li>创建 <code>variable object</code>：(全局下就是全局变量, 没有arguments, <code>AO</code>下就是4种:函数的形参实参, 函数内声明的函数和变量)<ul>
<li>创建<code>arguments</code>对象，初始化该入参变量名和值(<strong>这个函数有, 全局的没有</strong>)</li>
<li>扫描该执行上下文中声明的函数： (其实就是<code>host提升</code>, 看<a href="/2019/01/10/js作用域链和闭包/" title="js作用域链和闭包">js作用域链和闭包</a>中的提升)<ul>
<li>对于声明的函数，<code>variable object</code>中创建对应的变量名，其值指向该函数（函数是存在<code>heap</code>中的）</li>
<li>如果函数名已经存在，用新的引用值<strong>覆盖</strong>已有的</li>
</ul>
</li>
<li>扫描上下文中声明的变量：(即:<strong>变量声明不会干扰<code>VO</code>中已经存在的同名函数声明或形式参数声明</strong>)<ul>
<li>对于变量的声明，同样在<code>variable object</code>中创建对应的变量名，其值初始化<code>为undefined</code></li>
<li>如果变量的名字已经存在，则直接略过继续扫描</li>
</ul>
</li>
</ul>
</li>
<li><strong>决定</strong>上下文<code>this</code>的指向, <strong>不要和作用域链, <code>VO</code>搞混</strong><ul>
<li><blockquote>
<p>用<code>this</code>的时候下一步就是用<code>VO</code>或<code>scope chain</code>中的变量咯</p>
</blockquote>
</li>
<li><blockquote>
<p>调用的时候才确定<code>this</code> <a href="/2018/11/26/javascript中this指向由函数调用方式决定/" title="javascript中this指向由函数调用方式决定">javascript中this指向由函数调用方式决定</a></p>
</blockquote>
</li>
<li><blockquote>
<p>4种: 直接调用(<code>window</code>或<code>global</code>), 方法调用(那个<code>obj</code>, 注意指向全局的那种调用方式, 从作用域链来看没错), <code>new</code>调用(就是创建的那个), 箭头(没有绑定<code>this</code>, 但使用<code>this</code>的话就是包含它的那个函数或表达式, 外面的父的<code>this</code>)</p>
</blockquote>
</li>
<li><blockquote>
<p>即: <code>this</code> 永远指向最后调用它的那个对象</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>代码执行阶段：<ul>
<li>执行函数内的代码并给对应变量进行赋值（创建阶段为<code>undefined</code>的变量）</li>
</ul>
</li>
</ol>
<p><code>this</code>结合上下文接着看<br><a href="http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html" target="_blank" rel="noopener">深入理解JavaScript系列（13）：This? Yes,this! 666666</a><br><a href="https://www.jianshu.com/p/d647aa6d1ae6" target="_blank" rel="noopener">前端基础进阶（五）：全方位解读this 666</a></p>
<p><a href="http://www.admin10000.com/document/6711.html" target="_blank" rel="noopener">深入浅出 妙用Javascript中apply、call、bind 6666</a></p>
<p>JavaScript 的一大特点是，函数存在「<strong>定义时上下文</strong>」和「<strong>运行时上下文</strong>」以及「<strong>上下文是可以改变的</strong>」这样的概念。</p>
<p>JavaScript 中，某些函数的参数数量是不固定的，因此要说适用条件的话，<br>当你的参数是<strong>明确知道</strong>数量时用 <code>call</code> 。而<strong>不确定</strong>的时候用 <code>apply</code>，然后把参数 <code>push</code> 进数组传递进去。当参数数量不确定时，函数内部也可以通过 <code>arguments</code> 这个数组来遍历所有的参数。</p>
<p>常用来转化为数组:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<p><strong>一个简单例子如下</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">22</span>))</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">'hello world'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> <span class="title">privateB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提升后是如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提升函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> <span class="title">privateB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提升变量的</span></span><br><span class="line"><span class="keyword">var</span> x</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">22</span>))</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line">x = <span class="string">'hello world'</span>;</span><br></pre></td></tr></table></figure>
<p>(a)：代码首先进入到<code>全局上下文</code>的<strong>创建阶段</strong>。</p>
<ol>
<li>初始化作用域链 <code>Scope Chain</code></li>
<li>创建 <code>variable object</code><ol>
<li>创建<code>arguments</code>对象，初始化该入参变量名和值(这个函数有, 全局的没有)</li>
<li>函数声明和变量声明提升</li>
</ol>
</li>
<li>决定上下文<code>this</code>的指向</li>
</ol>
<p>得到如下的<code>ExecutionContextGlobal</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContextGlobal = &#123;</span><br><span class="line">  scopeChain: &#123;...&#125;,  <span class="comment">// 当成[]更贴切点</span></span><br><span class="line">  variableObject: &#123;</span><br><span class="line">      x: <span class="literal">undefined</span>,</span><br><span class="line">      foo: pointer to <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  &#125;,</span></span><br><span class="line"><span class="function">  <span class="title">this</span>: </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(b): 然后进入<code>全局执行上下文</code>的<strong>执行阶段</strong>。</p>
<p>这一阶段从上至下逐条执行代码，运行到<code>console.log(foo(22))</code>该行时，<strong>创建阶段</strong>已经为<code>variableObject</code>中的<code>foo</code>赋值了，因此执行时会执行<code>foo(22)</code>函数。<br>当执行<code>foo(22)</code>函数时，又将进入<code>foo()</code>的执行上下文，详见(c)阶段。<br>当执行到<code>console.log(x)</code>时，此时<code>x</code>在<code>variableObject</code>中赋值为<code>undefined</code>，因此打印出<code>undefined</code>，这也正是<strong>变量提升产生</strong>的结果。<br>当执行到<code>var x = &#39;hello world&#39;;</code>，<code>variableObject</code>中的x被赋值为<code>hello world</code>。<br>继续往下是<code>foo</code>函数的声明，因此什么也不做，执行阶段结束。下面是执行阶段完成后的<code>ExecutionContextGlobal</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContextGlobal = &#123;</span><br><span class="line">  scopeChain: &#123;...&#125;,  <span class="comment">// 当成[]更贴切点</span></span><br><span class="line">  variableObject: &#123;</span><br><span class="line">      x: <span class="string">'hello world'</span>,</span><br><span class="line">      foo: pointer to <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  &#125;,</span></span><br><span class="line"><span class="function">  <span class="title">this</span>: </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(c): 当js调用<code>foo(22)</code>时，进入到<code>foo()</code>函数的<code>执行上下文</code>，首先进行该上下文的<strong>创建阶段</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContextFoo = &#123;</span><br><span class="line">    scopeChain: &#123;...&#125;,  <span class="comment">// 当成[]更贴切点</span></span><br><span class="line">    variableObject: &#123;</span><br><span class="line">      <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">22</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      i: <span class="number">22</span>,</span><br><span class="line">      c: pointer to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">      <span class="title">a</span>: <span class="title">undefined</span>,</span></span><br><span class="line"><span class="function">      <span class="title">b</span>: <span class="title">undefined</span></span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function">    <span class="title">this</span>: </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<strong>执行阶段</strong>运行完后，<code>ExecutionContextFoo</code>如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fooExecutionContext = &#123;</span><br><span class="line">    scopeChain: &#123; ... &#125;,  <span class="comment">// 当成[]更贴切点</span></span><br><span class="line">    variableObject: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="number">22</span>,</span><br><span class="line">            length: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        i: <span class="number">22</span>,</span><br><span class="line">        c: pointer to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        <span class="title">a</span>: '<span class="title">hello</span>',</span></span><br><span class="line"><span class="function">        <span class="title">b</span>: <span class="title">pointer</span> <span class="title">to</span> <span class="title">function</span> <span class="title">privateB</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function">    <span class="title">this</span>: </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理清了JS中的<code>执行上下文</code>，就很容易明白<strong>变量提升</strong>具体是怎么回事了。<br>在<strong>代码执行前</strong>，执行上下文已经给对应的声明赋值，只不过<strong>变量是赋值</strong>为<code>undefined</code>，<strong>函数赋值</strong>为对应的引用，<br>而后在<strong>执行阶段</strong>再将对应值<strong>赋值</strong>给变量。</p>
<blockquote>
<p><strong>区分函数声明和函数表达式</strong>, 这个不再多说</p>
</blockquote>
<p>在前面看到<code>execution context</code>中的是<code>VO</code>, 然后 <code>AO</code>是啥</p>
<p><code>Variable object(VO)</code> ：在<strong>全局作用域</strong>就是<strong>全局对象</strong>，而在<strong>其他作用域</strong>是<code>活动对象AO</code>。<br><code>Activation object(AO)</code> ：包含：函数的<code>形式参数</code>，函数的<code>arguments</code>对象，<code>函数内声明的变量</code>和<code>内部函数</code> <strong>4种(函数的形参实参, 函数内声明的函数和变量)</strong>。</p>
<blockquote>
<p><strong>其实<code>AO</code>是<code>VO</code>的一种情况</strong>。<code>全局下是没有</code><strong>arguments</strong>这个对象的，所以<strong>全局对象不能称为活动对象</strong>。</p>
</blockquote>
<p>未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p>
<h3 id="全局上下文的变量对象"><a href="#全局上下文的变量对象" class="headerlink" title="全局上下文的变量对象"></a>全局上下文的变量对象</h3><p>以浏览器中为例，全局对象为<code>window</code>。<br>全局上下文有一个特殊的地方，它的变量对象，就是<code>window</code>对象。而这个特殊，在<code>this</code>指向上也同样适用，<code>this</code>也是指向<code>window</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以浏览器中为例，全局对象为window</span></span><br><span class="line"><span class="comment">// 全局上下文</span></span><br><span class="line">windowEC = &#123;</span><br><span class="line">    VO: Window,</span><br><span class="line">    scopeChain: &#123;&#125;,  <span class="comment">// 当成[]更贴切点</span></span><br><span class="line">    <span class="keyword">this</span>: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。</p>
<h3 id="另一种VO不是this"><a href="#另一种VO不是this" class="headerlink" title="另一种VO不是this"></a>另一种VO不是this</h3><p><a href="https://www.zhihu.com/question/51336888" target="_blank" rel="noopener">js中 执行环境(execution context) 和 作用域(scope) 的区别在哪里?</a></p>
<p>执行环境（<code>Execution Context</code>，简称<code>Context</code>）只是一个<strong>抽象概念</strong>，在具体<code>JS Engine</code>实现中，<strong>它对应很多内容</strong>，变量对象（<code>Variable Object</code>，简写<code>VO</code>）是其一，还有<code>Scope Chain</code>，<code>this</code>等，这些<strong>共同组成</strong>了执行环境这个概念。</p>
<p><code>VO</code>不是指具体某个<code>Object</code>，而是<strong>指一类<code>Object</code></strong>，所以也具有一定程度的<strong>抽象</strong>。</p>
<blockquote>
<p><code>VO</code>是<code>JS Engine</code><strong>内部实现</strong>，用于<code>identifier resolution</code>，<strong>JS代码层面是接触不到的</strong>, <strong>但<code>this</code>是执行环境的一部分</strong>，所以不要与<code>VO</code>搞混.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//color, anotherColor, and tempColor are all accessible here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//color and anotherColor are accessible here, but not tempColor</span></span><br><span class="line">    swapColors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//only color is accessible here</span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
<p>书上（《Javascript高级程序设计(第三版)》）的代码（如下）说得很清楚：<strong><code>global context</code>对应一个<code>VO</code>（就是<code>window</code>!!）</strong>, <code>changeColor</code>的<code>local context</code>对应一个<code>VO</code>，<code>swapColors</code>的<code>local context</code>对应一个<code>VO</code>。所以每个context都对应了一个<code>VO</code>。</p>
<p>如上所说，<strong><code>this</code>也是执行环境的一部分</strong>，所以不要与<code>VO</code>搞混，<code>VO</code>是<code>JS Engine</code><strong>内部实现</strong>，用于<code>identifier resolution</code>，<strong>JS代码层面是接触不到的</strong>。参见ES2016规范：(<strong>而我们这里要访问到<code>VO</code>是通过<code>this</code>或者<code>window</code>来, 而不是直接访问<code>VO</code></strong>)</p>
<blockquote>
<p>Lexical Environments and Environment Record values are purely specification mechanisms and need not correspond to any specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to directly access or manipulate such values.</p>
</blockquote>
<p>当然如果你这个<code>VO</code>是<code>global</code>的话，比较特殊一点：</p>
<blockquote>
<p>A global environment’s Environment Record may be prepopulated with identifier bindings and includes an associated global object whose properties provide some of the global environment’s identifier bindings. As ECMAScript code is executed, additional properties may be added to the global object and the initial properties may be modified.</p>
</blockquote>
<p>这也是为什么前面提到说<code>global context</code>对应<code>window</code>。</p>
<p>同一本书专门讲Function一章有这样一句话：</p>
<blockquote>
<p>The this object is bound at runtime based on the context in which a function is executed: when used inside global functions, this is equal to window in nonstrict mode and undefined in strict mode, whereas this is equal to the object when called as an object method.</p>
</blockquote>
<p>简言之，<code>this</code>只是存了一个地址，要么指向<code>window</code>，要么指向<strong>调用该方法</strong>的那个<code>object</code>。<br>把上面代码改一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>: <span class="string">"black"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">        <span class="built_in">console</span>.log(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swapColors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor(); <span class="comment">// Output: true, true, undefined, red</span></span><br><span class="line">o.changeColor = changeColor;</span><br><span class="line">o.changeColor(); <span class="comment">// Output: false, true, undefined, red</span></span><br></pre></td></tr></table></figure>
<p><code>swapColors</code>里的<code>this</code>，和<code>swapColors</code>的<code>context</code>对应的<code>VO</code>没什么关系，而是指向<code>window</code>。</p>
<h3 id="说下全局上下文"><a href="#说下全局上下文" class="headerlink" title="说下全局上下文"></a>说下全局上下文</h3><p><a href="https://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html" target="_blank" rel="noopener">深入理解JavaScript系列（12）：变量对象（Variable Object）66666 看全局上下文中的变量对象这段</a></p>
<p>首先，我们要<strong>给<code>全局对象</code>一个明确的定义</strong>：</p>
<ul>
<li>全局对象(<code>Global object</code>) 是在<strong>进入任何执行上下文</strong>之前就已经创建了的对象；</li>
<li>这个对象只存在一份，它的属性在程序中任何地方都可以访问，全局对象的生命周期终止于程序退出那一刻。</li>
</ul>
<p>全局对象<strong>初始创建阶段</strong>将<code>Math、String、Date、parseInt</code>作为自身<strong>属性</strong>，等属性初始化，同样也可以有额外创建的其它对象作为属性（其可以指向到全局对象自身）。例如，在<code>DOM</code>中，全局对象的<code>window属性</code>就可以<strong>引用全局对象自身</strong>(当然，并不是所有的具体实现都是这样)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">global = &#123;</span><br><span class="line">  <span class="built_in">Math</span>: <span class="xml"><span class="tag">&lt;<span class="name">...</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  String: <span class="tag">&lt;<span class="name">...</span>&gt;</span></span></span><br><span class="line"><span class="xml">  ...</span></span><br><span class="line"><span class="xml">  ...</span></span><br><span class="line"><span class="xml">  window: global //引用自身, 就是上面的那个例如</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>当访问<strong>全局对象的属性时</strong>通常会<strong>忽略掉前缀</strong>(<code>global</code>)，这是因为全局对象是<strong>不能通过名称直接访问</strong>的。不过我们依然可以通过<strong>全局上下文</strong>的<code>this</code>来访问全局对象，同样<strong>也可以递归引用自身</strong>。例如，<code>DOM</code>中的<code>window</code>, <code>nodejs</code>中的<code>global</code>。综上所述，代码可以简写为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="number">10</span>); <span class="comment">// 就是global.String(10);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有前缀</span></span><br><span class="line"><span class="keyword">this</span>.b = <span class="number">20</span>; <span class="comment">// global.b = 20;  //通过this</span></span><br><span class="line"><span class="built_in">window</span>.a = <span class="number">10</span>; <span class="comment">// === global.window.a = 10 === global.a = 10; // 通过递归引用自身</span></span><br></pre></td></tr></table></figure>
<p>因此，回到全局上下文中的变量对象——在这里，变量对象就是全局对象自己：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VO(globalContext) === global;</span><br></pre></td></tr></table></figure>
<p><strong>非常有必要要理解上述结论</strong>，基于这个原理，在全局上下文中声明的对应，我们才可以<strong>间接通过</strong><code>全局对象的属性</code>来访问它（例如，事先不知道变量名称）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line">alert(a); <span class="comment">// 直接访问，在VO(globalContext)里找到："test"</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">window</span>[<span class="string">'a'</span>]); <span class="comment">// 间接通过global访问：global === VO(globalContext): "test"</span></span><br><span class="line">alert(a === <span class="keyword">this</span>.a); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aKey = <span class="string">'a'</span>;</span><br><span class="line">alert(<span class="built_in">window</span>[aKey]); <span class="comment">// 间接通过动态属性名称访问："test"</span></span><br></pre></td></tr></table></figure>
<h3 id="函数上下文中的变量对象"><a href="#函数上下文中的变量对象" class="headerlink" title="函数上下文中的变量对象"></a>函数上下文中的变量对象</h3><p>在函数执行上下文中，<code>VO</code>是<strong>不能直接访问的</strong>，此时由活动对象(<code>activation object</code>,缩写为AO)扮演<code>VO</code>的角色。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VO(functionContext) === AO;</span><br></pre></td></tr></table></figure>
<p>活动对象是在<strong>进入函数上下文时</strong>刻被<strong>创建</strong>的，它通过函数的<code>arguments</code>属性<strong>初始化</strong>。<code>arguments</code>属性的值是<code>Arguments</code>对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">  <span class="built_in">arguments</span>: <span class="xml"><span class="tag">&lt;<span class="name">ArgO</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
<p><code>Arguments</code>对象是活动对象的一个<strong>属性</strong>，它包括如下属性：</p>
<ol>
<li><code>callee</code> — 指向当前函数的引用</li>
<li><code>length</code> — 真正传递的参数个数</li>
<li><code>properties-indexes</code> (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 <code>properties-indexes</code>内部元素的个数等于<code>arguments.length</code>. <code>properties-indexes</code> 的值和实际传递进来的参数之间是共享的。<br>例如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 形参, 声明的函数参数数量arguments (x, y, z)</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实参, 真正传进来的参数个数(only x, y)</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数的callee是函数自身</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee === foo); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 形参实参, 参数共享. 还有同名形参和函数内变量这个看变量提升, 就是忽略</span></span><br><span class="line">  <span class="built_in">console</span>.log(x === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">  x = <span class="number">30</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不过，没有传进来的参数z，和参数的第3个索引值是不共享的</span></span><br><span class="line">  z = <span class="number">40</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">50</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(z); <span class="comment">// 40</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子的代码，在当前版本(71.0.3578.98 (Official Build) (64-bit))的<code>Google Chrome</code>浏览器里有一个bug  — 即使没有传递参数<code>z</code>，<code>z</code>和<code>arguments[2]</code>仍然是共享的。</p>
<h3 id="处理上下文代码的2个阶段"><a href="#处理上下文代码的2个阶段" class="headerlink" title="处理上下文代码的2个阶段"></a>处理上下文代码的2个阶段</h3><p>现在我们终于到了本文的核心点了。执行上下文的代码被分成两个基本的阶段来处理：</p>
<ol>
<li>进入执行上下文</li>
<li>执行代码</li>
</ol>
<p><strong>变量对象</strong>的修改变化与这两个阶段紧密相关。</p>
<p>注：这2个阶段的处理是一般行为，和上下文的类型无关（也就是说，<strong>在全局上下文和函数上下文中的表现是一样的</strong>）。</p>
<h3 id="这里说下变量-以前认知中有个错误概念"><a href="#这里说下变量-以前认知中有个错误概念" class="headerlink" title="这里说下变量(以前认知中有个错误概念)"></a>这里说下变量(以前认知中有个错误概念)</h3><p>通常，各类文章和JavaScript相关的书籍都声称：“不管是使用<code>var</code>关键字(在全局上下文)<strong>还是不使用<code>var</code>关键字(在任何地方)</strong>，都可以声明一个变量”。请记住，<strong>这是错误的概念</strong>：</p>
<p><strong>任何时候，<code>变量</code>只能通过使用<code>var</code>关键字才能声明</strong>。</p>
<p>赋值语句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这仅仅是给<code>全局对象</code>创建了一个<strong>新属性(但它不是变量)</strong>。“不是变量”并不是说它不能被改变，而是<strong>指它不符合<code>ECMAScript</code>规范中的变量概念</strong>，所以它“不是变量”(它<strong>之所以能成为全局对象的属性</strong>，完全是因为<code>VO(globalContext) === global</code>，大家还记得这个吧？, 忽略了前缀)。</p>
<p>让我们通过下面的实例看看具体的区别吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>所有根源仍然是<code>VO</code>和<strong>进入上下文阶段</strong>和<strong>代码执行阶段</strong>：</p>
<p>进入上下文阶段：是这样的, 如果<code>b</code>是变量的话那么它也应该在<code>VO</code>中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VO = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 如果b是变量  那么也会存在 b: undefined, 但实际上报错, 所以并不存在这个变量b</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，因为“<code>b</code>”不是一个变量，所以在这个阶段根本就没有“<code>b</code>”，“<code>b</code>”将只在<strong>代码执行阶段</strong>才会出现(但是在我们这个例子里，还没有到那就已经出错了)。</p>
<p>让我们改变一下例子代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined, 这个大家都知道，</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 10, 代码执行阶段创建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 20, 代码执行阶段修改</span></span><br></pre></td></tr></table></figure>
<p>关于变量，还有一个重要的知识点。<strong>变量相对于简单属性来说</strong>，变量有一个特性(<code>attribute</code>)：{<code>DontDelete</code>},这个特性的含义就是不能用<code>delete</code>操作符直接删除变量属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> a); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> b); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// still 20</span></span><br></pre></td></tr></table></figure>
<p>但是这个规则在<strong>有个上下文里不起</strong>作用，那就是<code>eval</code>上下文，变量没有{<code>DontDelete</code>}特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'var a = 10;'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> a); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>使用一些调试工具(例如：<code>Firebug</code>)的控制台测试该实例时，请注意，<code>Firebug</code>同样是使用<code>eval</code>来执行控制台里你的代码。因此，变量属性同样没有{<code>DontDelete</code>}特性，可以被删除。</p>
<h3 id="特殊实现-parent-属性"><a href="#特殊实现-parent-属性" class="headerlink" title="特殊实现: __parent__ 属性"></a>特殊实现: <code>__parent__</code> 属性</h3><p>前面已经提到过，<strong>按标准规范，活动对象是不可能被直接访问到的</strong>。但是，<code>一些具体实现</code>并没有完全遵守这个规定，例如<code>SpiderMonkey</code>和<code>Rhino</code>；的实现中，函数有一个特殊的属性 <code>__parent__</code>，通过这个属性<strong>可以直接引用到活动对象</strong>（或全局变量对象），在此对象里创建了函数。</p>
<p>例如 (<code>SpiderMonkey</code>, <code>Rhino</code>)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.__parent__); <span class="comment">// global</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> VO = foo.__parent__;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(VO.a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(VO === global); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中我们可以看到，函数<code>foo</code>是在全局上下文中创建的，所以属性<code>__parent__</code> 指向全局上下文的变量对象，即全局对象。</p>
<p>然而，在<code>SpiderMonkey</code>中用同样的方式访问活动对象是不可能的：在不同版本的<code>SpiderMonkey</code>中，内部函数的<code>__parent__</code> 有时指向<code>null</code> ，有时指向<code>全局对象</code>。</p>
<p>在<code>Rhino</code>中，用同样的方式访问活动对象是完全可以的。</p>
<p>例如 (<code>Rhino</code>)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// "foo"上下文里的活动对象</span></span><br><span class="line">  <span class="keyword">var</span> AO = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).__parent__;</span><br><span class="line"></span><br><span class="line">  print(AO.y); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前活动对象的__parent__ 是已经存在的全局对象</span></span><br><span class="line">  <span class="comment">// 变量对象的特殊链形成了</span></span><br><span class="line">  <span class="comment">// 所以我们叫做作用域链</span></span><br><span class="line">  print(AO.__parent__ === global); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  print(AO.__parent__.x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="再说下作用域与执行上下文"><a href="#再说下作用域与执行上下文" class="headerlink" title="再说下作用域与执行上下文"></a>再说下作用域与执行上下文</h3><p>JavaScript代码的整个执行过程，分为两个阶段，<strong>代码编译阶段与代码执行阶段</strong>。<br><strong>编译阶段</strong>由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。<br><strong>执行阶段</strong>由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</p>
<p><img src="process.webp" alt="process.webp"></p>
<p>然后是前面说的<code>执行上下文</code>的<strong>生命周期</strong></p>
<p><img src="execution_context.webp" alt="execution_context.webp"></p>
<p>下面的链接更详细分为4个阶段, 整合了从<code>global context</code>开始</p>
<p><a href="https://segmentfault.com/a/1190000011504517" target="_blank" rel="noopener">图解JS闭包形成的原因 666</a></p>
<h4 id="程序执行的四个阶段"><a href="#程序执行的四个阶段" class="headerlink" title="程序执行的四个阶段"></a>程序执行的四个阶段</h4><p>我以下面一段代码解释一下程序执行的几个阶段</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="string">"21"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span>;</span><br><span class="line">    age++;</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">myAge();</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br></pre></td></tr></table></figure>
<p><strong>第一阶段</strong>：在内存中创建执行执行环境栈、把全局对象<code>window</code>压入栈底、在<code>window</code>中声明变量</p>
<p><img src="step1.jpeg" alt="step1.jpeg"></p>
<p><strong>第二阶段：函数调用时</strong><br>在执行环境中添加当前函数调用、为本次函数调用创建<code>活动对象AO</code>、根据<code>scope</code>指定运行期活动对象AO的<code>上下文内部对象</code></p>
<p><img src="step2.jpeg" alt="step2.jpeg"></p>
<p><strong>第三阶段：函数调用后</strong><br>函数调用从执行环境栈中出栈、函数作用域AO释放、函数作用域AO中的局部变量也一同被释放</p>
<p><img src="step3.jpeg" alt="step3.jpeg"></p>
<h3 id="函数调用栈与作用域链"><a href="#函数调用栈与作用域链" class="headerlink" title="函数调用栈与作用域链"></a>函数调用栈与作用域链</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innnerFoo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(c); <span class="comment">// 在这里，试图访问函数bar中的c变量，会抛出错误</span></span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    fn = innnerFoo; <span class="comment">// 将 innnerFoo的引用，赋值给全局变量中的fn</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">100</span>;</span><br><span class="line">    fn(); <span class="comment">// 此处的保留的innerFoo的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<p>这里打印<code>c</code>要看你的作用域链上能不能找到<code>c</code>,而不是说调用的时候, 前面有个<code>c</code>用过.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.menvscode.com/detail/599fd4673bb2bd430d7a7e01" target="_blank" rel="noopener">《高性能JavaScript》第2章</a></p>
<p><strong>重点是这4篇文章, 然后看完就看下浏览器的机制, 再看下执行上下文的结构</strong><br><a href="https://www.css88.com/archives/7262" target="_blank" rel="noopener">JavaScript 核心概念之作用域和闭包 666</a><br><a href="https://www.css88.com/archives/7255" target="_blank" rel="noopener">深入理解JavaScript中的作用域和上下文 666</a><br><a href="https://www.css88.com/archives/7300" target="_blank" rel="noopener">实例分析 JavaScript 作用域 6666</a><br><a href="https://www.css88.com/archives/7924" target="_blank" rel="noopener">JavaScript 中的 Hoisting (变量提升和函数声明提升) 666</a></p>
<a href="/2018/12/28/从输入URL到页面加载发生了什么/" title="从输入URL到页面加载发生了什么">从输入URL到页面加载发生了什么</a>
<p><a href="https://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/" target="_blank" rel="noopener">了解JavaScript的执行上下文</a><br><a href="https://juejin.im/post/5a5ee28f6fb9a01cbe655860" target="_blank" rel="noopener">由变量提升谈谈 JavaScript Execution Context</a></p>
<p><a href="https://www.zhihu.com/question/51336888" target="_blank" rel="noopener">js中 执行环境(execution context) 和 作用域(scope) 的区别在哪里?</a><br><a href="https://www.zhihu.com/question/36393048" target="_blank" rel="noopener">js 中的活动对象 与 变量对象 什么区别？</a></p>
<p><a href="https://segmentfault.com/a/1190000014980841" target="_blank" rel="noopener">讲清楚之javascript作用域 6</a><br><a href="https://github.com/creeperyang/blog/issues/16" target="_blank" rel="noopener">深入理解JS中声明提升、作用域（链）和<code>this</code>关键字</a><br><a href="https://segmentfault.com/a/1190000011504517" target="_blank" rel="noopener">图解JS闭包形成的原因 666</a><br><a href="https://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html" target="_blank" rel="noopener">深入理解JavaScript系列（12）：变量对象（Variable Object）666666</a><br><a href="http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html" target="_blank" rel="noopener">深入理解JavaScript系列（13）：This? Yes,this! 666666</a><br><a href="http://www.admin10000.com/document/6711.html" target="_blank" rel="noopener">深入浅出 妙用Javascript中apply、call、bind 6666</a><br><a href="https://juejin.im/entry/5aca253e5188255c5668b7bb" target="_blank" rel="noopener">闭包，是真的美 666</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/YAML语言入门/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/YAML语言入门/" itemprop="url">YAML语言入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T11:37:53+08:00">2019-02-12</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/YAML/" itemprop="url" rel="index"><span itemprop="name">YAML</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="YAML语言入门"><a href="#YAML语言入门" class="headerlink" title="YAML语言入门"></a>YAML语言入门</h1><p>YAML 是专门用来<strong>写配置文件</strong>的语言，非常简洁和强大，远比 <code>JSON</code> 格式方便。</p>
<h2 id="二-对象"><a href="#二-对象" class="headerlink" title="二 对象"></a>二 对象</h2><p>对象的一组键值对，使用冒号结构表示。(<strong>记住这个是基本的结构</strong>)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">pets</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">animal</span>: <span class="string">'pets'</span> &#125;</span><br></pre></td></tr></table></figure>
<p><code>Yaml</code> 也允许另一种写法，将所有键值对写成一个行内对象。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hash:</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">Steve,</span> <span class="attr">foo:</span> <span class="string">bar</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">hash</span>: &#123; <span class="attr">name</span>: <span class="string">'Steve'</span>, <span class="attr">foo</span>: <span class="string">'bar'</span> &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>然后是多个的</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">YAML:</span> <span class="string">yaml.org</span></span><br><span class="line"><span class="attr">Ruby:</span> <span class="string">ruby-lang.org</span></span><br><span class="line"><span class="attr">Python:</span> <span class="string">python.org</span></span><br><span class="line"><span class="attr">Perl:</span> <span class="string">use.perl.org</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    YAML: <span class="string">'yaml.org'</span>,</span><br><span class="line">    Ruby: <span class="string">'ruby-lang.org'</span>,</span><br><span class="line">    Python: <span class="string">'python.org'</span>,</span><br><span class="line">    Perl: <span class="string">'use.perl.org'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-数组"><a href="#三-数组" class="headerlink" title="三 数组"></a>三 数组</h2><p>一组连词线开头的行，构成一个数组。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span> ]</span><br></pre></td></tr></table></figure>
<p>数据结构的子成员是一个数组，则可以在该项下面<strong>缩进一个空格</strong>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ [ <span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span> ] ]</span><br></pre></td></tr></table></figure>
<p>数组也可以采用行内表示法。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">[Cat,</span> <span class="string">Dog]</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">animal</span>: [ <span class="string">'Cat'</span>, <span class="string">'Dog'</span> ] &#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、复合结构"><a href="#四、复合结构" class="headerlink" title="四、复合结构"></a>四、复合结构</h2><p>对象和数组可以结合使用，形成复合结构。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">languages:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Ruby</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Perl</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Python</span></span><br><span class="line"><span class="attr">websites:</span></span><br><span class="line"><span class="attr"> YAML:</span> <span class="string">yaml.org</span></span><br><span class="line"><span class="attr"> Ruby:</span> <span class="string">ruby-lang.org</span></span><br><span class="line"><span class="attr"> Python:</span> <span class="string">python.org</span></span><br><span class="line"><span class="attr"> Perl:</span> <span class="string">use.perl.org</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">languages</span>: [ <span class="string">'Ruby'</span>, <span class="string">'Perl'</span>, <span class="string">'Python'</span> ],</span><br><span class="line">  websites:</span><br><span class="line">   &#123; <span class="attr">YAML</span>: <span class="string">'yaml.org'</span>,</span><br><span class="line">     Ruby: <span class="string">'ruby-lang.org'</span>,</span><br><span class="line">     Python: <span class="string">'python.org'</span>,</span><br><span class="line">     Perl: <span class="string">'use.perl.org'</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面可以得出写法, <strong>从最里层往外看</strong>,就可以转成<code>JavaScript</code>的写法</p>
</blockquote>
<h2 id="五、纯量"><a href="#五、纯量" class="headerlink" title="五、纯量"></a>五、纯量</h2><p>纯量是最基本的、不可再分的值。以下数据类型都属于 <code>JavaScript</code> 的纯量。</p>
<ul>
<li>字符串</li>
<li>布尔值</li>
<li>整数</li>
<li>浮点数</li>
<li>Null</li>
<li>时间</li>
<li>日期</li>
</ul>
<p><code>null</code>用<code>~</code>表示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">parent:</span> <span class="string">~</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">parent</span>: <span class="literal">null</span> &#125;</span><br></pre></td></tr></table></figure>
<p>时间采用 <code>ISO8601</code> 格式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iso8601: <span class="number">2001</span><span class="number">-12</span><span class="number">-14</span>t21:<span class="number">59</span>:<span class="number">43.10</span><span class="number">-05</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">iso8601</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2001-12-14t21:59:43.10-05:00'</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>日期采用复合 <code>iso8601</code> 格式的年、月、日表示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">date:</span> <span class="number">1976</span><span class="bullet">-07</span><span class="bullet">-31</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1976-07-31'</span>) &#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">YAML 语言教程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/31/url的组成/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/31/url的组成/" itemprop="url">url的组成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-31T20:09:33+08:00">2019-01-31</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/网络/" itemprop="url" rel="index"><span itemprop="name">网络</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="url的组成"><a href="#url的组成" class="headerlink" title="url的组成"></a>url的组成</h1><h2 id="whatwg标准"><a href="#whatwg标准" class="headerlink" title="whatwg标准"></a>whatwg标准</h2><p><a href="https://url.spec.whatwg.org/" target="_blank" rel="noopener">whatwg</a></p>
<p>WHATWG 的 <code>API</code> 与遗留的 <code>API</code> 的区别如下。 在下图中，URL <code>&#39;http://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash&#39;</code> 上方的是遗留的 <code>url.parse()</code> 返回的对象的属性。 下方的则是 <code>WHATWG</code> 的 URL 对象的属性。</p>
<p>WHATWG 的 <code>origin</code> 属性包括 <code>protocol</code> 和 <code>host</code>，但<strong>不包括</strong> <code>username</code> 或 <code>password</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                                              href                                              │</span><br><span class="line">├──────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬───────┤</span><br><span class="line">│ protocol │  │        auth         │          host          │           path            │ hash  │</span><br><span class="line">│          │  │                     ├─────────────────┬──────┼──────────┬────────────────┤       │</span><br><span class="line">│          │  │                     │    hostname     │ port │ pathname │     search     │       │</span><br><span class="line">│          │  │                     │                 │      │          ├─┬──────────────┤       │</span><br><span class="line">│          │  │                     │                 │      │          │ │    query     │       │</span><br><span class="line"><span class="string">"  https:   //    user   :   pass   @ sub.example.com : 8080   /p/a/t/h  ?  query=string   #hash "</span></span><br><span class="line">│          │  │          │          │    hostname     │ port │          │                │       │</span><br><span class="line">│          │  │          │          ├─────────────────┴──────┤          │                │       │</span><br><span class="line">│ protocol │  │ username │ password │          host          │          │                │       │</span><br><span class="line">├──────────┴──┼──────────┴──────────┼────────────────────────┤          │                │       │</span><br><span class="line">│   origin    │                     │         origin         │ pathname │     search     │ hash  │</span><br><span class="line">├─────────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴───────┤</span><br><span class="line">│                                              href                                              │</span><br><span class="line">└────────────────────────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>host是hostname + port<br>origin是protocol(这个有个<code>:</code>) + host<br>然后后面是pathname(这个有<code>/</code>), search(这个有<code>?</code>), hash(这个有<code>#</code>)</p>
<p>username:password这个是用来保护url的, 而不是用来登录的.</p>
<p>比如在ftp中, 你的浏览器登录后会使用<code>anonymous</code>, 所以你可以指定某一个<code>username</code>来, 只不过对于<code>password</code>不建议使用. 会被窃听到的, 况且还有https这个呢.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://nodejs.cn/api/url.html#url_url_strings_and_url_objects" target="_blank" rel="noopener">nodejs中 URL 字符串与 URL 对象</a><br><a href="https://www.cs.rutgers.edu/~watrous/user-pass-url.html" target="_blank" rel="noopener">Specifying username/password in a URL</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/13/静态作用域与动态作用域/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/13/静态作用域与动态作用域/" itemprop="url">静态作用域与动态作用域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-13T15:44:24+08:00">2019-01-13</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h1><p>作用域有两种常见的模型：词法作用域(<code>Lexical Scope</code>，通常也叫做 静态作用域) 和 动态作用域(<code>Dynamic Scope</code>)。其中词法作用域更常见，被 <code>JavaScript</code> 等大多数语言采用。（愚人码头注：这里避开了with和eval特殊语句，不再做介绍）。</p>
<p><strong>静态作用域与动态作用域</strong>:</p>
<ul>
<li><p>词法作用域：词法作用域是指<strong>在词法分析阶段</strong>就确定了，不会改变。变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。</p>
</li>
<li><p>动态作用域：动态作用域是在<strong>运行时</strong>根据程序的流程信息来动态确定的，而不是在写代码时进行静态确定的。 动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们在何处调用。</p>
</li>
</ul>
<p><strong>JavaScript的词法作用域</strong>:</p>
<p>如果一个文档流中包含多个script代码段（用script标签分隔的js代码或引入的js文件），它们的运行顺序是：</p>
<ol>
<li>读入第一个代码段（js执行引擎并非一行一行地分析程序，而是一段一段地分析执行的）</li>
<li>做词法分析，有错则报语法错误（比如括号不匹配等），并跳转到步骤5</li>
<li>对var变量和function定义做“预解析“（永远不会报错的，因为只解析正确的声明）</li>
<li>执行代码段，有错则报错（比如变量未定义）</li>
<li>如果还有下一个代码段，则读入下一个代码段，重复步骤2</li>
<li>完成</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"><span class="comment">// 结果是 ???</span></span><br></pre></td></tr></table></figure>
<p>假设JavaScript采用<strong>静态作用域</strong>，让我们分析下执行过程：(这部分要结合作用域链看)</p>
<p>执行 <code>foo</code> 函数，先从 <code>foo</code> 函数局部作用域中查找是否有变量 <code>value</code>，如果没有，就从全局作用域中查找变量<code>value</code>的值，所以结果会打印 1。</p>
<p>假设JavaScript采用<strong>动态作用域</strong>，让我们分析下执行过程：</p>
<p>执行 <code>foo</code> 函数，依然是从 <code>foo</code> 函数内部查找是否有局部变量 <code>value</code>。如果没有，就从调用函数的作用域，也就是 <code>bar</code> 函数内部查找 <code>value</code> 变量，所以结果会打印 2。</p>
<p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.css88.com/archives/7300" target="_blank" rel="noopener">实例分析 JavaScript 作用域, 同时讲了形参, 实参, 同名局部变量</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/js作用域链和闭包/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/10/js作用域链和闭包/" itemprop="url">js作用域链和闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-10T19:15:16+08:00">2019-01-10</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="js作用域链和闭包"><a href="#js作用域链和闭包" class="headerlink" title="js作用域链和闭包"></a>js作用域链和闭包</h1><h2 id="1-执行环境-execution-context"><a href="#1-执行环境-execution-context" class="headerlink" title="1.执行环境(execution context)"></a>1.执行环境(execution context)</h2><blockquote>
<p>执行环境<code>execution context</code>和环境<code>context</code>不一样, 后面有介绍</p>
</blockquote>
<p>执行环境定义了<strong>变量和函数有权访问的其他数据</strong>，决定了他们各自的行为。每个执行环境都有与之对应的<strong>变量对象</strong>（<code>variable object</code>）</p>
<blockquote>
<p><code>变量对象</code>就是执行环境中定义的变量和函数，<code>活动对象</code>是函数执行的时候被创建的，是属于某个函数的<br><strong>保存着该环境中定义的所有变量和函数</strong>。我们无法通过代码来访问变量对象，但是<strong>解析器</strong>在处理数据时会在后台使用到它。<br>执行环境有<strong>全局执行环境</strong>（也称全局环境）和<strong>函数执行环境</strong>之分。执行环境如其名是在运行和执行代码的时候才存在的，所以我们<strong>运行浏览器的时候</strong>会创建全局的执行环境，在<strong>调用函数</strong>时，会创建函数执行环境。</p>
</blockquote>
<h3 id="1-1-全局执行环境"><a href="#1-1-全局执行环境" class="headerlink" title="1.1 全局执行环境"></a>1.1 全局执行环境</h3><p>全局执行环境是<strong>最外围的一个执行环境</strong>，在web浏览器中，我们可以认为他是<strong>window对象</strong>，因此所有的全局变量和函数都是作为<code>window</code>对象的<strong>属性和方法</strong>创建的。代码载入浏览器时，全局环境被创建，关闭网页或者关闭浏览时全局环境被销毁。</p>
<h3 id="1-2-函数执行环境"><a href="#1-2-函数执行环境" class="headerlink" title="1.2 函数执行环境"></a>1.2 函数执行环境</h3><p>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被<strong>推入一个环境栈</strong>中，当函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>
<h2 id="2-作用域、作用域链"><a href="#2-作用域、作用域链" class="headerlink" title="2 作用域、作用域链"></a>2 作用域、作用域链</h2><h3 id="2-1作用域-Scope"><a href="#2-1作用域-Scope" class="headerlink" title="2.1作用域(Scope)"></a>2.1作用域(Scope)</h3><p>作用域概念是理解<code>JavaScript</code>的关键所在，不仅仅从性能角度，还包括从功能角度。<strong>作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期</strong>，换句话说，作用域决定了代码区块中变量和其他资源的可见性。在<code>JavaScript</code>中变量的作用域有全局作用域和局部作用域。<code>JavaScript</code>采用词法作用域(<code>lexical scoping</code>)，也就是<strong>静态作用域</strong>。</p>
<a href="/2019/01/13/静态作用域与动态作用域/" title="静态作用域与动态作用域">静态作用域与动态作用域</a>
<blockquote>
<p>在下面的图中, <code>AO</code>就是一个作用域, <code>Global object</code>也是一个作用域<code>scope</code>, 他们串一起就是<code>scope chain</code>咯</p>
</blockquote>
<h4 id="2-1-全局作用域（globe-scope）和局部作用域（local-scope）和块级作用域"><a href="#2-1-全局作用域（globe-scope）和局部作用域（local-scope）和块级作用域" class="headerlink" title="2.1 全局作用域（globe scope）和局部作用域（local scope）和块级作用域"></a>2.1 全局作用域（globe scope）和局部作用域（local scope）和块级作用域</h4><p>在<code>ECMAScript 5</code>（包括ECMAScript 5）之前的版本中，作用域只有全局作用域和局部作用域，不存在块级作用域；<code>ECMAScript 6</code>引入了<code>let</code>和<code>const</code>关键字，利用<code>let</code>和<code>const</code>可以形成块级作用域。(<strong>和c go那样的在<code>{}</code>里面表示块,不需要结合<code>if for</code>一起用才能形成块</strong>)</p>
<p><strong>1、全局作用域</strong>:</p>
<p>在代码中任何地方都能访问到的<strong>对象</strong>拥有全局作用域。全局作用域的变量是<strong>全局对象</strong>的属性，不论在什么函数中都可以直接访问，而不需要通过全局对象，但加上全局对象，可以提供搜索效率。</p>
<blockquote>
<p>a、没有用var声明的变量（除去函数的参数）都具有全局作用域，成为全局变量，所以声明<strong>局部变量</strong>必须要用var。<br>b、<code>window</code>的所有属性都具有全局作用域<br>c、最外层<strong>函数体外声明的变量</strong>也具有全局作用域</p>
</blockquote>
<p>2、局部作用域</p>
<p>局部变量的优先级高于全局变量。</p>
<blockquote>
<p>a、函数体内用var声明的变量具有局部作用域，成为局部变量<br>b、<strong>函数的参数</strong>也具有局部作用域</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">3</span>; <span class="comment">// a全局变量  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">b</span>)</span>&#123; <span class="comment">// fn全局变量 b局部变量  </span></span><br><span class="line"> c=<span class="number">2</span>; <span class="comment">// c全局变量  </span></span><br><span class="line"> <span class="keyword">var</span> d=<span class="number">5</span>; <span class="comment">// d局部变量  </span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">subFn</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// subFn局部变量</span></span><br><span class="line">    <span class="keyword">var</span> e=d; <span class="comment">// 父函数的局部变量对子函数可见  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;  </span><br><span class="line">      <span class="built_in">console</span>.write(i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    alert(i);<span class="comment">// 3, 在for循环内声明，循环外function内仍然可见，没有块作用域  </span></span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">alert(c); <span class="comment">// 在function内声明但不带var修饰，仍然是全局变量</span></span><br></pre></td></tr></table></figure>
<p><strong>3、块级作用域</strong>:</p>
<p>使用let和const关键字声明的变量，会在形成块级作用域。常见的是在<code>if</code>和<code>for</code>的<code>{}</code>语句块里面用, 可以单独使用<code>{}</code>作为块作用域哦</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="comment">// 'if' 条件语句块不会创建一个新的作用域</span></span><br><span class="line">   <span class="comment">// name 在全局作用域中，因为通过 'var' 关键字定义</span></span><br><span class="line">   <span class="keyword">var</span> name = <span class="string">'Hammad'</span>;</span><br><span class="line">   <span class="comment">// likes 在局部（本地）作用域中，因为通过 'let' 关键字定义</span></span><br><span class="line">   <span class="keyword">let</span> likes = <span class="string">'Coding'</span>;</span><br><span class="line">   <span class="comment">// skills 在局部（本地）作用域中，因为通过 'const' 关键字定义</span></span><br><span class="line">   <span class="keyword">const</span> skills = <span class="string">'JavaScript and PHP'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// logs 'Hammad'</span></span><br><span class="line"><span class="built_in">console</span>.log(likes); <span class="comment">// Uncaught ReferenceError: likes is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(skills); <span class="comment">// Uncaught ReferenceError: skills is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<h3 id="上下文-context-不是执行上下文-execution-scope"><a href="#上下文-context-不是执行上下文-execution-scope" class="headerlink" title="上下文(context)不是执行上下文(execution scope)"></a>上下文(context)不是执行上下文(execution scope)</h3><p>许多开发人员经常混淆作用域(<code>scope</code>)和上下文(<code>context</code>)，很多误解为它们是相同的概念。但事实并非如此。作用域(<code>scope</code>)我们上面已经讨论过了，而上下文(<code>context</code>)是用来指定代码某些特定部分中<code>this</code>的值。<br>作用域(<code>scope</code>) 是指<strong>变量的可访问性</strong>，上下文(<code>context</code>)是指<code>this</code>在<strong>同一作用域内的值</strong>。<br>我们也可以使用<code>call()</code>、<code>apply()</code>、<code>bind()</code>、<code>箭头函数</code>等改变上下文。<br>在浏览器中在全局作用域(<code>scope</code>)中上下文中始终是<code>Window对象</code>。在Node.js中在全局作用域(<code>scope</code>)中上下文中始终是<code>Global</code> 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Cherry"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  <span class="comment">// windowsName</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"inner:"</span> + <span class="keyword">this</span>);<span class="comment">// inner: Window</span></span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outer:"</span> + <span class="keyword">this</span>) <span class="comment">// outer: Window</span></span><br></pre></td></tr></table></figure>
<p>上下文始终坚持一个原理：<code>this</code> <strong>永远指向最后调用它的那个对象</strong>参考<a href="/2018/11/26/javascript中this指向由函数调用方式决定/" title="javascript中this指向由函数调用方式决定">javascript中this指向由函数调用方式决定</a>，上例中调用<code>a</code>函数的是<code>window</code>，所以a函数中的<code>this</code>指向<code>window</code>对象。关于<code>this</code>以及改变<code>this</code>的指向，可以参考<a href="https://juejin.im/post/59bfe84351882531b730bac2" target="_blank" rel="noopener">this、apply、call、bind</a></p>
<h3 id="2-2-作用域链（scope-chain）"><a href="#2-2-作用域链（scope-chain）" class="headerlink" title="2.2 作用域链（scope chain）"></a>2.2 作用域链（scope chain）</h3><p><code>JavaScript</code> 中每个函数都都表示为一个<strong>函数对象</strong>（函数实例），函数对象有一个仅供 <code>JavaScript</code> 引擎使用的<code>[[scope]]</code> 属性。通过<strong>语法分析和预解析</strong>，将<code>[[scope]]</code> 属性<strong>指向函数定义时</strong>作用域中的<strong>所有对象集合</strong>。这个<strong>集合</strong>被称为函数的<strong>作用域链</strong>（<code>scope chain</code>），包含函数定义时作用域中所有可访问的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<strong>定义</strong> <code>add</code> 函数后，<strong>其作用域链就创建了</strong>。函数所在的全局作用域的全局对象被放置到 <code>add</code> 函数作用域链（<code>[[scope]]</code> 属性）中。我们可以从下图中看到作用域链的<strong>第一个对象保存的是全局对象</strong>，全局对象中保存了诸如 <code>this</code> , <code>window</code> , <code>document</code> 以及全局对象中的 <code>add</code> 函数，也就是他自己。这也就是我们可以在全局作用域下的函数中访问 <code>window(this)</code>，<strong>访问全局变量</strong>，<strong>访问函数自身</strong>的原因。全局上下文中的变量对象(<code>Variable object，VO</code>)就是全局对象。</p>
<p><img src="scopechain1.png" alt="scopechain1.png"></p>
<p>全局作用域和局部作用域中<strong>变量的访问权限</strong>，其实是<strong>由作用域链决定的</strong>。</p>
<p>每次进入一个新的执行环境(<strong>这里就表示程序执行起来了</strong>)，都会创建一个用于<strong>搜索变量和函数的作用域链</strong>。作用域链是函数被创建的作用域中对象的<strong>集合</strong>。作用域链可以保证对执行环境有权访问的所有变量和函数的有序访问。</p>
<p><strong>作用域链的最前端始终是当前执行的代码所在环境的变量对象</strong>（如果该环境是函数，则将其<strong>活动对象</strong>作为变量对象），下一个变量对象来自包含环境（包含当前还行环境的环境），下一个变量对象来自包含环境的包含环境，依次往上，直到全局执行环境的变量对象。全局执行环境的变量对象始终是作用域链中的最后一个对象。</p>
<p><strong>标识符解析</strong>是沿着作用域一级一级的向上搜索标识符的过程。搜索过程始终是从作用域的前端逐地向后回溯，直到找到标识符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">"foo"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar=<span class="string">"bar"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(foo);<span class="comment">//foo</span></span><br><span class="line">        <span class="built_in">console</span>.log(bar);<span class="comment">//bar</span></span><br><span class="line">        <span class="keyword">var</span> tName=<span class="string">"tName"</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(tName);<span class="comment">//tName</span></span><br><span class="line">    &#125;</span><br><span class="line">    bName();</span><br><span class="line">&#125;</span><br><span class="line">fName();</span><br></pre></td></tr></table></figure>
<p>上述代码中，一共有<strong>三个执行环境</strong>：<code>全局环境</code>、<code>fName()</code>的局部环境和 <code>sName()</code> 的局部环境。所以，</p>
<ol>
<li>函数 <code>sName()</code>的作用域链包含三个对象：自己的变量对象——-&gt;<code>fName()</code>局部环境的变量对象 ——-&gt;全局环境的变量对象。</li>
<li>函数 <code>fName()</code>的作用域链包含两个对象：自己的变量对象——-&gt;全局环境的变量对象。</li>
</ol>
<p>就上述程序中出现的变量和函数来讲（不考虑隐形变量）：</p>
<ol>
<li><code>sName()</code> 局部环境的变量对象中存放变量 <code>tName</code>；</li>
<li><code>fName()</code> 局部环境的变量对象中存放变量 <code>bar</code> 和 函数<code>sName()</code>；</li>
<li>全局环境的变量对象中存放变量 <code>foo</code> 、函数<code>fName()</code>;</li>
</ol>
<p><img src="scope1.gif" alt="scope1.gif"></p>
<p>作用域链相关知识的总结：</p>
<ol>
<li>执行环境决定了变量的生命周期，以及哪部分代码可以访问其中变量和函数</li>
<li>执行环境有全局执行环境（全局环境）和局部执行环境之分。</li>
<li>每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链</li>
<li>函数的局部环境可以访问函数作用域中的变量和函数，也可以访问其父环境，乃至全局环境中的变量和环境。</li>
<li>全局环境只能访问全局环境中定义的变量和函数，不能直接访问局部环境中的任何数据。</li>
<li>变量的执行环境有助于确定应该合适释放内存。</li>
</ol>
<h3 id="execution-context-scope-chain-scope三者关系"><a href="#execution-context-scope-chain-scope三者关系" class="headerlink" title="execution context, scope chain, scope三者关系"></a>execution context, scope chain, scope三者关系</h3><p>看闭包那个图图可以知道, 最左边的是<code>execution context</code>, 中间的是<code>scope chain</code>, 最右边的是<code>scope</code></p>
<h3 id="再说下执行器上下文-execution-context"><a href="#再说下执行器上下文-execution-context" class="headerlink" title="再说下执行器上下文(execution context)"></a>再说下执行器上下文(execution context)</h3><p><strong>执行具体的某个函数时</strong>，JS引擎在执行每个函数实例时，都会创建一个执行期上下文（<code>Execution Context</code>）和激活对象（<code>active Object</code>）（它们<strong>属于宿主对象</strong>，与函数实例执行的生命周期保持一致，也就是函数执行完成，这些对象也就被销毁了，闭包例外。）</p>
<p>假设我们运行以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = add(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>执行该函数创建一个<strong>内部对象</strong>，称为 <code>Execution Context</code>（执行期上下文）。执行期上下文<strong>定义了一个函数正在执行时的作用域环境</strong>。</p>
<blockquote>
<p>特别注意，<strong>执行期上下文<code>execution context</code>和我们平常说的上下文<code>context</code>不同</strong>，执行期上下文指的是<strong>作用域<code>[[scope]]</code></strong>??。平常说的上下文是<code>this</code>的取值指向。</p>
</blockquote>
<p><strong>执行期上下文</strong>和<strong>函数创建时</strong>的作用域链对象 <code>[[scope]]</code> 区分，<strong>这是两个不同的作用域链对象</strong>。分开的原因很简单，函数定义时的作用域链对象 <code>[[scope]]</code> 是固定的，而 执行期上下文 会<strong>根据不同的运行时环境变化</strong>。而且该函数每执行一次，都会创建单独的 执行期上下文，因此对同一函数调用多次，会导致创建多个执行期上下文。一旦函数执行完成，执行期上下文将被销毁。</p>
<p>执行期上下文对象有自己的作用域链，当创建执期行上下文时，其作用域链将使用执行函数<code>[[scope]]</code>属性所包含的对象（即，函数定义时的作用域链对象）进行初始化。<strong>这些值按照它们在函数中出现的顺序复制到执行期上下文作用域链中</strong>。(所以要注意闭包的产生)</p>
<p>无论有多少个函数上下文，但是全局上下文只有一个。<strong>执行期上下文有创建和代码执行的两个阶段</strong>。</p>
<p>下面链接讲了函数定义时的作用域链,以及函数运行时的执行上下文的区别.<br><a href="https://www.css88.com/archives/7262" target="_blank" rel="noopener">JavaScript 核心概念之作用域和闭包</a><br><a href="https://www.jianshu.com/p/21a16d44f150" target="_blank" rel="noopener">前端基础进阶（四）：详细图解作用域链与闭包</a></p>
<blockquote>
<p>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段<strong>作用域规则</strong>会确定。执行阶段由引擎完成，主要任务是执行可执行代码，<strong>执行上下文</strong>在这个阶段创建。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第一阶段：创建阶段"><a href="#第一阶段：创建阶段" class="headerlink" title="第一阶段：创建阶段"></a>第一阶段：创建阶段</h4><p>当一个<strong>函数被调用但是其代码还没有被执行</strong>的时候。在创建阶段主要做的三件事情是：</p>
<ol>
<li>创建变量（激活）对象（<code>VO == AO</code>) <strong>详看变量对象干了啥</strong>: <a href="https://www.jianshu.com/p/330b1505e41d" target="_blank" rel="noopener">前端基础进阶（三）：变量对象详解</a></li>
<li>创建作用域链</li>
<li>设置上下文(<code>context</code>)的值（ <code>this</code> ）</li>
</ol>
<p><strong>激活对象(<code>Activation Object，AO</code>)</strong></p>
<p>当一个函数被调用但是其代码还没有被执行的时，在执行其上下文中创建一个名为 <code>Activation Object</code>（激活对象）的<strong>新对象</strong>。这个激活对象保存了函数中的<strong>所有形参，实参，局部变量</strong>，<code>this</code> 指针等函数执行时函数内部的数据情况。然后将这个激活对象推送到执行其上下文作用域链的顶部。</p>
<ol>
<li>函数参数(若未传入，初始化该参数值为<code>undefined</code>)</li>
<li>函数声明(若发生命名冲突，会覆盖)</li>
<li>变量声明(初始化变量值为<code>undefined</code>，若发生命名冲突，会忽略。)</li>
</ol>
<p>例如: <code>add</code>函数被调用，但是还未执行时的VO(变量对象)==AO(激活对象)是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO(add) = &#123;</span><br><span class="line">  <span class="built_in">arguments</span>: &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">10</span></span><br><span class="line">    length: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  num1: <span class="number">5</span>,  </span><br><span class="line">  num2: <span class="number">10</span>,  </span><br><span class="line">  sum: <span class="literal">undefined</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码是不是少了<code>this</code>的值, 调用的时候<code>this</code>就可以确定了的啊, 图中就有<code>this</code></p>
</blockquote>
<p><strong>激活对象AO是一个可变对象</strong>，里面的数据随着函数执行时的数据的变化而变化(比如进行赋值)，当函数执行结束之后，执行期上下文将被销毁。也就会销毁<code>Execution Context</code>的作用域链，激活对象也同样被销毁。<strong>但如果存在闭包</strong>，激活对象就会以另外一种方式存在，这也是<strong>闭包产生的真正原因</strong>，具体的我们稍后讨论。下图显示了执行上下文及其作用域链：</p>
<p><img src="execution_scope1.png" alt="execution_scope1.png"></p>
<p>从左往右看，<strong>第一部分</strong>是函数执行时创建的执行期上下文，它有自己的作用域链，<strong>第二部分</strong>是作用域链中的对象，<strong>索引为1</strong>的对象是从<code>[[scope]]</code>作用域链中<strong>复制</strong>过来的，<strong>索引为0</strong>的对象是在函数执行时<strong>创建</strong>的激活对象，<strong>第三部分</strong>是作用域链中的对象的内容<code>Activation Object</code>(激活对象)和<code>Global Object</code>(全局对象)。</p>
<p><strong>函数在执行时，每遇到一个变量，都会去执行期上下文的作用域链的顶部，执行函数的激活对象开始向下搜索</strong>，如果在第一个作用域链（即，<code>Activation Object</code> 激活对象）中找到了，那么就返回这个变量。如果没有找到，那么继续向下查找，直到找到为止。如果在整个执行期上下文中都没有找到这个变量，在这种情况下，该变量被认为是未定义的。这也就是为什么函数可以访问全局变量，当局部变量和全局变量同名时，会使用局部变量而不使用全局变量，以及 <code>JavaScript</code> 中各种看似怪异的、有趣的作用域问题的答案。</p>
<h4 id="第二阶段：代码执行"><a href="#第二阶段：代码执行" class="headerlink" title="第二阶段：代码执行"></a>第二阶段：代码执行</h4><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值，并最终执行代码(这里只是变化变量的值, 但<code>this</code>是一直在的)。当代码执行完后，这时候的 AO 是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO(add) = &#123;</span><br><span class="line">  <span class="built_in">arguments</span>: &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">10</span></span><br><span class="line">    length: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  num1: <span class="number">5</span>,  </span><br><span class="line">  num2: <span class="number">10</span>,  </span><br><span class="line">  sum: <span class="number">15</span>       <span class="comment">// sum有了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="闭包Closure-重点看这里-前面讲的不怎么细"><a href="#闭包Closure-重点看这里-前面讲的不怎么细" class="headerlink" title="闭包Closure 重点看这里, 前面讲的不怎么细"></a>闭包Closure 重点看这里, 前面讲的不怎么细</h2><blockquote>
<p>前面讲的不怎么细, 这里重新开始把在函数定义时产生的<code>scope chain</code>和<code>函数调用但未执行时</code>和<code>函数执行时</code>的各个情况画图</p>
</blockquote>
<p>闭包（<code>Closure</code>）是 <code>JavaScript</code> 最强大的特性之一，它允许函数访问局部作用域之外的数据。闭包在日常编码工作中非常常见。但是，它会对性能造成影响。了解闭包我们使用以下示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignEvents</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="string">"666677"</span>;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"save-btn"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        saveDocument(id);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>闭包是一种特殊的对象。<br>它由两部分组成。执行上下文(代号A)，以及在该执行上下文中创建的函数（代号B）。<br>当B执行时，<strong>如果访问了A中变量对象中的值(不访问当然不产生闭包)</strong>，那么闭包就会产生。<br>在大多数理解中，包括许多著名的书籍，文章里都<strong>以函数B</strong>的名字代指这里生成的<strong>闭包</strong>。而在<code>chrome</code>中，则以<strong>执行上下文A的函数名</strong>代指<strong>闭包</strong>。</p>
</blockquote>
<p><code>assignEvents</code> 函数为DOM元素分配一个事件处理程序。这个处理函数就是一个闭包。为了使该闭包访问id变量，必须创建一个特定的作用域链。</p>
<p><strong>我们一起来从作用域的角度分析一下闭包的形成过程</strong>：</p>
<p><code>assignEvents</code> 函数创建并且词法解析后，函数对象<code>assignEvents</code>的<code>[[scope]]</code>属性被初始化，作用域链形成，作用域链中包含了全局对象的所有属性和方法（<strong>注意，此时因为 <code>assignEvents</code> 函数还未被执行，所以闭包函数并没有被解析</strong>）。</p>
<p>类似这图:<br><img src="scopechain1.png" alt="scopechain1.png"></p>
<p><code>assignEvents</code> 开始执行时，创建 <code>Execution Context</code>（执行期上下文），在执行期上下文的作用域链中创建 <code>Activation Object</code>(激活对象)，并将 <code>Activation Object</code>(激活对象) 推送到作用域链顶部，在其中保存了函数执行时所有可访问函数内部的数据。激活对象包含 id 变量。</p>
<p>类似这图:<br><img src="execution_scope1.png" alt="execution_scope1.png"></p>
<p>当执行到闭包时，<code>JavaScript</code> 引擎发现了闭包函数的存在，按照通常的手法，将闭包函数解析，为闭包函数对象创建 <code>[[scope]]</code> 属性，初始化作用域链。特别注意的是，这个时候，闭包函数对象的作用域链中有两个对象，一个是 <code>assignEvents</code> 函数执行时的 <code>Activation Object</code>(激活对象) ，还有一个是全局对象，如下图</p>
<p><img src="closure1.png" alt="closure1.png"></p>
<p>我们看到图中闭包函数对象的作用域链和 <code>assignEvents</code> 函数的执行期上下文的作用域链是相同的。为什么相同呢？我们来分析一下，闭包函数是在 <code>assignEvents</code> 函数执行的过程中被定义并且解析的，而函数执行时的作用域是 <code>Activation Object</code>(激活对象) ，闭包函数被解析的时候它的作用域正是 <code>assignEvents</code> 作用域链中的第一个作用域对象 <code>Activation Object</code>(激活对象) ，当然，由于作用域链的关系，全局对象作用域也被引入到闭包函数的作用域链中。</p>
<p>在词法分析的时候闭包函数的 <code>[[scope]]</code> 属性 就已经在作用域链中保存了对 <code>assignEvents</code> 函数的 <code>Activation Object</code>(激活对象) 的引用，所以当 <code>assignEvents</code> 函数执行完毕之后，<strong>闭包函数虽然还没有开始执行(执行后是另一个作用域链)</strong>，但依然可以访问 <code>assignEvents</code> 的局部数据，并不是因为闭包函数要访问 <code>assignEvents</code> 的局部变量<code>id</code>，所以当 <code>assignEvents</code> 函数执行完毕之后依然保持了对局部变量<code>id</code>的引用。而是不管是否存在变量引用，都会保存对 <code>assignEvents</code> 的 <code>Activation Object</code>(激活对象)作用域对象的引用。因为在词法分析时，闭包函数没有执行，函数内部根本就不知道是否要对 <code>assignEvents</code> 的局部变量进行访问和操作，所以只能先把 <code>assignEvents</code> 的 <code>Activation Object</code>(激活对象) 作用域对象保存起来，当闭包函数执行时，如果需要访问 <code>assignEvents</code> 的局部变量，那么再去作用域链中查找。</p>
<p>也正是因为这种引用，造成了一个<strong>副作用</strong>。通常，当执行期上下文被销毁时，函数的激活对象也就被销毁了。当有闭包引用时，激活对象就不会被销毁，因为他仍然被引用。这意味着闭包比非隔离的函数需要更多的内存。</p>
<p><strong>闭包函数</strong>执行时创建了自己的 <code>Execution Context</code>（执行期上下文），其作用域链使用了 <code>[[scope]]</code> 属性，其引用了 <code>assignEvents</code> 函数的 <code>Activation Object</code>(激活对象) 和 全局对象。然后为闭包本身创建一个新的 <code>Activation Object</code>(激活对象)。 所以在闭包函数的执行期上下文的作用域链中保存了自己的 <code>Activation Object</code>(激活对象)，外层函数 <code>assignEvents</code> <code>Execution Context</code>（执行期上下文）的 <code>Activation Object</code>(激活对象)，以及 <code>Global Object</code>(全局对象)，如图：</p>
<p><img src="closure2.png" alt="closure2.png"></p>
<h2 id="3-提升（hoisting）"><a href="#3-提升（hoisting）" class="headerlink" title="3.提升（hoisting）"></a>3.提升（hoisting）</h2><p><strong>提升有变量提升和函数提升之分, 先提升函数声明, 在提升变量声明</strong>.</p>
<p><a href="https://www.css88.com/archives/7924" target="_blank" rel="noopener">JavaScript 中的 Hoisting (变量提升和函数声明提升)</a></p>
<p><strong>规则</strong>:</p>
<ol>
<li>扫描当前<strong>函数声明</strong>中的代码。<strong>函数表达式和箭头函数</strong>会被跳过。对于每个被发现的函数，<strong>都会创建一个新的函数</strong>，并使用函数名称将其绑定到环境中。如果标识符的名称已经存在，那么它的值就会被<strong>覆盖</strong>。</li>
<li>然后扫描当前环境的<strong>变量</strong>。找到使用 <code>var</code> 定义的变量和放置在其他函数之外的变量，并注册一个标识符，其值初始化为 <code>undefined</code> 。<strong>如果存在标识符，则该值将保持不变(就是忽略后面的生命, 反正都是<code>undefined</code>)</strong>。</li>
</ol>
<blockquote>
<p>注意：用 <code>let</code> 和 <code>const</code> 定义的是块变量，与 <code>var</code> 的处理稍微不同, <strong>不能重复定义</strong>。</p>
</blockquote>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/4" target="_blank" rel="noopener">JavaScript深入之执行上下文栈</a></p>
<blockquote>
<p>javascript 函数声明和变量声明会被解释器提升到最顶端，但是<strong>变量的初始化不会被提升</strong>  因为<code>var foo = &quot;变量&quot;</code>; <code>foo</code>被初始化了<br>其实主要是<code>var foo</code>;并不会覆盖之前的变量</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">"function"</span>;</span><br><span class="line"><span class="keyword">var</span> foo;<span class="comment">//它只是定义，全不会覆盖变量</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);<span class="comment">//返回 function</span></span><br></pre></td></tr></table></figure>
<p><strong>例子</strong>: 如果先提升函数声明,在提升变量声明, 那么结果怎么不打印<code>变量</code>,而是函数. (<strong>注意只是提升声明而已, 不是提升变量的初始化</strong>)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);   <span class="comment">// 这边是执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"函数声明"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">"变量"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>解答</strong>:</p>
<p>函数提升优先级比变量提升要高，<strong>且不会被变量声明覆盖</strong>，<strong>但是会被变量赋值覆盖</strong>，所以你上面的代码实际上是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;             <span class="comment">// 函数声明提前了</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"函数声明"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo;                    <span class="comment">// 然后是变量声明再提前</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);           <span class="comment">// 执行在这里哦, 执行的语句不会提, 还是在原来的位置</span></span><br><span class="line">foo = <span class="string">"变量"</span>;</span><br></pre></td></tr></table></figure>
<p>在最后再加上打印就能看到函数已经被覆盖了。<br>注：初始化变量不会把值也提上上去，只会提升变量的声明。(<strong>只是提升声明, 运行还是在那行运行的</strong>)</p>
<p><strong>再比如</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 ???  1</span></span><br></pre></td></tr></table></figure>
<p>提升后的结果是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value;</span><br><span class="line">value = <span class="number">1</span>;  <span class="comment">// 注意这里条赋值语句之前都是提升, 然后这行开始运行, 赋值了,</span></span><br><span class="line"></span><br><span class="line">bar();      <span class="comment">// 这边的bar()是执行前面声明过的函数, 运行前value的值就是1了, 所以最后打印1</span></span><br></pre></td></tr></table></figure>
<p>这里注意作用域链</p>
<h3 id="3-1-变量提升（variable-hoisting）"><a href="#3-1-变量提升（variable-hoisting）" class="headerlink" title="3.1 变量提升（variable hoisting）"></a>3.1 变量提升（variable hoisting）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"foo"</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line">     <span class="keyword">var</span> name=<span class="string">"bar"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> fName();</span><br><span class="line"> <span class="built_in">console</span>.log(name); <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<p>输出结果结果分别是 <code>undefined</code> 和 <code>foo</code>。为什么是<code>undefined</code>？</p>
<p>那我们先来分析一下代码 函数<code>fName()</code>的作用域链： 自己的变量对象 ——-&gt; 全局变量对象。解析器在函数执行环境中发现变量 <code>name</code>，因此不会再向全局环境的变量对象中寻找。但是大家要注意的是，解析器在解析第3句代码时，<strong>还不知道变量<code>name</code>的值</strong>，也就是说只知道有变量<code>name</code>，但是不知道它具体的值（因为还没有执行第4句代码），因此输出是 <code>undefined</code>，第7行输出<code>foo</code>大家应该都理解把（作用域问题）。所以上述代码可以写成下面的形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"foo"</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> name;</span><br><span class="line">     <span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line">     name=<span class="string">"bar"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> fName();</span><br><span class="line"> <span class="built_in">console</span>.log(name); <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<p>这个现象就是<strong>变量提升</strong>！</p>
<p>变量提升，就是把变量提升到函数的顶部，需要注意的是，<strong>变量提升只是提升变量的声明，不会把变量的值也提升上来</strong></p>
<h3 id="3-2-函数提升"><a href="#3-2-函数提升" class="headerlink" title="3.2 函数提升"></a>3.2 函数提升</h3><p>函数提升就是把函数提升到前面。</p>
<p>在<code>JavaScript</code>中函数的创建方式有三种：函数声明（静态的）、函数表达式（函数字面量）、函数构造法（动态的，匿名的）。</p>
<p>函数声明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n1,n2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//function body;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数表达式的形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params">n1,n2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//function body;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数构造法构造函数的形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func2 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"para1"</span>,<span class="string">"para2"</span>,...,<span class="string">"function body"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="总结下"><a href="#总结下" class="headerlink" title="总结下"></a>总结下</h2><a href="/2019/02/12/再谈js作用域/" title="再谈js作用域">再谈js作用域</a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/buchongming/p/5858026.html" target="_blank" rel="noopener">JavaScript中作用域和作用域链的简单理解（变量提升）</a><br><a href="https://blog.csdn.net/qq_27626333/article/details/78463565" target="_blank" rel="noopener">JavaScript作用域、上下文、执行期上下文、作用域链、闭包 666</a><br><a href="https://www.css88.com/archives/7300" target="_blank" rel="noopener">实例分析 JavaScript 作用域, 同时讲了形参, 实参, 同名局部变量 666</a></p>
<p>4个一起看<br><a href="https://www.css88.com/archives/7262" target="_blank" rel="noopener">JavaScript 核心概念之作用域和闭包 666</a><br><a href="https://www.css88.com/archives/7255" target="_blank" rel="noopener">深入理解JavaScript中的作用域和上下文 666</a><br><a href="https://www.css88.com/archives/7300" target="_blank" rel="noopener">实例分析 JavaScript 作用域</a><br><a href="https://www.css88.com/archives/7924" target="_blank" rel="noopener">JavaScript 中的 Hoisting (变量提升和函数声明提升) 666</a></p>
<p><a href="https://www.jianshu.com/p/21a16d44f150" target="_blank" rel="noopener">前端基础进阶（四）：详细图解作用域链与闭包</a><br><a href="https://www.jianshu.com/p/cd3fee40ef59" target="_blank" rel="noopener">前端基础进阶系列 贼6</a></p>
<p><a href="http://www.menvscode.com/detail/599fd4673bb2bd430d7a7e01" target="_blank" rel="noopener">《高性能JavaScript》第2章</a><br><a href="https://juejin.im/entry/5aca253e5188255c5668b7bb" target="_blank" rel="noopener">闭包，是真的美 666</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/04/react-router/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/react-router/" itemprop="url">react-router</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-04T09:08:00+08:00">2019-01-04</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><a href="/2018/12/16/react-router-v4/" title="react-router-v4">react-router-v4</a>
<p><a href="https://github.com/reactjs/react-router-tutorial" target="_blank" rel="noopener">React Router Tutorial</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/04/2019-TODO-list/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/2019-TODO-list/" itemprop="url">2019-TODO-list</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-04T08:29:57+08:00">2019-01-04</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/年计划/" itemprop="url" rel="index"><span itemprop="name">年计划</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2019-TODO-list"><a href="#2019-TODO-list" class="headerlink" title="2019-TODO-list"></a>2019-TODO-list</h1><p>收集了一些 github、掘金、segmentfault 等平台文章或小册中的内容，完成一些整理并总结!</p>
<h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><h3 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h3><p>每日英语听力</p>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h3><p><a href="https://github.com/hanzichi/leetcode" target="_blank" rel="noopener">LeetCode solutions with JavaScript</a></p>
<h2 id="打字"><a href="#打字" class="headerlink" title="打字"></a>打字</h2><p>typingclub</p>
<h2 id="JS-篇"><a href="#JS-篇" class="headerlink" title="JS 篇"></a>JS 篇</h2><h3 id="导引"><a href="#导引" class="headerlink" title="导引"></a>导引</h3><p><a href="https://zhuanlan.zhihu.com/p/55357377" target="_blank" rel="noopener">给 2019 前端的 5 个建议</a></p>
<h3 id="专题"><a href="#专题" class="headerlink" title="专题"></a>专题</h3><p><a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">预计写四个系列：JavaScript 深入系列、JavaScript 专题系列、ES6 系列、React 系列。666</a><br><a href="https://www.jianshu.com/p/cd3fee40ef59" target="_blank" rel="noopener">前端基础进阶系列 666</a><br><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="noopener">深入理解 JavaScript 系列 666666</a><br><a href="https://www.jianshu.com/p/dd35aa1472b3" target="_blank" rel="noopener">给前端好文多一首歌的时间（九）</a><br><a href="https://segmentfault.com/a/1190000017072371" target="_blank" rel="noopener">程序员练级攻略（2018）：前端基础和底层原理</a><br><a href="https://segmentfault.com/a/1190000012646488" target="_blank" rel="noopener">前端基础进阶目录</a></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><a href="https://www.cnblogs.com/c2016c/articles/9328725.html" target="_blank" rel="noopener">JS 基本数据类型和引用数据类型的区别及深浅拷贝</a><br><a href="https://www.jianshu.com/p/eab46f1af003" target="_blank" rel="noopener">的第七种数据类型</a><br><a href="https://www.cnblogs.com/Trr-984688199/p/6180040.html" target="_blank" rel="noopener">JS 中 typeof 与 instanceof 的区别</a><br><a href="https://www.cnblogs.com/wzybnzy/p/7232618.html?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">typeof null 为什么等于 object?</a><br><a href="https://www.cnblogs.com/youhong/p/6209054.html" target="_blank" rel="noopener">为什么用 Object.prototype.toString.call(obj)检测对象类型?</a><br><a href="https://blog.csdn.net/gnail_oug/article/details/53135603" target="_blank" rel="noopener">JS 显性数据类型转换和隐性数据类型转换</a><br><a href="https://segmentfault.com/a/1190000007434923" target="_blank" rel="noopener">理解 Object.defineProperty 的作用</a></p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><a href="https://segmentfault.com/a/1190000011194676#articleHeader13" target="_blank" rel="noopener">深入理解 js this 绑定 ( 无需死记硬背，尾部有总结和面试题解析 )</a><br><a href="https://www.jianshu.com/p/d647aa6d1ae6" target="_blank" rel="noopener">前端基础进阶（五）：全方位解读 this</a><br><a href="https://juejin.im/post/59bfe84351882531b730bac2" target="_blank" rel="noopener">this、apply、call、bind</a><br><a href="https://www.jianshu.com/p/00dc4ad9b83f" target="_blank" rel="noopener">JavaScript 中的 call、apply、bind 深入理解</a></p>
<h3 id="作用域链与闭包"><a href="#作用域链与闭包" class="headerlink" title="作用域链与闭包"></a>作用域链与闭包</h3><p><a href="https://cnodejs.org/topic/59662f6dbda29e0f7480235b" target="_blank" rel="noopener">我所认识的 JavaScript 作用域链和原型链 666</a><br><a href="https://github.com/MrErHu/blog/issues/11" target="_blank" rel="noopener">浅谈 JavaScript 闭包</a><br><a href="https://www.cnblogs.com/buchongming/p/5858026.html" target="_blank" rel="noopener">JavaScript 中作用域和作用域链的简单理解（变量提升） nonono</a><br><a href="https://blog.csdn.net/qq_27626333/article/details/78463565" target="_blank" rel="noopener">JavaScript 作用域、上下文、执行期上下文、作用域链、闭包 666</a></p>
<p>4 连套<br><a href="https://www.css88.com/archives/7262" target="_blank" rel="noopener">JavaScript 核心概念之作用域和闭包 666</a><br><a href="https://www.css88.com/archives/7255" target="_blank" rel="noopener">深入理解 JavaScript 中的作用域和上下文 666</a><br><a href="https://www.css88.com/archives/7300" target="_blank" rel="noopener">实例分析 JavaScript 作用域</a><br><a href="https://www.css88.com/archives/7924" target="_blank" rel="noopener">JavaScript 中的 Hoisting (变量提升和函数声明提升) 666</a></p>
<p><a href="https://www.jianshu.com/p/21a16d44f150" target="_blank" rel="noopener">前端基础进阶（四）：详细图解作用域链与闭包 666 还带基础进阶的</a><br><a href="https://juejin.im/post/58832fe72f301e00697b672d" target="_blank" rel="noopener">JavaScript 闭包入门（译文）</a><br><a href="https://juejin.im/post/590159d8a22b9d0065c2d918" target="_blank" rel="noopener">JavaScript 深入之闭包</a><br><a href="https://segmentfault.com/a/1190000006875662" target="_blank" rel="noopener">JavaScript 闭包</a><br><a href="https://juejin.im/post/5979b5755188253df1067397" target="_blank" rel="noopener">浏览器是怎么看闭包的。</a></p>
<h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><p><a href="https://github.com/dreamapplehappy/blog/blob/master/2018/12/30/README.md" target="_blank" rel="noopener">JavaScript 原型与继承的秘密</a><br><a href="https://juejin.im/post/599d69fc6fb9a0248f4a7b31" target="_blank" rel="noopener">白话原型和原型链</a><br><a href="https://www.jianshu.com/p/15ac7393bc1f" target="_blank" rel="noopener">前端基础进阶（九）：详解面向对象、构造函数、原型与原型链</a><br><a href="https://www.jianshu.com/p/dee9f8b14771" target="_blank" rel="noopener">最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一）</a><br><a href="https://www.jianshu.com/p/652991a67186" target="_blank" rel="noopener">最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二）</a><br><a href="https://www.jianshu.com/p/a4e1e7b6f4f8" target="_blank" rel="noopener">最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）</a></p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><a href="https://segmentfault.com/a/1190000016848192" target="_blank" rel="noopener">关于 ES6 中 Promise 的面试题</a></p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><a href="https://segmentfault.com/a/1190000017224799" target="_blank" rel="noopener">8 张图让你一步步看清 async/await 和 promise 的执行顺序</a><br><a href="https://segmentfault.com/a/1190000007535316" target="_blank" rel="noopener">理解 JavaScript 的 async/await</a><br><a href="/2018/11/25/JavaScript-的-async-await/" title="JavaScript-的-async-await">JavaScript-的-async-await</a></p>
<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p><a href="https://segmentfault.com/a/1190000017742993" target="_blank" rel="noopener">深度介绍：也许你对 Fetch 了解得不是那么多</a></p>
<h3 id="JS-执行底层"><a href="#JS-执行底层" class="headerlink" title="JS 执行底层"></a>JS 执行底层</h3><p><a href="https://www.jianshu.com/p/996671d4dcc4" target="_blank" rel="noopener">前端基础进阶（一）：内存空间详细图解</a><br><a href="https://www.jianshu.com/p/a6d37c77e8db" target="_blank" rel="noopener">前端基础进阶（二）：执行上下文详细图解</a><br><a href="https://www.jianshu.com/p/12b9f73c5a4f" target="_blank" rel="noopener">前端基础进阶（十二）：深入核心，详解事件循环机制</a><br><a href="https://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">js 中的事件委托或是事件代理详解</a></p>
<h3 id="ES6-ES7"><a href="#ES6-ES7" class="headerlink" title="ES6/ES7.."></a>ES6/ES7..</h3><p><a href="https://juejin.im/post/5b0238f66fb9a07aca7a74ba" target="_blank" rel="noopener">ES6 系列之 let 和 const</a><br><a href="https://www.jianshu.com/p/cfb0893c34f1" target="_blank" rel="noopener">前端基础进阶（十四）：es6 常用基础合集</a><br><a href="https://juejin.im/post/5b14d0b4f265da6e60393680" target="_blank" rel="noopener">ES6 系列之箭头函数</a><br><a href="https://juejin.im/post/59327a58a0bb9f0058c8caae" target="_blank" rel="noopener">JavaScript 初学者必看“箭头函数”</a><br><a href="https://juejin.im/post/5b32f552f265da59991155f0" target="_blank" rel="noopener">Promise 之你看得懂的 Promise</a><br><a href="https://juejin.im/post/5bc5e114e51d450e632277aa" target="_blank" rel="noopener">ES6 系列之我们来聊聊 Promise</a><br><a href="https://juejin.im/post/5aa7868b6fb9a028dd4de672" target="_blank" rel="noopener">Promise 原理讲解 &amp;&amp; 实现一个 Promise 对象 (遵循 Promise/A+规范)</a><br><a href="https://www.jianshu.com/p/1016160e91fe" target="_blank" rel="noopener">web 前端-js 继承的理解</a><br><a href="https://juejin.im/post/59ac1c4ef265da248e75892b" target="_blank" rel="noopener">js 深拷贝 vs 浅拷贝</a><br><a href="https://juejin.im/post/5bc1ae9be51d450e8b140b0c" target="_blank" rel="noopener">深拷贝的终极探索（90%的人都不知道）</a><br><a href="https://juejin.im/post/596e142d5188254b532ce2da" target="_blank" rel="noopener">理解 async/await</a><br><a href="https://juejin.im/post/5bcf3e3f6fb9a05cd53b3e3d" target="_blank" rel="noopener">ES6 系列之我们来聊聊 Async</a><br><a href="https://juejin.im/post/5c6234f16fb9a049a81fcca5" target="_blank" rel="noopener">近一万字的 ES6 语法知识点补充</a></p>
<p>除此之外强烈推荐<a href="https://juejin.im/user/58e4b9b261ff4b006b3227f4/posts" target="_blank" rel="noopener">冴羽老师的 ES6 系列</a>)文章，深入骨髓的理解 ES6 中的核心</p>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p><a href="https://jkchao.github.io/typescript-book-chinese/" target="_blank" rel="noopener">深入理解 TypeScript</a><br><a href="https://juejin.im/post/59c46bc86fb9a00a4636f939" target="_blank" rel="noopener">TypeScript 体系调研报告</a><br><a href="https://juejin.im/post/5a9c004a6fb9a028b92c9e91" target="_blank" rel="noopener">TypeScript 实践</a></p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p><a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">Node 入门</a><br><a href="https://juejin.im/post/5a8e44ea5188257a8929bf9b" target="_blank" rel="noopener">谈谈 Node 中的常见概念</a><br><a href="https://github.com/xitu/gold-miner/blob/master/TODO/introduction-to-node-express.md" target="_blank" rel="noopener">Node &amp; Express 入门指南</a><br><a href="https://juejin.im/post/5902973eb123db3ee46a0107" target="_blank" rel="noopener">Express 使用手记：核心入门</a><br><a href="https://juejin.im/post/5ba48fc4e51d450e704277fa" target="_blank" rel="noopener">node 进阶——之事无巨细手写 koa 源码</a><br><a href="https://juejin.im/post/5914fdce44d904006c44dfac" target="_blank" rel="noopener">带你走进 koa2 的世界（koa2 源码浅谈）</a><br><a href="https://juejin.im/post/59f6ec44f265da43252895be" target="_blank" rel="noopener">fly.js—Node 下增强的 API</a></p>
<h2 id="HTML-CSS-篇"><a href="#HTML-CSS-篇" class="headerlink" title="HTML/CSS 篇"></a>HTML/CSS 篇</h2><p><a href="https://juejin.im/post/599970f4518825243a78b9d5" target="_blank" rel="noopener">CSS 常见布局方式</a><br><a href="https://segmentfault.com/a/1190000010989110" target="_blank" rel="noopener">【整理】CSS 布局方案</a><br><a href="https://segmentfault.com/a/1190000006242814" target="_blank" rel="noopener">CSS 查漏补缺</a><br><a href="https://juejin.im/post/5909db2fda2f60005d2093db" target="_blank" rel="noopener">[布局概念] 关于 CSS-BFC 深入理解</a><br><a href="https://juejin.im/post/5a6c5881518825733201daf7" target="_blank" rel="noopener">[译]这些 CSS 命名规范将省下你大把调试时间</a><br><a href="https://juejin.im/post/5a954add6fb9a06348538c0d" target="_blank" rel="noopener">CSS 知识总结</a><br><a href="https://juejin.im/post/592d4a5b0ce463006b43b6da" target="_blank" rel="noopener">前端开发规范：命名规范、html 规范、css 规范、js 规范</a></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><a href="HTTP 状态码（HTTP Status Code）">HTTP 状态码（HTTP Status Code）</a></p>
<p><a href="https://juejin.im/post/5872309261ff4b005c4580d4" target="_blank" rel="noopener">面试 — 网络 HTTP</a><br><a href="https://juejin.im/post/58ddb636ac502e0063992865" target="_blank" rel="noopener">HTTP 最强资料大全</a><br><a href="https://juejin.im/post/5a757d2f5188254e5c6c404a" target="_blank" rel="noopener">我知道的 HTTP 请求</a></p>
<h2 id="性能-amp-优化篇"><a href="#性能-amp-优化篇" class="headerlink" title="性能&amp;优化篇"></a>性能&amp;优化篇</h2><p><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/" target="_blank" rel="noopener">深入浅出浏览器渲染原理</a><br><a href="https://juejin.im/post/5a9923e9518825558251c96a" target="_blank" rel="noopener">浏览器的回流与重绘 (Reflow &amp; Repaint)</a><br><a href="https://segmentfault.com/a/1190000008377508" target="_blank" rel="noopener">浏览器缓存</a><br><a href="https://zcfy.cc/article/optimising-the-front-end-for-the-browser-hacker-noon-2847.html" target="_blank" rel="noopener">浏览器前端优化</a><br><a href="https://juejin.im/post/5ac45882518825558723c4fd" target="_blank" rel="noopener">浏览器渲染引擎</a><br><a href="https://zhuanlan.zhihu.com/p/22718822" target="_blank" rel="noopener">JavaScript 浏览器事件解析</a><br><a href="http://www.cnblogs.com/chuaWeb/p/PerformanceMonitoring.html" target="_blank" rel="noopener">前端性能——监控起步</a><br><a href="https://juejin.im/post/5b89274de51d4538c17e0f7d" target="_blank" rel="noopener">javascript 性能优化</a><br><a href="https://juejin.im/post/59da456951882525ed2b706d" target="_blank" rel="noopener">浏览器性能优化-渲染性能</a><br><a href="https://juejin.im/post/59d489156fb9a00a571d6509" target="_blank" rel="noopener">浏览器渲染过程与性能优化</a><br><a href="https://juejin.im/post/5a461f006fb9a0450408358f" target="_blank" rel="noopener">现代浏览器性能优化-CSS 篇</a><br><a href="https://juejin.im/post/5b721656f265da28140e53ba" target="_blank" rel="noopener">浏览器工作原理及 web 性能优化</a></p>
<h2 id="Webpack-篇"><a href="#Webpack-篇" class="headerlink" title="Webpack 篇"></a>Webpack 篇</h2><p><a href="https://juejin.im/post/5aa3d2056fb9a028c36868aa" target="_blank" rel="noopener">webpack 详解</a><br><a href="https://juejin.im/post/5ac42d5c6fb9a028b617b851" target="_blank" rel="noopener">Webpack4 优化之路</a><br><a href="https://juejin.im/post/5ab7c222f265da237f1e4434" target="_blank" rel="noopener">webpack4 之高级篇</a><br><a href="https://juejin.im/post/5adea0106fb9a07a9d6ff6de" target="_blank" rel="noopener">webpack4-用之初体验，一起敲它十一遍</a><br><a href="https://juejin.im/post/5c25b76ef265da614b120ed0" target="_blank" rel="noopener">📚 免费的渐进式教程：Webpack4 的 16 篇讲解和 16 份代码</a><br><a href="https://juejin.im/post/5b4609f5e51d4519596b66a7" target="_blank" rel="noopener">手写一个 webpack4.0 配置</a></p>
<h2 id="React-篇"><a href="#React-篇" class="headerlink" title="React 篇"></a>React 篇</h2><p><a href="https://juejin.im/post/5c1f01fef265da61587723f4" target="_blank" rel="noopener">五星推荐的系列文章清单</a><br><a href="https://www.cnblogs.com/huzidaha/p/6603658.html" target="_blank" rel="noopener">胡子大哈 React.js 小书</a><br><a href="https://juejin.im/post/5b07caf16fb9a07aa83f2977" target="_blank" rel="noopener">TypeScript 2.8 下的终极 React 组件模式</a></p>
<h2 id="面试篇"><a href="#面试篇" class="headerlink" title="面试篇"></a>面试篇</h2><p><a href="https://www.cnblogs.com/DCL1314/p/7903102.html" target="_blank" rel="noopener">HTML&amp;&amp;css 面试题</a><br><a href="https://zhuanlan.zhihu.com/p/25407758" target="_blank" rel="noopener">Excuse me？这个前端面试在搞事！</a><br><a href="https://juejin.im/post/58cf180b0ce4630057d6727c" target="_blank" rel="noopener">80% 应聘者都不及格的 JS 面试题</a><br><a href="https://juejin.im/post/5bf5610be51d452a1353b08d" target="_blank" rel="noopener">2019 年前端面试都聊啥？一起来看看</a><br><a href="https://juejin.im/post/5bbaa549e51d450e827b6b13" target="_blank" rel="noopener">一篇文章搞定前端面试</a><br><a href="https://juejin.im/post/5bbc54a2e51d450e5a7445b4" target="_blank" rel="noopener">如何轻松拿到淘宝前端 offer | 掘金技术征文</a><br><a href="https://juejin.im/post/5c19c1b6e51d451d1e06c163" target="_blank" rel="noopener">腾讯前端面试篇（一）</a><br><a href="https://juejin.im/post/5c1869ab6fb9a049f154207a" target="_blank" rel="noopener">腾讯前端面试篇（二）</a><br><a href="https://30secondsofinterviews.org/" target="_blank" rel="noopener">30secondsofinterviews</a></p>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h3><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><h3 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP"></a>HTTP</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/js事件处理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/js事件处理/" itemprop="url">js事件处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-28T17:35:51+08:00">2018-12-28</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="js事件处理"><a href="#js事件处理" class="headerlink" title="js事件处理"></a>js事件处理</h1><p>客户端js程序采用了异步事件驱动编程模型(有介绍, 搞个链接). 在这种程序设计风格下, 当文档, 浏览器, 元素或<strong>与之相关的对象</strong>发生某些有趣的事情时, web浏览器就会产生事件(<code>event</code>).</p>
<p>例如: 当web浏览器加载完文档, 用户把鼠标指针移到超链接上或敲击键盘时, web浏览器都会产生事件. 如果js应用程序关注特定类型的事件, 那么他可以注册当这类事件发生时要调用的一个或多个函数.</p>
<blockquote>
<p>注意: 这种风格并不止应用于web编程, 所有使用图形用户界面的应用程序都采用了它, 他们静待某些事情发生(即, 它们等待事件发生), 然后它们响应.</p>
</blockquote>
<p>事件就是web浏览器通知应用程序发生了什么事情. 事件不是js对象, 不会出现在程序源代码中. 当然, <strong>会有一些事件相关的对象出现在源代码中</strong>, 他们需要技术说明.</p>
<p><strong>事件类型(<code>event type</code>)</strong>是一个用来说明发生什么类型事件的字符串.<br>例如: <code>mousemove</code>表示用户鼠标移动, <code>keydown</code>表示键盘上某个键被按下, 而<code>load</code>表示文档(或某个其他资源)从网络上加载完毕.<br>由于事件类型只是一个字符串, 因此实际上<strong>有时会称之为事件名字</strong>(<code>event name</code>), 我们用这个名字来标识所谈论的特定类型的事件.</p>
<p><strong>事件目标(<code>event target</code>)</strong>是发生的<strong>事件</strong>或与之相关的<strong>对象</strong>.当将事件时, 我们必须同时指明类型(<code>type, name</code>)和目标(<code>target</code>).</p>
<p>例如: <code>window</code>上的<code>load</code>事件或<code>&lt;button&gt;</code>元素的<code>click</code>事件. 在客户端的js应用程序中, <code>Window</code>, <code>Document</code>和<code>Element</code>对象是最常见的事件目标, 但某些事件是由其他类型的对象触发.比如<code>XMLHttpRequest</code>对象触发的<code>readystatechange</code>事件.</p>
<p><strong>事件处理程序</strong><code>event handle</code>或<strong>事件监听程序</strong>(<code>event listener</code>)是处理或响应事件的函数. 应用程序通过指明事件类型<code>type</code>和事件目标<code>target</code>, 在web浏览器中注册他们的事件处理程序<code>handle, listener</code>. 当在特定的目标上发生特定类型的事件时, 浏览器会调用对应的处理程序. 当对象上注册的事件处理程序被调用时, 我们有时会说浏览器”触发”(<code>fire, trigger</code>)和”派发”(<code>dispatch</code>)了事件. 有很多注册事件处理程序的方法.</p>
<p><strong>事件对象(<code>event object</code>)</strong>是与特定事件相关且包含有关该<strong>事件详细信息的对象</strong>. 事件对象<code>object</code><strong>作为参数</strong>传递给事件处理程序函数<code>handle</code>. 所有的事件对象<code>object</code>都有用来指定事件类型的<code>type</code>属性和指定事件目标的<code>target</code>属性. 每个事件类型都为其相关事件对象<code>object</code>定义一组属性.<br>例如: 鼠标事件的相关对象会包含鼠标指针的坐标, 而键盘事件的相关对象会包含按下的键和辅助键的详细信息. 许多事件类型仅定义了像<code>type</code>和<code>target</code>这样少量的标准属性, 就无法获取许多其他有用的信息.</p>
<p><strong>事件传播(<code>event propagation</code>)</strong>是<strong>浏览器决定哪个对象触</strong>发其事件处理程序的过程. 对于单个对象的特定事件(比如<code>Window</code>对象的<code>load</code>事件), 必须是不能传播的. 当文档元素上发生某个类型的事件时, 然而, 他们会在文档树上向上传播或”冒泡(<code>bubble</code>)”, 如果用户移动鼠标指针到超链接上, 在定义这个链接的<code>&lt;a&gt;</code>元素上首先会触发<code>mousemove</code>事件, 然后是在这个容器元素上触发这个时间, 也许是<code>&lt;p&gt;</code>元素,<code>&lt;div&gt;</code>元素或<code>Document</code>对象本身. 有时, 在<code>Document</code>或其他容器元素上注册单个事件处理程序比在每个独立的目标元素上都注册程序要更方便. 事件处理程序能通过调用方法或设置事件对象属性来阻止事件传播, 这样它就能停止冒泡且将无法在容器元素上触发处理程序.</p>
<p>事件传播的另外一种形式称之为<strong>事件捕获(<code>event capturing</code>)</strong>, 在容器元素上注册的特定处理程序有机会在事件传播倒真实目标之前拦截(或”捕获”)它., 但是,当处理鼠标拖放事件时, 捕获或”夺取”鼠标时间的能力是必须的.</p>
<p>一些事件有与之相关的默认操作. 例如: 当超链接上发生<code>click</code>事件时, 浏览器的默认操作是按照链接加载新页面. 事件处理程序可以通过返回一个适当的值, 调用时间对象的某个方法或设置事件对象的某个属性来阻止默认操作的发生. 这有时称为”取消”事件.</p>
<h2 id="17-1事件类型"><a href="#17-1事件类型" class="headerlink" title="17.1事件类型"></a>17.1事件类型</h2><p>web初期,客户端程序员只能使用很少部分事件,<code>load</code>, <code>click</code>, <code>mouseover</code>, 现在有新事件,3个来源:</p>
<ul>
<li>3级DOM事件(<code>DOM Level Events</code>)规范,经过长期的停滞之后, 在W3Cde主持下又开始焕发生机.</li>
<li>HTML5规范及相关衍生规范的大量新API定义了新事件, 比如历史管理, 拖放, 跨文档通信,以及视频和音频的播放.</li>
<li>基于触摸和支持JavaScript的移动设备的出现, 他们需要定义新的触摸和手势事件类型.</li>
</ul>
<p><strong>注意</strong>:许多新事件类型尚未广泛实现, 定义它们的标准也依旧处于草案阶段.</p>
<p>事件分类: 大致先分6类吧</p>
<p><strong>1依赖与设备的输入事件</strong>:<br>有些事件和特定输入设备直接相关, 比如鼠标和键盘. 包括诸如<code>mousedown</code>, <code>mousemove</code>,<code>mouseup</code>,<code>keypress</code>,<code>keyup</code>这样传统事件类型, 也包括像<code>touchmove</code>,<code>getsturcchange</code>这样新的触摸事件类型</p>
<p><strong>2独立于设备的输入事件</strong>:<br>有些输入事件没有直接相关的特定输入设备. 比如<code>click</code>事件表示激活了链接, 按钮或其他文档元素, 这通常是通过鼠标单击实现, 但也能通过键盘或触控感知设备上的手势来实现. 尚未广泛实现的<code>textinput</code>事件就是一个独立与设备的输入事件, 他既能取代按键事件并支持键盘输入, 也可以取代剪切和粘贴与手写识别的事件.</p>
<p><strong>3用户界面事件</strong>:<br>用户界面事件是比较高级的事件, 通常出现在定义web应用用户界面的HTML表单元素上. 包括文本输入域获取键盘焦点的<code>focus</code>事件, 用户改变表单元素显示值的<code>change</code>事件和用户单击表单中的提交按钮的<code>submit</code>事件</p>
<p><strong>4状态变化事件</strong>:<br>有些事件不是由用户活动而是由网络或浏览器活动触发, 用来表示某种生命周期或相关状态的变化. 当文档完全加载时, 在Window对象上会发生<code>load</code>事件, 这可能是这类事件中最常用的, <code>DOMContentLoaded</code>事件与此类似, HTML5历史管理机制会触发<code>popstate</code>事件来响应浏览器的后退按钮. HTML5离线web应用API包括<code>online</code>和<code>offline</code>事件. 当向服务器请求的数据准备就绪事, 如何利用<code>readystatechange</code>事件得到通知, 类似的, 用于读取用户选择本地文件中的新API使用像<code>loadstate</code>, <code>progress</code>和<code>loadend</code>事件来实现I/O过程的异步通知.</p>
<p><strong>5特定API事件</strong>:<br>HTML5及相关规范定义的大量web API都有自己的事件类型. 拖放API定义了诸如<code>dragstart</code>, <code>dragenter</code>, <code>dragover</code>和<code>drop</code>事件, 应用程序想自定义拖放源(drag source)或拖放目标(drop target)就必须处理这些相关事件. HTML5的<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>元素定义一长串像<code>waiting</code>, <code>playibg</code>, <code>seeking</code>和<code>volumechange</code>等相关事件, 这些事件通常仅用于web应用, 这些web应用希望为视频和音频的播放定义自定义控件.</p>
<p><strong>6计数器和错误处理程序</strong>:<br>在第14章中介绍过计时器(<code>timer</code>)和错误处理程序(<code>error handler</code>)属于客户端JavaScript异步编程模型的部分, 并有相似的事件.</p>
<h3 id="17-1-1传统事件类型"><a href="#17-1-1传统事件类型" class="headerlink" title="17.1.1传统事件类型"></a>17.1.1传统事件类型</h3><p>处理鼠标, 键盘, HTML表单和window对象的事件都是web应用中最常用的, 他们已经存在很长的时间并得到了广泛的支持.</p>
<h4 id="1-表单事件"><a href="#1-表单事件" class="headerlink" title="1.表单事件"></a>1.表单事件</h4><p>回到web和JavaScript的早期, 表单和超链接都是网页中<strong>最早支持脚本的元素</strong>. 这就意味着表单事件是所有事件类型中<strong>最稳定且得到良好支持</strong>的那部分.</p>
<ul>
<li>当提交表单和重置表单时, <code>&lt;form&gt;</code>元素会分别触发<code>submit</code>和<code>reset</code>事件.</li>
<li>当用户和类按钮表单元素(包括单选按钮和复选框)交互时, 他们会发生<code>click</code>事件.</li>
<li>当用户通过输入文字, 选择选项或选择复选框来改变相应表单元素的状态时, 这些通常维护某种状态的表单元素会触发<code>change</code>事件.</li>
<li>对于文本输入域, 只有用户和表单元素完成交互并通过<code>Tab</code>键或单击的方式移动焦点到其他元素上时才会触发<code>change</code>事件.响应通过键盘改变焦点的表单元素在得到和失去焦点时会分别触发<code>focus</code>和<code>blur</code>事件</li>
</ul>
<p><strong>15.9.3</strong>节涵盖了所有表单相关事件的详细信息, 不过还有一些进一步说明. 通过事件处理程序能取消<code>submit</code>和<code>reset</code>事件的默认操作, 某些<code>click</code>事件也是如此. <code>focus</code>和<code>blur</code>事件不会冒泡, 但其他所有表单事件都可以. IE定义了<code>focusin</code>和<code>focusout</code>事件可以冒泡, 他们可以用于替代<code>focus</code>和<code>blur</code>事件. jQuery库为不持之<code>focusin</code>和<code>focusout</code>事件的浏览器模拟了这两个事件, 同时3级DOM事件规范也正在标准化他们.</p>
<p>最后注意, 无论用户何时输入文字(通过键盘或剪切和粘贴)到<code>&lt;textarea&gt;</code>和其他文本输入表单元素, 除IE外的浏览器都会触发<code>input</code>事件. 不像<code>change</code>事件, 每次文字插入都会触发<code>input</code>事件. 遗憾的是, <code>input</code>事件的事件对象没有指定输入文本的内容 (稍后介绍的<code>textinput</code>事件将会成为这个事件的有用替代方案)</p>
<h4 id="2-Window事件"><a href="#2-Window事件" class="headerlink" title="2.Window事件"></a>2.Window事件</h4><p>window事件是指事件的发生于<strong>浏览器窗口本身</strong>而非窗口中显示的任何特定文档内容相关. 但是, 这些事件中有一些会和文档元素发生的事件同名.</p>
<p><code>load</code>事件是这些事件中最重要的一个, 当文档和其所有外部资源(比如图片)完全加载并显示给用户时就会触发它. 有关<code>load</code>事件的讨论贯穿整个<strong>第13章</strong>. <code>DOMContentLoaded</code>和<code>readystatechange</code>是<code>load</code>事件的替代方案, 当文档和其他元素为操作准备就绪, 但外部资源完全加载完毕之前, 浏览器就会尽在触发他们. 17.4有这些与文档加载相关事件的示例.</p>
<p><code>unload</code>事件和<code>load</code>相对, 当用户离开当前文档转向其他文档时会触发它. <code>unload</code>事件处理程序可有用于保护用户的状态, 但他不能用于取消用户转向其他地方. <code>beforeunload</code>事件和<code>unload</code>事件类似, 但他能提供询问用户是否正确离开当前页面的机会. 如果<code>beforeunload</code>的处理程序返回字符串, 那么在新页面加载之前, 字符串会出现在展示给用户确认的对话框上, 这样用户就有机会取消其跳转而留在当前页上.</p>
<p><code>window</code>对象的<code>onerror</code>属性有点像事件处理程序, 当JavaScript出错时会触发它. 但是, 他不是真正的事件处理程序, 因为他能用不同的参数来调用. 更多详细信息看14.6节</p>
<p>像<code>&lt;img&gt;</code>元素这样的单个文档元素也能为<code>load</code>和<code>error</code>事件注册处理程序. 当外部资源(例如图片)完全家在或发生阻止加载的错误时就会触发它们. 某些浏览器也支持<code>abort</code>事件(HTML5将其标准化), 当图片(或其他网络资源)因为用户停止加载进程而导致失败就会触发它.</p>
<p>前面介绍的表单元素的<code>focus</code>和<code>blur</code>事件也能用做<code>Window</code>事件, 当浏览器窗口从操作系统中得到或失去键盘焦点时会触发它们.</p>
<p>最后, 当用户调整浏览器窗口大小或滚动它时会触发<code>resize</code>和<code>scroll</code>事件.<code>scroll</code>事件也能在任何可以滚动的文档元素上触发, 比如那些设置<code>CSS</code>的<code>overflow</code>属性的元素. 传递给<code>resize</code>和<code>scroll</code>事件处理程序的事件对象是一个非常普遍的<code>Event</code>对象, 他没有制定调整大小或发生滚动的详细信息属性, 但可以通过15.8节介绍的技术来确定新窗口的尺寸和滚动条的位置.</p>
<h4 id="3-鼠标事件"><a href="#3-鼠标事件" class="headerlink" title="3.鼠标事件"></a>3.鼠标事件</h4><p>当用户在文档上移动或单击鼠标时都会产生鼠标事件. 这些事件在鼠标指针所对应的最深嵌套元素上触发, 但他们会冒泡直到文档最顶层. 传递给鼠标事件处理程序的事件对象有属性集, 它们描述了当事件发生时鼠标的位置和按键状态, 也指明了当时是否有任何辅助键按下. <code>clientX</code>和<code>clientY</code>属性制定了鼠标在窗口坐标中的位置. <code>button</code>和<code>which</code>属性指定了按下的鼠标键是哪个.(无论如何请看<code>Event</code>参考页, 因为这些属性难以简单使用.) 当键盘辅助键按下时, 对应的属性<code>altkey</code>, <code>ctrlKey</code>, <code>metaKey</code>和<code>shiftKey</code>会设置为<code>true</code>. 而对于<code>click</code>事件, <code>detail</code>事件指定了其是单击, 双击还是三击.</p>
<p>用户每次移动或拖动鼠标时, 会触发<code>mousemove</code>事件. 这些事件的发生非常繁琐, 所以<code>mousemove</code>事件处理程序一定不能触发计算密集型任务. 当用户按下或释放鼠标按键时, 会触发<code>mousedown</code>和<code>mousemove</code>事件. 通过注册<code>mousedown</code>和<code>mousemove</code>事件处理程序, 可以探测和响应鼠标的拖动. 合理地这样做能捕获鼠标事件, 甚至当鼠标从开始元素移出时我们都能持续地接收到<code>mousemove</code>事件.</p>
<p>在<code>mousedown</code>和<code>mouseup</code>事件队列之后, 浏览器也会触发<code>click</code>事件. 之前介绍过<code>click</code>事件是独立于设备的表单事件, 但实际上他不仅仅在表单元素上触发, 他可以在任何文档元素上触发, 同时传递拥有之前介绍的所有鼠标相关额外字段的事件对象. 如果用户在相当短的时间内连续两次单击鼠标按键, 跟在第二个<code>click</code>事件之后是<code>dblick</code>事件. 当单击鼠标右键时, 浏览器通常会显示上下文菜单(<code>context menu</code>). 在显示菜单之前, 他们通常会触发<code>contextmenu</code>事件, 而取消这个事件就可以阻止菜单的显示. 这个事件也是获得鼠标右击通知的简单方法.</p>
<p>当用户移动鼠标指针从而使他悬停到新元素上时, 浏览器就会在该元素上触发<code>mouseover</code>事件. 当鼠标移动指针从而使他不在悬停在某个元素上时, 李兰器就会在该元素上触发<code>mouseout</code>事件. 对于这些事件, 事件对象将有<code>relatedTarget</code>属性指明这个过程设计的其他元素. (到<code>Event</code>参考页查看<code>relatedTarget</code>属性的IE等效属性) <code>mouseover</code>和<code>mouseout</code>事件和这里介绍的素有鼠标事件一样会冒泡. 但这通常不方便, 因为当触发<code>mouseout</code>事件处理程序时, 你不得不检查鼠标是否真的离开目标元素还是仅仅是从这个元素的一个子元素移动到另一个. 正因为如此, IE提供了这些事件的不冒泡版本<code>mouseenter</code>和<code>mouseleave</code>, JQuery模拟非IE的浏览器中这些事件的支持, 同时3级DOM事件规范把它们标准化了.</p>
<p>当用户滚动鼠标滚轮时, 浏览器触发<code>mousewheel</code>事件(或在firefox中是<code>DOMMouseScroll</code>事件). 传递的时间对象属性指定滚轮转动的大小和方向. 3级DOM事件规范正在标准化一个更通用的多维<code>wheel</code>事件, 一旦实现将取代<code>mousewheel</code>和<code>DOMMouseScroll</code>事件.</p>
<h4 id="4-键盘事件"><a href="#4-键盘事件" class="headerlink" title="4.键盘事件"></a>4.键盘事件</h4><p>当键盘聚焦到Web浏览器时, 用户每次按下或释放键盘上的按键时都会产生事件. 键盘快捷键对于操作系统和浏览器本身有特殊意义, 他们经常被操作系统或浏览器”吃掉”, 并对JavaScript事件处理程序不可见. 无论任何文档元素获取键盘焦点都会触发键盘事件, 并且他们会冒泡到<code>Document</code>和<code>Window</code>对象. 如果没有元素获取焦点, 可以直接在文档上触发事件. 传递给键盘事件处理程序的事件对象有<code>keyCode</code>字段, 他指定按下或释放的键是哪个. 除了<code>keyCode</code>, 键盘事件对象也有<code>altKey</code>, <code>ctrlKey</code>, <code>metaKey</code>和<code>shiftKey</code>, 描述键盘辅助键的状态.</p>
<p><code>keydown</code>和<code>keyup</code>事件是低级键盘事件, 无论何时按下或释放按键(甚至是辅助键)都会触发他们.<br>当<code>keydown</code>事件产生可打印字符时, 在<code>keydown</code>和<code>keyup</code>之间会触发另外一个<code>keypress</code>事件.<br>当按下键重复产生字符时, 在<code>keyup</code>事件之前可能产生很多<code>keypress</code>事件. <code>keypress</code>是较高级的文本事件, 其事件对象指定产生的字符而非按下的键.</p>
<p>所有浏览器都支持<code>keydown</code>, <code>keyup</code>和<code>keypress</code>事件, 但有一些互用性问题, 因为事件对象的<code>keyCode</code>属性值从未标准化过. 3级DOM事件规范尝试解决之前的互用性问题, 但尚未实施.</p>
<h3 id="17-1-2-DOM事件"><a href="#17-1-2-DOM事件" class="headerlink" title="17.1.2 DOM事件"></a>17.1.2 DOM事件</h3><p>W3C开发3级DOM事件规范已经长达十年之久. 现在终于处于标准化的”最后征集工作草案”阶段, 它标准化了前面介绍的许多传统事件, 同时增加了这里介绍的一些新事件. 这些新事件类型尚未得到广泛支持, 一旦标准确定, 我们就期望浏览器厂商能实现他们.</p>
<p>如上所述, 3级DOM事件规范标准化了不冒泡的<code>focusin</code>和<code>focusout</code>事件来取代冒泡的<code>focus</code>和<code>blur</code>事件. 此版本的标准也弃用了大量由2级DOM事件规范定义但未得到广泛实现的事件类型. 浏览器依旧允许产生像<code>DOMActive</code>, <code>DOMFocusIn</code>和<code>DOMNodeInserted</code>这样的事件, 但他们不在必要, 同时本书的文档也不会列出他们(在名字中使用”DOM”的唯一常用事件就是<code>DOMContentLoaded</code>, 这个事件由<code>Mozilla</code>引入, 但绝不属于DOM事件标准的一部分).</p>
<p>3级DOM事件规范中新增内容有通过<code>wheel</code>事件对二维鼠标滚轮提供标准支持, 通过<code>textinput</code>事件和传递新<code>KeyboardEvent</code>对象作为参数给<code>keydown</code>, <code>keyup</code>和<code>keypress</code>的事件处理程序来给文本输入事件提供更好的支持.</p>
<p><code>wheel</code>事件的处理程序接收到的事件对象除了所以普通鼠标事件属性, 还有<code>delatX</code>, <code>delatY</code>和<code>delatZ</code>属性来报告三个不同的鼠标滚轴. 大多数鼠标滚轮是一维或二维的, 并不使用<code>delatZ</code>. 更多关于<code>mousewheel</code>事件的内容请参见17.6节.</p>
<p>如上所述, 3级DOM事件规范定义了<code>keypress</code>事件, 但不赞成使用它而使用称为<code>textinput</code>的新事件. 传递给<code>textinput</code>事件处理程序的时间对象不再有难以使用的数字<code>keyCode</code>属性值, 而有指定输入文本字符串的<code>data</code>属性. <code>textinput</code>事件不是键盘特定事件, 无论通过键盘, 剪切和粘贴, 拖放方式, 每当发生文本输入时就会触发它. 规范定义了时间对象的<code>inputMethod</code>属性和一组代表各种文本输入种类的常量(键盘, 粘贴, 拖放,手写和语音识别等). 在写本章时, Safari和Chrome使用混合大小写的<code>textInput</code>来支持这个事件版本, 其事件对象有<code>data</code>属性但没有<code>inputMethod</code>属性.</p>
<p>新DOM标准通过在事件对象中加入新的<code>key</code>和<code>char</code>属性来简化<code>keydown</code>, <code>keyup</code>和<code>keypress</code>事件, 这些属性都是字符串. 对于产生可打印字符的键盘事件, <code>key</code>和<code>char</code>值将等于生成的文本. 对于控制键, <code>key</code>属性将会是像标识键的”<code>Enter</code>“, “<code>Delete</code>“和”<code>Left</code>“这样的字符串, 而<code>char</code>属性将是<code>null</code>, 或对于像<code>Tab</code>这样的控制键有一个字符编码, 它将是按键产生的字符串. 在写本章时, 尚未有浏览器支持<code>key</code>和<code>char</code>属性.</p>
<h3 id="17-1-3-HTML5事件"><a href="#17-1-3-HTML5事件" class="headerlink" title="17.1.3 HTML5事件"></a>17.1.3 HTML5事件</h3><p>HTML5及相关标准定义了大量新的web应用API(第22章), 其中许多API都定义了事件. 本节列出并简要介绍这些HTML5和web应用事件. 其中一些事件现在已经可以开始使用.</p>
<p>广泛推广的HTML特性之一是加入用于播放音频和视频的<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>元素. 这些元素有长长的事件列表, 他们触发各种关于网络事件, 数据缓冲状况和播放状态的通知:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">canplay         loadeddata      playing     stalled</span><br><span class="line">canplaythrough  loadedmetadata  progress    suspend</span><br><span class="line">durationchange  loadstart       ratechange  timeupdate</span><br><span class="line">emptied         pause           seeked      volumechange</span><br><span class="line">ended           play            seeking     waiting</span><br></pre></td></tr></table></figure>
<p>传递给美体时间处理程序的事件对象普通且没有特殊属性, <code>target</code>属性用于识别<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>元素, 然而这些元素有多相关的属性和方法. 21.2节有更多关于这些元素及其属性和事件的详细内容.</p>
<p>HTML5的拖放API允许JavaScript应用参与基于操作系统的拖放操作, 实现web和原生应用间的数据传输. 该API定义了如下7个事件类型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dragstart       drag        dragend</span><br><span class="line">dragenter       dragover    dragleave</span><br><span class="line">drop</span><br></pre></td></tr></table></figure>
<p>触发拖放事件的事件对象和通过鼠标事件发送的对象类似, 其附加属性<code>dataTransfer</code>持有<code>DataTransfer</code>对象, 它包含关于传输的数据和其中可用的格式信息.</p>
<p>HTML5定义了历史管理机制, 它允许web应用同浏览器的返回和前进按钮交互. 这个机制涉及的事件是<code>hashchange</code>和<code>popstate</code>, 这些事件是类似<code>load</code>和<code>unload</code>的生命周期通知事件, 他在<code>Window</code>对象上触发而非任何单独的文档元素.</p>
<p>HTML5为HTML表单定义了大量的新特性. 除了标准化前面介绍的表单输入事件外, HTML5也定义了表单验证机制, 包括当验证失败时在表单元素上会触发<code>invalid</code>事件. 除<code>Opera</code>外的浏览器厂商已经慢慢实现HTML5的新表单特性和事件, 但本书没有涵盖他们.</p>
<p>HTML5包含了对离线web应用的支持, 他们可以安装到本地应用缓存中, 所以即使路蓝旗离线时它们依旧能运行, 比如当移动设备不在网络范围内时. 相关的两个最重要的事件是<code>offline</code>和<code>online</code>, 无论何时浏览器失去或得到网络连接都会在<code>Window</code>对象上触发它们. 标准还定义了大量其他事件来通知应用下载进度和应用缓存更新:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cached      checking        downloading     error</span><br><span class="line">noupdate    obsolete        progress        upateready</span><br></pre></td></tr></table></figure>
<p>很多新web应用API都使用<code>message</code>事件进行异步通信. 跨文档通信API允许一台服务器上的文档脚本能和另一台服务器上的文档脚本交换信息. 其工作受限于同源策略这一安全方式. 发送的每一条消息都会在接受文档的Window上触发<code>message</code>事件. 传递给处理程序的事件对象包含<code>data</code>属性, 它有保存信息内容以及用于识别消息发送者的<code>source</code>属性和<code>origin</code>策略. <code>message</code>事件的使用方式与使用<code>Web Worker</code>通信, 通过<code>Server-Sent</code>事件和<code>WebSocket</code>进行网络通信相似.</p>
<p>HTML5及相关标准定义了一些不在窗口, 文档和文档元素的对象上触发的事件. <code>XMLHttpRequest</code>规范第2版和<code>File API</code>规范都定义了一系列事件来跟踪异步I/O的进度. 它们在<code>XMLHttpRequest</code>或<code>FileReader</code>对象上触发事件. 每次读取操作都是以<code>loadstart</code>事件开始, 接着是<code>progress</code>和<code>loadend</code>事件. 此外, 每个操作仅在最终<code>loadend</code>事件之前会有<code>load</code>,<code>error</code>或<code>abort</code>事件.</p>
<p>最后, HTML5及相关标准定义了少量庞杂的事件类型. 在Window对象上发生的web存储API定义了<code>storage</code>事件用于通知存储数据的改变. HTML5页标准化了最早由Microsoft在IE中引入的<code>beforeprint</code>和<code>afterprint</code>事件. 顾名思义, 当文档打印之前或之后立即在<code>Window</code>对象触发这些事件, 它提供了打印文档时添加或删除类似日期或事件等内容的机会. (这些事件不应该用于处理打印文档的样式, 因为CSS媒体类型更适合这个用途.)</p>
<h3 id="17-1-4-触摸屏和移动设备事件"><a href="#17-1-4-触摸屏和移动设备事件" class="headerlink" title="17.1.4 触摸屏和移动设备事件"></a>17.1.4 触摸屏和移动设备事件</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/从输入URL到页面加载发生了什么/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/从输入URL到页面加载发生了什么/" itemprop="url">从输入URL到页面加载发生了什么?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-28T17:02:58+08:00">2018-12-28</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/网络/" itemprop="url" rel="index"><span itemprop="name">网络</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从输入URL到页面加载发生了什么"><a href="#从输入URL到页面加载发生了什么" class="headerlink" title="从输入URL到页面加载发生了什么?"></a>从输入URL到页面加载发生了什么?</h1><p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h2 id="在此之前的准备"><a href="#在此之前的准备" class="headerlink" title="在此之前的准备"></a>在此之前的准备</h2><p><a href="https://zhuanlan.zhihu.com/p/34453198" target="_blank" rel="noopener">从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！666</a></p>
<h3 id="level3"><a href="#level3" class="headerlink" title="level3:"></a>level3:</h3><p>基本能到这一步的，不是高阶就是接近高阶，因为很多概念并不是靠背就能理解的，而要理解这么多，需形成体系，一般都需要积累，非一日之功。</p>
<p>一般包括什么样的回答呢？（这里就以自己的简略回答进行举例），一般这个阶段的人员都会符合若干条（不一定全部，当然可能还有些是这里遗漏的）:</p>
<ul>
<li>首先略去那些键盘输入、和操作系统交互、以及屏幕显示原理、网卡等硬件交互之类的（前端向中，很多硬件原理暂时略去。。。）</li>
<li>对浏览器模型有整体概念，知道浏览器是多进程的，浏览器内核是多线程的，清楚进程与线程之间得区别，以及输入url后会开一个新的网络线程</li>
<li>对从开启网络线程到发出一个完整的http请求中间的过程有所了解（如dns查询，tcp/ip链接，五层因特尔协议栈等等，以及一些优化方案，如dns-prefetch）</li>
<li>对从服务器接收到请求到对应后台接收到请求有一定了解（如负载均衡，安全拦截以及后台代码处理等）</li>
<li>对后台和前台的http交互熟悉（包括http报文结构，场景头部，cookie，跨域，web安全，http缓存，http2.0，https等）</li>
<li>对浏览器接收到http数据包后的解析流程熟悉（包括解析html，词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、里面可能还包括复合图层的合成、GPU绘制、外链处理、加载顺序等）</li>
<li>对JS引擎解析过程熟悉（包括JS的解释，预处理，执行上下文，VO，作用域链，this，回收机制等）</li>
</ul>
<h3 id="前端向知识的重点"><a href="#前端向知识的重点" class="headerlink" title="前端向知识的重点"></a>前端向知识的重点</h3><p>此部分的内容是站在个人视角分析的，并不是说就一定是正确答案</p>
<p>首先明确，计算机方面的知识是可以无穷无尽的挖的，而本文的<strong>重点是梳理前端向的重点知识</strong></p>
<p>对于前端向（这里可能没有提到node.js之类的，更多的是指客户端前端），这里将知识点按重要程度划分成以下几大类：</p>
<ul>
<li><strong>核心知识</strong>，必须掌握的，也是最基础的，<strong>譬如浏览器模型，渲染原理，JS解析过程，JS运行机制, JS引擎解析流程等，作为骨架来承载知识体系</strong></li>
<li><strong>重点知识</strong>，往往每一块都是一个知识点，而且这些知识点都很重要，譬如http相关，web安全相关，跨域处理等</li>
<li><strong>拓展知识</strong>，这一块可能更多的是了解，稍微实践过，但是认识上可能没有上面那么深刻，譬如五层因特尔协议栈，hybrid模式，移动原生开发，后台相关等等（当然，在不同领域，可能有某些知识就上升到重点知识层次了，譬如hybrid开发时，懂原生开发是很重要的）</li>
</ul>
<h3 id="梳理主干流程"><a href="#梳理主干流程" class="headerlink" title="梳理主干流程"></a>梳理主干流程</h3><p>回到这道题上，如何回答呢？先梳理一个骨架</p>
<p>知识体系中，最重要的是骨架，脉络。有了骨架后，才方便填充细节。所以，先梳理下主干流程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，<span class="keyword">catch</span>-control等）</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）</span><br></pre></td></tr></table></figure>
<h2 id="核心知识梳理"><a href="#核心知识梳理" class="headerlink" title="核心知识梳理"></a>核心知识梳理</h2><h3 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h3><p>浏览器是<strong>多进程</strong>的，有一个<strong>主控进程</strong>，以及<strong>每一个tab页面</strong>都会新开一个进程（某些情况下多个tab会<strong>合并</strong>进程）</p>
<p><strong>进程</strong>可能包括<strong>主控进程</strong>，<strong>插件进程</strong>，<strong>GPU</strong>，<strong>tab页</strong>（浏览器内核）等等</p>
<ul>
<li>Browser进程：浏览器的主进程（负责协调、主控），只有一个, <strong>是其他进程的父进程</strong></li>
<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li>
<li>GPU进程：最多一个，用于3D绘制</li>
<li>浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li>
</ul>
<p>例如查看chrome的task manager: 在window =&gt; task manager</p>
<p><img src="taskManager1.png" alt="taskManager1.png"></p>
<h3 id="多线程的浏览器内核-浏览器渲染进程"><a href="#多线程的浏览器内核-浏览器渲染进程" class="headerlink" title="多线程的浏览器内核(浏览器渲染进程)"></a>多线程的浏览器内核(浏览器渲染进程)</h3><p>每一个<strong>tab页面可以看作是浏览器内核进程</strong>，然后这个进程是<strong>多线程</strong>的，它有几大类子线程</p>
<ul>
<li>GUI线程</li>
<li><strong>JS引擎线程</strong></li>
<li>事件触发线程</li>
<li>定时器线程</li>
<li>网络请求线程</li>
</ul>
<p><img src="thread1.jpg" alt="thread1.jpg"></p>
<p>可以看到，里面的<strong>JS引擎是内核进程中的一个线程</strong>，这也是为什么常说<strong>JS引擎是单线程</strong>的</p>
<p><a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p>
<h4 id="进程和线程区别"><a href="#进程和线程区别" class="headerlink" title="进程和线程区别"></a>进程和线程区别</h4><ul>
<li><strong>进程</strong>是cpu<strong>资源分配</strong>的最小单位（是能拥有资源和独立运行的最小单位）</li>
<li><strong>线程</strong>是cpu<strong>调度</strong>的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>
</ul>
<p>打开mac的monitor可以看到一个进程中有多少线程, 系统按进程来分配资源. 点开详情可以看到父进程是什么<br><img src="process1.png" alt="process1.png"><br><img src="process2.png" alt="process2.png"></p>
<p>对于chrome这个程序而言, 他有一个主进程<code>Google Chrome</code>, 以及对应tab页的<code>Google Chrome Helper</code><br><a href="https://juejin.im/post/5c00c469f265da616413bdb8" target="_blank" rel="noopener">mac下chrome浏览器的标签页、进程和内存分配</a></p>
<p>这里可以看到一个主进程以及其他内核进程, 记得在monitor中按PID升序, 在chrome中的<code>task manager</code>中也是, 可以看到对应的.<strong>这里也更加确定了浏览器时多进程的</strong>(进程优化, 比如知乎的不是每个tab创建一个进程)<br><img src="taskManager2.png" alt="taskManager2.png"><br><img src="chromeHelper1.png" alt="chromeHelper1.png"></p>
<blockquote>
<p>注意：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被<strong>合并</strong>了 (<strong>所以每一个Tab标签对应一个进程并不一定是绝对的, 比如知乎的那个进程</strong>）<br>通过 <code>monitor</code> 和 <code>task Manager</code>去研究mac下chrome浏览器的标签页和进程的关系以及标签页的内存分配，发现chrome默认会启动一个主进程和两个子进程，之后每启动一个标签页会启动2个进程，加载完成后会结束一个。每个标签页都会分配实际内存和虚拟内存，当实际内存达到300M左右时，之后就只会分配虚拟内存。因为这种机制的存在，mac下页面还是没那么容易因为内存溢出而崩溃的，更多的要去关心windows下的内存占用情况。<br>浏览器多进程好处, 防止页面或第三方插件崩了就全崩了, 就是内存消耗多点.</p>
</blockquote>
<h4 id="浏览器内核-渲染进程"><a href="#浏览器内核-渲染进程" class="headerlink" title="浏览器内核(渲染进程)"></a>浏览器内核(渲染进程)</h4><p>对前端而言, 页面的渲染，JS的执行，事件的循环，都在这个进程内进行。还是来说说这个进程里面5个主要线程.</p>
<p>1 GUI渲染线程</p>
<ul>
<li><strong>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</strong></li>
<li>当界面需要重绘（<code>Repaint</code>）或由于某种操作引发回流(<code>reflow</code>)时，该线程就会执行</li>
<li>注意，GUI渲染线程与JS引擎线程是<strong>互斥</strong>的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li>
</ul>
<p>2 JS引擎线程</p>
<ul>
<li>也称为JS内核，<strong>负责处理Javascript脚本程</strong>序。（例如V8引擎）</li>
<li>JS引擎线程负责解析Javascript脚本，运行代码。</li>
<li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，<strong>一个Tab页（<code>renderer进程</code>）中无论什么时候都只有一个JS线程在运行JS程序</strong></li>
<li>同样注意，GUI渲染线程与JS引擎线程是<strong>互斥</strong>的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>
</ul>
<blockquote>
<p>只是GUI渲染线程和JS引擎线程是互斥的</p>
</blockquote>
<p>3 事件触发线程</p>
<ul>
<li><strong>归属于浏览器</strong>而不是JS引擎，用来<code>控制事件循环</code>(可以理解，<strong>JS引擎自己都忙不过来，需要浏览器另开线程协助</strong>）</li>
<li>当JS引擎执行代码块如<code>setTimeOut</code>时（也可来自浏览器内核的其他线程,如<code>鼠标点击</code>、<code>AJAX异步请求</code>等），会将对应任务添加到事件线程中</li>
<li>当对应的事件符合触发条件被触发时，该线程会把事件<strong>添加到待处理队列的队尾，等待JS引擎的处理</strong></li>
<li>注意，由于<strong>JS的单线程</strong>关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li>
</ul>
<p>4 定时触发器线程</p>
<ul>
<li>传说中的<code>setInterval</code>与<code>setTimeout</code>所在线程</li>
<li>浏览器定时计数器并不是由JavaScript引擎计数的,（<strong>因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确</strong>）</li>
<li><strong>因此通过单独线程来计时并触发定时</strong>（计时完毕后，<strong>添加到事件队列中</strong>，等待JS引擎空闲后执行）</li>
<li>注意，W3C在HTML标准中规定，规定要求<code>setTimeout</code>中低于4ms的时间间隔算为4ms。</li>
</ul>
<p>5 异步http请求线程</p>
<ul>
<li>在<code>XMLHttpRequest</code>在连接后是通过浏览器新开一个线程请求</li>
<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调<strong>再放入事件队列中</strong>。再由JavaScript引擎执行。</li>
</ul>
<blockquote>
<p>3.4.5都有<strong>事件队列</strong>哦, 可以并行的, 3还控制事件循环机制, 就1和2是<strong>互斥</strong>的, 其他可以并行.</p>
</blockquote>
<p>补充: HTML5的 <code>Web Worker</code>线程<br><a href="https://zhuanlan.zhihu.com/p/32751855" target="_blank" rel="noopener">聊聊 JavaScript 与浏览器的那些事 - 引擎与线程</a></p>
<blockquote>
<p>上面链接中的 <strong>一个浏览器的主要组件可分为如下几个部分</strong>这块不用看,看上面的多进程浏览器, 多线程内核就行, 免得糊涂, 最后也得出我们会更注重呈现引擎和 <code>JavaScript</code> 解释器的部分. ]<br><code>Web Worker</code> 允许 <code>JavaScript</code> 脚本创建多个线程，但是<strong>子线程完全受主线程控制，且不得操作 DOM</strong> 。所以，这个新标准并没有改变 <code>JavaScript</code> 单线程的本质。</p>
<p>然后 <strong>注意</strong>定时器和异步是不同的线程控制哦</p>
</blockquote>
<h3 id="Browser进程和浏览器内核（Renderer进程）的通信过程-父进程和子进程之间通信"><a href="#Browser进程和浏览器内核（Renderer进程）的通信过程-父进程和子进程之间通信" class="headerlink" title="Browser进程和浏览器内核（Renderer进程）的通信过程(父进程和子进程之间通信)"></a>Browser进程和浏览器内核（Renderer进程）的通信过程(父进程和子进程之间通信)</h3><p>那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。</p>
<p>如果自己打开任务管理器(<code>Activity Monitor</code>)，然后打开一个浏览器(<code>chrome</code>)，就可以看到：任务管理器中出现了两个进程（一个是主控进程(<code>Google chrome</code>)，一个则是打开Tab页的渲染进程<code>Google Chrome Helper</code>），<br>然后在这前提下，看下整个的过程：(简化了很多)</p>
<ul>
<li><code>Browser</code><strong>进程</strong>收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过<code>RendererHost</code>接口传递给<code>Render</code><strong>进程</strong></li>
<li><code>Renderer</code><strong>进程</strong>的<code>Renderer</code>接口收到消息，简单解释后，交给<code>渲染线程</code>，然后开始渲染<ul>
<li><code>渲染线程</code>接收请求，加载网页并渲染网页，这其中可能需要<code>Browser</code><strong>进程</strong>获取资源和需要<code>GPU</code><strong>进程</strong>来帮助渲染</li>
<li>当然可能会有<code>JS线程</code>操作DOM（这样可能会造成<strong>回流并重绘</strong>）</li>
<li>最后<code>Render</code><strong>进程</strong>将结果传递给<code>Browser</code><strong>进程</strong></li>
</ul>
</li>
<li><code>Browser</code><strong>进程</strong>接收到结果并将结果绘制出来</li>
</ul>
<p>这里绘一张简单的图：（很简化）<strong>这里是进程</strong>不是线程</p>
<p><img src="render1.png" alt="render1.png"></p>
<p><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/" target="_blank" rel="noopener">深入浅出浏览器渲染原理</a></p>
<h3 id="梳理浏览器内核中线程之间的关系"><a href="#梳理浏览器内核中线程之间的关系" class="headerlink" title="梳理浏览器内核中线程之间的关系"></a>梳理浏览器内核中<code>线程之间</code>的关系</h3><p>到了这里，已经对浏览器的运行有了一个整体的概念，接下来，先简单梳理一些概念, 在回顾下图.</p>
<p><img src="thread1.jpg" alt="thread1.jpg"></p>
<h4 id="GUI渲染线程与JS引擎线程互斥"><a href="#GUI渲染线程与JS引擎线程互斥" class="headerlink" title="GUI渲染线程与JS引擎线程互斥"></a>GUI渲染线程与JS引擎线程互斥</h4><p>由于<code>JavaScript</code>是<strong>可操纵DOM</strong>的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能<strong>不一致</strong>了。</p>
<p>因此为了防止渲染出现不可预期的结果，浏览器设置<code>GUI渲染线程</code>与<code>JS引擎</code>为<strong>互斥</strong>的关系，当JS引擎执行时GUI线程会被挂起，<br>GUI更新则会被保存在一个队列中<strong>等到JS引擎线程空闲时</strong>立即被执行。</p>
<h4 id="JS阻塞页面加载"><a href="#JS阻塞页面加载" class="headerlink" title="JS阻塞页面加载"></a>JS阻塞页面加载</h4><p>从上述的互斥关系，可以推导出，<strong>JS如果执行时间过长就会阻塞页面</strong>。</p>
<p>譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行, 就是后面的<code>task =&gt; 渲染 =&gt; task</code>。<br>然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。</p>
<p>所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>
<h4 id="WebWorker，JS的多线程？"><a href="#WebWorker，JS的多线程？" class="headerlink" title="WebWorker，JS的多线程？"></a>WebWorker，JS的多线程？</h4><p>前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，<strong>那么JS就真的对<code>cpu密集型计算</code>无能为力么</strong>？</p>
<p>所以，后来HTML5中支持了<code>Web Worker</code>。</p>
<p>MDN的官方解释是：</p>
<blockquote>
<p><code>Web Worker</code>为Web内容在<strong>后台线程中运行脚本</strong>提供了一种简单的方法。线程可以执行任务而不干扰用户界面<br>一个<code>worker</code>是使用一个<strong>构造函数创建的一个对象</strong>(e.g. <code>Worker()</code>) 运行一个命名的JavaScript文件<br>这个文件包含将在工作线程中运行的代码; <code>workers</code> 运行在另一个全局上下文中,不同于当前的window<br>因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 <code>Worker</code> 内将返回错误</p>
</blockquote>
<p>这样理解下：</p>
<ul>
<li>创建<code>Worker</code>时，<code>JS引擎线程</code>向浏览器<strong>申请开一个子线程</strong>（子线程是浏览器开的，<strong>完全受主线程控制</strong>，而且<strong>不能操作DOM</strong>）</li>
<li><code>JS引擎线程</code>与<code>worker</code>线程间通过<strong>特定的方式通信</strong>（<code>postMessage API</code>，需要通过<code>序列化对象</code>来与线程交互特定的数据）</li>
</ul>
<p>所以，<strong>如果有非常耗时的工作，请单独开一个<code>Worker</code>线程</strong>，这样里面不管如何翻天覆地都不会影响JS引擎主线程，<br>只待计算出结果后，将结果通信给主线程即可，perfect!</p>
<p>而且注意下，<strong>JS引擎是单线程的，这一点的本质仍然未改变</strong>，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p>
<p>其它，关于Worker的详解就不是本文的范畴了，因此不再赘述。</p>
<h4 id="WebWorker与SharedWorker"><a href="#WebWorker与SharedWorker" class="headerlink" title="WebWorker与SharedWorker"></a>WebWorker与SharedWorker</h4><p>既然都到了这里，就再提一下<code>SharedWorker</code>（避免后续将这两个概念搞混）</p>
<p><code>WebWorker</code><strong>只属于某个页面</strong>，不会和其他页面的<code>Render进程</code>（浏览器内核进程）共享<br>所以Chrome在<code>Render进程</code>中（每一个Tab页就是一个<code>render进程</code>）<strong>创建一个新的<code>线程</code></strong>来运行<code>Worker</code>中的JavaScript程序。</p>
<p><code>SharedWorker</code>是<strong>浏览器所有页面共享的</strong>，不能采用与<code>Worker</code>同样的方式实现，因为它不隶属于某个<code>Render进程</code>，可以为多个<code>Render进程</code>共享使用</p>
<p>所以Chrome浏览器为<code>SharedWorker</code><strong>单独创建一个<code>进程</code></strong>来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个<code>SharedWorker</code>进程，不管它被创建多少次。</p>
<p>看到这里，应该就很容易明白了，<strong>本质上就是<code>进程和线程</code>的区别</strong>。<code>SharedWorker</code>由独立的<strong>进程</strong>管理，WebWorker只是属于<code>render进程</code>下的一个<strong>线程</strong>.</p>
<h3 id="简单梳理下浏览器渲染流程"><a href="#简单梳理下浏览器渲染流程" class="headerlink" title="简单梳理下浏览器渲染流程"></a>简单梳理下浏览器渲染流程</h3><p>为了简化理解，前期工作直接省略成：</p>
<ul>
<li>浏览器输入url，浏览器<strong>主进程</strong>接管，开一个下载线程，</li>
<li>然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，</li>
<li>随后将内容通过RendererHost接口转交给<code>Renderer</code><strong>进程</strong></li>
<li>浏览器渲染流程开始</li>
</ul>
<p><strong>浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤</strong>：</p>
<ul>
<li>解析<code>html</code>建立<strong>dom树</strong></li>
<li>再解析<code>css</code>一起构建<strong>render树</strong>（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</li>
<li>布局<strong>render树</strong>（Layout/reflow），负责各元素尺寸、位置的计算</li>
<li>绘制<strong>render树</strong>（paint），绘制页面像素信息</li>
<li>浏览器会将各层的信息发送给<code>GPU</code>，<code>GPU</code>会将各层合成（<code>composite</code>），显示在屏幕上。</li>
</ul>
<p>所有详细步骤都已经略去，渲染完毕后就是<code>load</code>事件了，之后就是自己的JS逻辑处理了</p>
<p>既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。</p>
<p>这里重绘参考来源中的一张图：（参考来源第一篇）</p>
<p><img src="render2.png" alt="render2.png"></p>
<p><a href="https://segmentfault.com/a/1190000008015671" target="_blank" rel="noopener">一篇文章说清浏览器解析和CSS（GPU）动画优化 666</a></p>
<blockquote>
<p>上面链接讲了js和会作用在<code>DOM tree</code>和<code>style rules</code>, 讲的细点.</p>
</blockquote>
<h4 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h4><p>上面提到，渲染完毕后会触发<code>load</code>事件，那么你能分清楚<code>load</code>事件与<code>DOMContentLoaded</code>事件的<strong>先后</strong>么？</p>
<p>很简单，知道它们的定义就可以了：</p>
<p>当 <code>DOMContentLoaded</code> 事件触发时，<strong>仅当DOM加载完成，不包括样式表，图片</strong>。<br>(譬如如果有async加载的脚本就不一定完成)</p>
<p>当 <code>onload</code> 事件触发时，<strong>页面上所有的DOM，样式表，脚本，图片都已经加载完成了</strong>。<br>（渲染完毕了）</p>
<p>所以，顺序是：<code>DOMContentLoaded</code> -&gt; <code>load</code></p>
<p><a href="https://segmentfault.com/a/1190000018130499?utm_source=weekly&amp;utm_medium=email&amp;utm_campaign=email_weekly" target="_blank" rel="noopener">css加载会造成阻塞吗</a> 看这个链接里的<code>DOMContentLoaded</code>, <strong>css会阻塞Dom渲染和js执行，而js会阻塞Dom解析。</strong></p>
<ol>
<li>如果页面中同时存在<code>css</code>和<code>js</code>，并且存在<code>js</code>在<code>css</code>后面，则<code>DOMContentLoaded</code>事件会在<code>css</code>加载完后才执行。(加载完全部css么?)</li>
<li>其他情况下，<code>DOMContentLoaded</code>都不会等待<code>css</code>加载，并且<code>DOMContentLoaded</code>事件也不会等待图片、视频等其他资源加载。</li>
</ol>
<h4 id="css加载是否会阻塞dom树渲染？"><a href="#css加载是否会阻塞dom树渲染？" class="headerlink" title="css加载是否会阻塞dom树渲染？"></a>css加载是否会阻塞dom树渲染？</h4><p><a href="https://segmentfault.com/a/1190000018130499?utm_source=weekly&amp;utm_medium=email&amp;utm_campaign=email_weekly" target="_blank" rel="noopener">css加载会造成阻塞吗</a></p>
<p>这里说的是<strong>头部引入css的情况</strong></p>
<p>首先，我们都知道：<strong>css是由单独的<code>下载线程</code>异步下载的</strong>。</p>
<p>然后再说下几个现象：</p>
<ul>
<li><strong>css加载不会阻塞DOM树解析</strong>（异步加载时DOM照常构建）</li>
<li><strong>但会阻塞render树渲染</strong>（渲染时需等css加载完毕，因为render树需要css信息）</li>
</ul>
<p>这可能也是浏览器的一种<strong>优化</strong>机制。</p>
<p><strong>因为你加载css的时候，可能会修改下面DOM节点的样式</strong>，<br>如果css加载不阻塞render树渲染的话，那么当css加载完之后，<br>render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。<br>所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，<br>在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。</p>
<h4 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h4><p>渲染步骤中就提到了<code>composite</code>概念。</p>
<p>可以简单的这样理解，<strong>浏览器渲染的图层</strong>一般包含两大类：<code>普通图层</code>以及<code>复合图层</code></p>
<p>首先，<strong>普通文档流</strong>内可以理解为一个<code>复合图层</code>（这里称为<code>默认复合层</code>，里面不管添加多少元素，其实都是在同一个复合图层中）</p>
<p>其次，<code>absolute</code>布局（<code>fixed</code>也一样），<strong>虽然可以脱离普通文档流，但它仍然属于<code>默认复合层</code></strong>。</p>
<p>然后，可以通过<code>硬件加速</code>的方式，声明一个新的复合图层，它会单独分配资源<br>（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</p>
<p>可以简单理解下：<strong>GPU中，各个复合图层是<code>单独绘制</code>的，所以互不影响</strong>，这也是为什么某些场景<code>硬件加速效果一级棒</code></p>
<p>可以<code>Chrome</code>源码调试 -&gt; <code>More Tools</code> -&gt; <code>Rendering</code> -&gt; <code>Layer borders</code>中看到，黄色的就是复合图层信息</p>
<h5 id="如何变成复合图层（硬件加速）"><a href="#如何变成复合图层（硬件加速）" class="headerlink" title="如何变成复合图层（硬件加速）"></a>如何变成复合图层（硬件加速）</h5><p>将该元素<strong>变成一个复合图层，就是传说中的硬件加速技术</strong></p>
<ul>
<li>最常用的方式：<code>translate3d</code>、<code>translateZ</code></li>
<li><code>opacity</code>属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</li>
<li><code>will-chang</code>属性（这个比较偏僻），一般配合<code>opacity</code>与<code>translate</code>使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），</li>
</ul>
<p>作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</p>
<ul>
<li><code>&lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;</code>等元素</li>
<li>其它，譬如以前的flash插件</li>
</ul>
<h5 id="absolute和硬件加速的区别"><a href="#absolute和硬件加速的区别" class="headerlink" title="absolute和硬件加速的区别"></a><code>absolute</code>和硬件加速的区别</h5><p>可以看到，<code>absolute</code>虽然可以脱离普通文档流，<code>但是无法脱离默认复合层</code>。<br>所以，就算<code>absolute</code>中信息改变时<strong>不会改变普通文档流中render树</strong>，<br>但是，浏览器最终绘制时，是整个复合层绘制的，所以<code>absolute</code>中信息的改变，<strong>仍然会影响整个复合层的绘制</strong>。<br>（浏览器会重绘它，如果复合层中内容多，<code>absolute</code>带来的绘制信息变化过大，资源消耗是非常严重的）</p>
<p>而<code>硬件加速</code>直接就是在另一个复合层了（另起炉灶），所以它的信息改变<strong>不会影响默认复合层</strong><br>（当然了，内部肯定会影响属于自己的复合层），<strong>仅仅是引发最后的合成</strong>（输出视图）</p>
<h5 id="复合图层的作用？"><a href="#复合图层的作用？" class="headerlink" title="复合图层的作用？"></a>复合图层的作用？</h5><p>一般一个元素开启硬件加速后会变成复合图层，可以<strong>独立于普通文档流中，改动后可以避免整个页面重绘</strong>，提升性能</p>
<p>但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡</p>
<h5 id="硬件加速时请使用index"><a href="#硬件加速时请使用index" class="headerlink" title="硬件加速时请使用index"></a>硬件加速时请使用index</h5><p>使用硬件加速时，尽可能的使用<code>index</code>，防止浏览器默认给后续的元素创建复合层渲染</p>
<p>具体的原理时这样的：</p>
<blockquote>
<p><code>webkit CSS3</code>中，如果这个元素添加了<code>硬件加速</code>，并且<strong>index层级比较低</strong>，<br>那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且<code>releative</code>或<code>absolute</code>属性相同的），<br><strong>会默认变为复合层渲染</strong>，如果处理不当会极大的影响性能</p>
</blockquote>
<p>简单点理解，其实可以认为是一个隐式合成的概念：<strong>如果a是一个<code>复合图层</code>，而且b在a上面，那么b也会被隐式转为一个<code>复合图层</code></strong>，这点需要特别注意</p>
<p>另外，这个问题可以在这个地址看到重现（原作者分析的挺到位的，直接上链接）：</p>
<p><a href="http://web.jobbole.com/83575/" target="_blank" rel="noopener">CSS3硬件加速也有坑</a></p>
<h3 id="从Event-Loop谈JS的运行机制"><a href="#从Event-Loop谈JS的运行机制" class="headerlink" title="从Event Loop谈JS的运行机制"></a>从Event Loop谈JS的运行机制</h3><p>到此时，已经是<strong>属于浏览器页面初次渲染完毕后</strong>的事情，JS引擎的一些运行机制分析。</p>
<p>注意，这里不谈<code>可执行上下文</code>，<code>VO</code>，<code>scope chain</code>等概念（这些完全可以整理成另一篇文章了），这里主要是结合<code>Event Loop</code>来谈JS代码是如何执行的。</p>
<p>读这部分的前提是已经知道了<strong>JS引擎是单线程</strong>，而且这里会用到上文中的几个概念：（如果不是很理解，可以回头温习）</p>
<ul>
<li>JS引擎线程</li>
<li>事件触发线程</li>
<li>定时触发器线程</li>
</ul>
<p>然后再理解一个概念：</p>
<ul>
<li>JS分<code>同步任务</code>和<code>异步任务</code></li>
<li><strong><code>同步任务</code>都在主线程上执行</strong>，形成一个<strong>执行栈</strong></li>
<li>主线程之外，<strong>事件触发线程</strong>管理着一个<strong>任务队列</strong>，只要<code>异步任务</code>有了运行结果，就在任务队列之中放置一个事件。</li>
<li>一旦<strong>执行栈</strong>中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取<strong>任务队列</strong>，将可运行的异步任务添加到可执行栈中，开始执行。</li>
</ul>
<p>看图：</p>
<p><img src="sync1.png" alt="sync1.png"></p>
<p>看到这里，应该就可以理解了：为什么有时候<code>setTimeout</code>推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，所以自然有误差。</p>
<p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html#comment-text" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop 666</a></p>
<blockquote>
<p>当然看了<code>microtask</code>就知道<code>task =&gt; 渲染 =&gt; task</code>这个套路</p>
</blockquote>
<h4 id="事件循环机制进一步补充"><a href="#事件循环机制进一步补充" class="headerlink" title="事件循环机制进一步补充"></a>事件循环机制进一步补充</h4><p>这里就直接引用一张图片来协助理解：（参考自Philip Roberts的演讲《<a href="https://vimeo.com/96425312" target="_blank" rel="noopener">Help, I’m stuck in an event-loop</a>》）</p>
<p><img src="loop1.png" alt="loop1.png"></p>
<blockquote>
<p><code>one thread == one call stack == one thing at a time</code><br><code>执行栈</code>就是<code>task</code>, <code>任务队列</code>就是<code>task queue</code>, 然后进行<code>event loop</code></p>
</blockquote>
<p>也有是 Event Table 和 Event Queue</p>
<p>上图大致描述就是：</p>
<ul>
<li><strong>主线程</strong>运行时会产生<strong>执行栈</strong>，</li>
<li>栈中的代码<strong>调用某些api(<code>定时, 异步, 事件</code>)</strong>时，它们会在<strong>事件队列中</strong>添加各种事件（当满足触发条件后，如ajax请求完毕后才推入事件队列）</li>
<li><strong>而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调</strong></li>
<li>如此循环</li>
</ul>
<blockquote>
<p>注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件</p>
</blockquote>
<h4 id="单独说说定时器"><a href="#单独说说定时器" class="headerlink" title="单独说说定时器"></a>单独说说定时器</h4><p>上述<strong>事件循环机制</strong>的核心是：<strong>JS引擎线程和事件触发线程</strong></p>
<p>但事件上，里面还有一些隐藏细节，譬如调用<code>setTimeout</code>后，是如何等待特定时间后才添加到事件队列中的？</p>
<p>是JS引擎检测的么？当然不是了。它是由<strong>定时器线程</strong>控制（因为JS引擎自己都忙不过来，根本无暇分身）</p>
<p>为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此<strong>很有必要单独开一个线程</strong>用来计时。</p>
<p>什么时候会用到定时器线程？当使用<code>setTimeout</code>或<code>setInterval</code>时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p>
<p>譬如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码的作用是当1000毫秒计时完毕后（由<strong>定时器线程</strong>计时），将<strong>回调函数推入事件队列</strong>中，等待主线程执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'begin'</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码的效果是<strong>最快的时间内</strong>将回调函数推入事件队列中，<strong>等待主线程执行</strong></p>
<p>注意：</p>
<p>执行结果是：<strong>先<code>begin</code>后<code>hello!</code></strong><br>虽然代码的本意是0毫秒后就推入事件队列，但是<code>W3C</code>在HTML标准中规定，规定要求<code>setTimeout</code>中低于<code>4ms</code>的时间间隔算为<code>4ms</code>。<br><a href="https://www.jeffjade.com/2016/01/10/2016-01-10-javacript-setTimeout/#2-setTimeout%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">你所不知道的setTimeout</a><br>(不过也有一说是不同浏览器有不同的最小时间设定)</p>
<p>就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（<strong>因为只有可执行栈内空了后才会主动读取事件队列</strong>）</p>
<h4 id="setTimeout而不是setInterval"><a href="#setTimeout而不是setInterval" class="headerlink" title="setTimeout而不是setInterval"></a>setTimeout而不是setInterval</h4><p>用<code>setTimeout</code>模拟定期计时和直接用<code>setInterval</code>是有区别的。</p>
<p>因为模拟的话, 每次<code>setTimeout</code>计时到后就会去执行，然后执行一段时间后才会继续<code>setTimeout</code>，中间就多了误差<br>（误差多少与代码执行时间有关）</p>
<p>而<code>setInterval</code>则是每次都精确的隔一段时间推入一个事件<br>（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）</p>
<p>而且<code>setInterval</code>有一些比较致命的问题就是：</p>
<p>累计效应（上面提到的），如果<code>setInterval</code>代码在（<code>setInterval</code>）再次添加到队列之前<strong>还没有完成执行</strong>，<br><strong>就会导致定时器代码连续运行好几次，而之间没有间隔</strong>。<br>就算正常间隔执行，多个<code>setInterval</code>的代码执行时间可能会比预期小（因为代码执行需要一定时间）</p>
<p>譬如像iOS的<code>webview</code>,或者Safari等浏览器中都有一个特点，在滚动的时候是不执行JS的，如果使用了<code>setInterval</code>，会发现在滚动结束后会执行多次由于滚动不执行JS积攒回调，如果回调执行时间过长,就会非常容器造成卡顿问题和一些不可知的错误（这一块后续有补充，<code>setInterval</code>自带的优化，不会重复添加回调）<br>而且把浏览器最小化显示等操作时，<code>setInterval</code>并不是不执行程序，它会把<code>setInterval</code>的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行.</p>
<p>所以，鉴于这么多但问题，目前一般认为的<strong>最佳方案</strong>是：用<code>setTimeout</code>模拟<code>setInterval</code>，或者特殊场合直接用<code>requestAnimationFrame</code></p>
<p>补充：JS高程中有提到，JS引擎会对<code>setInterval</code>进行优化，如果当前事件队列中有<code>setInterval</code>的回调，不会重复添加。不过，仍然是有很多问题。。。</p>
<h3 id="事件循环进阶：macrotask与microtask"><a href="#事件循环进阶：macrotask与microtask" class="headerlink" title="事件循环进阶：macrotask与microtask"></a>事件循环进阶：macrotask与microtask</h3><p>强烈推荐有英文基础的同学直接观看原文，作者描述的很清晰，示例也很不错，如下：</p>
<p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a><br>链接中对<code>tasks</code>, <code>microtasks</code>, <code>JS stack</code>, <code>log</code>有一个动画过程</p>
<p>上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure>
<p>嗯哼，它的正确执行顺序是这样子的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>
<p>为什么呢？因为<code>Promise</code>里有了一个一个新的概念：<code>microtask</code></p>
<p>或者，进一步，JS中分为两种任务类型：<code>macrotask</code>和<code>microtask</code>，在ECMAScript中，<code>macrotask</code>可称为<code>task</code>, <code>microtask</code>称为<code>jobs</code></p>
<blockquote>
<p>也就是<code>tasks</code>和<code>microtask</code></p>
</blockquote>
<p>它们的定义？区别？简单点可以按如下理解：</p>
<ul>
<li><p><code>macrotask</code>（又称之为<strong>宏任务</strong>），可以理解是<strong>每次执行栈执行的代码</strong>就是一个<strong>宏任务</strong>（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p>
<ul>
<li>每一个<code>task</code>会从头到尾将这个任务执行完毕，不会执行其它</li>
<li>浏览器为了能够使得JS内部<code>task</code>与DOM任务能够有序的执行，会在一个<code>task</code>执行结束后，在下一个 <code>task</code> 执行开始前，对页面进行重新渲染<ul>
<li><code>（</code>task-&gt;渲染-&gt;task-&gt;…<code>）</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>microtask</code>（又称为<strong>微任务</strong>），可以理解是在当前 <code>task</code> 执行结束后<strong>立即执行的任务</strong></p>
<ul>
<li>也就是说，在当前<code>task</code>任务后，下一个<code>task</code>之前，<strong>在渲染之前</strong></li>
<li>所以它的响应速度相比<code>setTimeout</code>（<code>setTimeout</code>是<code>task</code>）会<strong>更快</strong>，因为无需等渲染</li>
<li><strong>也就是说，在某一个<code>macrotask</code>执行完后，就会将在它执行期间产生的所有<code>microtask</code>都执行完毕（在渲染前）</strong></li>
</ul>
</li>
</ul>
<p>分别怎么样的场景会形成<code>macrotask</code>和<code>microtask</code>呢？</p>
<p><code>macrotask</code>：主代码块，<code>setTimeout</code>，<code>setInterval</code>等（可以看到，事件队列中的每一个事件都是一个<code>macrotask</code>）<br><code>microtask</code>：<code>Promise</code>，<code>process.nextTick</code>等<br><strong>补充：在node环境下，<code>process.nextTick</code>的优先级高于<code>Promise</code></strong>，也就是可以简单理解为：在<strong>宏任务</strong>结束后会先执行<strong>微任务队列</strong>中的<code>nextTickQueue</code>部分，然后才会执行<strong>微任务</strong>中的<code>Promise</code>部分。</p>
<p>参考：<a href="https://segmentfault.com/q/1010000011914016" target="_blank" rel="noopener">process.nextTick()与promise.then()</a><br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html#comment-text" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop 666</a></p>
<p><strong>再根据<code>线程</code>来理解下</strong>：</p>
<ul>
<li><code>macrotask</code>中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护</li>
<li><code>microtask</code>中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前<code>macrotask</code>执行完毕后执行，而这个队列由JS引擎线程维护</li>
</ul>
<p>（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）</p>
<p><strong>所以，<code>总结</code>下运行机制</strong>：</p>
<ul>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
<li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li>
</ul>
<p>如图：</p>
<p><img src="tasks.png" alt="tasks.png"></p>
<p>再来一个例子, 里面还有3个例子<br><a href="https://juejin.im/post/5c148ec8e51d4576e83fd836" target="_blank" rel="noopener">从event loop到async await来了解事件循环机制 666666</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>) <span class="comment">// 同步任务</span></span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>这段代码作为宏任务，进入主线程。</li>
<li>先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。</li>
<li>接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。</li>
<li>遇到console.log()，立即执行。</li>
<li>整体代码script作为第一个宏任务执行结束。查看当前有没有可执行的微任务，执行then的回调。<br>（第一轮事件循环结束了，我们开始第二轮循环。）</li>
<li>从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。<br>执行结果：1 - 2 - 3 - 4</li>
</ol>
<p>另外，请注意下<code>Promise</code>的<code>polyfill</code>与官方版本的区别：</p>
<ul>
<li>官方版本中，是标准的<code>microtask</code>形式</li>
<li><code>polyfill</code>，一般都是通过<code>setTimeout</code>模拟的，所以是<code>macrotask</code>形式</li>
<li>请特别注意这两点区别</li>
</ul>
<p>注意，有一些浏览器执行结果不一样（因为它们可能把<code>microtask</code>当成<code>macrotask</code>来执行了），<br>但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）</p>
<h4 id="20180126补充：使用MutationObserver实现microtask"><a href="#20180126补充：使用MutationObserver实现microtask" class="headerlink" title="20180126补充：使用MutationObserver实现microtask"></a>20180126补充：使用MutationObserver实现microtask</h4><p><code>MutationObserver</code>可以用来实现<code>microtask</code><br>（它属于<code>microtask</code>，优先级小于<code>Promise</code>，<br>一般是<code>Promise</code>不支持时才会这样做）</p>
<p>它是HTML5中的新特性，作用是：监听一个DOM变动，<br>当DOM对象树发生任何变动时，<code>Mutation Observer</code>会得到通知</p>
<p>像以前的Vue源码中就是利用它来模拟<code>nextTick</code>的，<br>具体原理是，创建一个<code>TextNode</code>并监听内容变化，<br>然后要<code>nextTick</code>的时候去改一下这个节点的文本内容，<br>如下：（Vue的源码，未修改）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(nextTickHandler)</span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line"></span><br><span class="line">observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95" target="_blank" rel="noopener">对应Vue源码链接</a></p>
<p>不过，现在的Vue（2.5+）的nextTick实现移除了MutationObserver的方式（据说是兼容性原因），<br>取而代之的是使用MessageChannel<br>（当然，默认情况仍然是Promise，不支持才兼容的）。</p>
<p>MessageChannel属于宏任务，优先级是：MessageChannel-&gt;setTimeout，<br>所以Vue（2.5+）内部的nextTick与2.4及之前的实现是不一样的，需要注意下。</p>
<p>这里不展开，可以看下<a href="https://juejin.im/post/5a1af88f5188254a701ec230" target="_blank" rel="noopener">Vue.js 升级踩坑小记</a></p>
<h3 id="浏览器内核类型"><a href="#浏览器内核类型" class="headerlink" title="浏览器内核类型"></a>浏览器内核类型</h3><p><code>KDE</code>的开放原始码<code>KHTML</code>引擎在<code>KDE</code>的<code>Konqueror</code>网页浏览器使用，后来成为<code>WebKit</code>的基础，<code>WebKit</code>是<code>Apple Safari</code>、傲游浏览器和早期<code>Google Chrome</code>网页浏览器的渲染引擎，在<code>StatCounter</code>的统计当中是最被广泛使用的浏览器引擎。<code>Chromium／Chrome</code>（iOS版除外）和<code>Opera</code>目前版本则是以<code>Blink</code>为基础，是<code>WebKit</code>的一个分支。</p>
<p><code>Mozilla</code>开放原始码专案的网页浏览器引擎<code>Gecko</code>，被<code>Mozilla</code>代码库中的各种产品所使用，其中包括<code>Firefox</code>网页浏览器、Thunderbird电子邮件客户端和SeaMonkey网路套件。<code>Goanna</code>是<code>Gecko</code>的一个分支。</p>
<p><code>Internet Explorer</code>的网页浏览器引擎<code>Trident</code>，被Microsoft Windows平台的许多应用程式如netSmart、Outlook Express、某些版本的Microsoft Outlook和Winamp、RealPlayer中的迷你浏览器所使用。<code>Trident</code>已经被<code>EdgeHTML</code>所取代。</p>
<p><code>Opera</code>软体公司的专有的<code>Presto</code>引擎被授权给其他许多软体供应商，并在<code>Opera</code>浏览器所使用，直到它在2013年被<code>Blink</code>取代。</p>
<p><a href="https://zh.wikipedia.org/zh-hans/%E6%8E%92%E7%89%88%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">排版引擎</a></p>
<h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>看到这里，不知道对JS的运行机制是不是更加理解了，从头到尾梳理，而不是就某一个碎片化知识应该是会更清晰的吧？</p>
<p>同时，也应该注意到了JS根本就没有想象的那么简单，前端的知识也是无穷无尽，层出不穷的概念、N多易忘的知识点、各式各样的框架、<br>底层原理方面也是可以无限的往下深挖，然后你就会发现，你知道的太少了。。。</p>
<p>另外，本文也打算先告一段落，其它的，如JS词法解析，可执行上下文以及VO等概念就不继续在本文中写了，后续可以考虑另开新的文章。</p>
<p>最后，喜欢的话，就请给个赞吧！</p>
<h2 id="输入任意字符到地址栏"><a href="#输入任意字符到地址栏" class="headerlink" title="输入任意字符到地址栏"></a>输入任意字符到地址栏</h2><p>第一步是浏览器对用户输入的网址做初步的格式化检查，只有通过检查才会进入下一步。<br>这里会区分你最后用的是搜索还是去那个网站. 比如输入<code>皮卡丘</code>是搜索, 输入<code>github.com</code>是去github网站.</p>
<h2 id="url的组成"><a href="#url的组成" class="headerlink" title="url的组成"></a>url的组成</h2><a href="/2019/01/31/url的组成/" title="url的组成">url的组成</a>
<h2 id="DNS解析-再具体就是chrome怎么识别网址-然后是DNS开机怎么来的DHCP"><a href="#DNS解析-再具体就是chrome怎么识别网址-然后是DNS开机怎么来的DHCP" class="headerlink" title="DNS解析(再具体就是chrome怎么识别网址, 然后是DNS开机怎么来的DHCP/)"></a>DNS解析(再具体就是chrome怎么识别网址, 然后是DNS开机怎么来的DHCP/)</h2><a href="/2018/12/26/CDN原理/" title="CDN原理">CDN原理</a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/34873227" target="_blank" rel="noopener">在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？</a><br><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">前端经典面试题: 从输入URL到页面加载发生了什么？</a><br><a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="noopener">当···时发生了什么？</a><br><a href="https://stackoverflow.com/questions/2092527/what-happens-when-you-type-in-a-url-in-browser" target="_blank" rel="noopener">what happens when you type in a URL in browser [closed]</a><br><a href="https://www.oschina.net/translate/what-happens-when-you-type-googlecom?from=20190114" target="_blank" rel="noopener">当你在浏览器中输入“google.com”并回车，会发生什么？</a><br><a href="http://www.cnblogs.com/iovec/p/7904416.html" target="_blank" rel="noopener">从输入cnblogs.com到博客园首页完全展示发生了什么</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/43369093" target="_blank" rel="noopener">浏览器输入 URL 后发生了什么？</a><br><a href="https://zhuanlan.zhihu.com/p/34453198" target="_blank" rel="noopener">从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！666</a><br><a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 666</a><br><a href="https://juejin.im/post/5c00c469f265da616413bdb8" target="_blank" rel="noopener">mac下chrome浏览器的标签页、进程和内存分配 666</a><br><a href="http://web.jobbole.com/83575/" target="_blank" rel="noopener">CSS3硬件加速也有坑</a><br><a href="https://www.jeffjade.com/2016/01/10/2016-01-10-javacript-setTimeout/#2-setTimeout%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">你所不知道的setTimeout 666</a><br><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules 666</a><br><a href="https://segmentfault.com/p/1210000012780980" target="_blank" rel="noopener">聊聊 JavaScript 与浏览器的那些事 - 引擎与线程 666</a><br><a href="https://segmentfault.com/q/1010000011914016" target="_blank" rel="noopener">process.nextTick()与promise.then()</a><br><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/" target="_blank" rel="noopener">深入浅出浏览器渲染原理</a></p>
<p><a href="https://www.cnblogs.com/lhb25/p/how-browsers-work.html" target="_blank" rel="noopener">前端文摘：深入解析浏览器的幕后工作原理 666</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/47407398" target="_blank" rel="noopener">图解浏览器的基本工作原理</a></p>
<p><a href="https://www.imweb.io/topic/58e3bfa845e5c13468f567d5" target="_blank" rel="noopener">浏览器进程？线程？傻傻分不清楚！有点多</a><br><a href="https://zhuanlan.zhihu.com/p/32751855" target="_blank" rel="noopener">聊聊 JavaScript 与浏览器的那些事 - 引擎与线程 一般般</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html#comment-text" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop 666</a><br><a href="https://segmentfault.com/a/1190000008015671" target="_blank" rel="noopener">一篇文章说清浏览器解析和CSS（GPU）动画优化 666</a></p>
<p><a href="https://segmentfault.com/a/1190000003944417" target="_blank" rel="noopener">预加载系列一：DNS Prefetching 的正确使用姿势</a><br><a href="https://segmentfault.com/a/1190000018130499?utm_source=weekly&amp;utm_medium=email&amp;utm_campaign=email_weekly" target="_blank" rel="noopener">css加载会造成阻塞吗 666</a><br><a href="https://juejin.im/post/5c148ec8e51d4576e83fd836" target="_blank" rel="noopener">从event loop到async await来了解事件循环机制 666666</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatarMogu.jpg" alt="Henry x">
            
              <p class="site-author-name" itemprop="name">Henry x</p>
              <p class="site-description motion-element" itemprop="description">this is description</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">117</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">121</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="weibo" target="_blank">weibo</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Henry x</span>

  

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.1"></script>



  



	





  





  










  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  

</body>
</html>
