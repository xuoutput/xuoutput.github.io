<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.1',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  
  <meta name="keywords" content="Hexo, NexT">


<meta name="description" content="this is description">
<meta property="og:type" content="website">
<meta property="og:title" content="Little H title">
<meta property="og:url" content="http://yoursite.com/page/11/index.html">
<meta property="og:site_name" content="Little H title">
<meta property="og:description" content="this is description">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Little H title">
<meta name="twitter:description" content="this is description">






  <link rel="canonical" href="http://yoursite.com/page/11/">


  <title>Little H title</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Little H title</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">this is subtitle</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益404</a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/08/基于-PotPlayer-和-madVR-的播放器教程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/08/基于-PotPlayer-和-madVR-的播放器教程/" itemprop="url">基于 PotPlayer 和 madVR 的播放器教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-08T11:17:40+08:00">2018-02-08</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/多媒体/" itemprop="url" rel="index"><span itemprop="name">多媒体</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接，本blog只是做个非商业学习存档<br><a href="https://vcb-s.com/archives/7228" target="_blank" rel="noopener">[VCB-Studio 科普教程 2.5] 基于 PotPlayer 和 madVR 的播放器教程</a></p>
<h1 id="VCB-Studio-科普教程-2-5-基于-PotPlayer-和-madVR-的播放器教程"><a href="#VCB-Studio-科普教程-2-5-基于-PotPlayer-和-madVR-的播放器教程" class="headerlink" title="[VCB-Studio 科普教程 2.5] 基于 PotPlayer 和 madVR 的播放器教程"></a>[VCB-Studio 科普教程 2.5] 基于 PotPlayer 和 madVR 的播放器教程</h1><p>Potplayer 是高清影视常用的播放器，界面简洁，功能齐全，比 MPC-HC 和 MPC-BE 更人性化；<strong>但其默认方案十分糟糕，预设过多错误，无法正确播放 10-bit 视频，一直饱受诟病</strong>。VCB-Stuido 以往发布的数篇高清教程大多偏重于 madVR，在 PotPlayer 的设置方面有些错漏。为了广大观众能正确、便捷地用 PotPlayer 享受高清影视，我们为大家带来一篇基于 PotPlayer 的高清影视全套 64-bit 工具链完整配置图文详解教程。</p>
<p>本教程花大力气调整 Potplayer ，<strong>很大程度上是为了纠正 Potplayer 错误的默认设置，让它能跟 MPC-HC 和 MPC-BE 站到同一起跑线上</strong>。如果 VCB-Studio 其他播放器教程中的 Potplayer 设置与本篇有冲突，<strong>以本篇教程为准</strong>。如果看不清图片，请在图片上右键点击-在新选项卡中打开，查看大图。<strong>先看完教程再跟着教程操作</strong></p>
<h1 id="工具安装篇"><a href="#工具安装篇" class="headerlink" title="工具安装篇"></a>工具安装篇</h1><p>1、为了避免版本混乱导致的bug，本教程提供所全套 64-bit 工具：</p>
<p>PotPlayer（播放器），LAV Filters（分离/解码器），madVR（视频渲染器），xy-vsFilter（通用字幕插件），xy-SubFilter（madVR专用字幕插件）。下载链接：<a href="https://pan.baidu.com/share/init?surl=jInDyOu" target="_blank" rel="noopener">百度网盘</a>  密码：fvq7</p>
<p>安装路径只允许纯英文，否则一些工具会无法使用，故建议单独建一个纯英文路径的文件夹 Tools，把这些以上提到的程序都放进去，方便更新与维护。</p>
<p>2、安装 PotPlayer 和 LAV Filters。<br>二者都是普通的 exe 安装包，双击启动即可，将安装路径设置到 Tools 文件夹，其他安装选项全默认。</p>
<p>3、安装 madVR，xy-VSFilter 或 xy-SubFilter。<br>二者都是插件，安装方法为：将压缩包解压至 Tools 文件夹中，右键点击各自的 install.bat，以管理员权限运行，若移动这些组件则需要重新安装。</p>
<p>我是按potplayer的路径，都放在里面了<br><img src="installPath.png" alt="installPath"></p>
<h1 id="PotPlayer-设置篇"><a href="#PotPlayer-设置篇" class="headerlink" title="PotPlayer 设置篇"></a>PotPlayer 设置篇</h1><h2 id="1、-显卡卡驱动设置。"><a href="#1、-显卡卡驱动设置。" class="headerlink" title="1、 显卡卡驱动设置。"></a>1、 显卡卡驱动设置。</h2><h3 id="N-卡用户"><a href="#N-卡用户" class="headerlink" title="N 卡用户"></a>N 卡用户</h3><p>打开 Nvidia 驱动面板，将红框中的动态范围参数调整至完全，蓝框的输出颜色深度调到10bpc或者8bpc（取决于显示器支持），如下图<br><img src="001-N卡驱动设置.png" alt="001-N卡驱动设置.png"><br><img src="N卡驱动2.png" alt="N卡驱动2.png"></p>
<h3 id="Intel-核显用户"><a href="#Intel-核显用户" class="headerlink" title="Intel 核显用户"></a>Intel 核显用户</h3><p>将量化范围设为全范围：</p>
<p><img src="IntelFullRange.png" alt="IntelFullRange.png"></p>
<h3 id="AMD-显卡"><a href="#AMD-显卡" class="headerlink" title="AMD 显卡"></a>AMD 显卡</h3><p>新版设置界面，选择 Full RGB：<br><img src="AMD_Full.png" alt="AMD_Full.png"></p>
<p>CCC 旧版界面，同样选择 Full RGB：<br><img src="AMDFullRange.png" alt="AMDFullRange.png"></p>
<h2 id="2、PotPlayer-选项设置。"><a href="#2、PotPlayer-选项设置。" class="headerlink" title="2、PotPlayer 选项设置。"></a>2、PotPlayer 选项设置。</h2><p>我们先用 PotPlayer 随便打开一个视频，按一下 Tab 键，调出 Potplayer 自带的 OSD 菜单，如下图。这是 Potplayer 的默认方案，读作 <strong>“a piece of shit”</strong>。接下来我们要调教它，关掉各种渣渣内置滤镜，以我们准备的各种外置滤镜代替之。<br><img src="002-pot默认方案.png" alt="002-pot默认方案.png"></p>
<p><strong>蓝色框</strong>中的 Pot 内置解码器，我们要用 LavFilters 代替；<br><strong>红色框</strong>中的视频渲染器，简称 EVR，是Windows 充话费送的渣渣，几乎所有名字中带有“影音”二字的垃圾播放器用的都是它；<br><strong>橙色框</strong>中的部分，是 Pot 内置的视频处理滤镜弄出来的，不知道它怎么 PS 画面的，故需要消灭之。</p>
<h3 id="（1）在播放界面点击鼠标右键-选项-播放，-快捷键F5-打开设置界面，开始调教-Pot-的进度条，将红框中的部分调整至如下图，其他选项也可参照图中改动。"><a href="#（1）在播放界面点击鼠标右键-选项-播放，-快捷键F5-打开设置界面，开始调教-Pot-的进度条，将红框中的部分调整至如下图，其他选项也可参照图中改动。" class="headerlink" title="（1）在播放界面点击鼠标右键-选项-播放，(快捷键F5)打开设置界面，开始调教 Pot 的进度条，将红框中的部分调整至如下图，其他选项也可参照图中改动。"></a>（1）在播放界面点击鼠标右键-选项-<strong>播放</strong>，(快捷键F5)打开设置界面，开始<strong>调教 Pot 的进度条</strong>，将<strong>红框</strong>中的部分调整至如下图，其他选项也可参照图中改动。</h3><p><img src="002-调进度条.png" alt="002-调进度条.png"></p>
<h3 id="（2）切至滤镜选项卡，关闭-Pot-内置滤镜（最重要），防止-Pot-对视频进行瞎处理，操作如下图。"><a href="#（2）切至滤镜选项卡，关闭-Pot-内置滤镜（最重要），防止-Pot-对视频进行瞎处理，操作如下图。" class="headerlink" title="（2）切至滤镜选项卡，关闭 Pot 内置滤镜（最重要），防止 Pot 对视频进行瞎处理，操作如下图。"></a>（2）切至<strong>滤镜</strong>选项卡，<strong>关闭 Pot 内置滤镜（最重要）</strong>，防止 Pot 对视频进行瞎处理，操作如下图。</h3><p><img src="003-关闭Pot内部滤镜.png" alt="003-关闭Pot内部滤镜.png"><br>如果没有关闭 Potplayer 内置图像滤镜，数据在传递给 madVR 前已经从 10-bit 砍成 8-bit 损失精度，madVR 内部再怎么精度高也是白搭。这一点 VCB-Studio 的旧版 PotPlayer 教程中最大的遗漏，它直接导致这片新教程的出现。</p>
<h3 id="（3）展开滤镜选项卡，点击-源滤镜-分离器-分支，开始载入外挂-LavFilters。点击红框中的按键，管理滤镜和解码器。"><a href="#（3）展开滤镜选项卡，点击-源滤镜-分离器-分支，开始载入外挂-LavFilters。点击红框中的按键，管理滤镜和解码器。" class="headerlink" title="（3）展开滤镜选项卡，点击 源滤镜/分离器 分支，开始载入外挂 LavFilters。点击红框中的按键，管理滤镜和解码器。"></a>（3）展开<strong>滤镜</strong>选项卡，点击 <strong>源滤镜/分离器</strong> 分支，开始载入外挂 LavFilters。点击红框中的按键，管理滤镜和解码器。</h3><p><img src="004-添加外挂滤镜.png" alt="004-添加外挂滤镜.png"><br>点击下图红框中的搜索后添加，左边蓝框会出现一堆解码器；点击确定，加载 LavFilters 完成。<br><img src="005-添加外挂滤镜2.png" alt="005-添加外挂滤镜2.png"><br><img src="005-添加外挂滤镜3.png" alt="005-添加外挂滤镜3.png"><br>点击确定后上图界面关闭，自动回到源滤镜/分离器选项卡。带*的选项都是外挂的滤镜/解码器。将红框中的所有选项都换成 Lav Splitter Source；无法切换为 Lav 的就保持原状，参考下图<br><img src="006-LAV分离器.png" alt="006-LAV分离器.png"><br>接下来，视频解码器和音频解码器也如法炮制，所有能换成 Lav 的项目全部换成 Lav。<br><img src="007-LAV视频解码器.png" alt="007-LAV视频解码器.png"><br><img src="008-LAV音频解码器.png" alt="008-LAV音频解码器.png"></p>
<p>下一步，个人滤镜优先权，添加字幕插件 xy-vsFilter（即 DirectVobSub，通用） 或 xy-SubFilter（madVR专用）。以前者为例，操作如图。<br><img src="010-字幕插件.png" alt="010-字幕插件.png"><br><img src="010-字幕插件2.png" alt="010-字幕插件2.png"><br><img src="xy-vsfilter字幕插件优先级.png" alt="xy-vsfilter字幕插件优先级.png"><br><img src="xy-vsfilter字幕插件优先级2.png" alt="xy-vsfilter字幕插件优先级2.png"><br>优先级设置上，DirectVobSub (auto-loading version) 设为强制使用，负责外挂字幕；DirectVobSub 设为按优先级使用，负责内挂字幕。</p>
<p>建议使用 madVR 的同学用 xy-SubFilter，设置方法相同，效果会好一点，Bug 也少点，支持内挂图形字幕，不支持外挂图形字幕。</p>
<p>如果要自动载入字幕，一定要让字幕文件跟视频频文件的文件名相同。</p>
<p>以上二者均可渲染内挂和外挂文字字幕（ass 和 srt 等格式），但是不能渲染外挂图形字幕（SUP 和 PGS）。外挂图形字幕请使用 Pot 内置字幕插件。</p>
<p>（个人滤镜优先权这块可以实现一些额外功能，比如一些特殊特效代码必须使用的vsFilterMod；插帧用的SVP或AFM都需要在这里加插件，但是我强烈不建议折腾这些东西。它们会极大地增加bug概率，还会造成降低精度、撕裂、鬼影等无法修复的瑕疵，其副作用足以抵消我们为优化画质所做的所有努力。）</p>
<h3 id="（4）切换至视频选项卡，设置默认视频渲染器，选择-madVR。"><a href="#（4）切换至视频选项卡，设置默认视频渲染器，选择-madVR。" class="headerlink" title="（4）切换至视频选项卡，设置默认视频渲染器，选择 madVR。"></a>（4）切换至视频选项卡，设置默认视频渲染器，选择 madVR。</h3><p><img src="012-视频渲染器选择.png" alt="012-视频渲染器选择.png"><br>madVR 的全称是 madshi Video Renderer，是 Windows 平台最强视频渲染器，调教得当的话效果媲美顶级蓝光机，当然消耗也不小。</p>
<p>屏幕 1920×1080 分辨率，则 GTX 960 / 1050 Ti 级别显卡足够体验 madVR 的所有好处；屏幕 2560×1440 或者 3840×2160 分辨率，GTX 970 / 1060 3G 级别显卡勉强可以享受所有好处，GTX 1060 6G 足够，GTX 1070 则绰绰有余。</p>
<h3 id="（5）切换至-色系-属性-选项卡，设置-YCbCr-lt-gt-RGB-规则，设为自动选择，如图。"><a href="#（5）切换至-色系-属性-选项卡，设置-YCbCr-lt-gt-RGB-规则，设为自动选择，如图。" class="headerlink" title="（5）切换至 色系/属性 选项卡，设置 YCbCr&lt;-&gt;RGB 规则，设为自动选择，如图。"></a>（5）切换至 色系/属性 选项卡，设置 YCbCr&lt;-&gt;RGB 规则，设为自动选择，如图。</h3><p><img src="013-色彩空间转换.png" alt="013-色彩空间转换.png"></p>
<h3 id="（6）音频渲染器设置"><a href="#（6）音频渲染器设置" class="headerlink" title="（6）音频渲染器设置"></a>（6）音频渲染器设置</h3><p>根据一些文档叙述，WSAPI渲染器比 Default Direct SoundDevice 效果好，具有程序独占，抗干扰，延迟低的优点；建议关闭规格化，避免 Pot 擅自改变音量。操作方式如下：<br><img src="014-音频渲染器选择.png" alt="014-音频渲染器选择.png"><br><img src="015-取消声音规格化.png" alt="015-取消声音规格化.png"></p>
<p>做完这一步，Potplayer 设置就完成了，记得点击应用和确定按钮，不然就白忙活了。</p>
<h1 id="LAV-和字幕设置篇"><a href="#LAV-和字幕设置篇" class="headerlink" title="LAV 和字幕设置篇"></a>LAV 和字幕设置篇</h1><p>本部分主要教如何切换视频、音频、字幕轨道，以及设置软解和硬解的方法。<br>随便打开一个视频，在播放界面点击右键-属性，打开此界面。点击橙色框就能进入视频/音频解码器设置界面。</p>
<p><img src="009-如何调整解码器（右键-属性）.png" alt="009-如何调整解码器（右键-属性）.png"></p>
<h2 id="（1）视频解码器-LAV-Video-Decoder-设置。LAV-的设置分为两套方案，A-方案应搭配-madVR-使用，B-方案搭配默认的-EVR-CP-使用。"><a href="#（1）视频解码器-LAV-Video-Decoder-设置。LAV-的设置分为两套方案，A-方案应搭配-madVR-使用，B-方案搭配默认的-EVR-CP-使用。" class="headerlink" title="（1）视频解码器 LAV Video Decoder 设置。LAV 的设置分为两套方案，A 方案应搭配 madVR 使用，B 方案搭配默认的 EVR(CP) 使用。"></a>（1）视频解码器 LAV Video Decoder 设置。LAV 的设置分为两套方案，A 方案应搭配 madVR 使用，B 方案搭配默认的 EVR(CP) 使用。</h2><p><strong>A</strong>：如果使用 madVR，橙色框中的 Output Format 勾选除了 AYUV 以外的所有选项；RGB Output Level选 PC；Dither Mode 选 Random。LAV 默认设置就是如此，如图所示。<br><img src="LAV-all.png" alt="LAV-all.png"></p>
<p><strong>B</strong>：如果使用 EVR（自动选择），橙色框中的 Output Format 只勾选 RGB24 选项；其他同上。（仅供需要省电或显卡性能不足者使用）<br><img src="LAV-RGB24.png" alt="LAV-RGB24.png"></p>
<p><strong>为什么 madVR 和 EVR 勾选方式不同？</strong></p>
<p>因为 madVR 能正确处理 LAV 解码出的所有数据，LAV 解码出的数据原封不动喂给 madVR 就是最好的，这是 madVR 被称作最强视频渲染器的主要原因之一。然而 EVR 只支持处理 8-bit 数据，LAV 解码出的 10-bit YUV 数据会被 EVR 直接砍成 8-bit YUV 进行处理，导致精度大幅降低，色带满天飞，这也是Pot 默认方案读作 a piece of shit 的主要原因之一；如果让 LAV 解码后将 10-bit YUV 转为 RGB24，也就是 8-bit RGB，再喂给 EVR 处理，可避免精度大幅损失。</p>
<p>渲染器 madVR 和 EVR 可以在 pot 的播放界面快速切换，方法是：右键-视频-视频输出设备。切换渲染器的同时，记得要修改对应的 LAV Video Decoder 设置。再次强调，A 方案配 madVR 使用，B 方案配 Potplayer 默认的 EVR 使用。</p>
<p>很多使用 madVR 的观众被这篇供非 MadVR 用户使用的教程 <a href="https://vcb-s.com/archives/4384" target="_blank" rel="noopener">https://vcb-s.com/archives/4384</a> 误导，只勾选了 RGB24，导致 madVR 没有接收到 LAV 解码出的正确的数据。</p>
<h2 id="（2）硬解相关设置。"><a href="#（2）硬解相关设置。" class="headerlink" title="（2）硬解相关设置。"></a>（2）硬解相关设置。</h2><p>N 卡 GTX 950 / GTX 960 / GTX 1000 全系列、A 卡 4 系 5 系全系列以及 Intel 七代（Kaby Lake）处理器集成显卡可硬解 HEVC 10-bit YUV420 视频。</p>
<p>常见显卡都能硬解 AVC 8-bit YUV420 视频，所有显卡都不能硬解 AVC 10-bit 视频。接下来以 HEVC 10-bit YUV420 的视频进行示范。</p>
<p>CPU 软解 + madVR 示范，注意绿框中的 Active Decoder 和红框中的输出：<br><img src="016-LAV解码器设置与HEVC-10bit-软解示范.png" alt="016-LAV解码器设置与HEVC-10bit-软解示范.png"></p>
<p>蓝色和绿色框中是解码器选项，如果使用 CPU 软解，则选择 None；如果使用显卡 GPU 进行硬解，则选择 DXVA2 (copy-back) 或 DXVA2 (native)，A/N 都可用，前者兼容性更好，后者更节省 CPU；如果使用英特尔核显，则选用 Intel QuickSync；NVIDIA CUVID 是 N 卡专用硬解方式，基本用不上。</p>
<p>DVXA2 (native)硬解 + madVR 示范：<br><img src="017-LAV解码器设置与HEVC-10bit-硬解示范.png" alt="017-LAV解码器设置与HEVC-10bit-硬解示范.png"></p>
<p>红框中显示 dxva，实际上输出依然是 P010，橙框中的 Active Decoder 为 dxva2n，OK 表明显卡支持此硬解方式。DXVA2 (copy-back) 和其他硬解方式都类似。</p>
<p>解码方案优先级推荐：CPU软解 &gt; DXVA2(copy-back) = Intel QuickSnyc &gt; DXVA2(native) &gt; NVIDIA CUVID （建议没事别用硬解，因为偶尔会出现 bug，况且大多数人也不缺这点 CPU 性能）</p>
<h2 id="（3）音频解码器-LAV-Audio-Decoder-设置。仅有一项需要调整，勾选-Enable-Mixing。"><a href="#（3）音频解码器-LAV-Audio-Decoder-设置。仅有一项需要调整，勾选-Enable-Mixing。" class="headerlink" title="（3）音频解码器 LAV Audio Decoder 设置。仅有一项需要调整，勾选 Enable Mixing。"></a>（3）音频解码器 LAV Audio Decoder 设置。仅有一项需要调整，勾选 Enable Mixing。</h2><p><img src="018-LAV音频解码器-混音设置.png" alt="018-LAV音频解码器-混音设置.png"></p>
<p>由于绝大部分人都使用双声道设备，所以遇到 5.1 声道音轨时，只有左/右两声道会被耳机/音响接收，其他声道都直接丢弃了。所以，一般来说我们应让 LAV 把多声道混流成双声道（Stereo）再输出；玩多声道音响的土豪请随意。</p>
<h2 id="（4）字幕处理"><a href="#（4）字幕处理" class="headerlink" title="（4）字幕处理"></a>（4）字幕处理</h2><p>我们已经在上面设置好了 xy-vsfilter 或 xy-Subfilter 字幕插件，所以要关闭 Pot 内置渣渣字幕插件，否则就会出现两行字幕的奇观，右键-字幕-取消勾选显示字幕，如图。字幕应该跟视频放在同一目录下，且与视频文件同名，会被自动加载，字幕由 DirectVobSub 或 xy-SubFilter 控制，而非 Potplayer。<br><img src="020-关闭Pot内置字幕滤镜.png" alt="020-关闭Pot内置字幕滤镜.png"></p>
<h2 id="（5）切换多字幕轨-多视频-多音轨"><a href="#（5）切换多字幕轨-多视频-多音轨" class="headerlink" title="（5）切换多字幕轨/多视频/多音轨"></a>（5）切换多字幕轨/多视频/多音轨</h2><p>使用右下角的任务栏里 LAV 和字幕插件 DirectVobSub 或 xy-SubFilter 的图标。很多观众都不知道 VCB-Studio 以及其他压制组制作的 BD 往往含多条音轨，比如文件名中含 2flac、flac_aac、FLACX2 等字眼的 mkv，以及外挂 mka。这意味着视频带有多音轨，可能是 5.1，也可能是声优或是 staff 评论音轨，可以切换着使用。<br><img src="020-如何切换字幕轨和音频轨（右下角任务栏）.png" alt="020-如何切换字幕轨和音频轨（右下角任务栏）.png"></p>
<p>切换音轨也可以直接点击右键-声音-选择声音来实现，进行切换；视频轨同理，不过多音轨很常见，而多视频轨几乎见不到。<br><img src="021-在potlapyer内切换音轨-02.png" alt="021-在potlapyer内切换音轨-02.png"></p>
<h1 id="madVR-调教篇"><a href="#madVR-调教篇" class="headerlink" title="madVR 调教篇"></a>madVR 调教篇</h1><p>madVR 的核心优势有两个：</p>
<p>1、高精度的数据处理，避免画面失真，产生色带、锯齿等瑕疵；</p>
<p>2、高质量的缩放算法，在片源分辨率低于屏幕分辨率时，提供更清晰、更锐利的画面，算法甚至优于很多高级蓝光机。</p>
<p>madVR 功能强大，其调教也大有学问，本篇教程不再赘述 madVR 调教具体步骤，详情请见我们之前做过的 madVR教程: <a href="https://vcb-s.com/archives/5610" target="_blank" rel="noopener">[VCB-Studio 科普教程 2] madVR 渲染器配置教程</a></p>
<p>如果教程也无法满足你的需求，欢迎有耐心、有基础者钻研：万年冷冻库 最强渲染器——madVR设置研究   </p>
<p>以上，以 Potplayer 为基础的高质量播放器工具链设置完成，请尽情享受高清影视的乐趣吧！</p>
<p>关于一些问题的统一回复：</p>
<p>1、为什么使用 madVR 全屏时候会黑屏？</p>
<p>答：黑短短几秒是正常的，表明 madVR 正在切换至全屏独占模式（fullscreen exlucsive mode，简称 FSE ），这个模式有一些好处，比如防止画面撕裂。</p>
<p>如果你不喜欢 FSE 模式，可以在 madVR 中关闭它，具体操作为：取消勾选 madVR 的控制面板里的 rendering -&gt; general settings -&gt; enable automatic fullscreen exlucsive mode 选项。</p>
<p>2、为什么全屏 FSE 模式下点鼠标/切音轨/切换字幕/拉进度条画面会闪？</p>
<p>答：因为全屏模式就是给你看视频用的，任何操作都应该在按 Enter 键 或 点击鼠标中键 退回到 窗口模式 后再进行。</p>
<p>此外，全屏模式下完全可以用键盘轻松控制，比如 ←/→  默认 后退/前进 5s；Ctrl + ←/Ctrl + → 默认后退/前进 30s；Ctrl + PageUp / Ctrl + PageDown 默认后退/前进 至上/下一章节，这些实用的快捷键都可以在 Potplayer 的设置里找到并定制。</p>
<p>3、为什么 EVR 和 madVR 切换时会卡死？</p>
<p>答：播放过程中， madVR 渲染器和 EVR 渲染器相互切换可能导致卡死，故建议尽量在暂停时切换。同理，任何切换字幕、音轨等操作，如果出现问题，应先暂停再操作；如果还不行，尝试关闭视频，重新打开。</p>
<p>4、为什么我按照教程设置还有这样那样的 Bug ？</p>
<p>答：最安全的方式是使用本教程文首提供的安装包，并按照教程从头重新设置 Potplayer。 Potplayer 本身就是个问题大户，版本号还那么多，导入 reg 文件导致的 Bug 也五花八门，无从下手。但按照本文的步骤从头设置，至少能将出问题的概率压到最低。我在许多台电脑上，按照本文的步骤设置过 LAV + Potplayer + madVR，从没出现过 Bug。</p>
<p>5、如何配合此教程的方案使用插帧/倍速播放/截图/录制等功能？</p>
<p>答：自己动手，丰衣足食，以上大多数功能可以由 Potplayer 本身实现，但不保证在使用 madVR 后还能用。本教程的目的是提供基本完美的视频播放功能，是为欣赏视频用的，不是拿来折腾的，不可能为各种细枝末节的需求做定制调整。更何况即使我们有心，播放器本身也未必能实现。</p>
<p>6、为何我的画面是上下颠倒的？为何我的 madVR 老是崩溃？</p>
<p>答：这两个问题大多是由 xy-vsFilter 造成的，因为 xy-vsFilter 存在不少 Bug，本教程以 xy-vsFilter 作为字幕插件纯粹是为了照顾无法使用 madVR 的用户。因此，只要你电脑能跑得动 madVR ，我都强烈建议改用 madVR + xy-SubFilter 的组合。各种字幕插件至今都是 beta 版，madVR 也是，如果出了问题，除了更新到最新的版本，也没什么更好的办法。实在不行那就用播放器自带吧，mpv、mpc-hc 和 mpc-be 自带的字幕插件尚且堪用；Potplayer 变黄前自带的字幕功能也勉强凑合，但变黄后就是一坨 shit。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/07/那些播放器教程背后的知识/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/那些播放器教程背后的知识/" itemprop="url">那些播放器教程背后的知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T20:57:45+08:00">2018-02-07</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/多媒体/" itemprop="url" rel="index"><span itemprop="name">多媒体</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下原文链接，非商业存个档学习<br><a href="https://vcb-s.com/archives/4567" target="_blank" rel="noopener">[VCB-Studio 科普教程 5] 那些播放器教程背后的知识</a></p>
<h1 id="VCB-Studio-科普教程-5-那些播放器教程背后的知识"><a href="#VCB-Studio-科普教程-5-那些播放器教程背后的知识" class="headerlink" title="[VCB-Studio 科普教程 5] 那些播放器教程背后的知识"></a>[VCB-Studio 科普教程 5] 那些播放器教程背后的知识</h1><p>几乎一年前，我们写了一篇科普向的文章：<a href="http://vcb-s.com/archives/2726，意外地广受大家好评。很多读者在评论中表达了希望有后续科普的意愿，今天我们为大家带来这个系列的后续篇。" target="_blank" rel="noopener">http://vcb-s.com/archives/2726，意外地广受大家好评。很多读者在评论中表达了希望有后续科普的意愿，今天我们为大家带来这个系列的后续篇。</a></p>
<p>阅读本篇之前，请务必确保你基本理解了科普三（上文链接）的内容。如标题所示，本篇致力于讲述播放器相关的知识，而不是任何播放器安装教程。<br>这篇教程的目的是，为那些希望折腾一个更好播放器的观众，讲述一些平时你阅读的教程，不会跟你说的重要知识，来解答以下问题：</p>
<ul>
<li><p>播放器播放视频，是怎样的一个流程？</p>
</li>
<li><p>硬解和软解的区别优劣在哪里？</p>
</li>
<li><p>什么样的播放效果是最标准、最原汁原味的？</p>
</li>
<li><p>为什么高级播放器教程全写的那么繁琐复杂，还特容易各种出错？</p>
</li>
<li><p>为什么动漫压制特别喜欢用10bit，而且播放器动不动推荐madVR？</p>
</li>
<li><p>不同精度在播放器中的标识是怎样？怎么判断播放过程是否对画质有折扣？</p>
</li>
<li><p>SVP/Reclock/XySubFilter是怎样插件？</p>
</li>
<li><p>我应该怎样选择合适我的播放环境？</p>
</li>
</ul>
<h1 id="本教程将分以下模块详细叙述："><a href="#本教程将分以下模块详细叙述：" class="headerlink" title="本教程将分以下模块详细叙述："></a>本教程将分以下模块详细叙述：</h1><ol>
<li><p>播放器的工作流程：分离，解码，渲染</p>
</li>
<li><p>硬解的定义、分类</p>
</li>
<li><p>YUV-&gt;RGB转换过程中的细节</p>
</li>
<li><p>硬解的优劣与选择</p>
</li>
<li><p>图像格式的标识与查看方法</p>
</li>
<li><p>动漫画面区别于常规录制视频的特殊性</p>
</li>
<li><p>播放器软件的现状与分析</p>
</li>
<li><p>其他常见播放器配件简介</p>
</li>
<li><p>播放器配置学习的建议</p>
</li>
</ol>
<h1 id="1、播放器的工作流程：分离，解码，渲染"><a href="#1、播放器的工作流程：分离，解码，渲染" class="headerlink" title="1、播放器的工作流程：分离，解码，渲染"></a>1、播放器的工作流程：分离，解码，渲染</h1><p><strong>简单说就三个大步骤：分离、解码、渲染。</strong></p>
<p><strong>分离</strong>，指的是拿到媒体文件(MKV/MP4/MKA)等，先收集相关的文件（包括外挂音轨、字幕），然后<strong>将所有轨道拆开</strong>，拆分成单独的内容。视频流、音频流、字幕、章节信息，等等。负责执行分离的模块滤镜，叫做<strong>分离器(splitter/demuxer)</strong>。</p>
<p>当同样类型的轨道不止一条的时候（比如多音轨），分离器还负责挑选其中的一条。通常同类型多轨道，会有一条轨道被设定为“默认轨”（比如多音轨MKV一般以主音轨为默认），你想选择副音轨，你就需要在分离器中手动切换。<strong>很多播放器会在自己的界面中提供音轨/字幕切换的功能，其实也是间接利用分离器实现的。</strong></p>
<p><strong>分离器现在能用的基本上只有LAV/ffmpeg了</strong>（这俩几乎可以算一家），以前还有个Haali，然而停止更新已久，不能适应HEVC时代了。</p>
<p>分离器一般不耗费运算性能。因为它只是简单地收集、拆分和选择。</p>
<p><strong>解码</strong>，指的是将分离器丢来的各种原生压缩格式，<strong>比如H264/H265的视频，FLAC/AAC的音频，解码为非压缩的格式，比如视频是YUV/RGB（相当于bmp），音频是PCM（相当于wav）</strong>，然后丢给下游模块。负责解码的模块滤镜称为解码器(decoder)。<strong>常见的有LAV/ffmpeg</strong>, ffdshow(同样停止更新了)……</p>
<p>当解码器能完全解码一个轨道中所有有效信息的时候，我们成为<strong>完全解码</strong>（现在绝大多数情况是如此），否则称为不完全解码。比如说，早期一些显卡的硬解，不能完全处理H264视频流的所有，解码出的画质有折扣；又或者DTS-HD MA解码器开源之前，基于ffmpeg/lav等解码器只能解码出部分信息，导致音频是有损的。</p>
<p><strong>解码出来的格式，都需要加上精度的度量</strong>。比如说10bit 视频完全解码后是YUV 10bit，8bit视频是YUV 8bit，16bit flac格式是PCM 16bit整数，aac是PCM 32bit浮点。<strong>麻烦在于，解码器下游的模块不见得能照单全收</strong>。比如说以前播放器就不支持10bit YUV丢给下游，解码器只好转为YUV 8bit（后来madVR之所以是一个极大的提升，就是因为<strong>madVR基本上全部通吃</strong>）。<strong>同理；很多声卡能支持24bit整数PCM已经是极限</strong>，所以32bit浮点的PCM需要转为24bit整数。</p>
<p>如果解码器可以将最原始的数据，或者更高精度（比如有时候为了方便，将10bit转为16bit）输出给下游，我们称为<strong>全精度输出</strong>；否则，解码器会试图降低精度输出，我们称为低精度输出。少数时候，我们会让解码器做一些转换（比如vcb-s新播放器教程中，让lav解码器做YUV-&gt;RGB的转换），我们称为<strong>转换输出</strong>。</p>
<p><strong>解码器，特别是视频解码器，往往成为大量消耗运算资源的地方</strong>。这个问题在H264早期非常严重，那时候的主流CPU很难负担720p/1080p的高清解码，能耗巨大，移动平台尤其如此。<strong>所以才催生了各种硬件加速和硬件解码</strong>，并逐渐成为一个规范标准。</p>
<p><strong>渲染</strong>，指的是将解码后的数据，在pc硬件上（显示器、扬声器）进行播放。负责渲染的模块我们称之为渲染器(Render)，视频渲染器主流有<strong>EVR</strong>（Enhanced Video Render, 微软送的）以及<strong>madVR</strong>(madshi Video Render)。</p>
<p>音频渲染器一般都是系统自带的（同样是微软送的），也有可以自定义的。比如MPC播放器有MPC Audio Render，可以支持类似wasapi输出等其他功能。</p>
<p><strong>因为显示器是RGB显示</strong>，而解码后的视频多为YUV格式，<strong>渲染器一般也需要负责将YUV转换为RGB</strong>，并保证输出的图像大小跟播放窗口吻合。</p>
<p>多数播放器自带的滤镜（mpc/pot都有很多调色之类的功能），显卡的加成，以及SVP，都作用于解码器和渲染器中间。它们接过解码器解码的数据，对其进行处理，然后将处理后的数据送给渲染器。因为渲染器是需要借助显卡进行图形运算，YUV数据基本上需要先进入显存，所以显卡可以检测到丢来的YUV数据，对其进行“优化”。同样需要当心的是，这些滤镜和处理，往往入口精度低，处理精度也低。导致的后果就是解码器被迫低精度输出，给这些滤镜低精度处理，从而大幅降低视频精度，导致色带色块问题。</p>
<p>字幕的加载可能在渲染器前（将字幕信息整合进YUV/RGB数据给渲染器），也可能在渲染器后（播放器来将字幕整合入生成完毕的RGB图像）。</p>
<p>多数解码包的配置界面，主要就是让你选择分离器、解码器和渲染器的：<br><img src="pc05.jpg" alt="pc5"><br>如上图，上方就有让你选择视频渲染器，然后下方左右分别是针对不同文件格式的分离器，以及针对不同媒体格式的解码器。</p>
<h1 id="2-硬解的定义与分类"><a href="#2-硬解的定义与分类" class="headerlink" title="2. 硬解的定义与分类"></a>2. 硬解的定义与分类</h1><p>如上文所说，<strong>硬解是为了缓解高分辨率新编码面世初期，CPU不堪重负的解码压力，而诞生的技术</strong>。如果说<strong>软解</strong>的定义是：<strong>利用CPU通用运算能力</strong>，进行解码，那么硬解的定义可以这么说：不利用CPU通用运算能力，而是依赖其他集成电路，无论是否特制，来进行解码。</p>
<p>更古老的时候，有些<strong>显卡没办法进行完全解码</strong>，只是帮助计算部分解码过程中的运算，那么可以归为“<strong>硬件加速</strong>”。估计Intel下一代CPU“混合加速HEVC解码”也是一样的道理。</p>
<p>硬解现在比较常见的是以下<strong>种类</strong>：</p>
<p><strong>DXVA</strong>(DirectX Video Acceleration)，比较古老的方案了。Windows XP以及之前系统上流行的。上古ffdshow的硬解就是利用DXVA。DXVA规范下容易出现不完全解码，导致画质降低。Vista以后，渐渐地被抛弃。</p>
<p><strong>DXVA2</strong>，<strong>目前主流的硬解方式。主要由GPU来实现</strong>，但是并非利用GPU的流处理器，INA三家都是使用了<strong>单独附在GPU芯片上的一块专职电路</strong>来完成。<strong>GPU硬解能力往往不与显卡游戏性能相关，而与搭载的专职电路先进与否相关</strong>。典型的就是GT610，它是NVIDIA第一款能硬解4K视频的GPU，同时代其他GTX650/GTX580什么面对4K视频只有傻眼的份儿，就因为它的GPU塞入的专职电路，是刚开发出最先进的一款（代号为VP5，其他同时代的都是VP4）。</p>
<p>使用DXVA解码，都需要先将视频数据（压缩的格式）传输到显存中，然后再让GPU进行解码。</p>
<p><strong>DXVA2有两种实现方式：native和copy-back</strong>。区别是解码后的数据是否还要传回内存。</p>
<p>native选择不传，直接丢给同样依赖GPU工作的渲染器，数据从头到尾都在显存中。而copy-back选择传，数据会传回内存，一番处理后再传回显存，让渲染器工作。<strong>native的输出必须为YUV 8bit，而copy-back则可以为10bit</strong>。</p>
<p>之所以需要有copy-back这么个传来传去的过程，<strong>就是因为有些滤镜，比如SVP，比如LAV的转格式，必须依赖CPU+内存进行工作</strong>。不传回来没办法继续处理。copy-back保证了硬解的流程类似软解，可以不漏下任何后处理。而代价是传来传去必定降低性能，增加能耗。需要注意的是，即便用native，也可能导致解码后的数据被“优化”，因为有些处理，包括播放器、显卡驱动带的那些，是可以完全作用在GPU环境中的。</p>
<p>除了DXVA2，<strong>还有两种特殊的硬解：Intel Quick Sync, 和NVIDIA CUVID</strong>。如同名称所示，它们是Intel和NV的专属。</p>
<p><strong>Intel Quick Sync是集成在CPU中的逻辑电路承担的。注意的是这玩意并非隶属于Intel的集显，而是CPU的直属</strong>。它直接读写内存，运行表现和软解非常类似。Intel Quick Sync堪称速度快，能耗低。</p>
<p><strong>NVIDIA CUVID，是基于NV自己的接口，写的一个类似DXVA2(copy-back)的升级版。</strong></p>
<p>硬解的模式可以在LAV Decoder的设置中选择：<br><img src="banner26.jpg" alt="banner26.jpg"><br>红框的下拉框可选None(软解)，CUVID，QuickSync，DXVA2(native 和 copy back)。</p>
<p>每选择一个模式（除了None），蓝框会显示一个单词：</p>
<p>Active：当前正在使用这种模式解码</p>
<p>Available：应该可以使用这种模式</p>
<p>Not Available：不支持使用这种模式</p>
<p>绿框当中则是显示当前在使用哪个解码器。如果是软解，显示avcodec，否则显示类似dxva2cb, dxva2n等标示。</p>
<p><strong>碰到没办法开启硬解，比如设备不能正常工作，或者碰到10bit AVC这种不支持的，那么自动转为软解。</strong></p>
<h1 id="3、YUV-gt-RGB转换过程中的细节"><a href="#3、YUV-gt-RGB转换过程中的细节" class="headerlink" title="3、YUV-&gt;RGB转换过程中的细节"></a>3、YUV-&gt;RGB转换过程中的细节</h1><p>将解码器输出的YUV格式，转为RGB，并且缩放到播放窗口输出，是视频渲染器的职能。可以说，如果解码过程是完全解码，也不主动添加播放器调校和驱动增强，渲染的环节决定了最终成品的画质。<strong>造成画质区别的可以说就三点：缩放算法，运算精度，和抖动算法</strong>。任何试图优化渲染器效果的尝试，都应该从这三个方面着手。</p>
<p><strong>缩放算法</strong>造成的区别，比较好理解。例如原图(150<em>150)：<br><img src="kanade.png" alt="kanade.png"><br>用双线性算法（上，多数播放器默认算法）和nnedi3(下)放大到272 </em> 272像素：<br><img src="19867d.png" alt="19867d.png"><br><img src="20153.png" alt="20153.png"></p>
<p>不同算法造成的效果肉眼可见。注意上图中随处可见的锯齿，以及细线的模糊。</p>
<p><strong>精度</strong>，是指运算的过程中，参与运算的数，有效位数的高低。在计算机中表现为使用怎样的格式来进行，8bit/16bit/32bit整数，16bit/32bit浮点。精度不足的表现在上篇教程中已经有展示，不做赘述，然而还是提醒一句：千万不要以为显示器是8bit，就认为8bit 整数 的片源精度/处理精度是足够的。</p>
<p>另外，RGB处理相对YUV处理，精度要求相对较低；或者说，RGB处理相比较，精度稍低带来的影响不明显。（不幸的是多数时候处理的数据都是YUV，然后根据水桶原理……）<strong>播放过程中，应该尽量减少RGB-YUV互转的次数</strong>，每一次转换都要做一次计算与取整，都会导致实际精度降低。</p>
<p><strong>抖动算法</strong>(Dithering Algorithm)，通常出现在高精度转低精度中。在数字图像高转低处理中，全部四舍五入不见得是好习惯。<strong>抖动算法通过科学的添加噪点，来掩盖精度的不足</strong>。比如说原图（RGB24，即RGB 8bit）：<br><img src="output0.png" alt="output0.png"><br>分别用四舍五入（上） 和 Floyd–Steinberg 抖动算法（下），将此图转为RGB16(RGB分别为5bit，6bit和5bit，早期windows桌面的“16色”，区别于RGB24的“真彩色”)<br><img src="output00e38b.png" alt="output00e38b.png"><br><img src="output012c78.png" alt="output012c78.png"></p>
<p>可以看出，使用抖动算法的图片较好的掩盖了精度不足引起的色带和偏色问题。在YUV 和 RGB的运算过程中，如果出现高精度转低精度，是否使用抖动，使用的抖动算法如何，也会决定输出效果。</p>
<p>现在，我们来模拟一下渲染器的工作流程，并用蓝色标注出可能造成画质差别的地方：</p>
<p>1、渲染器从解码器那里获取YUV数据。注意拿到的数据可能是全精度，也可能是降精度，取决于渲染器接口类型；</p>
<p>2、播放器和显卡驱动可能会试图“优化”画面；</p>
<p>3、如果不是YUV444格式的，渲染器会先将UV平面放大到Y平面的大小。这个步骤称为Chroma upscaling；</p>
<p>4、将YUV444的数据，转为RGB。转换的过程势必需要浮点运算（YUV-&gt;RGB一些参与运算的常数是浮点数）；</p>
<p>5、播放器或者渲染器将RGB用特定的算法缩放到播放窗口大小。这个步骤称为Image Upscaling(图像放大)/Downscaling(图像缩小)；</p>
<p>6、因为4的步骤中，必须以浮点数运算，而输出结果一定是RGB 8bit整数，因此输出之前必须有一个高转低的过程。</p>
<p>2~6每一步都涉及数字运算，因此有运算精度的区别。</p>
<p><strong>问：什么样的渲染器，什么样的输出画面是标准的、完美的？</strong><br>答：没有。因为运算精度总可以无限的高，缩放算法也永远有提升的空间，所以视频播放不存在“标准、完美”一说；只有相比较而言的好与差，以及在人眼识别程度内的“接近完美”</p>
<p><strong>问：有哪些渲染器能“接近完美”的处理以上所有情况？</strong><br>答：只有madVR。</p>
<p><strong>问：Windows充话费送的那个EVR，默认情况下有啥不好？</strong><br>答：1、接口精度低，强迫YUV 8bit/RGB 8bit的输入；2、缩放算法默认是平庸的双线性；3、运算精度较低，默认只有8bit整数和16bit浮点数；4、抖动算法有，较为单一和固定；5、如果输入的是YUV数据，EVR会任由播放器和驱动乱来。</p>
<p><strong>问：我们能怎么拯救EVR？</strong><br>答：1、因为RGB对精度要求不敏感，而且输入RGB后，驱动和播放器基本没办法插手，所以设法永远输入RGB 8bit，不让YUV数据经过低精度处理；2、让LAV解码器来做YUV-&gt;RGB。LAV可以以32bit浮点的高精度、双立方的UV放大算法、随机抖动算法，较高质量的完成转换；3、图像缩放算法手动设置为更高级的双立方。</p>
<p><strong>问：听上去不错，我们应该怎么操作？</strong><br>答：参见<a href="http://vcb-s.com/archives/4384或者http://vcb-s.com/archives/4407" target="_blank" rel="noopener">http://vcb-s.com/archives/4384或者http://vcb-s.com/archives/4407</a></p>
<p><strong>所以，如果你使用的是madVR渲染器，你应该允许LAV输出它默认设置的那些格式，YUV/RGB。LAV会以全精度输出YUV给madVR进行处理；如果你使用EVR渲染器，你应该永远只允许LAV输出RGB 8bit。</strong></p>
<p>RGB 8bit 包括RGB24和RGB32。RGB32多一个透明层通道，看似带了个没用的东西，但是因为计算机更喜欢2的次方，所以部分运算下RGB32比RGB24快。在视频播放中，这两个格式几乎完全等同；互转也人畜无害（加一个空的透明度通道 vs 去掉透明度通道）。</p>
<p>之前基于EVR CP教程中，之所以pot推荐RGB24输出，而mpc推荐RGB32输出，是测试的结果。这样设置播放器不会再多一次转换（虽然就算转换了也没啥）</p>
<h1 id="4、硬解的优劣与选择"><a href="#4、硬解的优劣与选择" class="headerlink" title="4、硬解的优劣与选择"></a>4、硬解的优劣与选择</h1><p><strong>绝大多数vcb-s的教程，都让大家不要开启硬解，就算开启，优先使用DXVA2(copy-back)，这里我们做一个详细的解释。</strong></p>
<p>首先考虑一个问题：什么样的视频能被硬解？</p>
<p>8bit AVC可以被各种显卡硬解；然而8bit AVC格式的软解压力小的可怜，以vcb-s常发的24fps 1080p的视频算，现在CPU软解，占用率普遍不到5%。</p>
<p>10bit AVC没有能硬解的。（所以10bit版炮姐时代，试图硬解的洗洗睡吧。）软解，解码压力尚可，不是很可怕，24fps 1080p的视频，现在的cpu大约10%</p>
<p>8bit HEVC现在最新显卡普遍能硬解；然而因为8bit x265的缺陷（或者说8bit x264的优越性），我们发现这玩意表现多数还不及8bit AVC，所以vcb-s从来不用；相对而言，它的解码压力也不大，大致相当于10bit AVC。</p>
<p>10bit HEVC，目前只有NV的GTX950和GTX960支持硬解。它的软解压力算是比较大，现在主流的CPU占用在20%左右；对于上古CPU或者一些低端笔记本CPU，流畅解码会比较吃力，特别是60fps的特典。对于将来的4K 60fps，现在桌面4核心CPU基本上完全无力软解。</p>
<p><strong>能硬解的视频必须是YUV420格式</strong>。</p>
<p>分析完毕了，你觉得自己需要硬解么？</p>
<p>如果你没有GTX960/GTX950，你也基本碰不到1080p 60fps乃至4K的8bit HEVC，那么你只能去硬解8bit AVC，省那么5%不到的CPU占用率——真有这个必要么？软解吃力的硬解解不了，硬解解得了的软解解的飞起，那我们为什么要冒着各种潜在风险去开硬解呢？</p>
<p>好吧，就算你说我真有理由要开硬解：我有GTX960/950，我的CPU真的太烂……我们来分析下不同情况下，硬解应该怎么开。硬解设置跟你使用的渲染器有关：</p>
<p>如果你使用madVR，通常是不建议你开硬解的。众所周知madVR会消耗大量显卡运算，因此没必要再去把大量数据塞进GPU和显存，跟madVR抢夺资源。让CPU分担解码，让GPU专心跑madVR，是比较推荐的做法；</p>
<p>如果你使用GTX960/950硬解10bit HEVC，请务必设置为DXVA2(copy-back)，这是现在唯一可以开启10bit HEVC硬解的模式；</p>
<p>其他情况下，如果你真的非要开硬解搭配madVR，建议顺序（保证你硬件可用）： Intel QS, DXVA2(native), NV CUVID, DXVA2(copy-back)，其实用哪个都没有太多关系，主要的功耗消耗点在madVR。</p>
<p>如果你使用EVR CP（调节过缩放算法），希望追求较高质量的播放，你首先要排除的是DXVA2(Native)。因为这种模式下，LAV会直接输出YUV 8bit给显卡，哪怕强制规定了输出只能是RGB。用DXVA2(copy-back)是可以的；这种模式下，解码后的数据将回传给CPU，继续做高质量转RGB的后续操作。</p>
<p>如果你使用GTX960/950硬解10bit HEVC，请务必设置为DXVA2(copy-back)，理由同上，并且也需要强制RGB输出。</p>
<p>其他情况下，建议顺序： Intel QS, NV CUVID, DXVA2(copy-back)</p>
<p>所以不难理解为什么之前教程我说了，要开硬解请用DXVA2(copy-back)。这种软解流程、硬解运算的泛用性模式，是最人畜无害的，哪怕这种模式折腾程度，导致在性能和功耗上大多是得不偿失。</p>
<p>追求最大性能的，特别是用来对付那些能够被硬解的高清病毒的，请使用EVR默认，搭配DXVA2(Native)播放。这样效率应该是最高的，各种专治8bit AVC 4K的高清病毒。只不过这种做法会损失画质，因此不建议日常使用。</p>
<h1 id="5、图像格式的标识与查看方法"><a href="#5、图像格式的标识与查看方法" class="headerlink" title="5、图像格式的标识与查看方法"></a>5、图像格式的标识与查看方法</h1><p>在播放器中，不同格式、不同精度的图像，有着规范的定义和标号。这一点可以在LAV的设置界面很清楚的看到：<br><img src="20154.png" alt="20154.png"><br>其中蓝色部分标示的这些是最常见到的，主要是YUV 420的不同精度，以及RGB格式（注意16bit RGB，即RGB48，在现有播放器体系下还没有实装，所以现在播放器中的RGB基本就是RGB 8bit）</p>
<p>使用DXVA2(Native)硬解的时候，输出是DXVA，也是YUV420 8bit。</p>
<p>RGB格式除了上文所说的RGB32和RGB24，播放器中还有XRGB和ARGB的标示，也都是一回事儿。</p>
<p>Potplayer中观察方法，可以用tab键显示：<br><img src="banner261.jpg" alt="banner261.jpg"></p>
<p>potplayer会给出视频解码器（图中是LAV）</p>
<p>解码器输入的格式是HVC1(HEVC)，输出是RGB给渲染器。YUV-&gt;RGB的过程完全是LAV处理。</p>
<p>渲染器是EVR CP，渲染整个过程，格式都是RGB，没有转回YUV。需要注意的是你必须关闭pot自带的内置滤镜（按F5，进入”参数选项”设置。 2、点击“滤镜”，将右边的”内置图像处理滤镜设置”激活条件设置为：”不使用”），否则potplayer一定会自作主张转回YUV的。</p>
<p>缩放算法是Lanczos 3。(注意如果你播放画面跟视频画面相同，比如你在1080p的显示器上全屏播放，缩放算法会显示临近采样，这是正常的)</p>
<p>MPC-HC/MPC-BE中，按Ctrl+J可以调出类似的信息：(再按1~2次取消)<br><img src="20155.png" alt="20155.png"><br>红框中勾选的，Formats表示渲染过程中格式变化，从始至终都是RGB；</p>
<p>Video Size给出了原始尺寸和播放尺寸，以及使用的缩放算法(双立方 A=-0.6)</p>
<p>Decoder则是解码器；输出是RGB。</p>
<p>通过这样的查看方法，你可以知道你的播放器工作流程，以及设置是否按照预期。</p>
<h1 id="6、动漫画面区别于常规录制视频的特殊性"><a href="#6、动漫画面区别于常规录制视频的特殊性" class="headerlink" title="6、动漫画面区别于常规录制视频的特殊性"></a>6、动漫画面区别于常规录制视频的特殊性</h1><p>一直以来都有这样的说法：“10bit, madVR这些东西都是那些压动漫的人弄出来的歪门邪道，我是看不出这些东西在电影上有个P用。”</p>
<p>其实吧，这还真不是这群人眼力不好或者装睡不醒。区别于录制视频，比如电影之类的，动漫、CG等有着自己的特殊性。<strong>总结起来就两点：1、噪点少，2、线条非常突兀。</strong></p>
<p>视频拍摄，限制于器材水准，噪点是不可避免的，在后续制作等过程中也难以完全去除。而动漫天生可以0噪点，动漫中的噪点更多是数字图像处理中主动加上去的。噪点的一大作用就是极大地降低视频处理和压制，对于精度的需要。说的简单点：<strong>高噪点的视频不怕低精度，反之亦然。</strong></p>
<p>怎么理解这个概念呢？我们借助一个简化的图片来演示。假设我们有一条平滑、高精度的曲线(这是y=1/x在[10,30]上的图)：<br><img src="19867df6ec8.png" alt="19867df6ec8.png"></p>
<p>现在，我们把所有函数值，四舍五入到小数点后三位数：<br><img src="19867d0c8de.png" alt="19867d0c8de.png"><br>降低精度的效果很明显，我们现在的图看上去跟楼梯一样，出现了明显的”断层”。表现在视频中，这种断层就是色带。同时值得注意的是，越是平坦、变化小的地方（就是之前科普中的”平面”），色带表现越严重。</p>
<p>现在，我们模仿给图像加噪点，来给这个函数加一个小幅度(约为1%)随机抖动：<br><img src="19867d90730.png" alt="19867d90730.png"><br>然后我们也把它的精度限制为小数点后3位：<br><img src="19867d5bb28.png" alt="19867d5bb28.png"><br>可见，这一次精度降低，图像似乎没有受到太多影响，精度降低造成的阶梯状效果也很不明显。表现在数字图像处理中，意味着噪点重的图片，在降低精度的时候收到的影响很小。</p>
<p><strong>这就是为什么那些致力于改善精度的提升，对于电影等视频几乎没有用——播放过程的精度低怎么了；能有什么视觉影响？</strong></p>
<p>类似的现象，噪点会使得人眼对图像锐利度等差异不敏感，或者说，缩放算法造成的区别，变得不太可见。以之前的图为例，假如为两幅图都加上强度相同的噪点：<br><img src="20151.png" alt="20151.png"><br><img src="20152.png" alt="20152.png"></p>
<p>区别已然几乎不可见。注意噪点是如何帮忙掩盖拉升过程中的锯齿等瑕疵，并加入虚假的高频信息，让图像看上去细节很丰富。这还是应用在线条/平面非常分明的动漫；换作电影，这样的差异只会更不起眼。</p>
<p><strong>小结一下，当有噪点存在的时候，主打高精度、优秀缩放算法的播放器，优势将不再明显。从另一个方面讲，面对较少噪点、较为突出线条的动漫，对播放器的精度和缩放算法提出的要求就很高。编码器也是一样的道理，动漫非常需要10bit x264/x265这样原生高精度的编码器来提升画质。</strong></p>
<p>因此，再面对本节开头的说法，不需要反驳，那是很自然的（摊手）。</p>
<p><strong>问：既然加噪点可以有效避免精度降低，为什么在动漫压制中不用这个方法呢？</strong></p>
<p>答：噪点作为一种高频信息，需要浪费成倍的码率。在今天10bit编码可以不增加（甚至减少）码率完美解决问题的前提下，我们为什么要用10年前的理解呢？</p>
<p>PS: 10年前只有8bit编码器的时候，主动加噪确实是很常见的防色带、去色带手段。在今天商业性蓝光编码器只有8bit精度的限制下，很多动漫蓝光后期也是通过加噪点解决的（Sony那高大上的“SBMV技术”的核心）。<strong>然而，蓝光可以不惜码率，Rip不行，除非你是Yousei。</strong>（所以Yousei的Devil-Jin至今用着这种手段）</p>
<h1 id="7、播放器软件的现状与分析"><a href="#7、播放器软件的现状与分析" class="headerlink" title="7、播放器软件的现状与分析"></a>7、播放器软件的现状与分析</h1><p>接上文分析。面对占绝对多数的电影观众，现有的播放器，pot/mpc默认，已然足够好了。再好的设置能带来的观感提升几乎没有，还不如在什么一键增强，左眼效果，以及在线字幕、弹幕上下功夫。</p>
<p>面对多数动漫党，稍微修改一下基于EVR CP+LAV的播放设置，也能达到很满意的效果，很平衡的兼顾画质、性能与稳定性。所以如果你不求折腾（还把这么长的教程看到这里，真是辛苦你了），<strong>建议使用vcb-s最新写的两篇64bit播放器教程</strong>。</p>
<p>如果你真的欲求不满，那么你就可以试着接触madVR，SVP这些东西。但是有一点需要提醒的是：这些纯粹由fans开发的东西，甚至包括mpc/pot这些软件，是高度不可靠的。哪怕所谓的“稳定版”，出bug的几率都很高。（更别提现在madVR一直都是“测试版”，版本号还在0.x）MadVR至今有个问题，就是它所在的目录路径不能有中文。这个问题存在几年了，作者压根不屑于，或者说，抽不出精力去修复它——你见过几个正儿八经的软件不支持安装目录有中文？！</p>
<p>更恐怖的是，高质量播放依赖的组件数量庞大，而彼此之间缺乏系统性的联系测试。开发者往往是各自测试各自的，没有组织、没有公司说作为一个整体来调试一套方案。当播放软件趋于复杂，组件数量增多，功能强化，出错的概率指数级上升。一个基于potplayer+madVR的播放方案，不考虑音频，涉及到以下可能出问题的地方：</p>
<p>potplayer本体,  LAV分离器，LAV视频解码器，madVR渲染器，操作系统，显卡和显卡驱动。</p>
<p>假设每一个组件出错的平均概率是3%，求问这一套方案正常运行不出错的概率是多少？1-0.97^6=83%。</p>
<p>也就是说，平均5个人里面，就有一个人用这套方案出错。出错的理由往往很难查到，每个人都有每个人的原因。</p>
<p>（举个我自己的例子，虽然我写的教程基于mpc-hc，但我自己在用mpc-be。因为对于mpc-hc，我设置让EVR渲染器使用双立方缩放，mpc-hc始终都使用的是最朴素的双线性，导致缩放效果很差（对我来说）。各种途径查错无功而返，最终换mpc-be问题解决。）</p>
<p>所以以后请别问我为什么不写madVR+SVP+Reclock+XySubFilter这些高端货的教程，更别出了错问我错在哪里、怎么解决——臣妾做不到啊！</p>
<h1 id="8、其他常见播放器配件简介"><a href="#8、其他常见播放器配件简介" class="headerlink" title="8、其他常见播放器配件简介"></a>8、其他常见播放器配件简介</h1><p>除了madVR，其他播放器折腾一般还有这些配件：</p>
<p>SVP(Smooth Video Project)比较众所周知了，它是一个插值平滑软件。本身依赖avisynth开发，通过ffdshow/ffdraw来加载，作用在解码器之后，渲染器之前。SVP只能支持YUV420 8bit输入输出。</p>
<p>SVP的性能消耗非常可观，特别是开启OpenCL之后，如果再开启madVR（接EVR CP容易导致精度问题，这时候可以手动在ffdshow/ffdraw中加噪点来缓解），对显卡的性能和驱动稳定性都是考验。尽管如此，SVP的插值平滑带来的观看提升也是非常可观的，强烈建议madVR的倍帧满足不了、同时又有很强配置的观众们爬文安装。</p>
<p><strong>XySubFilter，是目前最先进的字幕插件</strong>，对高级字幕特效的支持，渲染的质量，性能的优化，对高精度播放以及madVR的配合都做得很到位。如果你患有字幕强迫症末期，建议去折腾一下这个插件。</p>
<p>Reclock，一个致力于改善播放视频帧率不稳定的插件，不过多数人用它的目的可能还是为了它的wasapi输出。实际表现完全聊胜于无，特别是wasapi现在mpc自带的audio render就内置了，而且Reclock没有64bit版，因此不建议折腾。</p>
<h1 id="9、播放器配置学习的建议"><a href="#9、播放器配置学习的建议" class="headerlink" title="9、播放器配置学习的建议"></a>9、播放器配置学习的建议</h1><p>对于想自学高级播放器设置的同学们，教程总是不缺的，网上一搜一大堆，各大论坛什么的置顶帖，万年冷冻库，等等。写的比vcb-s现有几篇教程更新、更详细、更高端的比比皆是，也都可以作为很不错的教程。然而我一直认为，这些教程只是授人以鲤，或者授人以鳊、鲢、鳙……，导致的结果就是来一只鲫，或者给你个渔网让你按照自己喜好捞一只，很多人一下子就傻眼了。</p>
<p>这也是我写这篇教程的初衷，讲述一下现在网上林林总总的教程，不会跟你说的很多细节与知识。有的人madVR设置玩出了花，结果不知道检查pot内置的ffmpeg解码器，会把YUV420 10bit 降低精度+瞎转换 为YUV422 8bit丢给madVR，然后又说自己看不出区别……这折腾的意义何在呢。</p>
<p>学习播放器配置，有这么几条原则，是我希望分享给大家的：</p>
<p>1、实事求是。不要盲目的去折腾，也不要为了心理安慰去折腾。一套更好的方案，只有你确实感觉到了提升，并且这个提升在你心理满意度上，足够抵消麻烦，才值得你去升级。比较的过程中，相信自己的眼睛，而不是相信别人的说教。比如说我真不推荐笔记本用户折腾任何顶级缩放算法——那么小个屏幕你能看出点啥？教程里说出花的放大算法跟你有几毛钱关系？</p>
<p>2、循序渐进。先把一套简单基础的方案弄好弄懂，再去学习和尝试更好的方法。对于新的插件，你要尝试测试它们在你机器上的表现；对于别人的设置，设法了解他这么推荐的原因，以及这个原因是否适用于你。最典型的，很多人用着madVR问我，你在新教程里教我们LAV只勾选RGB，我要改么？看了这篇教程你应该知道要不要改与背后的原因了吧。</p>
<p>3、量力而行。播放器越高级，组件越多，往往性能消耗越大，出错概率也越高，同时收益越少。学会放弃与妥协，毕竟，你看的是片子，不是播放器组件和参数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/07/视频格式基础知识/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/视频格式基础知识/" itemprop="url">视频格式基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T19:47:30+08:00">2018-02-07</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/多媒体/" itemprop="url" rel="index"><span itemprop="name">多媒体</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="看连接内容好了-我只是存个档"><a href="#看连接内容好了-我只是存个档" class="headerlink" title="看连接内容好了,我只是存个档"></a>看连接内容好了,我只是存个档</h1><p><a href="https://vcb-s.com/archives/2726" target="_blank" rel="noopener">[VCB-Studio 科普教程 3] 视频格式基础知识</a></p>
<h1 id="VCB-Studio-科普教程-3-视频格式基础知识"><a href="#VCB-Studio-科普教程-3-视频格式基础知识" class="headerlink" title="[VCB-Studio 科普教程 3] 视频格式基础知识"></a>[VCB-Studio 科普教程 3] 视频格式基础知识</h1><p>这本来是群内写给队友做入门知识学习的，然后觉得挺适合改改贴出来向大家科普，所以就有了这篇教程。之前的两篇播放器教程可以算 1 和 2 吧。</p>
<p>本教程意在讲述一些视频音频制作的基础知识和术语，适合不了解压片原理的收片党们自学。它可以比较详细地回答以下常见的问题：</p>
<ul>
<li><p>MP4/MKV 这些格式有什么区别？哪个画质好？</p>
</li>
<li><p>视频的码率是怎么算的？为什么同样是 1080p 的视频，有些体积大有些体积小？</p>
</li>
<li><p>视频储存的图像信息是什么格式的？跟显示器一样的红绿蓝么？</p>
</li>
<li><p>8-bit/10-bit 到底指的什么？为什么说 8-bit 显示器还有必要看 10-bit 视频？</p>
</li>
<li><p>YUV420/444 这些标示到底什么意思？哪个好？</p>
</li>
<li><p>线条，平面，纹理这些到底是什么意思？视频为啥还有高频低频？</p>
</li>
<li><p>码率越高的视频画质越好么？</p>
</li>
</ul>
<h2 id="本教程将分以下模块详细叙述："><a href="#本教程将分以下模块详细叙述：" class="headerlink" title="本教程将分以下模块详细叙述："></a>本教程将分以下模块详细叙述：</h2><ol>
<li><p>封装格式（MP4/MKV…）vs 媒体格式（H.264/FLAC/AAC…）</p>
</li>
<li><p>视频的基础参数：分辨率、帧率和码率</p>
</li>
<li><p>图像的表示方法：RGB 模型 vs YUV 模型</p>
</li>
<li><p>色深</p>
</li>
<li><p>色度半采样</p>
</li>
<li><p>空间上的低频与高频：平面、纹理和线条</p>
</li>
<li><p>时间上的低频与高频：动态</p>
</li>
<li><p>清晰度与画质简述</p>
</li>
</ol>
<h3 id="1、封装格式-MP4-MKV…-vs-媒体格式-H-264-FLAC-AAC…"><a href="#1、封装格式-MP4-MKV…-vs-媒体格式-H-264-FLAC-AAC…" class="headerlink" title="1、封装格式(MP4/MKV…)  vs 媒体格式(H.264/FLAC/AAC…)"></a>1、封装格式(MP4/MKV…)  vs 媒体格式(H.264/FLAC/AAC…)</h3><p>MP4+MKV是你下载的视频文件最常见的种类。这些文件其实类似一个<strong>包裹</strong>，它的后缀则是包裹的包装方式。这些包裹里面，<strong>包含了视频（只有图像），音频（只有声音），字幕等</strong>。当播放器在播放的时候，首先对这个包裹进行拆包（专业术语叫做<strong>分离</strong>/splitting）,把其中的视频、音频等拿出来，再进行播放。</p>
<p>既然它们只是一个包裹，就意味着这个后缀不能保证里面的东西是啥，也不能保证到底有多少东西。包裹里面的每一件物品，我们称之为<strong>轨道(track)</strong>，一般有这么些：</p>
<p><strong>视频(Video)</strong>: 一般来说肯定都有，但是也有例外，比如mka格式的外挂音轨，其实就是没视频的mkv。<strong>注意我们说到视频的时候，是不包括声音的</strong>。</p>
<p><strong>音频(audio)</strong>：一般来说也肯定有，但是有些情况是静音的，就没必要带了。</p>
<p><strong>章节(Chapter)</strong>: 蓝光原盘中自带的分段信息。如果文件带上了，那么你可以在播放器中看到带章节的效果：</p>
<ul>
<li><p>potplayer右键画面，选项-播放-在进度条上显示书签/章节标记</p>
</li>
<li><p>mpc-hc 右键画面，选项-调节-在进度条显示章节标记</p>
</li>
</ul>
<p><strong>字幕(Subtitles)</strong>：有些时候文件自带字幕，并且字幕并非是直接整合于视频的硬字幕，那么就是一起被打包在封装容器中。</p>
<p>其他可能还有附件等，不一一列举。每个类型也不一定只有一条轨道，比如经常见到带多音轨的MKV。</p>
<p><strong>每个轨道，都有自己的格式。</strong>比如大家常说的，视频是H.264，音频是AAC，这些就是每个轨道的格式。</p>
<p>视频的格式，常见的有H.264(可以细分为8bit/10bit)，H.265(当前也有8bit/10bit之分)，RealVideo(常见于早期rm/rmvb)，VC-1(微软主导的，常见于wmv)。基本上，H.264=AVC=AVC1, H.265=HEVC。</p>
<p>音频的格式，常见的有 FLAC/ALAC/TrueHD/DTS-HD MA这<strong>四种无损</strong>，和AAC/MP3/AC3/DTS(Core)这<strong>四种有损</strong>。</p>
<p><strong>MKV vs MP4，主要的区别在于：</strong></p>
<ol>
<li>MKV支持封装FLAC作为音频，MP4则不支持。但是MP4也可以封装无损音轨(比如说ALAC，虽然普遍认为ALAC的效率不如FLAC优秀)</li>
<li>MKV支持封装ASS/SSA格式的字幕，MP4则不支持。一般字幕组制作的字幕是ASS格式，所以内封字幕多见于MKV格式</li>
<li>MP4作为工业标准，在视频编辑软件和播放设备上的<strong>兼容性</strong>一般好于MKV。这也是vcb-s那些为<strong>移动设备</strong>优化的视频基本上选择MP4封装的原因。<br>除此之外，这两个格式很大程度上可以互相代替。比如它们都支持封装AVC和HEVC，包括8bit/10bit的精度。<strong>所以MP4画质不如MKV好，这种论断是非常无知的——它们完全可以封装一样的视频</strong>。</li>
</ol>
<p>为什么会有这样的分歧，就是历史原因了。MKV是民间研发，<strong>为了代替古老的AVI</strong>，从而更好地支持H264，它开发和修改的灵活度使得它可以兼容flac/ass这类非工业标准的格式；而MP4则是出生豪门，作为工业标准，<strong>替代更古老的MPG</strong>，作为新一代视频/音频封装服务的。</p>
<h3 id="2、视频的基础参数：分辨率，帧率和码率。"><a href="#2、视频的基础参数：分辨率，帧率和码率。" class="headerlink" title="2、视频的基础参数：分辨率，帧率和码率。"></a>2、视频的基础参数：分辨率，帧率和码率。</h3><p>视频是由连续的图像构成的。<strong>每一张图像，我们称为一帧(frame)</strong>。图像则是由像素(pixel)构成的。<strong>一张图像有多少像素，称为这个图像的分辨率</strong>。比如说1920×1080的图像，说明它是由横纵1920×1080个像素点构成。视频的分辨率就是每一帧图像的分辨率。</p>
<p>一个视频，<strong>每一秒由多少图像构成，称为这个视频的帧率(frame-rate)</strong>。常见的帧率有24000/1001=23.976, 30000/1001=29.970, 60000/1001=59.940, 25.000, 50.000等等。这个数字是一秒钟内闪过的图像的数量。比如23.976，就是1001秒内，有24000张图像。视频的<strong>帧率是可以是恒定的</strong>(cfr, Const Frame-Rate)，<strong>也可以是变化的</strong>(vfr, Variable Frame-Rate)</p>
<p><strong>码率</strong>的定义是视频文件体积除以时间。单位一般是Kbps(Kbit/s)或者Mbps(Mbit/s)。注意1B(Byte)=8b(bit)。所以一个24分钟，900MB的视频：</p>
<p>体积：900MB = 900MByte = 7200Mbit</p>
<p>时间：24min = 1440s</p>
<p>码率：7200/1440  = 5000 Kbps = 5Mbps</p>
<p>当视频文件的时间基本相同的时候（比如现在一集番大概是24分钟），码率和体积基本上是等价的，<strong>都是用来描述视频大小的参数</strong>。长度分辨率都相同的文件，体积不同，实际上就是码率不同。</p>
<p><strong>码率也可以解读为单位时间内，用来记录视频的数据总量。码率越高的视频，意味着用来记录视频的数据量越多，潜在的解读就是视频可以拥有更好的质量</strong>。（注意，<strong>仅仅是潜在</strong>，后文我们会分析为什么高码率不一定等于高画质）</p>
<h3 id="3、图像的表示方法：RGB模型-vs-YUV模型"><a href="#3、图像的表示方法：RGB模型-vs-YUV模型" class="headerlink" title="3、图像的表示方法：RGB模型 vs YUV模型"></a>3、图像的表示方法：RGB模型 vs YUV模型</h3><p>光的三原色是红(Red)、绿(Green)、蓝(Blue)。现代的显示器技术就是通过组合不同强度的三原色，来达成几乎任何一种可见光的颜色。图像储存中，通过记录每个像素<strong>红绿蓝强度</strong>，来记录图像的方法，称为RGB模型 (RGB Model)</p>
<p>常见的图片格式中，<strong>PNG和BMP</strong>这两种就是基于RGB模型的。</p>
<p>比如说原图：<br><img src="1111.jpg" alt="1111"><br>分别只显示R G B通道的强度，效果如下：<br><img src="111.jpg" alt="111"><br><img src="1112.jpg" alt="1112"><br><img src="1113.jpg" alt="1113"><br>三个通道下，信息量和细节程度不一定是均匀分布的。比如说可以注意南小鸟脸上的红晕，在3个平面上的区分程度就不同——红色平面下几乎无从区分，造成区别的主要是绿色和蓝色的平面。外围白色的脸颊，三色都近乎饱和；但是红晕部分，只有红色饱和，绿色和蓝色不饱和。这是造成红色凸显的原因。</p>
<p>除了RGB模型，还有一种广泛采用的模型，称为<strong>YUV模型</strong>，又被称为<strong>亮度-色度模型（Luma-Chroma）</strong>。它是通过数学转换，将RGB三个通道，转换为一个代表亮度的通道(Y,又称为Luma)，和两个代表色度的通道(UV，并成为Chroma)。</p>
<p>举个形象点的例子：一家养殖场饲养猪和牛，一种记数方式是：（猪的数量，牛的数量）</p>
<p>但是也可以这么记录：（总数量=猪的数量+牛的数量，相差=猪的数量-牛的数量）。两种方法之间有数学公式可以互转。</p>
<p>YUV模型干的是类似的事儿。通过对RGB数据的合理转换，得到另一种表示方式。YUV模型下，还有不同的实现方式。举个用的比较多的YCbCr模型：它把RGB转换成一个亮度(Y)，和 蓝色色度(Cb) 以及 红色色度(Cr)。转换背后复杂的公式大家不需要了解，只需要看看效果：</p>
<p>只有亮度通道：<br><img src="1114.jpg" alt="1114"><br>只有蓝色色度：<br><img src="1115.jpg" alt="1115"><br>只有红色色度：<br><img src="1116.jpg" alt="1116"><br>在图像视频的加工与储存中，YUV格式一般更受欢迎，理由如下：</p>
<p>1、人眼对亮度的敏感度远高于色度，因此人眼看到的有效信息主要来自于亮度。YUV模型可以将绝大多数的有效信息分配到Y通道。UV通道相对记录的信息少的多。相对于RGB模型较为平均的分配，YUV模型将多数有效信息集中在Y通道，不但减少了冗余信息量，还为压缩提供了便利</p>
<p>2、保持了对黑白显示设备的向下兼容</p>
<p>3、图像编辑中，调节亮度和颜色饱和度，在YUV模型下更方便。</p>
<p><strong>几乎所有的视频格式，以及广泛使用的JPEG图像格式，都是基于YCbCr模型的。播放的时候，播放器需要将YCbCr的信息，通过计算，转换为RGB。这个步骤称为渲染（Rendering）</strong></p>
<p>每个通道的记录，通常是用整数来表示。比如RGB24，就是RGB各8个bit，用0~255 (8bit的二进制数范围)来表示某个颜色的强弱。YUV模型也不例外，也是用整数来表示每个通道的高低。</p>
<h3 id="4、色深"><a href="#4、色深" class="headerlink" title="4、色深"></a>4、色深</h3><p><strong>色深(bit-depth)</strong>，就是我们通常说的<strong>8bit和10bit</strong>，是指每个通道的精度。8bit就是每个通道用一个8bit整数(0~255)代表，10bit就是用10bit整数(0~1023)来显示。16bit则是0~65535</p>
<p>(注意，上文的表述是不严谨的，视频在编码的时候，并非一定能用到0~255的所有范围，而是可能有所保留，只用到一部分，比如16~235。这我们就不详细展开了)</p>
<p>你的显示器是8bit的，代表它能显示RGB每个通道0~255所有强度。但是视频的色深是YUV的色深，播放的时候，YUV需要通过计算转换到RGB。因此，<strong>10bit的高精度是间接的</strong>，它使得运算过程中精度增加，以让最后的颜色更细腻。</p>
<h4 id="如何理解8bit显示器，播放10bit是有必要的呢："><a href="#如何理解8bit显示器，播放10bit是有必要的呢：" class="headerlink" title="如何理解8bit显示器，播放10bit是有必要的呢："></a>如何理解8bit显示器，播放10bit是有必要的呢：</h4><p>一个圆的半径是12.33m, 求它的面积，保留两位小数。</p>
<p>半径的精度给定两位小数，结果也要求两位小数，那么圆周率精度需要给多高呢？也只要两位小数么？<br>取pi=3.14, 面积算出来是477.37平方米<br>取pi=3.1416，面积算出来是477.61平方米<br>取pi精度足够高，面积算出来是477.61平方米。所以取pi=3.1416是足够的，但是3.14就不够了。</p>
<p>换言之，即便最终输出的精度要求较低，也不意味着参与运算的数字，以及运算过程，可以保持较低的精度。在最终输出是8bit RGB的前提下，10bit YUV比起8bit YUV依旧具有精度优势的原因就在这里。<strong>事实上，8bit YUV转换后，覆盖的精度大概相当于8bit RGB的26%，而10bit转换后的精度大约可以覆盖97%——你想让你家8bit显示器发挥97%的细腻度么？看10bit吧。</strong></p>
<p>8bit精度不足，主要表现在亮度较低的区域，容易形成色带：<br><img src="logo11.png" alt="logo11.png"><br>注意这图右边那一圈圈跟波浪一样的效果。这就是颜色精度不足的表现。</p>
<p>10bit的优势不只在于显示精度的提高，在提高视频压缩率，减少失真方面，相对8bit也有优势。这方面就不展开了。</p>
<h3 id="5、色度半采样"><a href="#5、色度半采样" class="headerlink" title="5、色度半采样"></a>5、色度半采样</h3><p>在YUV模型的应用中，<strong>Y和UV的重要性是不等同的</strong>。图像视频的实际储存和传输中，通常将<strong>Y以全分辨率记录，UV以减半甚至1/4的分辨率记录</strong>。这个手段被称为<strong>色度半采样(Chroma Sub-Sampling)</strong>。色度半采样可以有效减少传输带宽，和加大UV平面的压缩率，但是不可避免的会损失UV平面的有效信息。</p>
<p>我们平常的视频，<strong>最常见的是420采样</strong>。配合YUV格式，常常被写作yuv420。这种采样是Y保留全部，UV只以(1/2) x (1/2)的分辨率记录。比如说1920×1080的视频，其实只有亮度平面是1920×1080。两个色度平面都只有960×540的分辨率。</p>
<p>当然了，你也可以选择不做缩减。这种称为<strong>444采样，或者yuv444</strong>。YUV三个平面全是满分辨率。</p>
<p>在做YUV-&gt;RGB的时候，首先需要将缩水的UV分辨率拉升到Y的分辨率（madVR中允许自定义算法，在Chroma Upscaling当中），然后再转换到RGB。做RGB-&gt;YUV的转换，也是先转换到444（YUV的分辨率相同），再将UV分辨率降低。</p>
<p><strong>一般能拿到的片源，包括所有蓝光原盘，都是420采样的</strong>。所以成品一般也保留420采样。所以yuv420就表示这个视频是420采样的yuv格式。</p>
<p>将420做成444格式，需要自己手动将UV分辨率拉升2×2倍。在今天madVR等渲染器可以很好地拉升UV平面的情况下，这种做法无异于毫无必要的拉升DVD做成伪高清。</p>
<p>当然了，<strong>有时候也需要在444/RGB平面下做处理和修复，常见的比如视频本身RGB平面不重叠</strong>（比如摩卡少女樱），这种修复过程首先要将UV分辨率拉升，然后转RGB，做完修复再转回YUV。修复后的结果相当于全新构图，这种情况下保留444格式就是有理由，有必要的。</p>
<p>H264格式编码444格式，需要High 4:4:4 Predictive Profile（简称Hi444pp）。<strong>所以看到Hi444pp/yuv444 之类的标示，你就需要去找压制者的陈述，为什么他要做这么个拉升。如果找不到有效的理由，你应该默认作者是在瞎做</strong>。</p>
<h3 id="6、空间上的低频与高频：平面，纹理和线条"><a href="#6、空间上的低频与高频：平面，纹理和线条" class="headerlink" title="6、空间上的低频与高频：平面，纹理和线条"></a>6、空间上的低频与高频：平面，纹理和线条</h3><p>在视频处理中，<strong>空间(spatial)</strong>的概念指的是一帧图片以内（你可以认为就是一张图所呈现的二维空间/平面）。跟<strong>时间(temporal)</strong>相对；时间的概念就强调帧与帧之间的变换。</p>
<p>于是我们重新来看这张亮度的图：<br><img src="1117.jpg" alt="1117"></p>
<p><strong>亮度变化较快，变动幅度大的区域</strong>，我们称之为<strong>高频区域</strong>。否则，亮度变化缓慢且不明显的区域，我们称为低频区域。</p>
<p>图中的<strong>蓝圈</strong>就是一块典型的<strong>低频</strong>区域，或者就叫做<strong>平面</strong>（平坦的部分）。亮度几乎没有变化</p>
<p><strong>绿圈</strong>中，亮度呈现跳跃式的突变，这种<strong>高频</strong>区域我们称之为<strong>线条</strong>。</p>
<p><strong>红圈</strong>中，亮度频繁变化，幅度有高有低，这种高频区域我们称为<strong>纹理</strong>。</p>
<p>有时候，线条和纹理（高频区域）统称为线条，平面（低频区域）又叫做非线条。</p>
<p>这是亮度平面。色度平面，高频低频，线条等概念也同样适用，就是描述色度变化的快慢轻重。<strong>一般我们所谓的“细节”，就是指图像中的高频信息。</strong></p>
<p>一般来说，<strong>一张图的高频信息越多，意味着这张图信息量越大，所需要记录的数据量就越多，编码所需要的运算量也越大</strong>。如果一个视频包含的空间性高频信息很多（通俗点说就是每一帧内细节很多），意味着这个视频的空间复杂度很高。</p>
<p>记录一张图片，编码器需要决定给怎样的部分多少码率。码率在一张图内不同部分的分配，叫做<strong>码率的空间分配</strong>。分配较好的时候，往往整幅图目视观感比较统一；分配不好常见的后果，就是线条纹理尚可，背景平面区域出现大量色带色块（码率被过分的分配给线条）；或者背景颜色过渡自然，纹理模糊，线条烂掉（码率被过分的分配给非线条）。</p>
<h3 id="7、时间上的低频与高频：动态"><a href="#7、时间上的低频与高频：动态" class="headerlink" title="7、时间上的低频与高频：动态"></a>7、时间上的低频与高频：动态</h3><p>在视频处理中，时间(temporal)的概念强调帧与帧之间的变换。跟空间(spatial)相对。</p>
<p>动态的概念无需多解释；就是<strong>帧与帧之间图像变化的强弱</strong>，变化频率的高低。一段视频如果动态很高，变化剧烈，我们称为时间复杂度较高，时域上的高频信息多。否则如果视频本身舒缓多静态，我们称为时间复杂度低，时域上的低频信息多。</p>
<p>一般来说，一段视频的时域高频信息多，动态的信息量就大，所需要记录的数据量就越多，编码所需要的运算量也越大。但是另一方面，<strong>人眼对高速变化的场景，敏感度不如静态的图片来的高（你没有时间去仔细观察细节），所以动态场景的优先度可以低于静态场景。</strong>如何权衡以上两点去分配码率，被称为<strong>码率的时间分配</strong>。分配较好的时候，看视频无论动态还是静态效果都较好；分配不好的时候往往是静态部分看着还行，动态部分糊烂掉；或者动态部分效果过分的好，浪费了大量码率，造成静态部分欠码，瑕疵明显。</p>
<p><strong>很多人喜欢看静止的截图对比，来判断视频的画质。从观看的角度，这种做法其实并不完全科学</strong>——如果你觉得比较烂的一帧其实是取自高动态场景，那么这一帧稍微烂点无可厚非，反正观看的时候你注意不到，将码率省下来给静态部分会更好。</p>
<h3 id="8、清晰度与画质简述"><a href="#8、清晰度与画质简述" class="headerlink" title="8、清晰度与画质简述"></a>8、清晰度与画质简述</h3><p>我们经常讨论，一个视频清晰度如何，画质好不好。但是如何给这两个术语做定义呢？</p>
<p>经常看到的说法：“<strong>这个视频清晰度是1080p的</strong>”。其实看过上文你就应该知道，<strong>1080p只是视频的分辨率</strong>，它不能直接代表清晰度——比如说，我可以把一个480p的dvd视频拉升到1080p，那又怎样呢？它的清晰度难道就提高了么？</p>
<p>一个比较接近清晰度的概念，是上文所讲述的，<strong>空间高频信息量，就是一帧内的细节。一张图，一个视频的细节多，它的清晰度就高</strong>。分辨率决定了高频信息量的上限；就是它最清晰能到什么地步。1080p之所以比480p好，是因为它可以允许图像记录的高频信息多。这个说法看样子很靠谱，但是，有反例：<br><img src="oversharped.png" alt="oversharped.png"><br>右图的高频信息远比左图多——它的线条很锐利，有大量致密的噪点（注意噪点完全符合高频信息的定义；它使得图像变化的非常快）<br>但是你真的觉得右图清晰度高么？<br>事实上，右图完全是通过左图加工而来。通过过度锐化+强噪点，人为的增加无效的高频信息。</p>
<p><strong>所以清晰度的定义我更倾向于这样一个说法：图像或视频中，原生、有效的高频信息。</strong><br>原生，强调这种清晰度是非人工添加的；有效；强调细节本身有意义，而不是毫无意义的噪点特效。</p>
<p>值得一提的是，人为增加的高频信息不见得完全没有帮助。有的时候适度锐化的确能够起到不错的目视效果：<br><img src="finesharped.png" alt="finesharped.png"></p>
<p>这是一幅适度锐化后的效果。如果有人觉得右图更好，至少某些部分更好，相信我，你不是一个人。所以适度锐化依旧是视频和图像处理中，可以接受的一种主观调整的手段，一定的场合下，它确实有助于提高目视效果。</p>
<p>以上是清晰度的概述。注意，清晰度只是空间方面（就是一帧以内）。如果再考虑到动态效果的优秀与否（视频是不是那种一动起来就糊成一团的，或者动起来感觉卡顿明显的，常见于早起RMVB），空间和时间上优秀的观看效果共同定义了画质。所以我们说madVR/svp那些倍帧效果有助于提高画质，实际上它们增强了时间上的观看效果。</p>
<p>好的画质，是制作者和观众共同追求的。怎么样的视频会有好的画质呢？是不是码率越高的视频画质越好呢？真不见得。<strong>视频的画质，是由以下几点共同决定的：</strong></p>
<p>1、源的画质。<br>俗话说的好，上梁不正下梁歪。如果源的画质本身很差，那么再如何折腾都别指望画质好到哪去。所以压制者往往会选择更好的源进行压制——举个栗子，BDRip一般都比TVRip来的好，哪怕是720p。蓝光也分销售地区，一般日本销售的日版，画质上比美版、台版、港版啥的都来得好，所以同样是BDRip，选取更好的源，就能做到画质上优先一步。</p>
<p>2、播放条件。<br>观众是否用了足矣支持高画质播放的硬件和软件。这就是为啥我们在发布Rip的同时大力普及好的播放器；有时候一个好的播放器胜过多少在制作方面的精力投入。 </p>
<p>3、码率投入vs编码复杂度。<br>视频的时间和空间复杂度，并称为编码复杂度。编码复杂度高的视频，往往细节多，动态高（比如《魔法少女小圆剧场版 叛逆的物语》），这样的视频天生需要较高的码率去维持一个优秀的观看效果。<br>相反，有些视频编码复杂度低（比如《请问今天要来点兔子么》，动态少，线条细节柔和），这种视频就是比较节省码率的。</p>
<p>4、码率分配的效率和合理度。<br>同样多的码率，能起到怎样好的效果，被称为效率。比如H264就比之前的RealVideo效率高；10bit比8bit效率高；编码器先进，参数设置的比较合理，编码器各种高端参数全开（通常以编码时间作为代价），码率效率就高。<br>合理度就是码率在时空分配方面合理与否，合理的分配，给观众的观看效果就比较统一协调。 码率分配的效率和合理度，是对制作者的要求，要求制作者对片源分析，参数设置有比较到位的理解。</p>
<p>码率分配和合理度做的好，就常常能做出低码率高画质的良心作品。</p>
<p>这里再多提一句，至少在这个时间点，也就是此文发布的2014年年底，HEVC相对于AVC可以提高50%的效率，依旧是一个纸面上的理论值。实际操作中，因为HEVC编码器的成熟度远不及经过了十几年发展的AVC编码器，导致现在HEVC的潜力远没有能发挥出来，特别是高画质下甚至不如。<br>对于目前主流的，定位收藏画质的BDRip，同样码率下x265的画质相对于x264没有优势；所以在近期，大家不用优先的去下载HEVC版作为收藏目的，更不必迷信什么“码率降低一半”。再强调一次，这个时间点；如果一年后以上陈述被不断进步的HEVC编码器推翻，我毫不惊讶。</p>
<p>5、编码前的预处理。预处理分三种：</p>
<p>①，客观修复。强调修复片源固有的瑕疵，比如锯齿，色带，晕轮等等。<br>②，主观调整，强调将片源调整的更适合人眼观看，比如适度的锐化，调色（有时候你是可以通过科学方法判定片源的颜色有问题，然后针对的做修复的）。<br>③，移除无效高频信息，比如降噪，避免码率浪费在无效的噪点上</p>
<p>预处理做的好，往往能达到画质上超越片源，或是在几乎不牺牲清晰度的前提下，节省码率开销。</p>
<p>但是预处理是一把双刃剑，优化的同时，可能引入副效果。降噪、抗锯齿、去晕轮等操作会不可避免的损失一些有效细节（或多或少，取决于制作者水准）；主观调整很可能会引入副效果（比如过度锐化会导致锯齿和晕轮），或是变成了作者的自我满足，形成对观众的欺骗。</p>
<p>综上，一个优秀的画质，是由片源、制作者、观看者共同决定的；码率高低也只是部分因素，并非决定性的效果。</p>
<p>于是这篇教程就写到这里吧。它最初的目的是给学习视频制作入门的人而写，也不知道对于一般的观众，能让大家理解多少。有啥需要交流讨论提问的就在下文回复吧。如果反响较好，以后我们还会发布更多这样科普教学类的文章。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/06/chrome的console功能/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/06/chrome的console功能/" itemprop="url">chrome的console功能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-06T18:35:57+08:00">2018-02-06</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="chrome的console功能"><a href="#chrome的console功能" class="headerlink" title="chrome的console功能"></a>chrome的console功能</h1><p>Console的9种用法，<br>1 显示信息的命令</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">'信息'</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">'错误'</span>);</span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">'警告'</span>);</span><br></pre></td></tr></table></figure>
<p>2 占位符(格式输出)<br>console上述的集中度支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;%d年%d月%d日&quot;,2018,2,2);</span><br></pre></td></tr></table></figure>
<p>3 信息分组(嵌套)</p>
<p>group是嵌套，groupEnd是结束一层嵌套</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.group(<span class="string">"第一组信息"</span>);    　　　　</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"第一组第一条"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"第一组第二条"</span>);</span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br><span class="line"><span class="built_in">console</span>.group(<span class="string">"第二组信息"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"第二组第一条"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"第二组第二条"</span>);</span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br></pre></td></tr></table></figure>
<p>4 查看对象信息</p>
<p>console.dir(obj)可以显示一个对象所有的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'Bob'</span>,</span><br><span class="line">    age: <span class="number">30</span>,</span><br><span class="line">    message: <span class="string">"hello world"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.dir(obj);</span><br></pre></td></tr></table></figure>
<p>5 显示某个节点的内容</p>
<p>console.dirxml(id)用来显示网页的某个节点（node）所包含的html/xml代码。</p>
<p>6 判断变量是否是真<br>console.assert(expression, object[, object…])</p>
<p>接收至少两个参数，第一个参数的值或返回值为false的时候，将会在控制台上输出后续参数的值。例如：<br>用来判断一个表达式或变量是否为真。如果结果为否，则在控制台输出一条相应信息，并且抛出一个异常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.assert(<span class="number">1</span> == <span class="number">1</span>, object); <span class="comment">// 无输出，返回 undefined</span></span><br><span class="line"><span class="built_in">console</span>.assert(<span class="number">1</span> == <span class="number">2</span>, object); <span class="comment">// 输出 object</span></span><br></pre></td></tr></table></figure>
<p>7 追踪函数的调用轨迹<br>console.trace()用来追踪函数的调用过程。在大型项目尤其是框架开发中，函数的调用轨迹可以十分复杂，console.trace()方法可以将函数的被调用过程清楚地输出到控制台上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tracer</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bar(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tracer(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="string">'tracer'</span>);</span><br></pre></td></tr></table></figure>
<p>8 计时功能<br>计时器，可以将成对的console.time()和console.timeEnd()之间代码的运行时间输出到控制台上，name参数可作为标签名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'计时器'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'计时器'</span>);</span><br></pre></td></tr></table></figure>
<p>9 console.profile()的性能分析<br>性能分析（Profiler）就是分析程序各个部分的运行时间，找出瓶颈所在，使用的方法是console.profile()</p>
<p>这是个挺高大上的东西，可用于性能分析。在 JS 开发中，我们常常要评估段代码或是某个函数的性能。在函数中手动打印时间固然可以，但显得不够灵活而且有误差。借助控制台以及console.profile()方法我们可以很方便地监控运行性能。</p>
<p>例如下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">  for (var i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">    childA()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function childA(j) &#123;</span><br><span class="line">  for (var i = 0; i &lt; j; i++) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.profile(&apos;性能分析&apos;);</span><br><span class="line">parent();</span><br><span class="line">console.profileEnd();</span><br></pre></td></tr></table></figure>
<p>10 输出执行到该行的次数</p>
<p>console.count([label])</p>
<p>输出执行到该行的次数，可选参数 label 可以输出在次数之前，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.count(<span class="string">'count'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// count: 1</span></span><br><span class="line"><span class="comment">// count: 2</span></span><br><span class="line"><span class="comment">// count: 3</span></span><br><span class="line"><span class="comment">// count: 4</span></span><br><span class="line"><span class="comment">// count: 5</span></span><br></pre></td></tr></table></figure>
<p>11 可将传入的对象或数组以表格形式输出<br>console.table()</p>
<p>可将传入的对象，或数组以表格形式输出，相比传统树形输出，这种输出方案更适合内部元素排列整齐的对象或数组，不然可能会出现很多的 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    name: <span class="string">'foo'</span>,</span><br><span class="line">    age: <span class="string">'33'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  bar: &#123;</span><br><span class="line">    name: <span class="string">'bar'</span>,</span><br><span class="line">    age: <span class="string">'45'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="string">'33'</span>],</span><br><span class="line">  [<span class="string">'bar'</span>, <span class="string">'45'</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(obj);</span><br><span class="line"><span class="built_in">console</span>.table(arr);</span><br></pre></td></tr></table></figure>
<p><a href="https://segmentfault.com/a/1190000000481884" target="_blank" rel="noopener">你真的了解 console 吗</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/05/axios使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/05/axios使用/" itemprop="url">axios使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-05T11:15:13+08:00">2018-02-05</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Axios-是一个基于-promise-的-HTTP-库，可以用在浏览器和-node-js-中。"><a href="#Axios-是一个基于-promise-的-HTTP-库，可以用在浏览器和-node-js-中。" class="headerlink" title="Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。"></a>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</h1><p>5种<br><a href="https://www.oschina.net/translate/top-javascript-libraries-for-making-ajax-calls?from=20180204" target="_blank" rel="noopener">用于进行 AJAX 调用的顶级 JavaScript 库</a></p>
<p><strong>Fetch API</strong><br>Fetch API 是 XMLHttpRequest 的现代替代方法，用于从服务器检索资源</p>
<p><strong>Axios</strong><br>Axios 是一个基于 XMLHttpRequest 构建的现代 JavaScript 库，用于进行 AJAX 调用</p>
<p><strong>jQuery</strong><br>jQuery 曾经是 JavaScript 的一线类库，涵盖从 AJAX 调用到操作 DOM 的内容。</p>
<p><strong>SuperAgent</strong><br>SuperAgent 是一个轻量级和渐进式 AJAX 库，更侧重于可读性和灵活性。</p>
<p><strong>Request - 一个简单的 HTTP 客户端</strong><br>这个 Request 库是进行 HTTP 调用最简单的方法之一。</p>
<p>我个人喜欢的是 Axios ，因为就我个人而言感觉它更具可读性和友好（easy on the eyes）。你也可以使用 Fetch ，因为它有良好的文档记录和标准化的解决方案。</p>
<h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/04/vuex使用总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/04/vuex使用总结/" itemprop="url">vuex使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-04T17:50:05+08:00">2018-02-04</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vuex总结-这个也是插件哦"><a href="#vuex总结-这个也是插件哦" class="headerlink" title="vuex总结(这个也是插件哦)"></a>vuex总结(这个也是插件哦)</h1><p><a href="https://vuex.vuejs.org/zh-cn/intro.html" target="_blank" rel="noopener">vuex官网</a></p>
<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用<strong>集中式存储</strong>管理应用的<strong>所有组件的状态</strong>，并以相应的规则保证状态以一种<strong>可预测的方式</strong>发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>
<h2 id="什么是“状态管理模式”？-这个例子别和后面的搞混了"><a href="#什么是“状态管理模式”？-这个例子别和后面的搞混了" class="headerlink" title="什么是“状态管理模式”？(这个例子别和后面的搞混了)"></a><strong>什么是“状态管理模式”？</strong>(这个例子别和后面的搞混了)</h2><p>让我们从一个简单的 Vue <strong>计数应用</strong>开始：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  // state</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // view</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `,</span><br><span class="line">  // actions</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment () &#123;</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意看上面的注释</strong><br>这个状态自管理应用包含以下3个部分：</p>
<ul>
<li>state，驱动应用的数据源；</li>
<li>view，以声明方式将 state 映射到视图；</li>
<li>actions，响应在 view 上的用户输入导致的状态变化。</li>
</ul>
<p>以下是一个表示“<strong>单向</strong>数据流”理念的极简示意：</p>
<p><img src="flow.png" alt="单向数据流"></p>
<p>但是，当我们的应用遇到<strong>多个组件共享状态</strong>时，单向数据流的简洁性很容易被破坏：</p>
<ul>
<li>多个视图依赖于同一状态。</li>
<li>来自不同视图的行为需要变更同一状态。</li>
</ul>
<p>对于问题一，传参的方法<strong>对于多层嵌套的组件将会非常繁琐</strong>，并且对于<strong>兄弟组件间的状态传递无能为力</strong>。<br>对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</p>
<p>因此，我们为什么不把组件的<strong>共享状态抽取出来</strong>，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！</p>
<p>另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。</p>
<p>这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。</p>
<p><img src="vuex.png" alt="vuex"></p>
<h2 id="什么情况下我应该使用-Vuex？"><a href="#什么情况下我应该使用-Vuex？" class="headerlink" title="什么情况下我应该使用 Vuex？"></a>什么情况下我应该使用 Vuex？</h2><p>虽然 Vuex 可以帮助我们管理共享状态，<strong>但也附带了更多的概念和框架</strong>。这需要对短期和长期效益进行权衡。</p>
<p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——<strong>如果您的应用够简单，您最好不要使用 Vuex</strong>。一个简单的 <strong>global event bus</strong> 就足够您所需了。但是，如果您需要构建是一个<strong>中大型单页应用</strong>，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：</p>
<p>Flux 架构就像眼镜：您自会知道什么时候需要它。</p>
<h1 id="开始-这里开始才是重头戏"><a href="#开始-这里开始才是重头戏" class="headerlink" title="开始(这里开始才是重头戏)"></a>开始(这里开始才是重头戏)</h1><p>每一个 Vuex 应用的<strong>核心就是 store（仓库）</strong>。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同：</p>
<ol>
<li>Vuex 的状态存储是<strong>响应式</strong>的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>你<strong>不能直接改变</strong> store 中的状态。改变 store 中的状态的<strong>唯一途径</strong>就是<strong>显式地提交 (commit) mutation</strong>。这样使得我们可以方便地<strong>跟踪</strong>每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>
</ol>
<h2 id="最简单的-Store"><a href="#最简单的-Store" class="headerlink" title="最简单的 Store"></a>最简单的 Store</h2><p>安装 Vuex 之后，让我们来创建一个 store。创建过程直截了当——仅需要提供一个初始 state 对象和一些 mutation(这个当成类actions好了)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在，你可以通过 <strong>store.state 来获取状态对象(后面用computed来返回)</strong>，以及通过 <strong>store.commit 方法触发状态变更</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//commit一个increment到mutations触发，然后这个mutations会mutate一个state</span><br><span class="line">store.commit('increment')</span><br><span class="line"></span><br><span class="line">console.log(store.state.count) // -&gt; 1</span><br></pre></td></tr></table></figure>
<p><strong>再次强调</strong>，我们<strong>通过提交 mutation</strong> 的方式，而<strong>非直接改变</strong> store.state.count，是因为我们想要更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。有了它，我们甚至可以实现如时间穿梭般的调试体验。</p>
<p>由于 store 中的<strong>状态是响应式</strong>的，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。<strong>触发变化</strong>也仅仅是在组件的 methods 中提交 mutation。</p>
<p>这是一个最基本的 Vuex 记数应用示例。</p>
<p>接下来，我们将会更深入地探讨一些核心概念。让我们先从 State 概念开始</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>在这一章，我们将会学到 Vue 的这些核心概念。他们是：</p>
<ul>
<li>State</li>
<li>Getter</li>
<li>Mutation</li>
<li>Action</li>
<li>Module</li>
</ul>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p><strong>单一状态树</strong><br>Vuex 使用单一状态树——是的，<strong>用一个对象就包含了全部的应用层级状态</strong>。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，<strong>每个应用将仅仅包含一个 store 实例</strong>。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p>
<p><strong>单状态树和模块化并不冲突</strong>——在后面的章节里我们会讨论如何将状态和状态变更事件分布到各个子模块中。</p>
<p><strong>那么我们如何在 Vue 组件中展示状态呢</strong>？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态<strong>最简单的方法</strong>就是在<strong>计算属性</strong>中返回某个状态：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 Counter 组件</span><br><span class="line">const Counter = &#123;</span><br><span class="line">  template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span><br><span class="line">  computed: &#123;   //稳得一比，前面console.log只是打印</span><br><span class="line">    count () &#123;</span><br><span class="line">      return store.state.count      //下面的例子会改下这里，从store变为this.$store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。</p>
<p>然而，<strong>这种模式导致组件依赖全局状态单例</strong>。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。</p>
<p>Vuex 通过 store 选项，<strong>提供了一种机制将状态从根组件“注入”到每一个子组件中</strong>（需调用 Vue.use(Vuex)）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: '#app',</span><br><span class="line">  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件(多个了store，和router一样用法)</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过在<strong>根实例中注册 store 选项</strong>，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 <strong>this.$store</strong> 访问到。让我们更新下 Counter 的实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Counter = &#123;</span><br><span class="line">  template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      return this.$store.state.count     //这里从store变为this.$store(从vue实例)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h4><p>当<strong>一个组件需要获取多个状态时候</strong>，将这些状态都声明为计算属性(<strong>这个函数还是在computed中用哦</strong>)会有些重复和冗余。为了解决这个问题，我们可以使用 mapState <strong>辅助函数帮助我们生成计算属性</strong>，让你少按几次键：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 在单独构建的版本中辅助函数为 Vuex.mapState</span><br><span class="line">import &#123; mapState &#125; from 'vuex'</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: mapState(&#123;      //还是computed中用</span><br><span class="line">    // 箭头函数可使代码更简练</span><br><span class="line">    count: state =&gt; state.count,</span><br><span class="line"></span><br><span class="line">    // 传字符串参数 'count' 等同于 `state =&gt; state.count`</span><br><span class="line">    countAlias: 'count',</span><br><span class="line"></span><br><span class="line">    // 为了能够使用 `this` 获取局部状态，必须使用常规函数</span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      return state.count + this.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当映射的<strong>计算属性的名称</strong>与 <strong>state 的子节点名称相同</strong>时，我们也可以给 mapState 传一个<strong>字符串数组</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  // 映射 this.count 为 store.state.count</span><br><span class="line">  'count'</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h4 id="对象展开运算符-…"><a href="#对象展开运算符-…" class="headerlink" title="对象展开运算符(…)"></a>对象展开运算符(…)</h4><p><strong>mapState 函数返回的是一个对象</strong>。我们<strong>如何将它与局部计算属性混合使用呢</strong>？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。但是自从有了对象展开运算符（现处于 ECMASCript 提案 stage-3 阶段），我们可以极大地简化写法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; /* ... */ &#125;,</span><br><span class="line">  // 使用对象展开运算符将此对象混入到外部对象中,上面算完后，这里获取</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组件仍然保有局部状态"><a href="#组件仍然保有局部状态" class="headerlink" title="组件仍然保有局部状态"></a>组件仍然保有局部状态</h4><p>使用 Vuex <strong>并不意味着你需要将所有的状态放入 Vuex。</strong>虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。</p>
<h3 id="Getter-在state基础上，可以认为是-store-的计算属性"><a href="#Getter-在state基础上，可以认为是-store-的计算属性" class="headerlink" title="Getter(在state基础上，可以认为是 store 的计算属性)"></a>Getter(在state基础上，可以认为是 store 的计算属性)</h3><p>有时候我们需要<strong>从 store 中的 state 中派生出一些状态</strong>，例如对列表进行过滤并计数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">      //在state中的todos进行过滤</span><br><span class="line">    return this.$store.state.todos.filter(todo =&gt; todo.done).length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——<strong>无论哪种方式都不是很理想</strong>。</p>
<p>Vuex 允许我们在 store 中定义“getter”（<strong>可以认为是 store 的计算属性</strong>）。就像计算属性一样，getter 的返回值会根据它的依赖被<strong>缓存</strong>起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<p><strong>Getter 接受 state 作为其第一个参数(废话，在state的基础上啊，然后也有mapGetters的)</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; id: 1, text: '...', done: true &#125;,</span><br><span class="line">      &#123; id: 2, text: '...', done: false &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">      //这就直接上了，这里就一个参数</span><br><span class="line">    doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>Getter 会暴露为 store.getters 对象(废话了，和state调用一样)</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.doneTodos // -&gt; [&#123; id: 1, text: '...', done: true &#125;]</span><br></pre></td></tr></table></figure>
<p>Getter 也可以接受其他 getter 作为<strong>第二个参数</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  // 话说第二个参数就是自己么</span><br><span class="line">  doneTodosCount: (state, getters) =&gt; &#123;</span><br><span class="line">    return getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.getters.doneTodosCount // -&gt; 1</span><br></pre></td></tr></table></figure>
<p>我们可以很容易地在任何组件中使用它：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    return this.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以通过让 getter <strong>返回一个函数</strong>，来实现给 getter 传参。在你<strong>对 store 里的数组进行查询时非常有用</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  // 这还两个箭头了</span><br><span class="line">  getTodoById: (state) =&gt; (id) =&gt; &#123;</span><br><span class="line">    return state.todos.find(todo =&gt; todo.id === id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.getters.getTodoById(2) // -&gt; &#123; id: 2, text: '...', done: false &#125;</span><br></pre></td></tr></table></figure>
<h4 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h4><p>mapGetters 辅助函数仅仅是将 store 中的 getter <strong>映射到局部计算属性</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from 'vuex'</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: &#123;</span><br><span class="line">  // 使用对象展开运算符将 getter 混入 computed 对象中,也是多个getters</span><br><span class="line">    ...mapGetters([</span><br><span class="line">      'doneTodosCount',</span><br><span class="line">      'anotherGetter',</span><br><span class="line">      // ...</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">如果你想将一个 getter 属性另取一个名字，使用对象形式：</span><br><span class="line"></span><br><span class="line">mapGetters(&#123;</span><br><span class="line">  // 映射 `this.doneCount` 为 `store.getters.doneTodosCount`</span><br><span class="line">  doneCount: 'doneTodosCount'</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Mutation-mutation-都是同步事务"><a href="#Mutation-mutation-都是同步事务" class="headerlink" title="Mutation(mutation 都是同步事务)"></a>Mutation(mutation 都是同步事务)</h3><p><strong>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</strong>。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个<strong>回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数(毕竟要改state)</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//还是那个计数的例子</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      // 变更状态</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>你<strong>不能直接调用一个 mutation handler</strong>。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit('increment')</span><br></pre></td></tr></table></figure>
<h4 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h4><p>你可以向 store.commit <strong>传入额外的参数</strong>，即 mutation 的 载荷（payload）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 这个n就是payload</span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//当然相应的</span><br><span class="line">store.commit('increment', 10)</span><br></pre></td></tr></table></figure>
<p>在大多数情况下，<strong>载荷应该是一个对象</strong>，这样可以包含多个字段并且记录的 mutation 会<strong>更易读</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit('increment', &#123;</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h4><p>提交 mutation 的<strong>另一种方式是直接使用包含 type 属性的对象</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: 'increment',</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 <strong>handler 保持不变</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Mutation-需遵守-Vue-的响应规则"><a href="#Mutation-需遵守-Vue-的响应规则" class="headerlink" title="Mutation 需遵守 Vue 的响应规则"></a>Mutation 需遵守 Vue 的响应规则</h4><p>既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p>
<ol>
<li><p>最好<strong>提前</strong>在你的 store 中<strong>初始化</strong>好所有所需属性(响应式都这样)。</p>
</li>
<li><p>当需要在<strong>对象上添加新属性(这不就和v-for那个一样么，用set)</strong>时，你应该</p>
<ul>
<li><p>使用 Vue.set(obj, ‘newProp’, 123), 或者</p>
</li>
<li><p>以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：</p>
<p><code>state.obj = { ...state.obj, newProp: 123 }</code></p>
</li>
</ul>
</li>
</ol>
<h4 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h4><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// mutation-types.js    这些大写的就是啦</span><br><span class="line">export const SOME_MUTATION = 'SOME_MUTATION'</span><br><span class="line">// store.js</span><br><span class="line">import Vuex from 'vuex'</span><br><span class="line">import &#123; SOME_MUTATION &#125; from './mutation-types'</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名，还有这操作</span><br><span class="line">    [SOME_MUTATION] (state) &#123;</span><br><span class="line">      // mutate state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做</p>
<h4 id="Mutation-必须是同步函数"><a href="#Mutation-必须是同步函数" class="headerlink" title="Mutation 必须是同步函数"></a>Mutation 必须是同步函数</h4><p>一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  someMutation (state) &#123;</span><br><span class="line">    api.callAsyncMethod(() =&gt; &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p>
<h4 id="在组件中提交-Mutation"><a href="#在组件中提交-Mutation" class="headerlink" title="在组件中提交 Mutation"></a>在组件中提交 Mutation</h4><p>你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from 'vuex'</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span><br><span class="line"></span><br><span class="line">      // `mapMutations` 也支持载荷：</span><br><span class="line">      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下一步：Action"><a href="#下一步：Action" class="headerlink" title="下一步：Action"></a>下一步：Action</h4><p>在 mutation 中混合异步调用会导致你的程序很难调试。例如，当你能调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念。<strong>在 Vuex 中，mutation 都是同步事务</strong>：</p>
<p><code>store.commit(&#39;increment&#39;)</code><br>// 任何由 “increment” 导致的状态变更都应该在此刻完成。<br><strong>为了处理异步操作，让我们来看一看 Action</strong>。</p>
<h3 id="Action-为了处理异步操作"><a href="#Action-为了处理异步操作" class="headerlink" title="Action(为了处理异步操作)"></a>Action(为了处理异步操作)</h3><p><strong>Action 类似于 mutation，不同在于</strong>：</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。</li>
</ul>
<p>让我们来注册一个简单的 action：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  //就是这个了，看图是mutation之前的一个</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit('increment')</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Action 函数接受一个<strong>与 store 实例具有相同方法和属性的 context 对象</strong>，因此你可以调用 <strong>context.commit</strong> 提交一个 mutation，或者通过 <strong>context.state</strong> 和 <strong>context.getters</strong> 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 <strong>context 对象为什么不是 store 实例本身</strong>了。</p>
<p>实践中，我们会经常用到 ES2015 的 <strong>参数解构</strong> 来简化代码（特别是我们需要调用 commit 很多次的时候）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment (&#123; commit &#125;) &#123;</span><br><span class="line">    commit('increment')</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h4><p>Action 通过 <strong>store.dispatch</strong> 方法触发：</p>
<p><code>store.dispatch(&#39;increment&#39;)</code><br>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，<strong>还记得 mutation 必须同步执行这个限制么</strong>？Action 就不受约束！我们可以在 action 内部执行异步操作：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      commit('increment')</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Actions 支持同样的载荷方式和对象方式进行分发：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 以载荷形式分发</span><br><span class="line">store.dispatch('incrementAsync', &#123;</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 以对象形式分发</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: 'incrementAsync',</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>来看一个更加实际的购物车示例，<strong>涉及到调用异步 API 和分发多重 mutation：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line">    // 把当前购物车的物品备份起来</span><br><span class="line">    const savedCartItems = [...state.cart.added]</span><br><span class="line">    // 发出结账请求，然后乐观地清空购物车</span><br><span class="line">    commit(types.CHECKOUT_REQUEST)</span><br><span class="line">    // 购物 API 接受一个成功回调和一个失败回调</span><br><span class="line">    shop.buyProducts(</span><br><span class="line">      products,</span><br><span class="line">      // 成功操作</span><br><span class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class="line">      // 失败操作</span><br><span class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们正在进行一系列的<strong>异步</strong>操作，并且通<strong>过提交 mutation 来记录 action 产生的副作用</strong>（即状态变更）。</p>
<h4 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h4><p>你在组件中使用 <strong>this.$store.dispatch(‘xxx’)</strong> 分发 action，或者使用 <strong>mapActions</strong> 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapActions &#125; from 'vuex'</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span><br><span class="line"></span><br><span class="line">      // `mapActions` 也支持载荷：</span><br><span class="line">      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h4><p>Action 通常是异步的，那么如何知道 <strong>action 什么时候结束呢</strong>？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>
<p>首先，你需要明白 <strong>store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise</strong>，并且 <strong>store.dispatch 仍旧返回 Promise：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        commit('someMutation')</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你可以：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch('actionA').then(() =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在另外一个 action 中也可以：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  // ...</span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    return dispatch('actionA').then(() =&gt; &#123;</span><br><span class="line">      commit('someOtherMutation')</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，如果我们利用 async / await，我们可以如下组合 action：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 假设 getData() 和 getOtherData() 返回的是 Promise</span><br><span class="line">actions: &#123;</span><br><span class="line">  async actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit('gotData', await getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  async actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    await dispatch('actionA') // 等待 actionA 完成</span><br><span class="line">    commit('gotOtherData', await getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>由于使用单一状态树，应用的<strong>所有状态会集中到一个比较大的对象</strong>。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>
<p>为了解决以上问题，Vuex 允许我们<strong>将 store 分割成模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure>
<h4 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h4><p>对于模块内部的 mutation 和 getter，接收的<strong>第一个参数是模块的局部状态对象</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; count: 0 &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      // 这里的 `state` 对象是模块的局部状态</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount (state) &#123;</span><br><span class="line">      return state.count * 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，对于模块内部的 action，局部状态通过<strong> context.state</strong> 暴露出来，<strong>根节点状态则为 context.rootState</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  actions: &#123;</span><br><span class="line">      //这有3个参数了，第3个参数是根节点的状态</span><br><span class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</span><br><span class="line">      if ((state.count + rootState.count) % 2 === 1) &#123;</span><br><span class="line">        commit('increment')</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  getters: &#123;</span><br><span class="line">    sumWithRootCount (state, getters, rootState) &#123;</span><br><span class="line">      return state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="命名空间-暂不懂"><a href="#命名空间-暂不懂" class="headerlink" title="命名空间(暂不懂)"></a>命名空间(暂不懂)</h4><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>
<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <strong>namespaced: true</strong> 的方式使其成为命名空间模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="在命名空间模块内访问全局内容（Global-Assets）"><a href="#在命名空间模块内访问全局内容（Global-Assets）" class="headerlink" title="在命名空间模块内访问全局内容（Global Assets）"></a>在命名空间模块内访问全局内容（Global Assets）</h4><h4 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="headerlink" title="带命名空间的绑定函数"></a>带命名空间的绑定函数</h4><h4 id="给插件开发者的注意事项"><a href="#给插件开发者的注意事项" class="headerlink" title="给插件开发者的注意事项"></a>给插件开发者的注意事项</h4><h4 id="模块动态注册"><a href="#模块动态注册" class="headerlink" title="模块动态注册"></a>模块动态注册</h4><h4 id="模块重用"><a href="#模块重用" class="headerlink" title="模块重用"></a>模块重用</h4><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：</p>
<ol>
<li><p>应用层级的状态应该集中到单个 store 对象中。</p>
</li>
<li><p>提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。</p>
</li>
<li><p>异步逻辑都应该封装到 action 里面。</p>
</li>
</ol>
<p>只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。</p>
<p>对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... # 抽取出API请求</span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          # 我们组装模块并导出 store 的地方</span><br><span class="line">    ├── actions.js        # 根级别的 action</span><br><span class="line">    ├── mutations.js      # 根级别的 mutation</span><br><span class="line">    └── modules</span><br><span class="line">        ├── cart.js       # 购物车模块</span><br><span class="line">        └── products.js   # 产品模块</span><br></pre></td></tr></table></figure>
<h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>开启严格模式，仅需在创建 store 的时候传入 strict: true：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  strict: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p>
<p><strong>开发环境与发布环境</strong><br><strong>不要在发布环境下启用严格模式</strong>！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。</p>
<p>类似于插件，我们可以让构建工具来处理这种情况：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  strict: process.env.NODE_ENV !== 'production'</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/03/vue-router使用总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/03/vue-router使用总结/" itemprop="url">vue-router使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T14:48:00+08:00">2018-02-03</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vue-route-这货是个插件"><a href="#vue-route-这货是个插件" class="headerlink" title="vue-route(这货是个插件)"></a>vue-route(这货是个插件)</h1><p>主要想整理的是这个配合v-for一起用</p>
<p><a href="https://router.vuejs.org/zh-cn/essentials/getting-started.html" target="_blank" rel="noopener">vue-router官网的介绍</a></p>
<p><strong>使用vue-cli来构建路由</strong></p>
<p>先说下3个基本概念：route, routes, router<br><a href="http://www.jb51.net/article/111499.htm" target="_blank" rel="noopener">详解vue-router基本使用</a></p>
<p>1， route，它是一条路由，是单数。<br>Home按钮  =&gt; home内容， 这是一条route,<br>about按钮 =&gt; about 内容， 这是另一条路由。</p>
<p>2， routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。<br>[<br>    {home 按钮 =&gt;home内容 }，<br>    { about按钮 =&gt; about 内容}<br>]</p>
<p>3， router 是一个机制，相当于一个<strong>管理者</strong>，它来管理路由。<br>因为routes 只是定义了一组路由放在那里，是静止的，当有请求时，怎么找到对应的那条route呢？ 比如当用户点击home 按钮的时候，怎么知道跳转到home页面？这时router 就起作用了，它到routes 中去查找，去找到对应的route(home页面)，所以页面中就显示了home 内容。</p>
<p>4，客户端中的路由，实际上就是dom 元素的显示和隐藏。当页面中显示home 内容的时候，about 中的内容全部隐藏，反之也是一样。<br>客户端路由有两种实现方式：基于hash 和基于html5 history api.</p>
<h2 id="基本的路由-静态路由"><a href="#基本的路由-静态路由" class="headerlink" title="基本的路由(静态路由)"></a>基本的路由(静态路由)</h2><p><strong>下面开始</strong><br>官网一个基本的例子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue-router/dist/vue-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 router-link 组件来导航. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当 &lt;router-link&gt; 对应的路由匹配成功，将自动设置 class 属性值 .router-link-active --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/bar"</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">JavaScript</span><br><span class="line">// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">// 1. 定义（路由）组件。</span><br><span class="line">// 可以从其他文件 import 进来</span><br><span class="line">const Foo = &#123; template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span>' &#125;</span><br><span class="line">const Bar = &#123; template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">div</span>&gt;</span>' &#125;</span><br><span class="line"></span><br><span class="line">// 2. 定义路由</span><br><span class="line">// 每个路由应该映射一个组件。 其中"component" 可以是</span><br><span class="line">// 通过 Vue.extend() 创建的组件构造器，</span><br><span class="line">// 或者，只是一个组件配置对象。</span><br><span class="line">// 我们晚点再讨论嵌套路由(就是放在children中)。</span><br><span class="line">const routes = [</span><br><span class="line">  &#123; path: '/foo', component: Foo &#125;,</span><br><span class="line">  &#123; path: '/bar', component: Bar &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 3. 创建 router 实例，然后传 `routes` 配置</span><br><span class="line">// 你还可以传别的配置参数, 不过先这么简单着吧。</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes // （缩写）相当于 routes: routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 4. 创建和挂载根实例。</span><br><span class="line">// 记得要通过 router 配置参数注入路由，</span><br><span class="line">// 从而让整个应用都有路由功能</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount('#app')</span><br><span class="line"></span><br><span class="line">// 现在，应用已经启动了！</span><br></pre></td></tr></table></figure>
<p>可以看到html中只用了2个标签<br><code>&lt;router-link&gt;</code> <code>&lt;router-view&gt;</code></p>
<p><code>&lt;router-view&gt;</code>反正是显示路由内容的，<br>功能都在<code>&lt;router-link&gt;</code>，它定义了to那个路由 。</p>
<p>javascript页面<br>可以简单的理解为就是定义了一组routers，然后通过vue的vuerouter来管理</p>
<h2 id="动态路由（也就是把routers中的path改了-多对一，传参而已。另外注意watch和beforeRouteUpdate）"><a href="#动态路由（也就是把routers中的path改了-多对一，传参而已。另外注意watch和beforeRouteUpdate）" class="headerlink" title="动态路由（也就是把routers中的path改了: 多对一，传参而已。另外注意watch和beforeRouteUpdate）"></a>动态路由（也就是把routers中的path改了: 多对一，传参而已。另外注意watch和beforeRouteUpdate）</h2><p><strong>除了这个传参，还有url 这个query传参</strong><br><strong>上面的例子中router里面都是静态的,一一对应</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/bar"</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">const routes = [</span><br><span class="line">  &#123; path: '/foo', component: Foo &#125;,</span><br><span class="line">  &#123; path: '/bar', component: Bar &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>我们来看下动态路由，然后比较他们的区别</strong></p>
<p>我们经常需要把某种模式匹配到的所有路由，<strong>全都映射到同个组件(组件复用)</strong>。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用『动态路径参数』（dynamic segment）来达到这个效果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//这还是原来的User组件</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">//动态路由下复用这个User组件，改为</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    // 动态路径参数 以冒号开头</span><br><span class="line">    &#123; path: '/user/:id', component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性，<strong>使用 props</strong> 将组件和路由解耦，<strong>详见路由组件传参</strong></p>
</blockquote>
<p>现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。</p>
<p>一个『路径参数』使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。于是，我们可以更新 User 的模板，输出当前用户的 ID：</p>
<p>这里如果你看<code>&lt;router-link&gt;</code>这个to还是不动的，该foo该bar。只是routes和组件内变化(毕竟动态)</p>
<blockquote>
<p>把这个当做函数的传参记，比如<code>&lt;router-link to=&quot;/ser/foo&quot;&gt;</code>这个to中传过来一个foo,(这里的话还是和静态一样，只是routes变了，组件复用当然也给改，就是拿出参数问题)<br>然后再routers中的{ path: ‘/user/:id’, component: User } 匹配到了这个id，成了这么一个对象{id：foo}<br>最后去User组件中用$route.params这个对象可以拿出来用，毕竟就是传过来用的<br>还有就是beforeRouteUpdate的用处</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:center">匹配路径</th>
<th style="text-align:center">$route.params</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/user/:username</td>
<td style="text-align:center">/user/evan</td>
<td style="text-align:center">{ username: ‘evan’ }</td>
</tr>
<tr>
<td style="text-align:left">/user/:username/post/:post_id</td>
<td style="text-align:center">/user/evan/post/123</td>
<td style="text-align:center">{ username: ‘evan’, post_id: 123 }</td>
</tr>
</tbody>
</table>
</div>
<p><strong>响应路由参数的变化</strong><br>提醒一下，当使用路由参数时，例如从 /user/foo 导航到 /user/bar，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会再被调用</strong>。</p>
<p>复用组件时，想对路由参数的变化作出响应的话，你可以简单地 <strong>watch（监测变化） $route 对象</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: '...',</span><br><span class="line">  watch: &#123;</span><br><span class="line">    '$route' (to, from) &#123;</span><br><span class="line">      // 对路由变化作出响应...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者使用 2.2 中引入的 beforeRouteUpdate 守卫：</span><br><span class="line"></span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '...',</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    // react to route changes...</span><br><span class="line">    // don't forget to call next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>匹配优先级</strong><br>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p>
<h2 id="嵌套路由-就是一个套一个，在-lt-router-view-gt-中套，在routes中套children-同级的呢，命名看命名视图"><a href="#嵌套路由-就是一个套一个，在-lt-router-view-gt-中套，在routes中套children-同级的呢，命名看命名视图" class="headerlink" title="嵌套路由 (就是一个套一个，在&lt;router-view&gt;中套，在routes中套children)(同级的呢，命名看命名视图)"></a>嵌套路由 (就是一个套一个，在<code>&lt;router-view&gt;</code>中套，在routes中套children)(同级的呢，命名看命名视图)</h2><p>前面的例子并没有嵌套，现在搞下嵌套</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//这个是默认app挂在的地方，看到app了么</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//这是User组件</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">//配置哦</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: '/user/:id', component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在app中的 <code>&lt;router-view&gt;</code>是最顶层的出口，渲染最高级路由匹配到的组件。同样地，一个被渲染组件同样可以包含自己的嵌套 <router-view>。例如，在 User 组件的模板添加一个 <router-view>：</router-view></router-view></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//这是User组件，现在就有两层了</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//要在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置(上面嵌套了2层，**想一下再往下呢，就是再放一个children咯**)：</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: '/user/:id', component: User,</span><br><span class="line">      children: [   //要再嵌套可以在放一个children</span><br><span class="line">        &#123;</span><br><span class="line">          // 当 /user/:id/profile 匹配成功，</span><br><span class="line">          // UserProfile 会被渲染在 User 的 <span class="tag">&lt;<span class="name">router-view</span>&gt;</span> 中</span><br><span class="line">          path: 'profile',    //可以注意这里是相对路径哦</span><br><span class="line">          component: UserProfile</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          // 当 /user/:id/posts 匹配成功</span><br><span class="line">          // UserPosts 会被渲染在 User 的 <span class="tag">&lt;<span class="name">router-view</span>&gt;</span> 中</span><br><span class="line">          path: 'posts',</span><br><span class="line">          component: UserPosts</span><br><span class="line">        &#125;,</span><br><span class="line">        // 这是一个当做默认路由的，空路由</span><br><span class="line">        // 当 /user/:id 匹配成功，</span><br><span class="line">        // UserHome 会被渲染在 User 的 <span class="tag">&lt;<span class="name">router-view</span>&gt;</span> 中</span><br><span class="line">        &#123; path: '', component: UserHome &#125;,</span><br><span class="line"></span><br><span class="line">        // ...其他子路由</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>问题</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//嵌套不是这样嵌套，</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//也不是这样哦。  嵌套是一对一啊，这个user套在app去，同理 你要多层的嵌套就再导入一个组件呗，在那个组件里写router-view</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span> <span class="comment">&lt;!-- 不报错，不过反正是丢弃 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//还有既然这样不行，那么直接在router-view写东西怎么样，和slot一回事么</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span></span><br><span class="line">    在这写东西怎么处理的？<span class="comment">&lt;!-- 这个直接丢弃了 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>有时候，通过一个<strong>名称来标识(name)</strong>一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。(只要先记住name好了，下面的编程式路由接着往下看)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: '/user/:userId',</span><br><span class="line">      name: 'user',   //就多了这个name</span><br><span class="line">      component: User</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>要链接到一个命名路由，可以给 <code>&lt;router-link&gt;</code>的 <strong>to 属性</strong>传一个<strong>对象</strong>：(这块往下看)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这跟代码调用 router.push() 是一回事(就是编程式路由一回事)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>这两种方式都会把路由导航到 /user/123 路径。</p>
<h2 id="编程式的导航-借助-router-的实例方法，通过编写代码来实现，重要的是学to的参数用法"><a href="#编程式的导航-借助-router-的实例方法，通过编写代码来实现，重要的是学to的参数用法" class="headerlink" title="编程式的导航(借助 router 的实例方法，通过编写代码来实现，重要的是学to的参数用法)"></a>编程式的导航(借助 router 的<strong>实例方法</strong>，通过编写代码来实现，重要的是学to的参数用法)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.push(location, onComplete?, onAbort?)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 2.2.0+，可选的在 router.push 或 router.replace 中提供 onComplete 和 onAbort 回调作为第二个和第三个参数。这些回调将会在导航<strong>成功完成</strong> (在所有的异步钩子被解析之后) 或<strong>终止</strong> (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。</p>
<p>注意：如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 /users/1 -&gt; /users/2)，你需要使用 <strong>beforeRouteUpdate</strong> 来响应这个变化 (比如抓取用户信息) (就是前面的动态路由 组件复用)。</p>
</blockquote>
<p>注意：在 <strong>Vue 实例内部</strong>，你可以通过 $router 访问路由实例。因此你可以调用 <strong>this.$router.push</strong>。</p>
<p>想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p>
<p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code>(看到这个用了v-bind哦动态) 等同于调用 router.push(…)。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">声明式</th>
<th style="text-align:center">编程式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>
<td style="text-align:center">router.push(…)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>上面没啥，下面重要来了，to的参数</strong><br><strong>同样的规则也适用于 router-link 组件的 to 属性。</strong></p>
<p>该方法的参数可以是一个<strong>字符串路径</strong>，或者一个描述地址的<strong>对象</strong>。例如：</p>
<p><strong>(3种传参，[path]/[name params]/[path/name+query])</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">router.push('home')</span><br><span class="line"></span><br><span class="line">// 对象</span><br><span class="line">router.push(&#123; path: 'home' &#125;)</span><br><span class="line"></span><br><span class="line">// 命名的路由</span><br><span class="line">router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;)</span><br><span class="line"></span><br><span class="line">// 带查询参数，变成 /register?plan=private</span><br><span class="line">router.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Get请求传参, 看最后一个带查询参数<br>这个明明实在不好形容啊。不过真的是和Get请求一样。你完全可以在链接后加上?进行传参。<br>样例：<a href="http://localhost:8080/linkParamsQuestion?age=18" target="_blank" rel="noopener">http://localhost:8080/linkParamsQuestion?age=18</a><br>项目里获取：<br><code>let age = this.$route.query.age;</code> //问号后面参数会被封装进 this.$route.query;</p>
</blockquote>
<p>注意：<strong>如果提供了 path，params 会被忽略(毕竟路径就代表参数)</strong>，上述例子中的 <strong>query 并不属于这种情况</strong>。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const userId = 123</span><br><span class="line">router.push(&#123; name: 'user', params: &#123; userId &#125;&#125;) // -&gt; /user/123</span><br><span class="line">router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123  es6写法</span><br><span class="line">// 这里的 params 不生效</span><br><span class="line">router.push(&#123; path: '/user', params: &#123; userId &#125;&#125;) // -&gt; /user</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>router.replace(location, onComplete?, onAbort?)</strong></p>
<p>跟 router.push 很像，唯一的不同就是，<strong>它不会向 history 添加新记录</strong>，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">声明式</th>
<th style="text-align:center">编程式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>
<td style="text-align:center">router.replace(…)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>router.go(n)</strong><br>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。</p>
<p>例子<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在浏览器记录中前进一步，等同于 history.forward()</span><br><span class="line">router.go(1)</span><br><span class="line"></span><br><span class="line">// 后退一步记录，等同于 history.back()</span><br><span class="line">router.go(-1)</span><br><span class="line"></span><br><span class="line">// 前进 3 步记录</span><br><span class="line">router.go(3)</span><br><span class="line"></span><br><span class="line">// 如果 history 记录不够用，那就默默地失败呗</span><br><span class="line">router.go(-100)</span><br><span class="line">router.go(100)</span><br></pre></td></tr></table></figure></p>
<p><strong>操作 History(我怎么觉得这东西都不用了)</strong><br>你也许注意到 router.push、 router.replace 和 router.go 跟 window.history.pushState、 window.history.replaceState 和 window.history.go好像， 实际上它们确实是效仿 window.history API 的。</p>
<p>因此，如果你已经熟悉 Browser History APIs，那么在 vue-router 中操作 history 就是超级简单的。</p>
<p>还有值得提及的，vue-router 的导航方法 （push、 replace、 go） 在各类路由模式（history、 hash 和 abstract）下表现一致。</p>
<h2 id="命名视图-同级的视图view，前面讲过嵌套的"><a href="#命名视图-同级的视图view，前面讲过嵌套的" class="headerlink" title="命名视图(同级的视图view，前面讲过嵌套的)"></a>命名视图(同级的视图view，前面讲过嵌套的)</h2><p>有时候想同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 <strong>sidebar（侧导航） 和 main（主内容） 两个视图</strong>，这个时候命名视图就派上用场了。你可以在界面中<strong>拥有多个单独命名的视图</strong>，而不是只有一个单独的出口。如果 router-view <strong>没有设置名字</strong>，那么<strong>默认为 default</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view one"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view two"</span> <span class="attr">name</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view three"</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个视图使用一个组件渲染，因此对于同个路由，<strong>多个视图就需要多个组件</strong>。确保正确使用 <strong>components 配置（带上 s）</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: '/',</span><br><span class="line">      components: &#123;</span><br><span class="line">        default: Foo,</span><br><span class="line">        a: Bar,</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>嵌套命名视图(厉害了，嵌套，同级的合在一起)</strong></p>
<p>重点记住这个就好了<br>我们也有可能使用命名视图创建嵌套视图的复杂布局。这时你也需要命名用到的嵌套 router-view 组件。我们以一个设置面板为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/settings/emails                                       /settings/profile</span><br><span class="line">+-----------------------------------+                  +------------------------------+</span><br><span class="line">| UserSettings                      |                  | UserSettings                 |</span><br><span class="line">| +-----+-------------------------+ |                  | +-----+--------------------+ |</span><br><span class="line">| | Nav | UserEmailsSubscriptions | |  +------------&gt;  | | Nav | UserProfile        | |</span><br><span class="line">| |     +-------------------------+ |                  | |     +--------------------+ |</span><br><span class="line">| |     |                         | |                  | |     | UserProfilePreview | |</span><br><span class="line">| +-----+-------------------------+ |                  | +-----+--------------------+ |</span><br><span class="line">+-----------------------------------+                  +------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>UserSettings 是一个视图组件。</li>
<li>Nav 只是一个常规组件。</li>
<li>UserEmailsSubscriptions、UserProfile、UserProfilePreview 是嵌套的视图组件。</li>
</ul>
<p>就是UserSettings下有左右两块，右边那块又有嵌套。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- UserSettings.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>User Settings<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">NavBar</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"helper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  path: '/settings',</span><br><span class="line">  // 你也可以在顶级路由就配置命名视图</span><br><span class="line">  component: UserSettings,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    path: 'emails',</span><br><span class="line">    component: UserEmailsSubscriptions</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: 'profile',</span><br><span class="line">    components: &#123;</span><br><span class="line">      default: UserProfile,</span><br><span class="line">      helper: UserProfilePreview</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重定向-和-别名"><a href="#重定向-和-别名" class="headerlink" title="重定向 和 别名"></a>重定向 和 别名</h2><p><strong>重定向(一对一，有3种: ‘’, name, =&gt;)</strong></p>
<p>重定向也是通过 <strong>routes 配置</strong>来完成，下面例子是从 /a 重定向到 /b：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/a',</span><br><span class="line">      redirect: '/b'  //就加了这么一条redirect</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>重定向的目标也可以是一个<strong>命名的路由(和编程式to的 name写法一样)</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/a', </span><br><span class="line">      redirect: &#123; name: 'foo' &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>甚至是一个<strong>方法(es6的箭头函数)</strong>，动态返回重定向目标：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/a', </span><br><span class="line">      redirect: to =&gt; &#123;</span><br><span class="line">      // 方法接收 目标路由 作为参数</span><br><span class="line">      // return 重定向的 字符串路径/路径对象</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意<strong>导航守卫并没有应用在跳转路由上</strong>，而仅仅应用在其目标上。在下面这个例子中，为 /a 路由添加一个 beforeEach 或 beforeLeave 守卫并不会有任何效果。</p>
<p><strong>别名(一对多)</strong><br>『<strong>重定向</strong>』的意思是，当用户访问 /a时，URL 将会被<strong>替换成 /b</strong>，然后匹配路由为 /b，那么『别名』又是什么呢？</p>
<p>/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。</p>
<p>上面对应的路由配置为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/a', </span><br><span class="line">      component: A, </span><br><span class="line">      alias: '/b' </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>『别名』的功能让你可以自由地将 UI 结构<strong>映射到任意的 URL</strong>，而<strong>不是受限于配置的嵌套路由结构</strong>。</p>
<h2 id="路由组件传参-props-也有3种模式-布尔，对象，函数"><a href="#路由组件传参-props-也有3种模式-布尔，对象，函数" class="headerlink" title="路由组件传参(props 也有3种模式: 布尔，对象，函数)"></a>路由组件传参(props 也有3种模式: 布尔，对象，函数)</h2><p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。</p>
<p><strong>使用 props 将组件和路由解耦，取代与 $route 的耦合</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//这是动态路由那块的东西</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: '/user/:id', component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>通过 props 解耦</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  props: ['id'],</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User &#123;&#123; id &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: '/user/:id', component: User, props: true &#125;,</span><br><span class="line"></span><br><span class="line">    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span><br><span class="line">    &#123;</span><br><span class="line">      path: '/user/:id',</span><br><span class="line">      components: &#123; default: User, sidebar: Sidebar &#125;,</span><br><span class="line">      props: &#123; default: true, sidebar: false &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>布尔模式</strong><br>如果 props 被设置为 true，route.params 将会被设置为组件属性。</p>
<p><strong>对象模式</strong><br>如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/promotion/from-newsletter', </span><br><span class="line">      component: Promotion, </span><br><span class="line">      props: &#123; newsletterPopup: false &#125; <span class="comment">&lt;!-- 这个newsletterPopup是name么？和布尔模式啥区别，就是同级的用命名视图解耦用么？ --&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>函数模式</strong><br>你可以创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/search', </span><br><span class="line">      component: SearchUser, </span><br><span class="line">      props: (route) =&gt; (&#123; query: route.query.q &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>URL /search?q=vue 会将 {query: ‘vue’} 作为属性传递给 SearchUser 组件。</p>
<p><strong>请尽可能保持 props 函数为无状态的</strong>，因为它只会在路由发生变化时起作用。如果你需要状态来定义 props，请使用包装组件，这样 Vue 才可以对状态变化做出反应。</p>
<h2 id="HTML5-History-模式-暂时不知道"><a href="#HTML5-History-模式-暂时不知道" class="headerlink" title="HTML5 History 模式(暂时不知道)"></a>HTML5 History 模式(暂时不知道)</h2><hr>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="导航守卫（『导航』表示路由正在发生改变。暂时用全局的）"><a href="#导航守卫（『导航』表示路由正在发生改变。暂时用全局的）" class="headerlink" title="导航守卫（『导航』表示路由正在发生改变。暂时用全局的）"></a>导航守卫（『导航』表示路由正在发生改变。暂时用全局的）</h2><p><strong>(做登录拦截 或 loading)</strong></p>
<p>正如其名，vue-router 提供的导航守卫主要用来<strong>通过跳转或取消的方式守卫导航</strong>。有多种机会植入路由导航过程中：<strong>全局的, 单个路由独享的, 或者组件级的。</strong><br>记住<strong>参数或查询的改变并不会触发进入/离开的导航守卫</strong>。你可以通过观察(watch) $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。</p>
<h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><p>你可以使用 <strong>router.beforeEach</strong> 注册一个全局前置守卫：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当一个导航触发时，全局前置守卫<strong>按照创建顺序调用</strong>。守卫是<strong>异步</strong>解析执行，此时导航在所有守卫 <strong>resolve 完之前一直处于 等待</strong>中。</p>
<p>每个守卫方法接收<strong>三个参数</strong>：</p>
<p>to: Route: 即将要进入的目标 路由对象</p>
<p>from: Route: 当前导航正要离开的路由</p>
<p>next: Function: 一定要<strong>调用该方法来 resolve</strong> 这个钩子。执行<strong>效果依赖 next 方法</strong>的调用参数。</p>
<ul>
<li><p>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。</p>
</li>
<li><p>next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。</p>
</li>
<li><p>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。</p>
</li>
<li><p>next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</p>
</li>
</ul>
<p><strong>确保要调用 next 方法，否则钩子就不会被 resolved。</strong></p>
<h3 id="全局解析守卫（router-beforeResolve）"><a href="#全局解析守卫（router-beforeResolve）" class="headerlink" title="全局解析守卫（router.beforeResolve）"></a>全局解析守卫（router.beforeResolve）</h3><p>2.5.0 新增</p>
<p>在 2.5.0+ 你可以用 <strong>router.beforeResolve</strong> 注册一个<strong>全局守卫</strong>。这和 router.beforeEach 类似，<strong>区别</strong>是在导航被确认之前，<strong>同时</strong>在<strong>所有</strong>组件内守卫和异步路由组件<strong>被解析之后</strong>，解析守卫就被调用。</p>
<h3 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h3><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子<strong>不会接受 next 函数也不会改变导航本身</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="组件内的守卫-3个"><a href="#组件内的守卫-3个" class="headerlink" title="组件内的守卫(3个)"></a>组件内的守卫(3个)</h3><p>最后，你可以在路由组件内直接定义以下路由导航守卫：</p>
<p>beforeRouteEnter<br>beforeRouteUpdate (2.2 新增)<br>beforeRouteLeave</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const Foo = &#123;</span><br><span class="line">  template: `...`,</span><br><span class="line">  beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">    // 不！能！获取组件实例 `this`</span><br><span class="line">    // 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br><span class="line">    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">    // 可以访问组件实例 `this`</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">    // 导航离开该组件的对应路由时调用</span><br><span class="line">    // 可以访问组件实例 `this`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>beforeRouteEnter 守卫 <strong>不能访问 this</strong>，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</p>
<p>不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">  next(vm =&gt; &#123;</span><br><span class="line">    // 通过 `vm` 访问组件实例</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 beforeRouteEnter <strong>是支持给 next 传递回调的唯一守卫</strong>。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">  // just use `this`</span><br><span class="line">  this.name = to.params.name</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave (to, from , next) &#123;</span><br><span class="line">  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')</span><br><span class="line">  if (answer) &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next(false)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ol>
<h2 id="路由元信息-可以用来搞允许登录页面"><a href="#路由元信息-可以用来搞允许登录页面" class="headerlink" title="路由元信息(可以用来搞允许登录页面)"></a>路由元信息(可以用来搞允许登录页面)</h2><p>定义路由的时候可以配置 meta 字段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: '/foo',</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: 'bar',</span><br><span class="line">          component: Bar,</span><br><span class="line">          // a meta field 和props挺像的啊</span><br><span class="line">          //设置一个允不允许登录的标志</span><br><span class="line">          meta: &#123; requiresAuth: true &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>那么<strong>如何访问</strong>这个 meta 字段呢？</p>
<p><strong>用处</strong></p>
<p>首先，我们称呼 routes 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录</p>
<p>例如，根据上面的路由配置，/foo/bar 这个 URL 将会<strong>匹配父路由记录以及子路由记录</strong>。</p>
<p>一个路由匹配到的所有路由记录会暴露为 $route 对象（还有在导航守卫中的路由对象）的 <strong>$route.matched</strong> 数组。因此，我们需要遍历 $route.matched 来检查路由记录中的 meta 字段。</p>
<p>下面例子展示在<strong>全局导航守卫中检查</strong>元字段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//全局导航守卫</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  //这个就难懂了</span><br><span class="line">  if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123;</span><br><span class="line">    // this route requires auth, check if logged in</span><br><span class="line">    // if not, redirect to login page 登录页.</span><br><span class="line">    //这个auth.loggedIn 方法是外部引入的，你可以先写好一个校验是否登录的方法，再import进 router.js中去判断</span><br><span class="line">    if (!auth.loggedIn()) &#123;</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: '/login',</span><br><span class="line">        query: &#123; redirect: to.fullPath &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next() // 确保一定要调用 next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="过渡效果-暂时不管"><a href="#过渡效果-暂时不管" class="headerlink" title="过渡效果(暂时不管)"></a>过渡效果(暂时不管)</h2><h2 id="数据获取（这里有渲染导航，还有获取数据两块的）"><a href="#数据获取（这里有渲染导航，还有获取数据两块的）" class="headerlink" title="数据获取（这里有渲染导航，还有获取数据两块的）"></a>数据获取（这里有渲染导航，还有获取数据两块的）</h2><p>有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：</p>
<ul>
<li><p><strong>导航完成之后</strong>获取：先完成导航，然后在接下来的<strong>组件生命周期钩子</strong>中获取数据。在<strong>数据获取期间显示『加载中』之类</strong>的指示。</p>
</li>
<li><p>导航完成<strong>之前</strong>获取：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。</p>
</li>
</ul>
<p>从技术角度讲，两种方式都不错(我喜欢之后的) —— 就看你想要的用户体验是哪种。</p>
<h3 id="导航完成后获取数据"><a href="#导航完成后获取数据" class="headerlink" title="导航完成后获取数据"></a>导航完成后获取数据</h3><p>当你使用这种方式时，我们会<strong>马上导航和渲染组件</strong>，然后在组件的<strong>created 钩子中获取数据</strong>。这让我们有机会在数据获取期间展示<strong>一个 loading 状态</strong>，还可以在<strong>不同视图间展示不同的 loading</strong> 状态。</p>
<p>假设我们有一个 Post 组件，需要基于 $route.params.id 获取文章数据：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading"</span> <span class="attr">v-if</span>=<span class="string">"loading"</span>&gt;</span></span><br><span class="line">      Loading...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"error"</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line">      &#123;&#123; error &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"post"</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; post.title &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; post.body &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      loading: false,</span><br><span class="line">      post: null,</span><br><span class="line">      error: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    // 组件创建完后获取数据，</span><br><span class="line">    // 此时 data 已经被 observed 了</span><br><span class="line">    this.fetchData()</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    // 如果路由有变化，会再次执行该方法</span><br><span class="line">    '$route': 'fetchData'</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fetchData () &#123;</span><br><span class="line">      this.error = this.post = null</span><br><span class="line">      this.loading = true</span><br><span class="line">      // replace getPost with your data fetching util / API wrapper</span><br><span class="line">      getPost(this.$route.params.id, (err, post) =&gt; &#123;</span><br><span class="line">        this.loading = false</span><br><span class="line">        if (err) &#123;</span><br><span class="line">          this.error = err.toString()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.post = post</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在导航完成前获取数据"><a href="#在导航完成前获取数据" class="headerlink" title="在导航完成前获取数据"></a>在导航完成前获取数据</h3><p>通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 <strong>beforeRouteEnter</strong> 守卫中获取数据，当数据获取成功后只调用 next 方法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      post: null,</span><br><span class="line">      error: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class="line">      next(vm =&gt; vm.setData(err, post))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 路由改变前，组件就已经渲染完了</span><br><span class="line">  // 逻辑稍稍不同</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    this.post = null</span><br><span class="line">    getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class="line">      this.setData(err, post)</span><br><span class="line">      next()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    setData (err, post) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        this.error = err.toString()</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.post = post</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，<strong>显示一些进度条或者别的指示</strong>。如果数据获取失败，同样有必要展示一些全局的错误提醒。</p>
<h3 id="滚动行为-就是跳转后滚动条位置确定-用scrollBehavior方法"><a href="#滚动行为-就是跳转后滚动条位置确定-用scrollBehavior方法" class="headerlink" title="滚动行为(就是跳转后滚动条位置确定, 用scrollBehavior方法)"></a>滚动行为(就是跳转后滚动条位置确定, 用scrollBehavior方法)</h3><p>使用前端路由，当<strong>切换到新路由</strong>时，想要页面滚到<strong>顶部</strong>，或者是保持<strong>原先</strong>的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p>
<p><strong>注意: 这个功能只在支持 history.pushState 的浏览器中可用。</strong></p>
<p>当创建一个 Router 实例，你可以提供一个 <strong>scrollBehavior</strong> 方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [...],</span><br><span class="line">  scrollBehavior (to, from, savedPosition) &#123;  </span><br><span class="line">    // return 期望滚动到哪个的位置</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>scrollBehavior 方法<strong>接收 to 和 from 路由对象</strong>。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。</p>
<p>这个方法返回滚动位置的对象信息，长这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; x: number, y: number &#125;</span><br><span class="line">&#123; selector: string, offset? : &#123; x: number, y: number &#125;&#125; (offset 只在 2.6.0+ 支持)</span><br></pre></td></tr></table></figure>
<p>如果返回一个 falsy (译者注：falsy 不是 false，参考这里)的值，或者是一个空对象，那么不会发生滚动。</p>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">  return &#123; x: 0, y: 0 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于所有路由导航，简单地让页面滚动到顶部<br>返回 savedPosition，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">  if (savedPosition) &#123;</span><br><span class="line">    return savedPosition</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &#123; x: 0, y: 0 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你要模拟『<strong>滚动到锚点</strong>』的行为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">  if (to.hash) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      selector: to.hash</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="路由懒加载-路由不用变，变的是webpack配置，和我想的有点不一样"><a href="#路由懒加载-路由不用变，变的是webpack配置，和我想的有点不一样" class="headerlink" title="路由懒加载(路由不用变，变的是webpack配置，和我想的有点不一样)"></a>路由懒加载(路由不用变，变的是webpack配置，和我想的有点不一样)</h3><h2 id="Router-构造配置"><a href="#Router-构造配置" class="headerlink" title="Router 构造配置"></a>Router 构造配置</h2><p><strong>routes</strong>(<strong>一看感觉都见过了，确实</strong>)<br>类型: Array<routeconfig></routeconfig></p>
<p>RouteConfig 的类型定义：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">declare type RouteConfig = &#123;</span><br><span class="line">  path: string;</span><br><span class="line">  component?: Component;</span><br><span class="line">  name?: string; // 命名路由</span><br><span class="line">  components?: &#123; [name: string]: Component &#125;; // 命名视图组件</span><br><span class="line">  redirect?: string | Location | Function;</span><br><span class="line">  props?: boolean | string | Function;</span><br><span class="line">  alias?: string | Array<span class="tag">&lt;<span class="name">string</span>&gt;</span>;</span><br><span class="line">  children?: Array<span class="tag">&lt;<span class="name">RouteConfig</span>&gt;</span>; // 嵌套路由</span><br><span class="line">  beforeEnter?: (to: Route, from: Route, next: Function) =&gt; void;</span><br><span class="line">  meta?: any;</span><br><span class="line"></span><br><span class="line">  // 2.6.0+</span><br><span class="line">  caseSensitive?: boolean; // 匹配规则是否大小写敏感？(默认值：false)</span><br><span class="line">  pathToRegexpOptions?: Object; // 编译正则的选项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>mode(一种hash， 一种history)</strong><br>类型: string</p>
<p>默认值: “hash” (浏览器环境) | “abstract” (Node.js 环境)</p>
<p>可选值: “hash” | “history” | “abstract”</p>
<p>配置路由模式:</p>
<p>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。</p>
<p>history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</p>
<p>abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。</p>
<p><strong>base</strong><br>类型: string</p>
<p>默认值: “/“</p>
<p><strong>应用的基路径</strong>。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 “/app/“。<br>一般写成 <strong>__dirname</strong>，在<strong>webpack</strong>中有配置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/31/vue2getstart/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/31/vue2getstart/" itemprop="url">vue2getstart</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-31T16:31:50+08:00">2018-01-31</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vue2的入门"><a href="#vue2的入门" class="headerlink" title="vue2的入门"></a>vue2的入门</h1><p>开始梳理一下vue2的入门，主要还是一些模块的使用，反正vue2就是路由和模块</p>
<h2 id="vue2-getstart-vue实例"><a href="#vue2-getstart-vue实例" class="headerlink" title="vue2 getstart vue实例"></a>vue2 getstart vue实例</h2><p>通过下面语句可以动态查看data</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;&#123;$data | json&#125;&#125; <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你也可以自定义一个json的filters ，方法同methods<br>有时候删除不一定要定义methods 也可以用filters</p>
<p>老外的那个例子来讲些vue基础</p>
<p>主要讲解用到了</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v-bind</span><br><span class="line"></span><br><span class="line">v-text &#123;&#123;&#125;&#125; v-if v-show v-for v-on ref v-model .prevant</span><br><span class="line"></span><br><span class="line">el data methdos computed filters mounted</span><br></pre></td></tr></table></figure>
<p>过滤器|只用在mustache和v-bind表达式中，在v-for中用的话写一个computed</p>
<p>做一个，todolist的例子，实现增删改功能。<br>上面部分是tasks，下面部分是完成打钩的tasks。</p>
<p><img src="getstart.png" alt="getstart"></p>
<hr>
<h2 id="创建一个-Vue-实例以及数据与方法"><a href="#创建一个-Vue-实例以及数据与方法" class="headerlink" title="创建一个 Vue 实例以及数据与方法"></a>创建一个 Vue 实例以及数据与方法</h2><p>v-bind和v-model都是双向绑定，但v-model特别的用在表单中就好了，v-bind也可以用在表单，用来动态绑定value</p>
<p>当一个 Vue 实例被创建时，它向 Vue 的<strong>响应式</strong>系统中加入了其 data 对象中能找到的所有的属性。<br>只有当实例被创建时 <strong>data 中存在的属性</strong>才是响应式的，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;meg&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">      msg: <span class="string">''</span>       <span class="comment">//这个msg是响应的,name不是响应式的，也可以说在vue实例中没name这个东西，不存在给name响应式。</span></span><br><span class="line">      <span class="comment">//name: '' 所以给暂时没用到的可以设置为空值就好了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般实例就</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>关于使用<strong>Object.freeze(obj)</strong>来阻止响应式，如果这个data是放在vue的data中该怎么freeze？<br>比如上面的msg，我总不能也在vue实例外面var一个吧，然后freeze。</p>
<p>官网的例子是可以freeze的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data () &#123;     <span class="comment">//看到这里和上面的写法不一样，是因为这个是按组件的写法，data写成一个函数，防止复用组件时作用域混了</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      obj</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>除了数据属性，<strong>Vue 实例</strong>还暴露了一些有用的<strong>实例属性与方法</strong>，它们都有<strong>前缀 $</strong>，以便与用户定义的属性区分开来</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例属性</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>) <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//嵌套对象的增添</span></span><br><span class="line">vm.$set(<span class="keyword">this</span>.userProfile, <span class="string">'age'</span>, <span class="number">27</span>)</span><br><span class="line"></span><br><span class="line">对于</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//$el,$data</span></span><br><span class="line">$el === <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>) <span class="comment">// =&gt; true</span></span><br><span class="line">$data === data <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">$watch</span><br><span class="line"></span><br><span class="line">比如用来看数据</span><br><span class="line">&lt;pre&gt; &#123;&#123;$data | json&#125;&#125; &lt;<span class="regexp">/pre&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="vue-lifecycle"><a href="#vue-lifecycle" class="headerlink" title="vue lifecycle"></a>vue lifecycle</h2><pre><code>可以通过例子vuelifecycyle.html来观察
</code></pre><p>beforecreate : 可以在这加个loading事件<br>created ：在这结束loading，还做一些初始化，实现函数自执行<br>mounted ： 在这发起axios请求，拿回数据，配合路由钩子做一些事情<br>beforeDestory： destoryed ：当前组件已被删除，清空相关内容</p>
<p><a href="https://segmentfault.com/a/1190000008010666" target="_blank" rel="noopener">Vue2.0 探索之路——生命周期和钩子函数的一些理解</a></p>
<hr>
<h2 id="模板语法-去HTML中了"><a href="#模板语法-去HTML中了" class="headerlink" title="模板语法 去HTML中了"></a>模板语法 去HTML中了</h2><h3 id="插值-Mustache-和-v-bind-一个用在文本，一个用在属性"><a href="#插值-Mustache-和-v-bind-一个用在文本，一个用在属性" class="headerlink" title="插值 Mustache 和 v-bind(:) (一个用在文本，一个用在属性)"></a>插值 Mustache 和 v-bind(:) (一个用在文本，一个用在属性)</h3><p>常见的数据绑定就是使用“Mustache”语法 (双大括号) 的<strong>文本</strong>插值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br><span class="line">//v-text效果一样，但不好用</span><br><span class="line">&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">//加了v-once表示执行一次性地插值，只执行一次哦</span><br><span class="line">&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br><span class="line">//v-html输出真正的 HTML，暂时不用，防止被xss攻击</span><br></pre></td></tr></table></figure>
<p>上面Mustache 语法用在文本上，不能作用在 HTML 特性（属性）上，遇到这种情况应该使用 v-bind 指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>上面两者都只能使用单个js表达式，事实上所有v-指令除了v-for都是。<br>指令么暂时 v-if v-show v-for v-on(@)<br><strong>参数</strong><br>再说下布尔值 truthy和falsy。falsy有5种：0，false，undefined， null， ‘’<br>还有别的参数，就当变量好了：串，函数</p>
<p><strong>修饰符</strong> <strong>缩写</strong></p>
<hr>
<h2 id="又回到vue实例中：计算属性和观察者"><a href="#又回到vue实例中：计算属性和观察者" class="headerlink" title="又回到vue实例中：计算属性和观察者"></a>又回到vue实例中：计算属性和观察者</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span></span><br><span class="line">    data: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>从刚开始的 el data<br>后面还有 filters<br>现在加上 <strong>computed methods watch</strong>  三者区别看<a href="https://juejin.im/post/58d8806bac502e0058d778a1" target="_blank" rel="noopener">史上最详细 VUE2.0 全套 demo 讲解 基础3（计算属性）</a></p>
<p>一.computed前面说了是适用于对多数据变动进行监听，然后来维护一个状态，就是返回一个状态<br>二.watch是对一个数据监听，在数据变化时，会返回两个值 ，一个是value(当前值)，二个是oldvalue是变化前的值，我们可以通过这些变化也可以去维护一个状态，但是不符合场景，主要用于什么地方呢？主要用于监听一个数据来进行复杂的逻辑操作,如图片加载完ajax，开销大的</p>
<p>当然别忘了lifecycle的 created mounted updated destroyed 以及他们对应的before</p>
<h3 id="在模板中（mustache），对于任何复杂逻辑，你都应当使用计算属性"><a href="#在模板中（mustache），对于任何复杂逻辑，你都应当使用计算属性" class="headerlink" title="在模板中（mustache），对于任何复杂逻辑，你都应当使用计算属性"></a>在模板中（mustache），对于任何复杂逻辑，你都应当使用计算属性</h3><p>官网例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"example"</span>&gt;</span><br><span class="line">  &#123;&#123; message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) &#125;&#125;       <span class="comment">//太多了</span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/改写为</span></span><br><span class="line"><span class="regexp">&lt;div id="example"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;Original message: "&#123;&#123; message &#125;&#125;"&lt;/</span>p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: <span class="string">"&#123;&#123; reversedMessage &#125;&#125;"</span>&lt;<span class="regexp">/p&gt;     /</span><span class="regexp">/这就清楚多了</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>计算属性的 setter</strong><br>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的写法和默认只有get的写法稍有不同</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;       <span class="comment">//here</span></span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">//这里看到了吗</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>计算属性缓存 vs 方法</strong></p>
<p>计算属性(computed)是基于它们的依赖进行<strong>缓存</strong>的。计算属性只有在它的相关依赖发生改变时才会重新求值。<br>方法(mtehods)：每当触发重新渲染时，调用方法将总会再次执行函数</p>
<p><strong>计算属性 vs 侦听属性</strong><br>侦听属性:当你有一些数据需要随着其它数据变动而变动时.通常更好的做法是使用计算属性而不是命令式的 watch 回调.<strong>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的</strong></p>
<p>官网例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"watch-example"</span>&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    &lt;input v-model=<span class="string">"question"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/cdn.jsdelivr.net/</span>npm/axios@<span class="number">0.12</span><span class="number">.0</span>/dist/axios.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>https:<span class="comment">//cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#watch-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    question: <span class="string">''</span>,</span><br><span class="line">    answer: <span class="string">'I cannot give you an answer until you ask a question!'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="line">    question: <span class="function"><span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.answer = <span class="string">'Waiting for you to stop typing...'</span></span><br><span class="line">      <span class="keyword">this</span>.getAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span><br><span class="line">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span><br><span class="line">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span><br><span class="line">    <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span><br><span class="line">    <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span><br><span class="line">    getAnswer: _.debounce(</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.question.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.answer = <span class="string">'Questions usually contain a question mark. ;-)'</span></span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.answer = <span class="string">'Thinking...'</span></span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">        axios.get(<span class="string">'https://yesno.wtf/api'</span>)</span><br><span class="line">          .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            vm.answer = <span class="string">'Error! Could not reach the API. '</span> + error</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 这是我们为判定用户停止输入等待的毫秒数</span></span><br><span class="line">      <span class="number">500</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="Class-与-Style-绑定-又回到模板中"><a href="#Class-与-Style-绑定-又回到模板中" class="headerlink" title="Class 与 Style 绑定 又回到模板中"></a>Class 与 Style 绑定 <strong>又回到模板中</strong></h2><p>都是属性啊，所以用v-bind，而且表达式结果的类型除了字符串之外，还可以是对象或数组<br>注意对象是key:value  数组时value 反正就是看对value就行</p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p><strong>对象</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这就是对象了 =&#123;&#125; key:value  本来是字符串=""</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive &#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多个</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"static"</span></span><br><span class="line">     v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">data: &#123;</span></span><br><span class="line"><span class="regexp">  isActive: true,</span></span><br><span class="line"><span class="regexp">  hasError: false</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/当然也可以直接就写个对象名</span></span><br><span class="line"><span class="regexp">&lt;div v-bind:class="classObject"&gt;&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'text-danger'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常用的还有写成computed的</span></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">'text-danger'</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">'fatal'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组 =[]    稍微和对象不一样哦这里只有value</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[activeClass, errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: <span class="string">'active'</span>,</span><br><span class="line">  errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组中也有对象哦，可以当做有个默认值</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[&#123; active: isActive &#125;, errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="style-会自动添加浏览器前缀"><a href="#style-会自动添加浏览器前缀" class="headerlink" title="style (会自动添加浏览器前缀)"></a>style (会自动添加浏览器前缀)</h3><p><strong>对象</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名，不推荐</span></span><br><span class="line">&lt;div v-bind:style=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: <span class="string">'red'</span>,</span><br><span class="line">  fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接绑定到一个样式对象通常更好，这会让模板更清晰：</span></span><br><span class="line">&lt;div v-bind:style=<span class="string">"styleObject"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="string">'13px'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同样的，对象语法常常结合返回对象的计算属性使用</span></span><br></pre></td></tr></table></figure></p>
<p><strong>数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上：</span></span><br><span class="line"></span><br><span class="line">&lt;div v-bind:style=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>当然他们还有在组件中应用，暂时不说</strong></p>
<hr>
<h2 id="接着说指令了，开始v-if-v-show-v-for-v-on"><a href="#接着说指令了，开始v-if-v-show-v-for-v-on" class="headerlink" title="接着说指令了，开始v-if v-show v-for -v-on"></a>接着说指令了，开始v-if v-show v-for -v-on</h2><h3 id="条件渲染-先说v-if-v-show"><a href="#条件渲染-先说v-if-v-show" class="headerlink" title="条件渲染 先说v-if v-show"></a>条件渲染 先说<strong>v-if v-show</strong></h3><p>看代码就明白了 <strong>v-if</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对一个元素 v-if v-else-if v-else 一个表示就一个根节点</span></span><br><span class="line">&lt;div v-<span class="keyword">if</span>=<span class="string">"type === 'A'"</span>&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div v-else-if="type === 'B'"&gt;</span></span><br><span class="line"><span class="regexp">  B</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;div v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"type === 'C'"</span>&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div v-else&gt;</span></span><br><span class="line"><span class="regexp">  Not A/</span>B/C</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/多个元素就要加上&lt;template&gt;，这个表示同级的(没有根节点，比如在表单中就不会用到嵌套,用的是同级的)，当然你直接在父元素上加也行啊(这就是嵌套)</span></span><br><span class="line"><span class="regexp">&lt;template v-if="ok"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;h1&gt;Title&lt;/</span>h1&gt;</span><br><span class="line">  &lt;p&gt;Paragraph <span class="number">1</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;Paragraph 2&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure>
<p>再说下key，上面的没加key是会复用的，所以会发生不会清除用户已经输入内容的情况<br>key表示”这两个元素是完全独立的，不要复用它们”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-<span class="keyword">if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/key加在了这里哦</span></span><br><span class="line"><span class="regexp">  &lt;input placeholder="Enter your username" key="username-input"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;template v-<span class="keyword">else</span>&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/还有这里</span></span><br><span class="line"><span class="regexp">  &lt;input placeholder="Enter your email address" key="email-input"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure>
<p><strong>v-show</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//只有一种形式，不多对于多个的只需要在父节点处用v-show就行了，反正不用同级的</span><br><span class="line">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>v-if vs v-show</strong><br>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>
<p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换display:none。</p>
<p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>
<p><strong>v-if 与 v-for 一起使用</strong><br>当 v-if 与 v-for 一起使用时，<strong>v-for</strong> 具有比 v-if 更高的<strong>优先级</strong></p>
<hr>
<h2 id="列表渲染-也就是v-for-优先级比v-if高"><a href="#列表渲染-也就是v-for-优先级比v-if高" class="headerlink" title="列表渲染 也就是v-for 优先级比v-if高"></a>列表渲染 也就是v-for 优先级比v-if高</h2><p>当然这个使用在对数组[] 以及对象的 {}</p>
<h3 id="用-v-for-把一个数组对应为一组元素"><a href="#用-v-for-把一个数组对应为一组元素" class="headerlink" title="用 v-for 把一个数组对应为一组元素"></a>用 v-for 把一个数组对应为一组元素</h3><p>在 v-for 块中，我们拥有对父作用域属性的完全访问权限<br>2种方式。一个是v-for=”item in items”   items 是源数据数组并且 item 是数组元素迭代的别名<br>一个是v-for=”(item, index) in items”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种只有value</span></span><br><span class="line">&lt;ul id=<span class="string">"example-1"</span>&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">"item in items"</span>&gt;</span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种有value和index</span></span><br><span class="line">&lt;ul id=<span class="string">"example-2"</span>&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">"(item, index) in items"</span>&gt;</span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMessage: <span class="string">'Parent'</span>,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="一个对象对应为一组元素"><a href="#一个对象对应为一组元素" class="headerlink" title="一个对象对应为一组元素"></a>一个对象对应为一组元素</h3><p>这就有3种了 毕竟对象有key: value  不过这里按 value key index 理由当然也是先拿value咯,不过还是<strong>按key的顺序</strong>哦<br>在遍历对象时，是按<strong> Object.keys()</strong> 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。<br>第1种是v-for=”value in object”<br>第2种是v-for=”(value, key) in object”<br>第3种是v-for=”(value, key, index) in object”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">&lt;ul id=<span class="string">"v-for-object"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">"value in object"</span>&gt;</span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#v-for-object'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      firstName: <span class="string">'John'</span>,</span><br><span class="line">      lastName: <span class="string">'Doe'</span>,</span><br><span class="line">      age: <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供第二个的参数为键名：</span></span><br><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">"(value, key) in object"</span>&gt;</span><br><span class="line">  &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/第三个参数为索引：</span></span><br><span class="line"><span class="regexp">&lt;div v-for="(value, key, index) in object"&gt;</span></span><br><span class="line"><span class="regexp">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="key，当然表示唯一咯，同v-if啦"><a href="#key，当然表示唯一咯，同v-if啦" class="headerlink" title="key，当然表示唯一咯，同v-if啦"></a>key，当然表示唯一咯，同v-if啦</h3><p><strong>建议尽可能在使用 v-for 时提供 key</strong><br>理想的 key 值是每项都有的且唯一的 id，它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值。<br>一般在数组或对象中提供了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">"item in items"</span> :key=<span class="string">"item.id"</span>&gt;</span><br><span class="line">  &lt;!-- 内容 --&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>它是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途，我们将在后面的指南中看到其他用途</strong></p>
<h3 id="数组更新检测-其实不用管这个，v-for还是会触发视图更新"><a href="#数组更新检测-其实不用管这个，v-for还是会触发视图更新" class="headerlink" title="数组更新检测(其实不用管这个，v-for还是会触发视图更新)"></a>数组更新检测(其实不用管这个，v-for还是会触发视图更新)</h3><p><strong>变异方法</strong> 就是改变原数组咯</p>
<ul>
<li>push()</li>
<li>pop()</li>
<li>unshift()</li>
<li>shift()</li>
<li>reverse()</li>
<li>sort()</li>
<li>splice()</li>
<li>clear()</li>
</ul>
<p><strong>替换数组</strong> 就是返回一个新数组咯</p>
<p>filter(), concat() 和 slice() map()</p>
<h2 id="有2种情况下数组检测不到更新-因为js的限制，要换方法使用"><a href="#有2种情况下数组检测不到更新-因为js的限制，要换方法使用" class="headerlink" title="有2种情况下数组检测不到更新(因为js的限制，要换方法使用)"></a>有2种情况下数组检测不到更新(因为js的限制，要换方法使用)</h2><ol>
<li>当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue</li>
<li>当你修改数组的长度时，例如：vm.items.length = newLength</li>
</ol>
<p><strong>看下面 我觉得统一下 用splice好了</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新：</span><br><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(example1.items, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">example1.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br><span class="line"></span><br><span class="line">为了解决第二类问题，你可以使用 splice：</span><br><span class="line">example1.items.splice(newLength)</span><br></pre></td></tr></table></figure></p>
<h3 id="上面是数组的增删，可以检测到，但对象属性的增删-又由于JS限制，检测不到。增加一个属性或多个属性"><a href="#上面是数组的增删，可以检测到，但对象属性的增删-又由于JS限制，检测不到。增加一个属性或多个属性" class="headerlink" title="上面是数组的增删，可以检测到，但对象属性的增删(又由于JS限制，检测不到。增加一个属性或多个属性)"></a>上面是数组的增删，可以检测到，但对象属性的增删(又由于JS限制，检测不到。增加一个属性或多个属性)</h3><p>就是不对<strong>根级别</strong>添加，而是对<strong>根里面嵌套的对象</strong>的添加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// `vm.a` 现在是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 不是响应式的</span></span><br></pre></td></tr></table></figure>
<p>对于已经创建的实例，Vue 不能动态添加<strong>根级别</strong>的响应式属性。但是，可以使用 Vue.set(object, key, value) 方法向<strong>嵌套对象</strong>添加响应式属性。例如，对于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userProfile: &#123;      <span class="comment">//看这里，嵌套哦</span></span><br><span class="line">      name: <span class="string">'Anika'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">你可以添加一个新的 age 属性到嵌套的 userProfile 对象：</span><br><span class="line"></span><br><span class="line">Vue.set(vm.userProfile, <span class="string">'age'</span>, <span class="number">27</span>)</span><br><span class="line"></span><br><span class="line">你还可以使用 vm.$set 实例方法，它只是上面全局 Vue.set 的别名：</span><br><span class="line"></span><br><span class="line">vm.$set(<span class="keyword">this</span>.userProfile, <span class="string">'age'</span>, <span class="number">27</span>)</span><br></pre></td></tr></table></figure>
<p>有时你可能需要为已有对象赋予<strong>多个新属性</strong>，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(<span class="keyword">this</span>.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br><span class="line">你应该这样做：</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.userProfile = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="v-for-显示过滤-排序结果-这个用不来filters，用computed，methods"><a href="#v-for-显示过滤-排序结果-这个用不来filters，用computed，methods" class="headerlink" title="v-for 显示过滤/排序结果(这个用不来filters，用computed，methods)"></a>v-for 显示过滤/排序结果(这个用不来filters，用computed，methods)</h3><p><strong>数组</strong><br>有时，我们想要显示一个<strong>数组</strong>的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的<strong>计算属性</strong>。</p>
<p>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">"n in evenNumbers"</span>&gt;&#123;&#123; n &#125;&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">data: &#123;</span></span><br><span class="line"><span class="regexp">  numbers: [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">computed: &#123;</span></span><br><span class="line"><span class="regexp">  evenNumbers: function () &#123;</span></span><br><span class="line"><span class="regexp">    return this.numbers.filter(function (number) &#123;</span></span><br><span class="line"><span class="regexp">      return number % 2 === 0</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>在计算属性不适用的情况下 (例如，<strong>在嵌套 v-for 循环中</strong>) 你可以使用一个 method 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">"n in even(numbers)"</span>&gt;&#123;&#123; n &#125;&#125;&lt;<span class="regexp">/li&gt;     /</span><span class="regexp">/可以看到这里不同</span></span><br><span class="line"><span class="regexp">data: &#123;</span></span><br><span class="line"><span class="regexp">  numbers: [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">methods: &#123;</span></span><br><span class="line"><span class="regexp">  even: function (numbers) &#123;</span></span><br><span class="line"><span class="regexp">    return numbers.filter(function (number) &#123;</span></span><br><span class="line"><span class="regexp">      return number % 2 === 0</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>一段取值范围的 v-for 整数</strong><br>v-for 也可以取整数。在这种情况下，它将重复多次模板。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"n in 10"</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>v-for on a <code>&lt;template&gt;</code>  多个同级，上面是一个根元素</strong><br>类似于 v-if，你也可以利用带有 v-for 的 <template> 渲染多个元素。比如：</template></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;template v-<span class="keyword">for</span>=<span class="string">"item in items"</span>&gt;</span><br><span class="line">    &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li class="divider"&gt;&lt;/</span>li&gt;</span><br><span class="line">  &lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>
<p><strong>v-for with v-if 前面说的优先级问题，在同一个标签上v-for高</strong><br>当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你想为<strong>仅有的一些项渲染节点</strong>时，这种优先级的机制会十分有用，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span> <span class="attr">v-if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span></span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码只传递了未完成的 todos。</p>
<p>而如果你的目的是<strong>有条件地跳过循环的执行</strong>，那么可以将 v-if 置于外层元素 (或 <template>)上。如：</template></p>
<p>这里没啥优先级而言，都不在一个元素标签上</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"todos.length"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No todos left!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="组件的v-for-（看完组件那块再回来体会）"><a href="#组件的v-for-（看完组件那块再回来体会）" class="headerlink" title="组件的v-for  （看完组件那块再回来体会）"></a>组件的v-for  （看完组件那块再回来体会）</h3><p>在自定义组件里，你可以像任何普通元素一样用 v-for 。用法不变,key一定要加 （但是这种做法错误的哦）。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>重点</strong></p>
<p>因为任何数据都<strong>不会被自动</strong>传递到组件里，因为组件有自己<strong>独立的作用域</strong>。为了把迭代数据传递到组件里，我们要用<strong> props</strong> ：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//上面的要改为这样写</span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:item</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>不自动</strong>将 item <strong>注入</strong>到组件里的<strong>原因</strong>是，这会使得组件与 v-for 的运作紧密<strong>耦合</strong>。明确组件数据的来源能够使组件在其他场合重复使用</p>
<p>下面是一个简单的 todo list 的完整例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"todo-list-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"newTodoText"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:keyup.enter</span>=<span class="string">"addNewTodo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">placeholder</span>=<span class="string">"Add a todo"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line">      is="todo-item"        //这里不是&lt;todo-item&gt; &lt;/todo-item&gt;</span><br><span class="line">      v-for="(todo, index) in todos"</span><br><span class="line">      v-bind:key="todo.id"</span><br><span class="line">      v-bind:title="todo.title"     //这里title 在组件中的props中绑定，todo.title才是变量名</span><br><span class="line">      v-on:remove="todos.splice(index, 1)"</span><br><span class="line">    &gt;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意这里的 is=”todo-item” 属性。这种做法在使用 DOM 模板时是十分必要的，<strong>因为在 <code>&lt;ul&gt;</code> 元素内只有 <code>&lt;li&gt;</code> 元素会被看作有效内容</strong>。这样做实现的效果与 <todo-item> 相同，但是可以避开一些潜在的浏览器解析错误</todo-item></p>
<p>类似的还有在<code>&lt;ul&gt;、&lt;ol&gt;、&lt;table&gt;、&lt;select&gt;</code></p>
<p><strong>当然有办法不这么麻烦 最简单的就是使用vue-cli咯</strong></p>
<p>如果使用来自以下来源之一的字符串模板，则没有这些限制：</p>
<ul>
<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>
<li>JavaScript 内联模板字符串</li>
<li>.vue 组件</li>
</ul>
<p>因此，请尽可能使用字符串模板。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  template: <span class="string">'\</span></span><br><span class="line"><span class="string">    &lt;li&gt;\</span></span><br><span class="line"><span class="string">      &#123;&#123; title &#125;&#125;\</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="$emit(\'remove\')"&gt;X&lt;/button&gt;\</span></span><br><span class="line"><span class="string">    &lt;/li&gt;\</span></span><br><span class="line"><span class="string">  '</span>,</span><br><span class="line">  props: [<span class="string">'title'</span>]      <span class="comment">//这是属性哦，title是属性名，不是变量名</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#todo-list-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    newTodoText: <span class="string">''</span>,</span><br><span class="line">    todos: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        title: <span class="string">'Do the dishes'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        title: <span class="string">'Take out the trash'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">3</span>,</span><br><span class="line">        title: <span class="string">'Mow the lawn'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    nextTodoId: <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addNewTodo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line">        id: <span class="keyword">this</span>.nextTodoId++,</span><br><span class="line">        title: <span class="keyword">this</span>.newTodoText</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.newTodoText = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="事件处理-（到v-on了-这个是监听事件，不是触发）"><a href="#事件处理-（到v-on了-这个是监听事件，不是触发）" class="headerlink" title="事件处理 （到v-on了 @ 这个是监听事件，不是触发）"></a>事件处理 （到v-on了 @ 这个是监听事件，不是触发）</h2><p><a href="https://juejin.im/post/58de6807da2f60005fc1a9bb" target="_blank" rel="noopener">Vue2.0进阶组件篇1 教你秒撸（短信倒计时组件）</a></p>
<p>可以用 v-on 指令<strong>监听(on) DOM 事件</strong>，并<strong>在触发时(emit)</strong>运行一些 JavaScript 代码。</p>
<p>示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"counter += 1"</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span>      //这里把方法直接写在""内了</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">var example1 = new Vue(&#123;</span><br><span class="line">  el: '#example-1',</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>更常见的，直接写一个方法名称</strong></p>
<p>然而许多事件处理逻辑会更为<strong>复杂</strong>，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的<strong>方法名称</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"greet"</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">var example2 = new Vue(&#123;</span><br><span class="line">  el: '#example-2',</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: 'Vue.js'</span><br><span class="line">  &#125;,</span><br><span class="line">  // 在 `methods` 对象中定义方法</span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: function (event) &#123;</span><br><span class="line">      // `this` 在方法里指向当前 Vue 实例</span><br><span class="line">      alert('Hello ' + this.name + '!')</span><br><span class="line">      // `event` 是原生 DOM 事件</span><br><span class="line">      if (event) &#123;</span><br><span class="line">        alert(event.target.tagName)     //这里还会弹出个'BUTTON'</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// F12也可以用 JavaScript 直接调用方法</span><br><span class="line">example2.greet() // =&gt; 'Hello Vue.js!' 没有'BUTTON'了</span><br></pre></td></tr></table></figure>
<p>除了直接绑定到一个方法，也可以在<strong>内联 JavaScript 语句中调用方法(传入参数就用好了)</strong>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('hi')"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span>    <span class="comment">&lt;!-- 直接传入参数用了 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('what')"</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-3',</span><br><span class="line">  methods: &#123;</span><br><span class="line">    say: function (message) &#123;</span><br><span class="line">      alert(message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>有时也需要在内联语句处理器中访问<strong>原始的 DOM 事件(这里是button)</strong>。可以用特殊变量 <strong>$event</strong> 把它传入方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"warn('Form cannot be submitted yet.', $event)"</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">// ...</span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: function (message, event) &#123;</span><br><span class="line">    // 现在我们可以访问原生事件对象 不懂这个什么意思</span><br><span class="line">    if (event) event.preventDefault()</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个小例子说明event.preventDefault()来阻止默认事件的发生，event.stopPropagation()阻止事件的冒泡<br>比如<code>&lt;a&gt;</code>点击它会发生跳转，用了preventDefault()之后就不跳转了,但会向上冒泡。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong><br>1.event.stopPropagation()方法<br>这是<strong>阻止事件的冒泡</strong>方法，不让事件向documen上蔓延，<strong>但是默认事件仍然会执行</strong>，当你掉用这个方法的时候，如果点击一个连接，这个连接仍然会被打开，</p>
<p>2.event.preventDefault()方法<br>这是<strong>阻止默认事件</strong>的方法，调用此方法是，连接不会被打开，<strong>但是会发生冒泡</strong>，冒泡会传递到上一层的父元素；</p>
<p>3.return false  ；<br>这个方法比较暴力，他会<strong>同时阻止事件冒泡也会阻止默认事件</strong>；写上此代码，连接不会被打开，事件也不会传递到上一层的父元素；可以理解为return false就等于同时调用了event.stopPropagation()和event.preventDefault()</p>
<p>不懂event.preventDefault()可以看下这个链接<br><a href="http://blog.csdn.net/wxl1555/article/details/53128966" target="_blank" rel="noopener">阻止事件冒泡，阻止默认事件，event.stopPropagation()和event.preventDefault()，return false的区别</a><br><a href="http://blog.csdn.net/zhangluo123__/article/details/72179543" target="_blank" rel="noopener">浅谈js中事件preventDefault()和addEventListener()</a></p>
<h4 id="v-on事件修饰符（接着上面的event-preventDefault-和event-stopPropagation-）"><a href="#v-on事件修饰符（接着上面的event-preventDefault-和event-stopPropagation-）" class="headerlink" title="v-on事件修饰符（接着上面的event.preventDefault()和event.stopPropagation()）"></a>v-on事件修饰符（接着上面的event.preventDefault()和event.stopPropagation()）</h4><p>在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是<strong>非常常见的需求</strong>。尽管我们可以在方法中轻松实现这点，<strong>但更好的方式是</strong>：方法<strong>只有纯粹的数据逻辑</strong>，而不是去处理 DOM 事件细节。</p>
<p>修饰符是由点开头的指令后缀来表示的，记5个</p>
<ul>
<li>stop      (event.stopPropagation())</li>
<li>prevent   (event.preventDefault())</li>
<li>capture</li>
<li>self</li>
<li>once      (这个和前面介绍过的v-once一样，都只一次)</li>
<li>passive   (尤其能够提升移动端的性能。对应 addEventListener 中的 passive 选项)</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 就是event.stopPropagation()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 就是event.preventDefault()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 注意次序很重要--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 (先自己，在内部，这什么操作，冒泡呢)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 (不是冒泡过来的，是自身div)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">"onScroll"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><p>记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>全部的按键别名：</p>
<ul>
<li>enter</li>
<li>tab</li>
<li>delete (捕获“删除”和“退格”键)</li>
<li>esc</li>
<li>space</li>
<li>up</li>
<li>down</li>
<li>left</li>
<li>right</li>
</ul>
<p>可以通过全局 config.keyCodes 对象自定义按键修饰符别名：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 可以使用 `v-on:keyup.f1`</span><br><span class="line">Vue.config.keyCodes.f1 = 112</span><br></pre></td></tr></table></figure>
<h4 id="系统修饰键-这个只要有一个按下了就行，模糊，要精准加-exact修饰符"><a href="#系统修饰键-这个只要有一个按下了就行，模糊，要精准加-exact修饰符" class="headerlink" title="系统修饰键(这个只要有一个按下了就行，模糊，要精准加.exact修饰符)"></a>系统修饰键(这个只要有一个按下了就行，模糊，要精准加.exact修饰符)</h4><p>请注意修饰键与常规按键不同，在<strong>和 keyup 事件一起用</strong>时，事件触发时修饰键<strong>必须处于按下状态</strong>。换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。</p>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>
<ul>
<li>ctrl</li>
<li>alt</li>
<li>shift</li>
<li>meta      (在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞))</li>
</ul>
<p><strong>.exact 修饰符</strong></p>
<p>.exact 修饰符允许你控制由<strong>精确</strong>的系统修饰符组合触发的事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">"onCtrlClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h4><ul>
<li>left</li>
<li>right</li>
<li>middle</li>
</ul>
<p>这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p>
<hr>
<h2 id="表单输入绑定v-model"><a href="#表单输入绑定v-model" class="headerlink" title="表单输入绑定v-model"></a>表单输入绑定v-model</h2><p><strong>也就单行 多行，单选 多选 下拉 5个</strong></p>
<p>用 v-model 指令在表单 <code>&lt;input&gt;</code> 及 <code>&lt;textarea&gt;</code> 元素上创建双向数据绑定。</p>
<p>v-model 会<strong>忽略所有表单元素</strong>的 value、checked、selected 特性的<strong>初始值</strong>而<strong>总是将 Vue 实例的数据作为数据来源</strong>。你应该通过 JavaScript 在组件的 <strong>data 选项</strong>中声明初始值。</p>
<h4 id="文本和多行文本"><a href="#文本和多行文本" class="headerlink" title="文本和多行文本"></a>文本和多行文本</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文本</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">多行文本</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"white-space: pre-line;"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"add multiple lines"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">单选按钮    看下面单选多选，一组的 只要v-model绑定的名字一样就是一组的 不用写key，render后也没有key</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"One"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"Two"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-4',</span><br><span class="line">  data: &#123;</span><br><span class="line">    picked: ''</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="复选"><a href="#复选" class="headerlink" title="复选"></a>复选</h4><p><strong>注意，这5种就这个复选除了静态的字符串，还有个布尔值，其他4种静态的只有字符串。后面v-bind解放一切</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">单个复选框，绑定到布尔值：显示的是boolean值 false 和 true，</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">多个复选框，绑定到同一个数组：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'example-3'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"mike"</span> <span class="attr">value</span>=<span class="string">"Mike"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mike"</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>    //这里显示初始值是空的，而value值是点击选中后才有的</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-3',</span><br><span class="line">  data: &#123;</span><br><span class="line">      checked: false,</span><br><span class="line">      checkedNames: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="选择框"><a href="#选择框" class="headerlink" title="选择框"></a>选择框</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">单选时：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span>  <span class="comment">&lt;!-- 提供一个值为空的禁用选项，防止无法选中第一个 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"DD"</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span>       <span class="comment">&lt;!-- 没有value时选内容，有value就value --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '...',</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: ''</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">多选时 (绑定到一个数组)：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-6"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span> <span class="attr">multiple</span> <span class="attr">style</span>=<span class="string">"width: 50px;"</span>&gt;</span> <span class="comment">&lt;!-- 多了个multiple --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-6',</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: []    <span class="comment">&lt;!-- 换成数组 --&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果 v-model 表达式的初始值未能匹配任何选项，<code>&lt;select&gt;</code> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样<strong>提供一个值为空的禁用选项</strong>。</p>
<hr>
<p>上面该讲的讲好了，下面做一些补充</p>
<p>用 v-for 渲染的动态选项：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">"option in options"</span> <span class="attr">v-bind:value</span>=<span class="string">"option.value"</span>&gt;</span></span><br><span class="line">    &#123;&#123; option.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '...',</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: 'A',</span><br><span class="line">    options: [</span><br><span class="line">      &#123; text: 'One', value: 'A' &#125;,</span><br><span class="line">      &#123; text: 'Two', value: 'B' &#125;,</span><br><span class="line">      &#123; text: 'Three', value: 'C' &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="值绑定-v-bind稳的一笔"><a href="#值绑定-v-bind稳的一笔" class="headerlink" title="值绑定 v-bind稳的一笔"></a>值绑定 v-bind稳的一笔</h3><p>对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是<strong>静态字符串</strong> (对于复选框也可以是<strong>布尔值</strong>)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当选中时，`picked` 为字符串 "a" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span> <span class="attr">value</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `toggle` 为 true 或 false --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"toggle"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当选中时，`selected` 为字符串 "abc" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"abc"</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是有时我们可能想把值绑定到 Vue 实例的一个动态属性上，这时可以用 <strong>v-bind</strong> 实现，<strong>并且这个属性的值可以不是字符串</strong>。</p>
<p>例子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">单选按钮</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"pick"</span> <span class="attr">v-bind:value</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">// 当选中时</span><br><span class="line">vm.pick === vm.a</span><br><span class="line"></span><br><span class="line">复选框</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"checkbox"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"toggle"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">true-value</span>=<span class="string">"yes"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">false-value</span>=<span class="string">"no"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">// 当选中时</span><br><span class="line">vm.toggle === 'yes'</span><br><span class="line">// 当没有选中时</span><br><span class="line">vm.toggle === 'no'</span><br><span class="line">这里的 true-value 和 false-value 特性并不会影响输入控件的 value 特性，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(比如“yes”或“no”)，请换用单选按钮。</span><br><span class="line"></span><br><span class="line">选择框的选项</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内联对象字面量 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-bind:value</span>=<span class="string">"&#123; number: 123 &#125;"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">// 当选中时</span><br><span class="line">typeof vm.selected // =&gt; 'object'</span><br><span class="line">vm.selected.number // =&gt; 123</span><br></pre></td></tr></table></figure>
<h3 id="修饰符-3个-lazy-number-trim"><a href="#修饰符-3个-lazy-number-trim" class="headerlink" title="修饰符 3个(.lazy, .number, .trim)"></a>修饰符 3个(.lazy, .number, .trim)</h3><p><strong>.lazy</strong><br>在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一输入就变化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"msg"</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新 比如回车后才变化 或则失去焦点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">"msg"</span> &gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>.number</strong><br>如果想自动将用户的<strong>输入值转为数值类型(因为这5种绑定的默认都是静态的字符串啊)</strong>，可以给 v-model 添加 number 修饰符：<br>也会自动去除不是数字的内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"number"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这通常很有用，<strong>因为即使在 type=”number” 时</strong>，HTML 输入元素的值也总会返回字符串。</p>
<p><strong>.trim</strong><br>如果要自动过滤用户输入的<strong>首尾空白字符</strong>，可以给 v-model 添加 trim 修饰符：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"msg"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>哈哈哈 3个一起用 顺序没关系</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy.number.trim</span>=<span class="string">"msg"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>参考<br><a href="https://www.w3cplus.com/vue/v-model.html" target="_blank" rel="noopener">Vue 2.0学习笔记：v-model</a></p>
<p><a href="https://juejin.im/post/58d4a19e5c497d0057e9afc0" target="_blank" rel="noopener">史上最详细VUE2.0全套demo讲解 基础1（模板语法）</a></p>
<hr>
<h2 id="路由就是使用-vue-router"><a href="#路由就是使用-vue-router" class="headerlink" title="路由就是使用 vue-router"></a>路由就是使用 vue-router</h2><h2 id="vuex-状态保存"><a href="#vuex-状态保存" class="headerlink" title="vuex 状态保存"></a>vuex 状态保存</h2><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><h2 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/27/vscode常用快捷键/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/27/vscode常用快捷键/" itemprop="url">vscode常用快捷键</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-27T13:29:05+08:00">2018-01-27</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="vscode常用快捷键"><a href="#vscode常用快捷键" class="headerlink" title="vscode常用快捷键"></a>vscode常用快捷键</h3><p>按按键个数分<br><code>ctrl+o</code> 单一<br><code>ctrl+shift+o</code> 组合<br><code>ctrl+k, ctrl+o</code> 依赖一个键<br><code>ctrl+k, o</code>先依赖一个,再单个<br><code>alt 鼠标</code> 键盘+鼠标点击<br><code>ctrl 鼠标拖动</code> 键盘+ 鼠标拖动</p>
<p>按 ctrl+k ctrl+s 可以查看键盘快捷方式</p>
<p>jj {</p>
<p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/24/PAT乙级/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/24/PAT乙级/" itemprop="url">PAT乙级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-24T13:59:32+08:00">2018-01-24</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PAT乙级-一共80题"><a href="#PAT乙级-一共80题" class="headerlink" title="PAT乙级(一共80题)"></a>PAT乙级(一共80题)</h1><h2 id="1001-害死人不偿命的-3n-1-猜想-15"><a href="#1001-害死人不偿命的-3n-1-猜想-15" class="headerlink" title="1001. 害死人不偿命的(3n+1)猜想 (15)"></a>1001. 害死人不偿命的(3n+1)猜想 (15)</h2><p>卡拉兹(Callatz)猜想：</p>
<p>对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p>
<p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？<br>·<br>输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。</p>
<p>输出格式：输出从n计算到1需要的步数。</p>
<p>输入样例：<br>3<br>输出样例：<br>5</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>读入题目给定的n，之后用while做循环，反复判断n是否为1</p>
<ol>
<li>如果n==1,则退出循环，</li>
<li>如果n!=1,则判断n是否是偶数，是则n除以2；否则n为(3*n+1)除以2.之后令计数器step加1<br>程序执行完后，step就是答案</li>
</ol>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, step = <span class="number">0</span>;    <span class="comment">//要初始化，不然vs2008输入数字是终止</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)&#123;    <span class="comment">//也可以用(n&amp;1) == 0  但是判断奇偶是不能用 n%2 !=0</span></span><br><span class="line">            n = n / <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            n = (<span class="number">3</span>*n + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, step);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1009-说反话-20"><a href="#1009-说反话-20" class="headerlink" title="1009. 说反话 (20)"></a>1009. 说反话 (20)</h2><p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p>
<p>输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。</p>
<p>输出格式：每个测试用例的输出占一行，输出倒序后的句子。</p>
<p>输入样例：<br>Hello World Here I Come<br>输出样例：<br>Come I Here World Hello</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用gets函数读入一整行，从左至右枚举每一个字符，以空格为分隔符对单词进行划分，并按顺序存放到二维字符数组中，最后按单词输入顺序的逆序来输出所有单词。</p>
<h3 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ans[<span class="number">90</span>][<span class="number">90</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>, ans[num]) != EOF) &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = num <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, ans[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">90</span>] = &#123;&#125;;</span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str), r = <span class="number">0</span>, h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ans[<span class="number">90</span>][<span class="number">90</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] != <span class="string">' '</span>) &#123;         <span class="comment">//还没到空格就存入</span></span><br><span class="line">            ans[r][h++] = str[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;             </span><br><span class="line">            ans[r][h] = <span class="string">'\0'</span>;   <span class="comment">//是空格就在末尾加\0 控制%s输出</span></span><br><span class="line">            r++;</span><br><span class="line">            h = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, ans[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1022-D进制的A-B-20"><a href="#1022-D进制的A-B-20" class="headerlink" title="1022. D进制的A+B (20)"></a>1022. D进制的A+B (20)</h2><p>输入两个非负10进制整数A和B(&lt;=230-1)，输出A+B的D (1 &lt; D &lt;= 10)进制数。</p>
<p>输入格式：</p>
<p>输入在一行中依次给出3个整数A、B和D。</p>
<p>输出格式：</p>
<p>输出A+B的D进制数。</p>
<p>输入样例：<br>123 456 8<br>输出样例：<br>1103</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>先计算A+B的按10进制，然后把结果转成D进制，除基取余法。</p>
<h3 id="代码参考-1"><a href="#代码参考-1" class="headerlink" title="代码参考"></a>代码参考</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;d);</span><br><span class="line">    <span class="keyword">int</span> sum = a + b;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">31</span>], num = <span class="number">0</span>;       <span class="comment">//存放D进制每一位 31表示以2进制表示最多31个位置就够了</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ans[num++] = sum % d;</span><br><span class="line">        sum /= d;</span><br><span class="line">    &#125;<span class="keyword">while</span>(sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = num<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;    <span class="comment">//逆序输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1032-挖掘机技术哪家强-20"><a href="#1032-挖掘机技术哪家强-20" class="headerlink" title="1032. 挖掘机技术哪家强(20)"></a>1032. 挖掘机技术哪家强(20)</h2><p>为了用事实说明挖掘机技术到底哪家强，PAT组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。</p>
<p>输入格式：</p>
<p>输入在第1行给出不超过105的正整数N，即参赛人数。随后N行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从1开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。</p>
<p>输出格式：</p>
<p>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。</p>
<p>输入样例：<br>6<br>3 65<br>2 80<br>1 100<br>2 70<br>3 40<br>3 0<br>输出样例：<br>2 150</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul>
<li>用一个数组school[maxn]，下标表示学校，内容表示分数，初始为0。对于每读入一个学校的schID和分数score，相应school[schID]+=score;</li>
<li>令变量k记录最高总分学校编号，变量MAX记录最高总分，初值-1.由于学校是连续编号的从1开始，因此枚举编号1~N， 不断更新k和MAX值就好</li>
</ul>
<h3 id="代码参考-2"><a href="#代码参考-2" class="headerlink" title="代码参考"></a>代码参考</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100001</span>;</span><br><span class="line">    <span class="keyword">int</span> school[maxn] = &#123;<span class="number">0</span>&#125;;     <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, schID = <span class="number">0</span>, score = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);            <span class="comment">//不判断n是否合法，因为给定就是在10^5内</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;schID, &amp;score);</span><br><span class="line">        school[schID] += score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k =<span class="number">1</span>, MAX = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(school[i] &gt; MAX)&#123;</span><br><span class="line">            MAX = school[i];</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, k, MAX);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1036-跟奥巴马一起编程-15"><a href="#1036-跟奥巴马一起编程-15" class="headerlink" title="1036. 跟奥巴马一起编程(15)"></a>1036. 跟奥巴马一起编程(15)</h2><p>美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！</p>
<p>输入格式：</p>
<p>输入在一行中给出正方形边长N（3&lt;=N&lt;=20）和组成正方形边的某种字符C，间隔一个空格。</p>
<p>输出格式：</p>
<p>输出由给定字符C画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的50%（四舍五入取整）。</p>
<p>输入样例：<br>10 a<br>输出样例：<br>aaaaaaaaaa<br>a        a<br>a        a<br>a        a<br>aaaaaaaaaa</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>看到上面正方形是9*10的。在看有字母的，行数是列数的50%(四舍五入)。</p>
<p>第1行和最后一行全输出n个a，2~row-1行奇数行不输出，偶数行就头尾有a</p>
<h3 id="代码参考-3"><a href="#代码参考-3" class="headerlink" title="代码参考"></a>代码参考</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %c"</span>, &amp;col, &amp;c);   <span class="comment">//输入列数和使用字符</span></span><br><span class="line">    <span class="keyword">if</span>(col % <span class="number">2</span> == <span class="number">1</span>) &#123;          <span class="comment">//四舍五入得row</span></span><br><span class="line">        row = col / <span class="number">2</span> +<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        row = col / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//frist row 1 这里就是从1开始 row表示数量，不用当做数组看，col还是按从0开始看</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= col<span class="number">-1</span>; i++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);               <span class="comment">//第一行后的空行 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2~row-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= row<span class="number">-1</span>; i++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, c);        <span class="comment">//第一个c</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);        <span class="comment">//输出col-2个空格</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, c);        <span class="comment">//最后一个c</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一行 row</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatarMogu.jpg" alt="Henry x">
            
              <p class="site-author-name" itemprop="name">Henry x</p>
              <p class="site-description motion-element" itemprop="description">this is description</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">117</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">121</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="weibo" target="_blank">weibo</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Henry x</span>

  

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.1"></script>



  



	





  





  










  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  

</body>
</html>
