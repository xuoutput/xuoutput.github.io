<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.1',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  
  <meta name="keywords" content="Hexo, NexT">


<meta name="description" content="this is description">
<meta property="og:type" content="website">
<meta property="og:title" content="Little H title">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Little H title">
<meta property="og:description" content="this is description">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Little H title">
<meta name="twitter:description" content="this is description">






  <link rel="canonical" href="http://yoursite.com/page/2/">


  <title>Little H title</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Little H title</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">this is subtitle</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益404</a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/20/eslint简单使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/eslint简单使用/" itemprop="url">eslint简单使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-20T15:46:50+08:00">2019-05-20</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/vsc插件/" itemprop="url" rel="index"><span itemprop="name">vsc插件</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="eslint简单使用"><a href="#eslint简单使用" class="headerlink" title="eslint简单使用"></a>eslint简单使用</h1><p>rules中 <a href="http://eslint.cn/docs/rules/" target="_blank" rel="noopener">“extends”: “eslint:recommended”</a></p>
<p><a href="https://www.thedreaming.org/2019/03/27/eslint-with-typescript/" target="_blank" rel="noopener">Use eslint with Typescript, today! 666</a></p>
<h2 id="tslint"><a href="#tslint" class="headerlink" title="tslint"></a>tslint</h2><p>暂时使用 tslint + tslint-microsoft-contrib 这个稳定点, 碰到要强制返回函数类型器的bug, 因为react的render和生命周期的函数</p>
<p><a href="https://palantir.github.io/tslint/rules/" target="_blank" rel="noopener">tslint core rules</a></p>
<h2 id="后面的-typescript-eslint-暂时不用"><a href="#后面的-typescript-eslint-暂时不用" class="headerlink" title="后面的 typescript-eslint 暂时不用"></a>后面的 typescript-eslint 暂时不用</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://eslint.cn/docs/user-guide/getting-started" target="_blank" rel="noopener">ESLint 中文入门</a><br><a href="http://eslint.cn/docs/rules/" target="_blank" rel="noopener">“extends”: “eslint:recommended”</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/css-nth-child和-nth-of-type的区别/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/css-nth-child和-nth-of-type的区别/" itemprop="url">css-:nth-child和:nth-of-type的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T19:57:26+08:00">2019-05-15</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/css教程/" itemprop="url" rel="index"><span itemprop="name">css教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="‘css-nth-child-和-nth-of-type-的区别’"><a href="#‘css-nth-child-和-nth-of-type-的区别’" class="headerlink" title="‘css-:nth-child 和:nth-of-type 的区别’"></a>‘css-:nth-child 和:nth-of-type 的区别’</h1><p>说的就是</p>
<ul>
<li><code>:nth-child</code> 这个就是看子, 然后又有 <code>if</code> 这个条件</li>
<li><code>:nth-of-type</code> 直接看这种类型的第几个, 都是同类型就没有 <code>if</code> 的判断了</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/liuyan19891230/article/details/52839788" target="_blank" rel="noopener">css-:nth-child 和:nth-of-type 的区别</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/javascript-AJAX/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/javascript-AJAX/" itemprop="url">javascript-AJAX</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T11:15:13+08:00">2019-05-15</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/网络/" itemprop="url" rel="index"><span itemprop="name">网络</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="javascript-AJAX"><a href="#javascript-AJAX" class="headerlink" title="javascript-AJAX"></a>javascript-AJAX</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 新建XMLHttpRequest对象</span></span><br><span class="line"></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">  <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// 成功完成</span></span><br><span class="line">    <span class="comment">// 判断响应结果:</span></span><br><span class="line">    <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// 成功，通过responseText拿到响应的文本:</span></span><br><span class="line">      <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">      <span class="keyword">return</span> fail(request.status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求:</span></span><br><span class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/api/categories'</span>);</span><br><span class="line">request.send();</span><br></pre></td></tr></table></figure>
<h2 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h2><p>创建 XMLHttpRequest 对象的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>
<p>老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="向服务器发送请求请求"><a href="#向服务器发送请求请求" class="headerlink" title="向服务器发送请求请求"></a>向服务器发送请求请求</h2><p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 <code>open()</code> 和 <code>send()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">'GET'</span>, <span class="string">'ajax_info.txt'</span>, <span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">'POST'</span>, <span class="string">'/try/ajax/demo_post2.php'</span>, <span class="literal">true</span>);</span><br><span class="line">xmlhttp.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">xmlhttp.send(<span class="string">'fname=Henry&amp;lname=Ford'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="服务器-响应"><a href="#服务器-响应" class="headerlink" title="服务器 响应"></a>服务器 响应</h2><p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>responseText</td>
<td>获得字符串形式的响应数据。</td>
</tr>
<tr>
<td>responseXML</td>
<td>获得 XML 形式的响应数据。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="onreadystatechange-事件"><a href="#onreadystatechange-事件" class="headerlink" title="onreadystatechange 事件"></a>onreadystatechange 事件</h2><p>当请求被发送到服务器时，我们需要执行一些<strong>基于响应的任务</strong>。</p>
<p>每当 <code>readyState</code> 改变时，就会触发 <code>onreadystatechange</code> 事件。</p>
<p><code>readyState</code> 属性存有 <code>XMLHttpRequest</code> 的状态信息。</p>
<p>下面是 XMLHttpRequest 对象的三个重要的属性：</p>
<h3 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h3><p>存有 <code>XMLHttpRequest</code> 的状态。从 0 到 4 发生变化。</p>
<ul>
<li>0：初始化，<code>XMLHttpRequest</code> 对象还没有完成初始化</li>
<li>1：载入，初始化完成, <code>XMLHttpRequest</code> 对象开始发送请求</li>
<li>2：载入完成，<code>XMLHttpRequest</code> 对象的请求发送完成, 开始接受</li>
<li>3：解析，<code>XMLHttpRequest</code> 对象开始读取服务器的响应, 解析中</li>
<li>4：完成，<code>XMLHttpRequest</code> 对象读取服务器响应结束</li>
</ul>
<p>onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.runoob.com/ajax/ajax-xmlhttprequest-create.html" target="_blank" rel="noopener">菜鸟 AJAX</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/javascript-立即执行函数表达式IIFE/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/13/javascript-立即执行函数表达式IIFE/" itemprop="url">javascript-立即执行函数表达式IIFE</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-13T20:37:51+08:00">2019-05-13</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="javascript-立即执行函数表达式-IIFE"><a href="#javascript-立即执行函数表达式-IIFE" class="headerlink" title="javascript-立即执行函数表达式 IIFE"></a>javascript-立即执行函数表达式 IIFE</h1><p>立即执行函数表达式(IIFE) 是<strong>在创建函数后立即执行函数的方法</strong>。</p>
<p>立即执行函数表达式(IIFE) 非常有用，因为它们不会污染全局对象，它们是<strong>隔离变量声明</strong>的简单方法。</p>
<p>这是定义 IIFE 的语法：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* */</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>立即执行函数也可以使用<strong>箭头函数定义</strong>：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;<span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* */</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>基本上，我们在<strong>括号内定义了一个函数</strong>，然后<strong>在后面加上一个括号 <code>()</code></strong> 来执行该函数：<code>(/* function */)()</code> 。</p>
<p>包裹函数的括号实际上是使我们的函数在内部被<strong>视为表达式</strong>。 否则，函数声明将无效，因为我们没有指定任何名称：</p>
<p><img src="IIFE.png" alt="IIFE.png"></p>
<p><strong>函数声明需要一个<code>名称</code>，而函数表达式不需要它</strong>。</p>
<p>你也可以将调用括号放在表达式括号内，<strong>没有区别</strong>，只是写法不同：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* */</span></span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* */</span></span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<h2 id="使用一元运算符的替代语法"><a href="#使用一元运算符的替代语法" class="headerlink" title="使用一元运算符的替代语法"></a>使用一元运算符的替代语法</h2><p>你可以使用一些<strong>更奇怪的语法</strong>来创建 IIFE ，但它在现实世界中<strong>很少使用</strong>，并且它依赖于使用任何一元运算符：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* */</span></span><br><span class="line">&#125;)() +</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* */</span></span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">~(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* */</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">!(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* */</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>但是这种方式<strong>不适用于箭头函数</strong>。</p>
<h2 id="命名的-IIFE"><a href="#命名的-IIFE" class="headerlink" title="命名的 IIFE"></a>命名的 IIFE</h2><p><code>IIFE</code> 也可以是<strong>命名的常规函数</strong>（不是箭头函数）。 这不会导致函数“泄漏”到全局作用域，并且在执行后也不能再次调用它：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* */</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h2 id="IIFE-前的分号"><a href="#IIFE-前的分号" class="headerlink" title="IIFE 前的分号"></a>IIFE 前的分号</h2><p>你可能已经注意到 <code>IIFE</code> <strong>前的分号</strong>了：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* */</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这可以<strong>防止在盲目合并两个 <code>JavaScript</code> 文件时出现问题</strong>。 由于 <code>JavaScript</code> 不需要分号，因此你可能会在最后一行中使用某些语句连接一个文件，从而导致语法错误。</p>
<p>这个问题基本上是通过像 <a href="http://webpack.html.cn/" target="_blank" rel="noopener">webpack</a> 这样的“智能”打包工具来解决的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.html.cn/archives/10277" target="_blank" rel="noopener">JavaScript 中的 立即执行函数表达式（IIFE） – JavaScript 完全手册（2018 版）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/javascript-this/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/13/javascript-this/" itemprop="url">javascript-this</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-13T20:16:15+08:00">2019-05-13</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="javascript-this"><a href="#javascript-this" class="headerlink" title="javascript-this"></a>javascript-this</h1><p><code>this</code> 值根据<strong>使用位置的不同具有不同的值</strong>。不了解 <code>JavaScript</code> 这个小细节会导致很多头痛的问题，所以花 5 分钟学习所有技巧是值得的。</p>
<h2 id="严格模式-strict-mode-中的-this"><a href="#严格模式-strict-mode-中的-this" class="headerlink" title="严格模式(strict mode) 中的 this"></a>严格模式(strict mode) 中的 this</h2><p>严格模式下，<strong>在任何对象之外</strong>的 <code>this</code> 始终是 <code>undefined</code> （未定义的）。</p>
<p>注意我提到了严格模式。 如果禁用严格模式（如果没有在<strong>文件顶部</strong>明确添加 <code>&#39;use strict&#39;</code>，则默认为禁用），即草率模式（sloppy mode），也有人称为非严格模式，在这种模式下 ， 如果在本文下面某有提及的这些情况下，<code>this</code> <strong>都指向全局对象</strong>。</p>
<p>浏览器的全局对象为 <code>window</code> 。</p>
<h2 id="方法中的-this"><a href="#方法中的-this" class="headerlink" title="方法中的 this"></a>方法中的 this</h2><p><strong>方法是附加到对象属性的函数</strong>。</p>
<p>你可以看到各种形式。</p>
<p>这是其中一种形式：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">  maker: <span class="string">'Ford'</span>,</span><br><span class="line">  model: <span class="string">'Fiesta'</span>,</span><br><span class="line"></span><br><span class="line">  drive() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Driving a <span class="subst">$&#123;<span class="keyword">this</span>.maker&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.model&#125;</span> car!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.drive()</span><br><span class="line"><span class="comment">//Driving a Ford Fiesta car!</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，使用常规函数，<code>this</code> <strong>会自动绑定到对象</strong>。</p>
<p>注意：上面的方法声明是 <code>drive: function（）{ …</code> 的简写形式，ES6 语法，等价于：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">  maker: <span class="string">'Ford'</span>,</span><br><span class="line">  model: <span class="string">'Fiesta'</span>,</span><br><span class="line"></span><br><span class="line">  drive: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Driving a <span class="subst">$&#123;<span class="keyword">this</span>.maker&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.model&#125;</span> car!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中同样有效：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">  maker: <span class="string">'Ford'</span>,</span><br><span class="line">  model: <span class="string">'Fiesta'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.drive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Driving a <span class="subst">$&#123;<span class="keyword">this</span>.maker&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.model&#125;</span> car!`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.drive()</span><br><span class="line"><span class="comment">//Driving a Ford Fiesta car!</span></span><br></pre></td></tr></table></figure>
<p><strong>箭头函数不能</strong>以相同的方式工作，因为它是词法绑定的：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">  maker: <span class="string">'Ford'</span>,</span><br><span class="line">  model: <span class="string">'Fiesta'</span>,</span><br><span class="line"></span><br><span class="line">  drive: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Driving a <span class="subst">$&#123;<span class="keyword">this</span>.maker&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.model&#125;</span> car!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">car.drive();</span><br><span class="line"><span class="comment">//Driving a undefined undefined car!</span></span><br></pre></td></tr></table></figure>
<h2 id="绑定箭头函数"><a href="#绑定箭头函数" class="headerlink" title="绑定箭头函数"></a>绑定箭头函数</h2><p>你不能像使用普通函数那样将值绑定到箭头函数。</p>
<p>由于他们的工作方式不同。箭头函数中 <code>this</code> 是词法（lexically）绑定，这意味着 <code>this</code> 的值来自定义它们的上下文。</p>
<p>了解更多详情请阅读：<a href="https://www.html.cn/archives/10176" target="_blank" rel="noopener">JavaScript 箭头函数（Arrow Function）</a></p>
<h2 id="显式传递要用作-this-的对象"><a href="#显式传递要用作-this-的对象" class="headerlink" title="显式传递要用作 this 的对象"></a>显式传递要用作 this 的对象</h2><p>JavaScript 提供了一些方法来将 <code>this</code> 映射到你想要的任何对象上。</p>
<p>在 <strong>函数声明</strong> 阶段使用 <code>bind()</code> ：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">  maker: <span class="string">'Ford'</span>,</span><br><span class="line">  model: <span class="string">'Fiesta'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> drive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Driving a <span class="subst">$&#123;<span class="keyword">this</span>.maker&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.model&#125;</span> car!`</span>)</span><br><span class="line">&#125;.bind(car)</span><br><span class="line"></span><br><span class="line">drive()</span><br><span class="line"><span class="comment">//Driving a Ford Fiesta car!</span></span><br></pre></td></tr></table></figure>
<p>你还可以绑定现有的对象方法来重新映射 <code>this</code> 值：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">  maker: <span class="string">'Ford'</span>,</span><br><span class="line">  model: <span class="string">'Fiesta'</span>,</span><br><span class="line"></span><br><span class="line">  drive() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Driving a <span class="subst">$&#123;<span class="keyword">this</span>.maker&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.model&#125;</span> car!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> anotherCar = &#123;</span><br><span class="line">  maker: <span class="string">'Audi'</span>,</span><br><span class="line">  model: <span class="string">'A4'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.drive.bind(anotherCar)()</span><br><span class="line"><span class="comment">//Driving a Audi A4 car!</span></span><br></pre></td></tr></table></figure>
<p>在 <strong>函数调用</strong> 阶段使用 <code>call()</code> 或 <code>apply()</code> ：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">  maker: <span class="string">'Ford'</span>,</span><br><span class="line">  model: <span class="string">'Fiesta'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> drive = <span class="function"><span class="keyword">function</span>(<span class="params">kmh</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Driving a <span class="subst">$&#123;<span class="keyword">this</span>.maker&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.model&#125;</span> car at <span class="subst">$&#123;kmh&#125;</span> km/h!`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drive.call(car, <span class="number">100</span>)</span><br><span class="line"><span class="comment">//Driving a Ford Fiesta car at 100 km/h!</span></span><br><span class="line"></span><br><span class="line">drive.apply(car, [<span class="number">100</span>])</span><br><span class="line"><span class="comment">//Driving a Ford Fiesta car at 100 km/h!</span></span><br></pre></td></tr></table></figure>
<p>传入 <code>call()</code> 或者 <code>apply()</code> 的第一个参数始终绑定 <code>this</code> 。<code>call()</code> 和 <code>apply()</code> 之间的区别在于， <code>apply()</code> 需要一个数组作为<strong>参数列表</strong>，而 <code>call()</code> 者可以接受多个参数。</p>
<blockquote>
<p>apply array</p>
</blockquote>
<h2 id="浏览器事件处理程序的特例"><a href="#浏览器事件处理程序的特例" class="headerlink" title="浏览器事件处理程序的特例"></a>浏览器事件处理程序的特例</h2><p>在事件处理程序回调中，<code>this</code> 指向接收事件的 <code>DOM</code> 元素：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#button'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//HTMLElement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以这样绑定：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#button'</span>).addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//这里的 this 指向全局的 Window 对象, 或者你的上下文</span></span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.html.cn/archives/10260" target="_blank" rel="noopener">JavaScript 中的 this – JavaScript 完全手册（2018 版）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/javascript-Promises/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/13/javascript-Promises/" itemprop="url">javascript-Promises</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-13T14:39:39+08:00">2019-05-13</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="javascript-Promises"><a href="#javascript-Promises" class="headerlink" title="javascript-Promises"></a>javascript-Promises</h1><a href="/2018/11/21/使用Promise/" title="使用Promise">使用Promise</a>
<p><code>Promises</code> 是一种 <code>JavaScript</code> 中<strong>处理异步代码</strong>的方法，无需在代码中编写太多回调。</p>
<p><code>Promises</code> 通常定义为<strong>最终可用的值的代理</strong>（a proxy for a value that will eventually become available）。</p>
<p><code>Promises</code> 是处理异步代码的一种方法，无需在代码中编写太多回调。</p>
<p>其实 <code>Promises</code> 已经存在多年，但是直到 ES2015 才被标准化和引入，现在它们已经在 ES2017 中被 <code>async</code>(异步) 函数所取代。</p>
<p><code>Async functions</code>(异步函数) 使用 <code>promises API</code> 作为构建块，因此理解 <code>Promises</code> 是必须的，即使在较新的代码中，你可能会使用 <code>async</code>(异步) 函数而不是 <code>promises</code> 。</p>
<h2 id="简而言之，Promsie-是如何工作的"><a href="#简而言之，Promsie-是如何工作的" class="headerlink" title="简而言之，Promsie 是如何工作的"></a>简而言之，<code>Promsie</code> 是如何工作的</h2><p>一旦调用了一个 <code>promise</code> ，它就会以 <strong>pending(挂起)</strong> 状态开始。 这意味着调用者函数继续执行，同时等待 <code>promise</code> 执行自己的处理，并为调用者函数提供一些反馈。</p>
<p>此时，调用者函数等待它以 <strong>resolved</strong> 状态或者 <strong>rejected</strong> 状态 返回 <code>promise</code>，但是如果你知道 JavaScript 是<strong>异步</strong>的，那么 函数会在 <code>promise</code> 完成其工作时继续执行 。</p>
<h2 id="哪些-JS-API-使用-promises-？"><a href="#哪些-JS-API-使用-promises-？" class="headerlink" title="哪些 JS API 使用 promises ？"></a>哪些 JS API 使用 promises ？</h2><p>除了你自己的代码和库代码之外，Promises 还被用于标准的现代 Web API，例如：</p>
<ul>
<li>Battery API</li>
<li><a href="https://www.html.cn/archives/9907" target="_blank" rel="noopener">Fetch API</a></li>
<li>Service Workers</li>
</ul>
<p>在现代 JavaScript 中你不太可能发现自己没有使用 Promises ，所以让我们开始深入了解它们。</p>
<h2 id="创建-promise"><a href="#创建-promise" class="headerlink" title="创建 promise"></a>创建 promise</h2><p><code>Promise API</code> 公开了一个 <code>Promise</code> 构造函数，你可以使用 <code>new Promise()</code> 进行初始化：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> isItDoneYet = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 也可写成 (res, rej) 这种, 反正是个名字, 记得下面也要改 res(workDone) 这种</span></span><br><span class="line">  <span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="keyword">const</span> workDone = <span class="string">'Here is the thing I built'</span>;</span><br><span class="line">    resolve(workDone); <span class="comment">// 这里不是 return哦</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> why = <span class="string">'Still working on something else'</span>;</span><br><span class="line">    reject(why); <span class="comment">// 这里不是 return哦</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>高阶函数, 函数当参数</strong><br>!<strong>注意, 这个 <code>executor</code> 不是用 <code>return</code>, 而是返回并执行 <code>resolve, reject</code> 回调函数</strong><br>!<strong>注意, 这个 <code>executor</code> 不是用 <code>return</code>, 而是返回并执行 <code>resolve, reject</code> 回调函数</strong><br>!<strong>注意, 这个 <code>executor</code> 不是用 <code>return</code>, 而是返回并执行 <code>resolve, reject</code> 回调函数</strong></p>
</blockquote>
<p>正如你所看到的，<code>promise</code> 会检查 <code>done</code> 这个全局常量，如果 <code>done</code> 为 <code>true</code> ，我们将返回 <code>resolved</code> 状态的 <code>promise</code> ，否则将返回 <code>rejected</code> 状态的 <code>promise</code> 。</p>
<p>使用 <code>resolve</code> 和 <code>reject</code> 时，我们可以<strong>回传一个值</strong>，在上面的例子中我们只是回传了一个字符串，但它也可以是一个对象。</p>
<h2 id="使用-promise"><a href="#使用-promise" class="headerlink" title="使用 promise"></a>使用 promise</h2><p>在上一节中，我们介绍了如何<strong>创建 <code>promise</code></strong>。</p>
<p>现在让我们看看如何<strong>使用 <code>promise</code></strong> 。</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isItDoneYet = <span class="keyword">new</span> <span class="built_in">Promise</span>();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">const</span> checkIfItsDone = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  isItDoneYet</span><br><span class="line">    .then(<span class="function">(<span class="params">ok</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ok 是resolve的一个promise</span></span><br><span class="line">      <span class="built_in">console</span>.log(ok);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也就是</span></span><br><span class="line"><span class="keyword">const</span> checkIfItsDone = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  isItDoneYet.then(</span><br><span class="line">    (ok) =&gt; &#123;</span><br><span class="line">      <span class="comment">// ok 是resolve的一个promise</span></span><br><span class="line">      <span class="built_in">console</span>.log(ok);</span><br><span class="line">    &#125;,</span><br><span class="line">    (err) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行 <code>checkIfItsDone()</code> 将执行 <code>isItDoneYet()</code> promise 并使用 <code>then</code> 回调等待该 <code>promise</code> 的 <code>resolve</code> 状态。如果有错误，它将在 <code>catch</code> 回调中处理这个错误。</p>
<h2 id="链式调用-promises"><a href="#链式调用-promises" class="headerlink" title="链式调用 promises"></a>链式调用 promises</h2><p><code>promise</code> 可以返回另一个 <code>promise</code> ，形成一个<strong>链式 <code>promise</code></strong> 。</p>
<p>链式调用 <code>promises</code> 的一个很好的例子是 <code>Fetch API</code>，<strong>它是 <code>XMLHttpRequest API</code> 上层 API</strong>，我们可以使用它来获取资源，并在获取资源时对 <strong>Promise 链</strong>进行排列。</p>
<blockquote>
<p><strong><code>promise</code> 和 <code>ajax</code> 没有关系, 而 <code>ajax</code> 是 <code>fetch</code> 的基础</strong></p>
</blockquote>
<p><code>Fetch API</code> 基于 <code>promise</code> 机制，调用 <code>fetch()</code> 等同于我们通过 <code>new promise()</code> 定义一个我们自己的 <code>promise</code>。</p>
<h3 id="链式调用-promises-例子"><a href="#链式调用-promises-例子" class="headerlink" title="链式调用 promises 例子"></a>链式调用 promises 例子</h3><p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> status = <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (response.status &gt;= <span class="number">200</span> &amp;&amp; response.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(response);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(response.statusText));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> json = <span class="function">(<span class="params">response</span>) =&gt;</span> response.json();</span><br><span class="line">fetch(<span class="string">'/todos.json'</span>)</span><br><span class="line">  .then(status)</span><br><span class="line">  .then(json)</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request succeeded with JSON response'</span>, data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request failed'</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们调用 <code>fetch()</code> 从根域名中的 <code>todos.json</code> 文件获取一个 <strong>TODO 清单</strong>，我们创建了一个 <strong>promises 链</strong>。</p>
<p>运行 <code>fetch()</code> <strong>返回一个包含很多个属性的 <code>response</code></strong>，我们引用了其中的：</p>
<ul>
<li><code>status</code>，数字值表示的 HTTP 状态代码</li>
<li><code>statusText</code>，状态消息，请求成功时为 OK</li>
</ul>
<p><code>response</code> 还有一个 <code>json()</code> 方法，该方法返回一个 <code>resolve</code> 状态的 <code>promise</code>，并且将响应内容转化为 JSON 作为该 promise 的回传值。</p>
<p>在这些前提下，会发生这样的情况:<strong>链中的第一个 promise</strong> 是我们定义的函数 <code>status()</code> ，它检查响应状态，<strong>如果响应不成功</strong>(在 200 到 299 之间)，则 reject 该 promise 。</p>
<p>此操作将导致 promise 链<strong>跳过队列中的所有的 promise</strong> ，并将直接跳到底部的 <code>catch()</code> 语句，打印 Request failed 文本以及错误消息。</p>
<p><strong>如果成功</strong>，它会调用我们定义的 <code>json()</code> 函数。 前一个 promise 返回 response 对象，作为第二个 promise 的输入。</p>
<p>在这种情况下，我们返回处理过的 JSON 数据 ，因此<strong>第三个 promise 直接接收 JSON</strong>：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Request succeeded with JSON response'</span>, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在控制台会打印出这些内容。</p>
<h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>在上面的例子中，<code>promises</code> 链后面有一个<strong>额外的 <code>catch</code> 块</strong>。当 <code>promises</code> 链有任何错误发生，将 promise 置为 <code>reject</code> ，控制会转到链中最近的 <code>catch()</code> 语句。</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>)      <span class="comment">// 这里用 throw</span></span><br><span class="line">&#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.error(err) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">'Error'</span>)             <span class="comment">// 这里用回调函数 reject好了</span></span><br><span class="line">&#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.error(err) &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="级联错误"><a href="#级联错误" class="headerlink" title="级联错误"></a>级联错误</h2><p>如果在 <code>catch()</code> <strong>内部又抛出一个错误</strong>，你可以添加第二个 <code>catch()</code> 处理它，以此类推。</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>) &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.error(err) &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p>这是 ES2018（ES9）的新特性.</p>
<p>当一个 <code>promise</code> 得到<strong>满足（fulfilled）</strong>时，<strong>它会一个接一个地调用 <code>then()</code> 方法</strong>。如果在此期间发生<strong>错误 <code>reject</code></strong>，<strong>则跳过 then() 方法并执行 catch() 方法</strong>。</p>
<p><code>finally()</code> 允许您运行一些代码，<strong>无论 promise 的执行成功或失败</strong>：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'file.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> data.json())</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error))</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finished'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="协调-promises"><a href="#协调-promises" class="headerlink" title="协调 promises"></a>协调 promises</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>如果你需要<strong>同步处理多个 promises</strong>，<code>Promise.all()</code> 可以帮助你定义<strong>一组 promises 列表</strong>，等待它们<strong>全部</strong> <code>resolved</code> 之后再执行某些操作。比如：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f1 = fetch(<span class="string">'/something.json'</span>)</span><br><span class="line"><span class="keyword">const</span> f2 = fetch(<span class="string">'/something2.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([f1, f2]).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Array of results'</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>ES2015 的<strong>解构语法</strong>也允许你这么做：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([f1, f2]).then(<span class="function">(<span class="params">[res1, res2]</span>) =&gt;</span> &#123;    <span class="comment">// 这里解构数组</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Results'</span>, res1, res2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>这不仅限于 <code>fetch</code>，任何 <code>promise</code> 都可以处理</strong>。</p>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p><code>Promise.race()</code> 会在你传递给它的<strong>第一个 promise resolves 时运行</strong>，并且它只运行一次附加的回调，并传入首先 resolved 的 promise 返回的结果。</p>
<p>示例：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">500</span>, <span class="string">'first'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> second = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">100</span>, <span class="string">'second'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([first, second]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result) <span class="comment">// second</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="Uncaught-TypeError-undefined-is-not-a-promise"><a href="#Uncaught-TypeError-undefined-is-not-a-promise" class="headerlink" title="Uncaught TypeError: undefined is not a promise"></a>Uncaught TypeError: undefined is not a promise</h3><p>如果你控制台中看到 <code>Uncaught TypeError: undefined is not a promise</code> 错误，<strong>请确保使用的是 <code>new Promise()</code> 而不是 <code>Promise()</code></strong>。</p>
<p>如果你还有什么疑问，可以查看 <a href="https://www.html.cn/archives/9933" target="_blank" rel="noopener">ES6 Promise 指南 666666</a></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.random() * <span class="number">100</span> &lt; <span class="number">90</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'resolving the promise ...'</span>);</span><br><span class="line">        resolve(<span class="string">'Hello, Promises!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'In 10% of the cases, I fail. Miserably.'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个函数</span></span><br><span class="line"><span class="keyword">const</span> onResolved = <span class="function">(<span class="params">resolvedValue</span>) =&gt;</span> <span class="built_in">console</span>.log(resolvedValue);</span><br><span class="line"><span class="keyword">const</span> onRejected = <span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.log(error);</span><br><span class="line"></span><br><span class="line">myPromise.then(onResolved, onRejected);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 效果同上，代码更加简明扼要</span></span><br><span class="line">myPromise.then(<span class="function">(<span class="params">resolvedValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resolvedValue);</span><br><span class="line">&#125;, (error) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有 90% 的概率输出下面语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// resolving the promise ...</span></span><br><span class="line"><span class="comment">// Hello, Promises!</span></span><br><span class="line"><span class="comment">// Hello, Promises!   // 这里没有输出resolving the promise ...了, 因为第一次已经成功了</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中还有一些需要注意的 <code>重要事项</code>。</p>
<p>我们创建了一个 promise 实例 myPromise。我们分别在第 13 行和第 16 行附加了两个 .then 的处理程序。尽管它们在功能上是相同的，<strong>但它们还是被被视为不同的处理程序</strong>。但是 ——</p>
<ul>
<li>一个 <code>promise</code> 只能成功（resolved）或失败（reject）一次。它不能成功或失败两次，也不能从成功切换到失败，反之亦然。</li>
<li>如果一个 <code>promise</code> 在你添加成功/失败回调（即 .then）<strong>之前就已经成功或者失败</strong>，则 <code>promise</code> <strong>还是会正确地调用回调函数</strong>，即使事件发生地比添加回调函数要早。</li>
</ul>
<p><strong>这意味着一旦 <code>promise</code> 达到最终状态，即使你多次附加 <code>.then</code> 处理程序，状态也不会改变（即不会再重新开始计算）</strong>。</p>
<blockquote>
<p>这说的就是第二个 <code>.then</code> 只会打印 <code>Hello, Promises!</code></p>
</blockquote>
<p>为了验证这一点，你可以在<strong>第 3 行</strong>看到一个 <code>console.log</code> 语句。当你用 <code>.then</code> 处理程序运行上述代码时，需要输出的语句只会被打印一次。 <strong>它表明 <code>promise</code> 缓存了结果，并且下次也会得到相同的结果</strong>。</p>
<p>另一个要注意的是，promise 的特点是<strong>及早求值</strong>（evaluated eagerly）。 <strong>只要声明并将其绑定到变量，就立即开始执行</strong>。没有 <code>.start</code> 或 <code>.begin</code> 方法。就像在上面的例子中那样。</p>
<p>为了确保 promise 不是立即开始而是<strong>惰性求值</strong>（evaluates lazily）， <strong>我们将它们包装在函数中</strong>。稍后会看到一个例子。</p>
<blockquote>
<p>一个 <code>.catch</code>本身总是被解析为 <code>promise</code>，并且不会被拒绝（除非你故意抛出错误）。这就是为什么 <code>.then</code> 后面的 <code>.catch</code>会被执行的原因。</p>
</blockquote>
<p>这里建议使用 <code>.catch</code> 而<strong>不是带有 <code>onResolved</code> 和 <code>onRejected</code> 参数的 <code>.then</code> 去处理</strong>。下面有一个案例解释了为什么最好这样做</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseThatResolves = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导致被拒绝的 promise 没有被处理</span></span><br><span class="line">promiseThatResolves().then(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(); <span class="comment">// 这里出错了就不能抓住</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; <span class="built_in">console</span>.log(err)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适当的错误处理</span></span><br><span class="line">promiseThatResolves()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err)); <span class="comment">// 这里可以抓住</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.html.cn/archives/10224" target="_blank" rel="noopener">理解 JavaScript 中的 Promises – JavaScript 完全手册（2018 版）</a><br><a href="https://www.html.cn/archives/9933" target="_blank" rel="noopener">ES6 Promise 指南 666</a><br><a href="https://www.html.cn/archives/7731" target="_blank" rel="noopener">ES2017 新特性：Async Functions (异步函数) 66 讲了和 generator 关系</a><br><a href="https://www.html.cn/archives/10235" target="_blank" rel="noopener">用 async 和 await 编写现代 JavaScript 异步代码 – JavaScript 完全手册（2018 版）</a><br><a href="https://juejin.im/post/5b04c7db6fb9a07aa542a772" target="_blank" rel="noopener">译】Async-Await≈Generators+Promises</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/javascript-异步编程和回调/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/13/javascript-异步编程和回调/" itemprop="url">javascript-异步编程和回调</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-13T12:02:50+08:00">2019-05-13</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="javascript-异步编程和回调"><a href="#javascript-异步编程和回调" class="headerlink" title="javascript-异步编程和回调"></a>javascript-异步编程和回调</h1><p>JavaScript <strong>默认是同步的，并且是单线程的</strong>。这意味着代码无法创建新线程并且并行运行。让我们了解一下什么是异步代码及其样子。</p>
<h2 id="编程语言中的异步"><a href="#编程语言中的异步" class="headerlink" title="编程语言中的异步"></a>编程语言中的异步</h2><p>计算机在<strong>设计上是异步</strong>的。</p>
<p>异步意味着某些事情可以<strong>独立于主程序流而发生</strong>。</p>
<p>在当前的消费者计算机中，每个程序都运行在一个特定的时间段，然后它停止执行，以让另一个程序继续执行。这种循环运行如此之快以至于我们无法注意到，我们认为我们的计算机同时运行许多程序，但这是一种幻觉（除了多处理器机器）。</p>
<p>程序内部使用 <strong>中断</strong> ，这是一个发送到处理器的信号，以引起系统的注意。</p>
<p>我不会深入讨论它的内部细节，但请记住，<strong>程序是异步的是很正常的</strong>，并在需要注意之前停止它们的执行，并且计算机可以在此期间执行其他操作。当程序正在等待来自网络的响应时，它不能在请求完成之前停止处理器。</p>
<p>通常，编程语言是同步的，有些语言提供了一种在语言或库中管理异步方法。 C，Java，C＃，PHP，Go，Ruby，Swift，Python，默认情况下它们都是同步的。其中一些通过使用线程处理异步，产生一个新进程。</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript <strong>默认是同步的，并且是单线程的</strong>。这意味着代码无法创建新线程并且并行运行。</p>
<p>代码行是一个接一个地串行执行的，例如：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> c = a * b;</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line">doSomething();</span><br></pre></td></tr></table></figure>
<p>但 JavaScript 诞生于浏览器中，一开始其主要工作就是响应用户操作，如 <code>onClick</code>，<code>onMouseOver</code>，<code>onChange</code>，<code>onSubmit等</code>。 怎么用同步编程模型呢？</p>
<p><strong>答案是在它的环境中</strong>。 <strong>浏览器</strong>通过提供一组可以处理这种功能的 <code>API</code> 来解决这个问题。</p>
<p>最近，Node.js 引入了一个非阻塞 I/O 环境，将这个概念扩展到文件访问，网络调用等。</p>
<h2 id="回调函数（Callbacks）"><a href="#回调函数（Callbacks）" class="headerlink" title="回调函数（Callbacks）"></a>回调函数（Callbacks）</h2><p>你无法知道用户何时要单击按钮，因此你 <strong>要为 click 事件定义事件处理程序</strong>。 此事件处理程序接受一个函数，该函数将在事件触发时调用：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'button'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">//item clicked</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这就是所谓的 <code>回调函数</code>。</p>
<p>回调是一个简单的函数，它<strong>作为值传递给另一个函数，并且只在事件发生时执行</strong>。 我们可以这样做，是因为函数是 JavaScript 的 “一等公民” ，可以分配给变量并传递给其他函数（称为 <a href="/2019/05/11/javascript-高阶函数/" title="javascript-高阶函数">javascript-高阶函数</a> ）</p>
<p>将所有客户端代码包装在 <code>window</code> 对象上的 <code>load</code> 事件侦听器中是很常见的，这样仅在<strong>该页面准备就绪时</strong>才运行回调函数：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">//window loaded</span></span><br><span class="line">  <span class="comment">//do what you want</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>回调在任何地方都使用，而不仅仅在 <code>DOM</code> 事件中使用</strong>。</p>
<p>一个常见的例子是使用定时器：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// runs after 2 seconds</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<p><code>XHR</code> 请求也接受回调。在本示例中，通过将函数分配给属性，该函数在特定事件发生时将被调用(在本例中，请求状态发生了变化)：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    xhr.status === <span class="number">200</span> ? <span class="built_in">console</span>.log(xhr.responseText) : <span class="built_in">console</span>.error(<span class="string">'error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'https://yoursite.com'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<h2 id="在回调中处理错误"><a href="#在回调中处理错误" class="headerlink" title="在回调中处理错误"></a>在回调中处理错误</h2><p>你如何<strong>处理回调错误</strong>？ 一个非常常见的策略是使用 <code>Node.js</code> 采用的办法：<strong>任何回调函数中的第一个参数是错误对象</strong>：<code>error-first callbacks</code>（错误优先的回调）</p>
<p>如果没有错误，则该对象为 <code>null</code>。 如果有错误，则包含错误的描述和其他信息。</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/file.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//handle error</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//no errors, process data</span></span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="回调带来的问题"><a href="#回调带来的问题" class="headerlink" title="回调带来的问题"></a>回调带来的问题</h2><p>对于简单的情况，回调非常有用！</p>
<p>但是<strong>每个回调都会增加嵌套层级</strong>，当你有很多回调时，代码开始变得非常复杂，也就大家经常会听到的 <strong>“回调地狱”</strong> ：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      items.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//your code here</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这只是一个简单的 4 层嵌套代码，但我已经看到了更多层级的嵌套，这并不好玩。</p>
<p>我们如何解决这个问题呢？</p>
<h2 id="回调的替代方案"><a href="#回调的替代方案" class="headerlink" title="回调的替代方案"></a>回调的替代方案</h2><p>从 ES6 开始，<code>JavaScript</code> 引入了一些新功能，可以帮助我们不用回调就能处理异步代码：</p>
<ul>
<li>Promises (ES6)</li>
<li>Async/Await (ES8)</li>
</ul>
<p>这些将在后面的章节中单独介绍。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.html.cn/archives/10222" target="_blank" rel="noopener">JavaScript 异步编程和回调 – JavaScript 完全手册（2018 版）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/javascript-事件循环event-loop/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/13/javascript-事件循环event-loop/" itemprop="url">javascript-事件循环event-loop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-13T11:23:57+08:00">2019-05-13</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="javascript-事件循环-event-loop"><a href="#javascript-事件循环-event-loop" class="headerlink" title="javascript-事件循环 event-loop"></a>javascript-事件循环 event-loop</h1><blockquote>
<a href="/2018/12/28/从输入URL到页面加载发生了什么/" title="从输入URL到页面加载发生了什么">从输入URL到页面加载发生了什么</a> > <a href="/2018/11/25/JavaScript-的-async-await/" title="JavaScript-的-async-await">JavaScript-的-async-await</a>
</blockquote>
<p>事件循环是 JavaScript 最重要的内容之一。</p>
<p>本节旨在解释 JavaScript 如何处理<strong>单个线程的内部细节</strong>，以及如何<strong>处理异步函数</strong>。</p>
<p>您的 JavaScript 代码运行是单线程的。一次只发生一件事。</p>
<p>这是一个实际上非常有用的限制，因为它简化了很多程序，而不必担心并发问题。</p>
<p>您只需要注意编写代码的方式，避免任何可能阻塞线程的内容，如同步网络请求或无限循环。</p>
<p>通常，在大多数浏览器中，<strong>每个浏览器标签</strong>都有一个<strong>独立的事件循环机制</strong>，以使每个<strong>进程隔离</strong>，并避免 web 页面具有无限循环或繁重的处理，从而阻塞整个浏览器。</p>
<p><strong>浏览器环境管理多个并发事件循环</strong>，例如处理 API 调用。 Web Workers 也在自己的事件循环中运行。</p>
<p>您只要明白您的代码将在单个事件循环上运行，并在编写代码时考虑到这一点，以避免阻塞它。</p>
<h2 id="阻塞事件循环"><a href="#阻塞事件循环" class="headerlink" title="阻塞事件循环"></a>阻塞事件循环</h2><p><strong>任何执行时间过长</strong>不能将控制权返回给事件循环的 <code>JavaScript</code> 代码都会阻塞页面内其它代码的执行，甚至阻塞 UI 线程，用户不能单击、滚动页面，等等。</p>
<p>几乎所有 JavaScript 中的 I/O 原语都是非阻塞的，比如网络请求，Node.js 文件系统操作等。 阻塞是个例外，这就是为什么 JavaScript <strong>基于回调</strong>，以及最近的 <code>promises</code> 和 <code>async/await</code> 。</p>
<h2 id="调用堆栈"><a href="#调用堆栈" class="headerlink" title="调用堆栈"></a>调用堆栈</h2><p>调用堆栈是 LIFO 队列（Last In, First Out）。 就是个<strong>栈</strong> 先进后出, 后出先进.</p>
<p>事件循环不断检查调用堆栈里是否仍有函数需要运行。</p>
<p>在这样做的同时，它将它找到的任何函数调用添加到调用堆栈，并按顺序执行每个调用。</p>
<p>您可以在调试器或浏览器控制台中了解您可能熟悉的<strong>错误堆栈跟踪</strong>吗？ 浏览器在调用堆栈中查找函数名称，以通知您哪个函数发起当前调用：</p>
<p>内到外, 栈</p>
<p><img src="stack.png" alt="stack.png"></p>
<h2 id="一个简单的事件循环说明"><a href="#一个简单的事件循环说明" class="headerlink" title="一个简单的事件循环说明"></a>一个简单的事件循环说明</h2><p>我们来举一个例子：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'baz'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">  bar();</span><br><span class="line">  baz();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>此代码打印:</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo;</span><br><span class="line">bar;</span><br><span class="line">baz;</span><br></pre></td></tr></table></figure>
<p>正如大家所料，和预期一样。</p>
<p>当此代码运行时，<strong>首先调用 <code>foo()</code> 。在 <code>foo()</code>里面我们先调用 <code>bar()</code>，然后调用 <code>baz()</code></strong>。</p>
<p>此时调用堆栈如下所示：</p>
<p><img src="call.png" alt="call.png"></p>
<p>每次迭代的事件循环都会查看调用栈中是否存在某些内容并执行它：</p>
<p><img src="call2.png" alt="call2.png"></p>
<p>直到调用堆栈为空。</p>
<h2 id="函数执行队列"><a href="#函数执行队列" class="headerlink" title="函数执行队列"></a>函数执行队列</h2><p>上面的例子看起来很正常，没有什么特别之处：<code>JavaScript</code> 找到要执行的东西，按<strong>顺序</strong>运行它们。</p>
<p>让我们看看如何<strong>推迟一个函数，直到堆栈清空</strong>。</p>
<p><code>setTimeout(() =&gt; {}), 0)</code> 用例是调用一个函数，会在代码中其他每个函数都已执行后再执行它。</p>
<p>举个例子：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'baz'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">  setTimeout(bar, <span class="number">0</span>);</span><br><span class="line">  baz();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>这段代码打印出来，结果是：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo;</span><br><span class="line">baz;</span><br><span class="line">bar;</span><br></pre></td></tr></table></figure>
<p>当此代码运行时，首先调用 <code>foo()</code> 。 在 <code>foo()</code> 里面我们首先调用 <code>setTimeout</code> ，将 <code>bar</code> 作为参数传递，然后将 <code>0</code> 作为计时器传递，意思是让它尽可能快地运行。 然后调用 <code>baz()</code>。</p>
<p>此时调用堆栈如下所示：</p>
<p><strong>注意看是 <code>foo()</code> 执行完后 再执行 <code>bar()</code></strong></p>
<p><img src="setTime.png" alt="setTime.png"></p>
<p>以下是我们程序中所有函数的执行顺序：</p>
<p><img src="setTime2.png" alt="setTime2.png"></p>
<p>为什么会这样？</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>当调用 <code>setTimeout()</code> 时，浏览器或者 Node.js 就会<strong>启动计时器</strong>。 一旦计时器到期，在这个例子中，当我们将 <code>0</code> 作为超时时间，<strong>回调函数</strong>立即被放入 <strong>消息队列</strong> 中。</p>
<p><strong>消息队列也包含用户发起的事件</strong>，如单击事件、键盘事件，或者在代码有机会对 <code>fetch</code> 响应作出响应之前，<code>fetch</code> 响应就已经进入队列了。再或者像 <code>onLoad</code> 这样的 <code>DOM</code> 事件。</p>
<p><strong>循环优先于调用堆栈</strong>，它首先处理它在调用堆栈中找到的所有内容，一旦没有任何东西，它就会在事件队列中查找要执行的内容。</p>
<p>我们<strong>不必等待</strong> <code>setTimeout</code> ，<code>fetch</code> 或其他函数来完成它们自己的工作，因为它们是由浏览器提供的，并且它们依赖于自己的线程。例如，如果您将 <code>setTimeout</code> 超时设置为 2 秒，那么您不必等待 2 秒 — 等待在其他地方发生。</p>
<h2 id="ES6-作业队列-Job-Queue"><a href="#ES6-作业队列-Job-Queue" class="headerlink" title="ES6 作业队列(Job Queue)"></a>ES6 作业队列(Job Queue)</h2><p>ECMAScript 2015 引入了 <code>Promises</code>（也在 ES6 / ES2015 中引入） ，使用了作业队列(<code>Job Queue</code>)概念。 这是一种<strong>尽快执行异步函数的方法</strong>，而不是放在调用堆栈的末尾。</p>
<p>在当前函数结束之前 <code>resolve</code> 状态的 <code>Promises</code> 将在当前函数之后立即执行。</p>
<p>我发现在游乐园里乘坐过山车的情况可以很好地解释 ES6 作业队列(Job Queue)：消息队列让你排队等候队列，等队列中所有其他人坐完之后乘坐，而作业队列(Job Queue)相当于是快速通行票，可以让您在乘坐完之后立即再乘一次。</p>
<p>例如：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'baz'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">  setTimeout(bar, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">    resolve(<span class="string">'should be right after baz, before bar'</span>)</span><br><span class="line">  ).then(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">console</span>.log(resolve));</span><br><span class="line">  baz();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>此代码打印:</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">baz</span><br><span class="line">should be right after baz, before bar</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>这是 <code>Promises</code>（包括基于 <code>promises</code> 的 <code>Async/await</code>）和普通的<strong>旧异步函数</strong>（通过 <code>setTimeout()</code> 或其他平台 API ）之间的巨大差异。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.html.cn/archives/10216" target="_blank" rel="noopener">JavaScript 中的事件循环（Event Loop） – JavaScript 完全手册（2018 版）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/javascript-事件events/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/13/javascript-事件events/" itemprop="url">javascript-事件events</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-13T10:25:49+08:00">2019-05-13</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="javascript-事件-events"><a href="#javascript-事件-events" class="headerlink" title="javascript-事件 events"></a>javascript-事件 events</h1><p><strong>浏览器</strong>中的 JavaScript 使用<strong>事件驱动</strong>的编程模型。 一切都始于事件。 本节介绍 JavaScript 事件以及事件处理的工作原理。</p>
<p>浏览器中的 JavaScript 使用<strong>事件驱动的编程模型</strong>。</p>
<p>一切都始于事件。</p>
<p>事件可能是 <code>DOM</code> 已加载，或者是<strong>异步请求</strong>完成，或用户<strong>单击</strong>元素或<strong>滚动</strong>页面，或用户<strong>按下</strong>键盘。</p>
<p>有很多不同类型的事件。</p>
<h2 id="事件处理器（Event-handlers）"><a href="#事件处理器（Event-handlers）" class="headerlink" title="事件处理器（Event handlers）"></a>事件处理器（Event handlers）</h2><p>你可以使用<strong>事件处理程序</strong>响应任何事件，事件处理程序只是<strong>在事件发生时调用的函数</strong>。</p>
<p>你可以为<strong>同一事件注册多个处理程序</strong>，并在事件发生时调用它们。</p>
<p>JavaScript 提供了<strong>三种</strong>注册事件处理程序的方法：</p>
<h3 id="内联事件处理程序-inline"><a href="#内联事件处理程序-inline" class="headerlink" title="内联事件处理程序 inline"></a>内联事件处理程序 inline</h3><p>由于他自身的限制，这种类型的事件处理程序<strong>今天很少使用</strong>，但这是 JavaScript <strong>早期的唯一方法</strong>：</p>
<p>HTML 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">'site.com'</span> onclick=<span class="string">'dosomething();'</span>&gt;</span><br><span class="line">  A link</span><br><span class="line">&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="DOM-事件处理器"><a href="#DOM-事件处理器" class="headerlink" title="DOM 事件处理器"></a>DOM 事件处理器</h3><p>当<strong>一个对象只有一个事件处理器时</strong>这种方法很常用，因为在这种情况下<strong>无法添加多个处理程序</strong>：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//window loaded</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它在处理<code>XHR</code>请求时最常用：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//.. do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>if (&#39;onsomething&#39; in window) {}</code> 检查是否已将处理程序分配给某个属性。</p>
<h3 id="使用-addEventListener"><a href="#使用-addEventListener" class="headerlink" title="使用 addEventListener()"></a>使用 addEventListener()</h3><p>这是 <strong>现代</strong> 方式。这种方法允许我们根据需求注册<strong>多个处理程序</strong>，你会发现它是绑定处理程序最受欢迎的方式：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">//window loaded</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：IE8 及以下版本不支持这个方法，可以使用 <code>attachEvent</code>() 代替。如果你需要支持旧浏览器，请记住这一点。</p>
</blockquote>
<h2 id="监听不同的元素"><a href="#监听不同的元素" class="headerlink" title="监听不同的元素"></a>监听不同的元素</h2><p>你可以监听 <code>window</code> 来拦截“<strong>全局</strong>”事件，比如<strong>键盘</strong>的使用，你也可以<strong>监听特定元素上</strong>发生的事件，比如鼠标点击了某个按钮。</p>
<p>这也是为什么 <code>addEventListener</code> <strong>有时候在 <code>window</code> 上调用，有时间在某个 <code>DOM</code> 元素上</strong>。</p>
<h2 id="Event-对象"><a href="#Event-对象" class="headerlink" title="Event 对象"></a>Event 对象</h2><p><strong>事件处理器</strong>会获得一个 <code>Event</code> <strong>对象</strong>作为第一个参数：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> link = <span class="built_in">document</span>.getElementById(<span class="string">'my-link'</span>);</span><br><span class="line">link.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="comment">// link clicked</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个对象包含很多有用的属性和方法，比如：</p>
<ul>
<li><code>target</code>，事件发生的目标 <code>DOM</code> 元素</li>
<li><code>type</code>，事件类型</li>
<li><code>stopPropagation()</code>，调用以阻止 <code>DOM</code> 事件传播</li>
</ul>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event" target="_blank" rel="noopener">(查看完整清单)Event</a></p>
<p>其它属性提供给<strong>特定的事件</strong>，<code>Event</code> 只是不同事件的一个接口：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent" target="_blank" rel="noopener">MouseEvent</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent" target="_blank" rel="noopener">KeyboardEvent</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/DragEvent" target="_blank" rel="noopener">DragEvent</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent" target="_blank" rel="noopener">FetchEvent</a></li>
</ul>
<p>…等等<br>上面的每一个都链接到了 MDN 页面，你可以在那查看它们所有的属性。</p>
<p>例如，<strong>当一个键盘事件发生时，你可以检查哪个键被按下</strong>，通过 <code>key</code> 属性值得到一个可读格式的值（ <code>Escape</code>, <code>Enter</code> 等等）：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'keydown'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="comment">// key pressed</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.key);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在<strong>鼠标事件中，我们可以检查按下了哪个鼠标按钮</strong>：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> link = <span class="built_in">document</span>.getElementById(<span class="string">'my-link'</span>);</span><br><span class="line">link.addEventListener(<span class="string">'mousedown'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="comment">// mouse button pressed</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.button); <span class="comment">//0=left, 2=right</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="事件冒泡和事件捕捉"><a href="#事件冒泡和事件捕捉" class="headerlink" title="事件冒泡和事件捕捉"></a>事件冒泡和事件捕捉</h2><p><strong>事件冒泡</strong>和<strong>事件捕捉</strong>是事件传播的两个模型。</p>
<p>假设你的 DOM 结构是这样的：</p>
<p>HTML 代码:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你希望跟踪用户何时单击该按钮，并且你有<strong>两个事件侦听器</strong>，一个在 <code>button</code> 上，另一个在 <code>#container</code> 上。 请记住，<strong>单击子元素将始终传播到其父元素</strong>，除非你停止事件传播（我们稍后会看到）。</p>
<p>这些事件侦听器会<strong>按照顺序调用</strong>，这个顺序通过<strong>事件冒泡/事件捕捉模型</strong>决定。</p>
<p><strong>冒泡</strong> 意味着事件<strong>从被点击的元素（子元素）一直向上传播到所有祖先元素</strong>，从最近的一个开始。从子开始处理相应程序</p>
<p>在我们的例子中，点击 <code>button</code> 的话, <code>button</code> 上的处理器会在 <code>#container</code> 之前发生。</p>
<p><strong>捕捉</strong> 恰恰相反：<strong>最外部的事件会在特定处理器之前</strong>发生，比如还是点击 <code>button</code> , 但先冒泡到最外层的 <code>#container</code> , <code>#container</code>上的事件处理先相应, 然后是 <code>button</code> 上的事件处理程序响应.</p>
<p>默认采用<code>事件冒泡</code>模型。从子开始处理</p>
<p>你也<strong>可以选择使用事件捕捉</strong>，通过将 <code>addEventListener</code> 的第三个参数设为 true：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'container'</span>).addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="comment">//window loaded</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意：<strong>首先运行所有<code>捕获</code>事件处理程序</strong>。<br><strong>然后是所有<code>冒泡</code>的事件处理程序</strong>。</p>
<p>这个顺序遵循这个<strong>原则</strong>：<code>DOM</code> 遍历从 <code>Window</code> 对象开始的所有元素，直到找到被点击的元素项。执行此操作时，调用与事件关联的任何事件处理程序（捕获阶段）。</p>
<p>一旦找到目标元素，它会重复这个过程直到回到 <code>Window</code> 对象，此时调用相应的事件处理器（冒泡阶段）。</p>
<p>这样图可以帮助你理解这个过程：</p>
<blockquote>
<p>注意咯, 如果你设置了多个事件处理, 比如一个 <code>window</code> 上设置了 2 个 一个用 <strong>冒泡</strong>, 一个用 <strong>捕获</strong>, 那么 都会触发的, 然后触发顺序是 下面的 1 2 3 4 先 处理 <strong>捕获的</strong> 在处理 <strong>冒泡</strong> 的事件处理程序</p>
</blockquote>
<p><img src="bubble.png" alt="bubble.png"></p>
<h2 id="停止传播"><a href="#停止传播" class="headerlink" title="停止传播"></a>停止传播</h2><p>DOM 元素上的事件将<strong>传播到其所有父元素上</strong>，除非手动停止传播：</p>
<p>HTML 代码:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"my-link"</span> <span class="attr">...</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>a</code> 上的 <code>click</code> 事件会传播到 <code>section</code> 然后是 <code>body</code> 。</p>
<p>你可以调用 <code>Event</code> 的 <code>stopPropagation()</code> 方法来<strong>停止事件传播</strong>，通常<strong>放在事件处理程序的末尾</strong>（注：我个人喜好放在事件处理程序的开始处）：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> link = <span class="built_in">document</span>.getElementById(<span class="string">'my-link'</span>);</span><br><span class="line">link.addEventListener(<span class="string">'mousedown'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="comment">// process the event</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h2><p>以下可能是你会处理的最常见事件的列表。</p>
<h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>页面加载完成后，在 <code>window</code> 和 <code>body</code> 元素上触发 <code>load</code> 事件。</p>
<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><p>单击鼠标按钮时 <code>click</code> 事件触发。 单击鼠标两次时触发 <code>dbclick</code> 事件。 当然，在这种情况下，<code>click</code> 事件会在此事件之前触发。<code>mousedown</code>，<code>mousemove</code> 和 <code>mouseup</code> 可以和<strong>拖动事件</strong>结合在一起。小心使用 <code>mousemove</code>，<strong>因为它会在鼠标移动过程中触发很多次（稍后会看到节流）</strong>。</p>
<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><p>当按下键盘键时 <code>keydown</code> 事件就会触发(当按下按钮时，任何时候重复键)。当键被释放时，将触发 <code>keyup</code> 事件。</p>
<h2 id="滚动-Scroll"><a href="#滚动-Scroll" class="headerlink" title="滚动(Scroll)"></a>滚动(Scroll)</h2><p>每次滚动页面时都会在 <code>window</code> 上触发 <code>scroll</code> 事件。在事件处理程序中，你可以通过检查 <code>window.scrollY</code>（Y 轴）(注：我个人喜好用 <code>document.documentElement.scrollTop)</code> 来检查当前的滚动位置。</p>
<p>请记住，此事件<strong>不是一次性的事件</strong>。它在滚动期间会发生很多次，而不仅仅是在滚动的结尾或开始时，所以<strong>不要在处理程序中进行任何频繁的计算或操作</strong> – 而是使用节流代替。</p>
<h2 id="节流-Throttling"><a href="#节流-Throttling" class="headerlink" title="节流(Throttling)"></a>节流(Throttling)</h2><p>如上所述，<code>mousemove</code> 和 <code>scroll</code> 这两个事件都<strong>不是一次性事件</strong>，而是在持续操作的时间内<strong>连续调用</strong>它们的事件处理函数。</p>
<p>这是因为它们提供坐标，因此你可以跟踪正在发生的事件。</p>
<p>如果你在这些事件处理器中进行复杂的操作，则会影响性能并导致站点用户体验不佳。</p>
<p>像 <a href="https://www.html.cn/doc/lodash/#_throttlefunc-wait0-options" target="_blank" rel="noopener">Lodash throttle</a> 这样的库提供了 100 行代码实现的节流函数来处理这个问题。一个简单易懂的实现是使用 <code>setTimeout</code> 每隔 <code>100ms</code> 缓存一次滚动事件：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cached = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!cached) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//you can access the original event at `cached`</span></span><br><span class="line">      cached = <span class="literal">null</span>;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cached = event;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a href="https://www.html.cn/doc/lodash/#_debouncefunc-wait0-options" target="_blank" rel="noopener">防抖动 debounce</a></p>
<p>两者区别</p>
<p><a href="https://www.jianshu.com/p/e91775195608" target="_blank" rel="noopener">理解 Debouncing 与 Throttling 的区别 666</a><br><a href="https://www.cnblogs.com/wilber2013/p/5893426.html" target="_blank" rel="noopener">白话 debounce 和 throttle</a></p>
<p>debounce 的主要区别是 推迟这次调用。 电梯例子<br>throttle 保证方法每 Xms 有规律的执行,</p>
<ul>
<li>debounce：把触发非常频繁的事件合并成一次执行</li>
<li>throttle：设置一个阀值，在阀值内，把触发的事件合并成一次执行；当到达阀值，必定执行一次事件</li>
</ul>
<h3 id="了解了-throttle-和-debounce-之后，下面看看他们的常用场景："><a href="#了解了-throttle-和-debounce-之后，下面看看他们的常用场景：" class="headerlink" title="了解了 throttle 和 debounce 之后，下面看看他们的常用场景："></a>了解了 throttle 和 debounce 之后，下面看看他们的常用场景：</h3><p>debounce</p>
<ul>
<li>对于键盘事件，当用户输入比较频繁的时候，可以通过 debounce 合并键盘事件处理</li>
<li>对于 <strong><code>ajax</code> 请求的情况</strong>，例如当页面下拉超过一定返回就通过 <code>ajax</code> 请求新的页面内容，这时候可以通过 debounce 合并 ajax 请求事件</li>
</ul>
<p>throttle</p>
<ul>
<li>对于键盘事件，当用户输入非常频繁，但是我们又必须要在一定时间内（阀值）内执行处理函数的时候，就可以使用 throttle<ul>
<li>例如，一些网页游戏的键盘事件</li>
</ul>
</li>
<li>对于<strong>鼠标移动和窗口滚动</strong>，鼠标的移动和窗口的滚动会带来大量的事件，但是在一段时间内又必须看到页面的效果<ul>
<li>例如对于可以拖动的 div，如果使用 debounce，那么 div 会在拖动停止后一下子跳到目标位置；这时就需要使用 throttle</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.html.cn/archives/10207" target="_blank" rel="noopener">JavaScript 中的事件（Events） – JavaScript 完全手册（2018 版）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/javascript-循环loop/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/13/javascript-循环loop/" itemprop="url">javascript-循环loop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-13T10:05:20+08:00">2019-05-13</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="javascript-循环-loop"><a href="#javascript-循环-loop" class="headerlink" title="javascript-循环 loop"></a>javascript-循环 loop</h1><p>JavaScript 提供了许多迭代循环的方法。本节通过一个小例子和主要属性解释现代 JavaScript 中的所有各种循环方法。</p>
<ul>
<li>while, do…whild</li>
<li>for</li>
<li>forEach  不能 跳出</li>
<li>for…in has​OwnProperty() key名</li>
<li>for…of value值</li>
</ul>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(list[i]); <span class="comment">//value</span></span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//index</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用 <code>break</code> 中断 <code>for</code> 循环<br>您可以使用 <code>continue</code> 快速进入到 <code>for</code> 循环的下一次迭代</p>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>在 ES5 中引入。给定一个数组，您可以使用 <code>list.forEach()</code> 迭代其属性：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">list.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">//value</span></span><br><span class="line">  <span class="built_in">console</span>.log(index); <span class="comment">//index</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//index is optional</span></span><br><span class="line">list.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item));</span><br></pre></td></tr></table></figure>
<p>不幸的是，你无法中断 <code>forEach</code> 循环。</p>
<h2 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h2><p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(list[i]); <span class="comment">//value</span></span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//index</span></span><br><span class="line">  i = i + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; list.length);</span><br></pre></td></tr></table></figure>
<p>可以通过 <code>break</code> 中断 <code>do...while</code> 循环：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>continue</code> 跳转到下一个迭代：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="comment">//do something else</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; list.length) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(list[i]); <span class="comment">//value</span></span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//index</span></span><br><span class="line">  i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用 <code>break</code> 中断 <code>while</code> 循环：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>continue</code> 跳转到下一个迭代：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="comment">//do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>while</code> 与 <code>do...while</code> 的区别在于 <code>do...while</code> <strong>至少执行一次循环</strong>。</p>
<h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>迭代对象所有可枚举属性。 会遍历原型链的, 结合 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="noopener">Object​.prototype​.has​OwnProperty()</a></p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> property <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(property); <span class="comment">//property name</span></span><br><span class="line">  <span class="built_in">console</span>.log(object[property]); <span class="comment">//property value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p>ES2015 中引入了 <code>for...of</code> 循环，它结合了 <code>forEach</code> 的简洁性，并且<code>for...of</code> 循环具有可以中断循环特性：</p>
<p>JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">//value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用 `entries()`,获取索引</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index); <span class="comment">//index</span></span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">//value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意使用 <code>const</code> 。这个循环在每次迭代都创建了一个<strong>新的作用域</strong>，所以我们可以安全的使用它替代 <code>let</code> 。</p>
<h2 id="for…in-vs-for…of"><a href="#for…in-vs-for…of" class="headerlink" title="for…in vs for…of"></a>for…in vs for…of</h2><p>和 <code>for...in</code> 不同的是：</p>
<ul>
<li><code>for...in</code> 迭代<strong>属性名</strong> key</li>
<li><code>for...of</code> 迭代<strong>属性值</strong> value</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.html.cn/archives/10205" target="_blank" rel="noopener">JavaScript 中的循环（Loops） – JavaScript 完全手册（2018 版）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatarMogu.jpg" alt="Henry x">
            
              <p class="site-author-name" itemprop="name">Henry x</p>
              <p class="site-description motion-element" itemprop="description">this is description</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">133</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">135</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="weibo" target="_blank">weibo</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Henry x</span>

  

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.1"></script>



  



	





  





  










  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  

</body>
</html>
