<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.1',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  
  <meta name="keywords" content="Hexo, NexT">


<meta name="description" content="this is description">
<meta property="og:type" content="website">
<meta property="og:title" content="Little H title">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Little H title">
<meta property="og:description" content="this is description">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Little H title">
<meta name="twitter:description" content="this is description">






  <link rel="canonical" href="http://yoursite.com/page/4/">


  <title>Little H title</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Little H title</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">this is subtitle</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益404</a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/11/http3xx重定向状态码/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/11/http3xx重定向状态码/" itemprop="url">http3xx重定向状态码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-11T14:26:55+08:00">2019-04-11</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/网络/" itemprop="url" rel="index"><span itemprop="name">网络</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="http3xx-重定向状态码"><a href="#http3xx-重定向状态码" class="headerlink" title="http3xx 重定向状态码"></a>http3xx 重定向状态码</h1><p>简单说下 301/302/303/307/308 这 5 种状态码的情况</p>
<h2 id="状态码的解释"><a href="#状态码的解释" class="headerlink" title="状态码的解释"></a>状态码的解释</h2><h3 id="301-Moved-Permanently（永久移动）"><a href="#301-Moved-Permanently（永久移动）" class="headerlink" title="301 Moved Permanently（永久移动）"></a>301 Moved Permanently（永久移动）</h3><p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。<br>除非额外指定，否则这个响应也是<strong>可缓存</strong>的。新的永久性的 URI 应当在响应的<code>Location</code>域中返回。<br>除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p>
<blockquote>
<p>注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个 301 响应的话，接下来的重定向请求将会变成 GET 方式。</p>
</blockquote>
<h3 id="302-Found（发现）"><a href="#302-Found（发现）" class="headerlink" title="302 Found（发现）"></a>302 Found（发现）</h3><p>要求客户端执行临时重定向（原始描述短语为“<code>Moved Temporarily</code>”）。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。<br>只有在<code>Cache-Control</code>或<code>Expires</code>中进行了指定的情况下，这个响应才是可缓存的。新的临时性的 URI 应当在响应的<code>Location</code>域中返回。<br>除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p>
<blockquote>
<p>注意：虽然 RFC 1945 和 RFC 2068 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将 302 响应视作为 303 响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。因此状态码 303 和 307 被添加了进来，用以明确服务器期待客户端进行何种反应。</p>
</blockquote>
<h3 id="303-See-Other（查看其他）"><a href="#303-See-Other（查看其他）" class="headerlink" title="303 See Other（查看其他）"></a>303 See Other（查看其他）</h3><p>对应当前请求的响应可以在另一个 URI 上被找到，当响应于 POST（或 PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的 GET 消息发出重定向。这个方法的存在主要是为了允许由脚本激活的 POST 请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303 响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。注意：许多 HTTP/1.1 版以前的浏览器不能正确理解 303 状态。如果需要考虑与这些浏览器之间的互动，302 状态码应该可以胜任，因为大多数的浏览器处理 302 响应时的方式恰恰就是上述规范要求客户端处理 303 响应时应当做的。</p>
<h3 id="307-Temporary-Redirect（临时重定向）"><a href="#307-Temporary-Redirect（临时重定向）" class="headerlink" title="307 Temporary Redirect（临时重定向）"></a>307 Temporary Redirect（临时重定向）</h3><p>在这种情况下，请求应该与另一个 URI 重复，但后续的请求应仍使用原始的 URI。 <strong>与 302 相反，当重新发出原始请求时，不允许更改请求方法</strong>。 例如，应该使用另一个 POST 请求来重复 POST 请求</p>
<h3 id="308-Permanent-Redirect-（永久重定向）"><a href="#308-Permanent-Redirect-（永久重定向）" class="headerlink" title="308 Permanent Redirect （永久重定向）"></a>308 Permanent Redirect （永久重定向）</h3><p>请求和所有将来的请求应该使用另一个 URI 重复。 <strong>307 和 308 重复 302 和 301 的行为，但不允许 HTTP 方法更改</strong>。 例如，将表单提交给永久重定向的资源可能会顺利进行。</p>
<h2 id="301-302-303-307-308-的区别"><a href="#301-302-303-307-308-的区别" class="headerlink" title="301/302/303/307/308 的区别"></a>301/302/303/307/308 的区别</h2><p><strong>301，302 是 http1.0</strong>的内容，<strong>303、307、308 是 http1.1</strong>的内容。</p>
<p>301 和 302 本来<strong>在规范中是不允许重定向时改变请求方法的（将 POST 改为 GET）</strong>，但是许多浏览器却允许重定向时改变请求方法（这是一种不规范的实现）。</p>
<p>303 的出现正是为了给上面的 301，302 这种行为作出个规范（将错就错吧），也就是允许重定向时改变请求方法。此外 303 响应禁止被缓存。</p>
<p><strong>大多数的浏览器处理 302 响应时的方式恰恰就是上述规范要求客户端处理 303 响应时应当做的，所以 303 基本用的很少，一般用 302</strong>。</p>
<p>307 和 308 的出现也是给上面的行为做个规范，不过是不允许重定向时改变请求方法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Permanent</th>
<th>Temporary</th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows changing the request method from POST to GET.</td>
<td>301</td>
<td>302</td>
</tr>
<tr>
<td>Does not allow changing the request method from POST to GET.</td>
<td>308</td>
<td>307</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注：永久（Permanent）和临时（Temporary）的区别</p>
</blockquote>
<p>永久是指<strong>原来访问的资源已经永久删除啦</strong>，客户端应该根据新的 URI 访问重定向。</p>
<p>临时是指访问的<strong>资源可能暂时先用 location 的 URI 访问，但旧资源还在的</strong>，下次你再来访问的时候可能就不用重定向了。</p>
<p>故 301 与 302 的区别：</p>
<p>301 表示搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302 表示旧地址 A 的资源还在（仍然可以访问），这个重定向只是临时地从旧地址 A 跳转到地址 B，搜索引擎会抓取新的内容而保存旧的网址。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>因为 301 与 302 的区别，所以导致产生 302 网址劫持，故不建议使用 302 重定向（然而浏览器默认是使用 302 重定向）</p>
<p>302 重定向和网址劫持（URL hijacking）</p>
<p>从网址 A 做一个 302 重定向到网址 B 时，主机服务器的隐含意思是网址 A 随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到 302 重定向时，一般只要去抓取目标网址就可以了，也就是说网址 B。如果搜索引擎在遇到 302 转向时，百分之百的都抓取目标网址 B 的话，就不用担心网址 URL 劫持了。问题就在于，有的时候搜索引擎，尤其是 Google，并不能总是抓取目标网址。比如说，有的时候 A 网址很短，但是它做了一个 302 重定向到 B 网址，而 B 网址是一个很长的乱七八糟的 URL 网址，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而 B 网址既难看，又不用户友好。这时 Google 很有可能会仍然显示网址 A。由于搜索引擎排名算法只是程序而不是人，在遇到 302 重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址 URL 劫持的可能性。也就是说，一个不道德的人在他自己的网址 A 做一个 302 重定向到你的网址 B，出于某种原因， Google 搜索结果所显示的仍然是网址 A，但是所用的网页内容却是你的网址 B 上的内容，这种情况就叫做网址 URL 劫持。你辛辛苦苦所写的内容就这样被别人偷走了。302 重定向所造成的网址 URL 劫持现象，已经存在一段时间了。不过到目前为止，似乎也没有什么更好的解决方法。在正在进行的谷歌大爸爸数据中心转换中，302 重定向问题也是要被解决的目标之一。从一些搜索结果来看，网址劫持现象有所改善，但是并没有完全解决。</p>
<h3 id="使用-301-的场景：（一般是资源位置永久更改）"><a href="#使用-301-的场景：（一般是资源位置永久更改）" class="headerlink" title="使用 301 的场景：（一般是资源位置永久更改）"></a>使用 301 的场景：（一般是资源位置永久更改）</h3><p>1.域名到期不想续费（或者发现了更适合网站的域名），想换个域名。</p>
<p>2.在搜索引擎的搜索结果中出现了不带 www 的域名，而带 www 的域名却没有收录，这个时候可以用 301 重定向来告诉搜索引擎我们目标的域名是哪一个。</p>
<p>3.空间服务器不稳定，换空间的时候。</p>
<p>注：另外，返回 301 请求码进行跳转被谷歌认为是将网站地址由 HTTP 迁移到 HTTPS 的最佳方法(然而大家都用 302。。。。)</p>
<h3 id="使用-302-的场景：（一般是普通的重定向需求：临时跳转）"><a href="#使用-302-的场景：（一般是普通的重定向需求：临时跳转）" class="headerlink" title="使用 302 的场景：（一般是普通的重定向需求：临时跳转）"></a>使用 302 的场景：（一般是普通的重定向需求：临时跳转）</h3><p>1.未登录前先使用 302 重定向到登录页面,登录成功后再跳回到原来请求的页面</p>
<p>举个例子，比如我未登录京东前我就访问京东的个人界面 <a href="https://home.jd.com/" target="_blank" rel="noopener">https://home.jd.com/</a> ,然后就会重定向到登录界面，我们可以通过浏览器的 dev-tool 查看状态码</p>
<p>我们可以发现响应的状态码为 302，并且返回了 location 为登录界面的 url，并且附带了 ReturnUrl 方便我们登录后跳回到 <a href="https://home.jd.com/" target="_blank" rel="noopener">https://home.jd.com/</a></p>
<p>2.有时候需要自动刷新页面，比如 5 秒后回到订单详细页面之类。</p>
<p>例子略。</p>
<p>3.有时系统进行升级或者切换某些功能时，需要临时更换地址。</p>
<p>例子略。</p>
<p>4.像微博之类的使用短域名，用户浏览后需要重定向到真实的地址之类。<br>再来个例子，我访问了另一个微博的秒拍视频链接：<a href="http://t.cn/RuOcwxn，然后重定向了两次，先是301重定向到video.weibo.com，再302重定向到miaopai.com。" target="_blank" rel="noopener">http://t.cn/RuOcwxn，然后重定向了两次，先是301重定向到video.weibo.com，再302重定向到miaopai.com。</a></p>
<p>5.电脑端与移动端的转换</p>
<p>比如我访问网页端页面<a href="https://www.taobao.com/，302重定向到了移动端页面m.taobao.com" target="_blank" rel="noopener">https://www.taobao.com/，302重定向到了移动端页面m.taobao.com</a></p>
<p>使用 303 的场景</p>
<p>几乎没有，一般就是用 302</p>
<h3 id="使用-307-的场景"><a href="#使用-307-的场景" class="headerlink" title="使用 307 的场景"></a>使用 307 的场景</h3><p>很少用，与 302 类似，只不过是针对 POST 方法的请求不允许更改方法</p>
<p>不过我在访问百度时，发现用了 307 状态码</p>
<h3 id="使用-308-的场景"><a href="#使用-308-的场景" class="headerlink" title="使用 308 的场景"></a>使用 308 的场景</h3><p>很少用，与 301 类似，只不过是针对 POST 方法的请求不允许更改方法</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/wuguanglin/p/redirect.html" target="_blank" rel="noopener">详解重定向（HTTP 状态码 301/302/303/307/308）附例子</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/08/在前端用JavaScript来实现下载/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/08/在前端用JavaScript来实现下载/" itemprop="url">在前端用JavaScript来实现下载</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-08T20:26:42+08:00">2019-04-08</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在前端用JavaScript来实现下载"><a href="#在前端用JavaScript来实现下载" class="headerlink" title="在前端用JavaScript来实现下载"></a>在前端用JavaScript来实现下载</h1><p>很多情况下我们都只能给出个链接，让用户点击打开-&gt;另存为。如下面这个链接：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">”file.js”</span>&gt;</span>file.js<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>用户点击这个链接的时候，浏览器会打开并显示链接指向的文件内容，显然，这并没有实现我们的需求。</p>
<p>幸好，HTML 5 里面为 <code>&lt;a&gt;</code> 标签添加了一个 <code>download</code> 的属性，我们可以轻易的利用它来实现下载功能。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://somehost/somefile.zip"</span> <span class="attr">download</span>=<span class="string">"filename.zip"</span>&gt;</span>Download file<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只要为 <code>&lt;a&gt;</code> 标签添加 <code>download</code> 属性就行, 并且添加的属性值是下载的文件名.</p>
<p>在用javascript写的时候也是按这个思路</p>
<ul>
<li>用 JavaScript 创建一个隐藏的 <code>&lt;a&gt;</code> 标签</li>
<li>设置它的 href 属性</li>
<li>设置它的 download 属性</li>
<li>用 JavaScript 来触发这个它的 click 事件</li>
</ul>
<p>翻译成javascript代码就是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line"><span class="keyword">var</span> filename = <span class="string">'what-you-want.csv'</span>;</span><br><span class="line">a.href = url;</span><br><span class="line">a.download = filename;</span><br><span class="line">a.click();</span><br><span class="line"><span class="built_in">window</span>.URL.revokeObjectURL(url);</span><br></pre></td></tr></table></figure>
<p>在设置属性的时候不用<code>setAttribute</code>可以看这个链接<a href="https://stackoverflow.com/questions/22151560/what-is-happening-behind-setattribute-vs-attribute" target="_blank" rel="noopener">What is happening behind .setAttribute vs .attribute=?</a></p>
<h2 id="DataURI"><a href="#DataURI" class="headerlink" title="DataURI"></a>DataURI</h2><p>这只是下载对应href中的文件, 或者说是在服务器端的文件, 如果是在前端的文件呢, <code>DataURI</code>来解决<br><a href="https://sjolzy.cn/What-is-the-data-URI-scheme-and-how-to-use-the-data-URI-scheme.html" target="_blank" rel="noopener">什么是data URI scheme及如何使用data URI scheme</a></p>
<p>这种取得资料的方法称为 <code>http URI scheme</code>, 同样的效果使用 <code>data URI scheme</code></p>
<blockquote>
<p>简单说就是这种方式会把所有的数据都存在href中, 而不会去请求服务器.</p>
</blockquote>
<h2 id="URL-createObjectURL"><a href="#URL-createObjectURL" class="headerlink" title="URL.createObjectURL()"></a>URL.createObjectURL()</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL" target="_blank" rel="noopener">URL.createObjectURL()</a></p>
<p>window.URL 里面有两个方法：</p>
<ul>
<li><code>createObjectURL</code> 用 blob 对象来创建一个 object URL(它是一个 DOMString)，我们可以用这个 object URL 来表示某个 blob 对象，这个 object URL 可以用在 href 和 src 之类的属性上。</li>
<li><code>revokeObjectURL</code> 释放由 createObjectURL 创建的 object URL，当该 object URL 不需要的时候，我们要主动调用这个方法来获取最佳性能和内存使用。</li>
</ul>
<p>知道了这两个方法之后，我们再回去看看上面的例子就很容易理解了吧！只是用 blob 对象来创建一条 URL，然后让 <code>&lt;a&gt;</code> 标签引用该 URL，然后触发个点击事件，就可以下载文件了！</p>
<h2 id="Blob-对象"><a href="#Blob-对象" class="headerlink" title="Blob 对象"></a>Blob 对象</h2><p>Blob 全称是 Binary large object，它表示一个类文件对象，可以用它来表示一个文件。根据 MDN 上面的说法，File API 也是基于 blob 来实现的。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener">Blob</a></p>
<p>这里使用 <code>Blob() 构造函数</code> 允许用其它对象创建 Blob 对象。比如，用字符串构建一个 blob：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debug = &#123;<span class="attr">hello</span>: <span class="string">"world"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">JSON</span>.stringify(debug, <span class="literal">null</span>, <span class="number">2</span>)],</span><br><span class="line">  &#123;<span class="attr">type</span> : <span class="string">'application/json'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>所以依赖这个我们可以从后端拿到数据, 然后再前端下载它. 设计分页的我们也都是前端开分页.</p>
<h2 id="MIME类型-Multipurpose-Internet-Mail-Extensions"><a href="#MIME类型-Multipurpose-Internet-Mail-Extensions" class="headerlink" title="MIME类型(Multipurpose Internet Mail Extensions)"></a>MIME类型(Multipurpose Internet Mail Extensions)</h2><p>上面Blob的类型type选择比如要下载csv的就要选<code>text/csv</code></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener">多用途Internet邮件扩展（MIME）类型</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types" target="_blank" rel="noopener">完整的MIME类型列表</a> 可以按扩展名来查看MIME Type</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://scarletsky.github.io/2016/07/03/download-file-using-javascript/" target="_blank" rel="noopener">如何用 JavaScript 下载文件</a><br><a href="https://lzw.me/a/fed-file-download.html" target="_blank" rel="noopener">前端 javascript 实现文件下载</a><br><a href="http://www.alloyteam.com/2014/01/use-js-file-download/" target="_blank" rel="noopener">在浏览器端用JS创建和下载文件</a><br><a href="https://sjolzy.cn/What-is-the-data-URI-scheme-and-how-to-use-the-data-URI-scheme.html" target="_blank" rel="noopener">什么是data URI scheme及如何使用data URI scheme</a><br><a href="https://stackoverflow.com/questions/22151560/what-is-happening-behind-setattribute-vs-attribute" target="_blank" rel="noopener">What is happening behind .setAttribute vs .attribute=?</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener">多用途Internet邮件扩展（MIME）类型</a><br><a href="https://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="noopener">Media Types</a><br><a href="https://sjolzy.cn/What-is-the-data-URI-scheme-and-how-to-use-the-data-URI-scheme.html" target="_blank" rel="noopener">什么是data URI scheme及如何使用data URI scheme</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/data_URIs" target="_blank" rel="noopener">Data URLs</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener">Blob</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/07/leetcode刷题-js版/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/07/leetcode刷题-js版/" itemprop="url">leetcode刷题 js版</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-07T15:55:12+08:00">2019-04-07</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="leetcode刷题-js版"><a href="#leetcode刷题-js版" class="headerlink" title="leetcode刷题 js版"></a>leetcode刷题 js版</h1><p>刷题地址在这<a href="https://leetcode.com/problemset/all/" target="_blank" rel="noopener">leetcode</a></p>
<p>当然网址上也会有java版的解答, 涉及优化的细节</p>
<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// Approach 1: Brute Force</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j] === target - nums[i]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [i,j]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Approach 2: Two-pass Hash Table</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    map.set(nums[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> complement = target - nums[i];</span><br><span class="line">    <span class="keyword">if</span> (map.has(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">      <span class="keyword">return</span> [map.get(complement), i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Approach 3: One-pass Hash Table</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> complement = target - nums[i];</span><br><span class="line">    <span class="keyword">if</span> (map.has(complement)) &#123;</span><br><span class="line">      <span class="keyword">return</span> [map.get(complement), i]</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(nums[i], i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h2><h2 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/hanzichi/leetcode" target="_blank" rel="noopener">LeetCode solutions with JavaScript</a><br><a href="https://github.com/chihungyu1116/leetcode-javascript" target="_blank" rel="noopener">chihungyu1116/leetcode-javascript</a><br><a href="https://github.com/MisterBooo/LeetCodeAnimation" target="_blank" rel="noopener">Demonstrate all the questions on LeetCode in the form of animation.</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/前端的网络请求方式和http/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/01/前端的网络请求方式和http/" itemprop="url">前端的网络请求方式和http</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T19:12:56+08:00">2019-04-01</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端教程/" itemprop="url" rel="index"><span itemprop="name">前端教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前端的网络请求方式和http"><a href="#前端的网络请求方式和http" class="headerlink" title="前端的网络请求方式和http"></a>前端的网络请求方式和http</h1><h2 id="http请求报文"><a href="#http请求报文" class="headerlink" title="http请求报文"></a>http请求报文</h2><h3 id="HTTP之请求消息Request"><a href="#HTTP之请求消息Request" class="headerlink" title="HTTP之请求消息Request"></a>HTTP之请求消息Request</h3><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</p>
<p>请求行（request line）、<strong>请求头部（header</strong>）、空行和请求数据四个部分组成。</p>
<p><img src="request.png" alt="request.png"></p>
<p>这里难理解的事请求头中各个字段的用法.</p>
<p>所有的头部信息<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers" target="_blank" rel="noopener">HTTP Headers</a></p>
<p>列一些常见的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>消息头</th>
<th>描述</th>
<th>更多信息</th>
<th>标准</th>
</tr>
</thead>
<tbody>
<tr>
<td>date</td>
<td>报文创建的日期和时间</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Date" target="_blank" rel="noopener">date</a></td>
<td>RFC 7231</td>
</tr>
<tr>
<td>cache-control</td>
<td>在http 请求和响应中通过指定指令来实现缓存机制</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">cache-control</a></td>
<td></td>
</tr>
<tr>
<td>Connection</td>
<td>决定当前的事务完成后，是否会关闭网络连接</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection" target="_blank" rel="noopener">Connection</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="HTTP之响应消息Response"><a href="#HTTP之响应消息Response" class="headerlink" title="HTTP之响应消息Response"></a>HTTP之响应消息Response</h3><p>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</p>
<p>HTTP响应也由四个部分组成，分别是：<strong>状态行、消息报头</strong>、空行和响应正文。</p>
<p><img src="response.png" alt="response.png"></p>
<h2 id="按http头部分"><a href="#按http头部分" class="headerlink" title="按http头部分"></a>按http头部分</h2><p>HTTP 首部表示在HTTP请求或响应中的用来传递附加信息的字段，修改所传递的消息（或者消息主体）的语义，或者使其更加精确。<strong>消息首部不区分大小写</strong>，开始于一行的开头，后面紧跟着一个’:’和与之相关的值。字段值在一个换行符（CR）前或者整个消息的末尾结束。</p>
<p><strong>自定专用消息头</strong>可通过<code>&#39;X-&#39;</code> 前缀来添加；但是这种用法被IETF在2012年6月发布的 RFC5548 中<strong>明确弃用</strong>，原因是其会在非标准字段成为标准时造成不便；其他的消息头在 IANA 注册表 中列出, 其原始内容在 RFC 4229 中定义。 此外，IANA 还维护着被提议的新HTTP 消息头注册表.</p>
<p>按照惯例，可以把<strong>消息首部分为几类</strong>，尽管这种划分不存在于任何一份规范文档中：</p>
<ul>
<li><code>General header</code>：可以应用于请求和响应中，但是与在消息主体中的数据无关。</li>
<li><code>Request header</code>：含有与所要获取的资源或者客户端自身相关的附加信息。</li>
<li><code>Response header</code>：含有与响应相关的附加信息，比如它的位置或者与服务器相关的信息（名称、版本号等）。</li>
<li><code>Entity header</code>: 含有与消息主体相关的附加信息，比如长度或者MIME类型。</li>
</ul>
<h3 id="General-header"><a href="#General-header" class="headerlink" title="General header"></a>General header</h3><p>通用首部指的是<strong>可以应用于请求和响应中，但是不能应用于消息内容自身</strong>的 HTTP header 。 取决于应用的上下文环境，<code>通用首部可以是response</code> 或者 <code>request headers</code>。但是不可以是 entity headers。</p>
<p>最常见的通用首部包括： <code>Date</code>, <code>Cache-Control</code> or <code>Connection</code>.</p>
<h3 id="Request-header"><a href="#Request-header" class="headerlink" title="Request header"></a>Request header</h3><p>请求头可以被定义为：被用于http请求中并且和请求主体无关的那一类HTTP header。某些请求头如<code>Accept</code>, <code>Accept-*</code>,  <code>If-*</code>允许执行条件请求。某些请求头如：<code>Cookie</code>, <code>User-Agent</code> 和<code>Referer</code>描述了请求本身以确保服务端能返回正确的响应。</p>
<p><strong>并非所有出现在请求中的http首部都属于请求头</strong>，例如在 POST请求中经常出现的<code>Content-Length</code>实际上是一个代表请求主体大小的<code>entity header</code>，虽然你也可以把它叫做请求头。</p>
<p>此外，CORS定义了一个叫做 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AE%80%E5%8D%95%E5%A4%B4%E9%83%A8" target="_blank" rel="noopener">simple headers</a>的集合，它是请求头集合的一个子集。如果某次请求是只包含simple headers的话，则被认为是简单请求，不会触发请求预检（preflight）。</p>
<h3 id="Response-header"><a href="#Response-header" class="headerlink" title="Response header"></a>Response header</h3><p>响应头 可以定义为：被用于http响应中并且和响应消息主体无关的那一类 HTTP header。像<code>Age</code>, <code>Location</code> 和 <code>Server</code>都属于响应头，他们被用于描述响应。</p>
<p><strong>并非所有出现在响应中的http header都属于响应头</strong>，例如<code>Content-Length</code>就是一个代表响应体消息大小的entity header，虽然你也可以把它叫做响应头。</p>
<p>下面展示了一个 GET请求的响应头。需要注意的是，严格来说<code>Content-Encoding</code>和<code>Content-Type</code>都是属于entity headers。</p>
<h3 id="Entity-header"><a href="#Entity-header" class="headerlink" title="Entity header"></a>Entity header</h3><p>实体报头HTTP header用来描述消息体内容。<strong>实体报头既可用于请求也可用于响应中</strong>。如<code>Content-Length</code>，<code>Content-Language</code>，<code>Content-Encoding</code>之类的报头都是实体报头。</p>
<p>尽管实体报头既非请求或响应报头，（由于它经常出现在请求头或响应头中）它们通常包含于此类概念中。</p>
<p>在下面例子中，<code>Content-Length</code>是一个实体报头，而<code>Host</code>和<code>User-Agent</code>是request headers（请求报头）</p>
<h2 id="按处理方式分"><a href="#按处理方式分" class="headerlink" title="按处理方式分"></a>按处理方式分</h2><p>消息头也可以根据代理对其的处理方式分为：</p>
<h3 id="端到端消息头"><a href="#端到端消息头" class="headerlink" title="端到端消息头"></a>端到端消息头</h3><p>这类消息头必须被传输到<strong>最终的消息接收者</strong>，也即，请求的服务器或响应的客户端。<strong>中间的代理服务器必须转发未经修改的端到端消息头，并且必须缓存它们</strong>。</p>
<h3 id="逐跳消息头"><a href="#逐跳消息头" class="headerlink" title="逐跳消息头"></a>逐跳消息头</h3><p>这类消息头仅对<strong>单次传输连接有意义</strong>，不能通过代理或缓存进行重新转发。这些消息头包括 <code>Connection</code>, <code>Keep-Alive</code>, <code>Proxy-Authenticate</code>, <code>Proxy-Authorization</code>, <code>TE</code>, <code>Trailer</code>, <code>Transfer-Encoding</code> 及 <code>Upgrade</code>。注意，只能使用 <code>Connection</code> 来设置逐跳一般头。</p>
<h2 id="按使用类别"><a href="#按使用类别" class="headerlink" title="按使用类别"></a>按使用类别</h2><h3 id="AuthenticationSection"><a href="#AuthenticationSection" class="headerlink" title="AuthenticationSection"></a>AuthenticationSection</h3><ul>
<li>WWW-Authenticate: Defines the <strong>authentication method</strong> that should be used to gain access to a resource.</li>
<li>Authorization: Contains the <strong>credentials</strong> to authenticate a user agent with a server.</li>
<li>Proxy-Authenticate: Defines the <strong>authentication method</strong> that should be used to gain access to a resource behind <strong>a Proxy server</strong>.</li>
<li>Proxy-Authorization: Contains the <strong>credentials</strong> to authenticate a user agent with <strong>a proxy server</strong>.</li>
</ul>
<h3 id="CachingSection"><a href="#CachingSection" class="headerlink" title="CachingSection"></a>CachingSection</h3><ul>
<li>Age: The time <strong>in seconds</strong> the object has been in a proxy cache.</li>
<li>Cache-Control: Specifies directives for <strong>caching mechanisms</strong> in both requests and responses.</li>
<li>Clear-Site-Data: <strong>Clears browsing data</strong> (e.g. cookies, storage, cache) associated with the requesting website.</li>
<li>Expires: The <strong>date/time</strong> after which the response is considered stale.</li>
<li>Pragma: Implementation-specific header that may have various effects anywhere along the request-response chain. Used for backwards compatibility with <strong>HTTP/1.0 caches</strong> where the <strong>Cache-Control</strong> header is <strong>not yet present</strong>.</li>
<li>Warning: A general warning field containing information about possible problems.</li>
</ul>
<h3 id="ConditionalsSection"><a href="#ConditionalsSection" class="headerlink" title="ConditionalsSection"></a>ConditionalsSection</h3><ul>
<li>Last-Modified: It is a validator, <strong>the last modification date</strong> of the resource, used to compare several versions of the same resource. It is <strong>less accurate than ETag</strong>, but easier to calculate in some environments. Conditional requests using <code>If-Modified-Since</code> and <code>If-Unmodified-Since</code> use this value to change the behavior of the <strong>request</strong>.</li>
<li>ETag: It is a validator, <strong>a unique string identifying the version</strong> of the resource. Conditional requests using <code>If-Match</code> and <code>If-None-Match</code> use this value to change the behavior of the <strong>request</strong>.</li>
<li>If-Match: Makes the <strong>request</strong> conditional and applies the method only if the stored resource <strong>matches</strong> one of the given <code>ETags</code>.</li>
<li>If-None-Match: Makes the <strong>request</strong> conditional and applies the method only if the stored resource <strong>doesn’t match</strong> any of the given <code>ETags</code>. This is <strong>used to update caches</strong> (for safe requests), or <strong>to prevent to upload</strong> a new resource when one is already existing.</li>
<li>If-Modified-Since: Makes the <strong>request</strong> conditional and expects the entity to be transmitted only if it has been modified after the given date. This is used to transmit data only when the cache is out of date.</li>
<li>If-Unmodified-Since: Makes the <strong>request</strong> conditional and expects the entity to be transmitted only if it has not been modified after the given date. This is used to ensure the coherence of a new fragment of a specific range with previous ones, or to implement an optimistic concurrency control system when modifying existing documents.</li>
<li>Vary: Determines how to match future <strong>request</strong> headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</li>
</ul>
<h3 id="Connection-managementSection"><a href="#Connection-managementSection" class="headerlink" title="Connection managementSection"></a>Connection managementSection</h3><ul>
<li>Connection: Controls whether the network connection stays open after the current transaction finishes.</li>
<li>Keep-Alive: Controls how long a persistent connection should stay open.</li>
</ul>
<h3 id="Content-negotiationSection"><a href="#Content-negotiationSection" class="headerlink" title="Content negotiationSection"></a>Content negotiationSection</h3><ul>
<li>Accept: Informs the server about the types of data that <strong>can be sent back</strong>. It is <code>MIME-type</code>.</li>
<li>Accept-Charset: Informs the server about which <strong>character set</strong> the client is able to understand.</li>
<li>Accept-Encoding: Informs the server about the <strong>encoding algorithm</strong>, usually a compression algorithm, that can be used on the resource sent back.</li>
<li>Accept-Language: Informs the server about the <strong>language</strong> the server is expected to send back. This is a hint and is not necessarily under the full control of the user: the server should always pay attention not to override an explicit user choice (like selecting a language in a drop down list).</li>
</ul>
<h3 id="ControlsSection"><a href="#ControlsSection" class="headerlink" title="ControlsSection"></a>ControlsSection</h3><ul>
<li>Expect: Indicates expectations that need to be fulfilled by the server in order to properly handle the request.</li>
</ul>
<h3 id="CookiesSection"><a href="#CookiesSection" class="headerlink" title="CookiesSection"></a>CookiesSection</h3><ul>
<li>Cookie: Contains stored HTTP cookies previously sent by the server with the <code>Set-Cookie</code> header.</li>
<li>Set-Cookie: Send cookies from the server to the user agent.</li>
</ul>
<h3 id="CORSSection"><a href="#CORSSection" class="headerlink" title="CORSSection"></a>CORSSection</h3><p>Learn more about CORS <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank" rel="noopener">here</a>.</p>
<ul>
<li>Access-Control-Allow-Origin: Indicates whether the response can be shared.</li>
<li>Access-Control-Allow-Credentials: Indicates whether the response to the request can be exposed when the credentials flag is true.</li>
<li>Access-Control-Allow-Headers: Used in response to a preflight request to indicate which HTTP headers can be used when making the actual request.</li>
<li>Access-Control-Allow-Methods: Specifies the method or methods allowed when accessing the resource in response to a preflight request.</li>
<li>Access-Control-Expose-Headers: Indicates which headers can be exposed as part of the response by listing their names.</li>
<li>Access-Control-Max-Age: Indicates how long the results of a preflight request can be cached.</li>
<li>Access-Control-Request-Headers: Used when issuing a preflight request to let the server know which HTTP headers will be used when the actual request is made.</li>
<li>Access-Control-Request-Method: Used when issuing a preflight request to let the server know which HTTP method will be used when the actual request is made.</li>
<li>Origin: Indicates where a fetch originates from.</li>
<li>Timing-Allow-Origin: Specifies origins that are allowed to see values of attributes retrieved via features of the Resource Timing API, which would otherwise be reported as zero due to cross-origin restrictions.</li>
</ul>
<h2 id="Do-Not-TrackSection"><a href="#Do-Not-TrackSection" class="headerlink" title="Do Not TrackSection"></a>Do Not TrackSection</h2><ul>
<li>DNT: Used for expressing the user’s tracking preference.</li>
<li>Tk: Indicates the tracking status that applied to the corresponding request.</li>
</ul>
<h3 id="DownloadsSection"><a href="#DownloadsSection" class="headerlink" title="DownloadsSection"></a>DownloadsSection</h3><ul>
<li>Content-Disposition: Is a response header if the resource transmitted should be displayed inline (default behavior when the header is not present), or it should be handled like a download and the browser should present a ‘Save As’ window.</li>
</ul>
<h3 id="Message-body-informationSection"><a href="#Message-body-informationSection" class="headerlink" title="Message body informationSection"></a>Message body informationSection</h3><ul>
<li>Content-Length: Indicates the size of the entity-body, in decimal number of octets, sent to the recipient.</li>
<li>Content-Type: Indicates the media type of the resource.</li>
<li>Content-Encoding: Used to specify the compression algorithm.</li>
<li>Content-Language: Describes the language(s) intended for the audience, so that it allows a user to differentiate according to the users’ own preferred language.</li>
<li>Content-Location: Indicates an alternate location for the returned data.</li>
</ul>
<h3 id="RedirectsSection"><a href="#RedirectsSection" class="headerlink" title="RedirectsSection"></a>RedirectsSection</h3><ul>
<li>Location: Indicates the URL to redirect a page to.</li>
</ul>
<h3 id="Request-contextSection"><a href="#Request-contextSection" class="headerlink" title="Request contextSection"></a>Request contextSection</h3><ul>
<li>From: Contains an Internet email address for a human user who controls the requesting user agent.</li>
<li>Host: Specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening.</li>
<li>Referer: The address of the previous web page from which a link to the currently requested page was followed.</li>
<li>Referrer-Policy: Governs which referrer information sent in the Referer header should be included with requests made.</li>
<li>User-Agent: Contains a characteristic string that allows the network protocol peers to identify the application type, operating system, software vendor or software version of the requesting software user agent. See also the Firefox user agent string reference.</li>
</ul>
<h3 id="Response-contextSection"><a href="#Response-contextSection" class="headerlink" title="Response contextSection"></a>Response contextSection</h3><ul>
<li>Allow: Lists the set of HTTP request methods support by a resource.</li>
<li>Server: Contains information about the software used by the origin server to handle the request.</li>
</ul>
<h3 id="Range-requestsSection"><a href="#Range-requestsSection" class="headerlink" title="Range requestsSection"></a>Range requestsSection</h3><ul>
<li>Accept-Ranges: Indicates if the server supports range requests, and if so in which unit the range can be expressed.</li>
<li>Range: Indicates the part of a document that the server should return.</li>
<li>If-Range: Creates a conditional range request that is only fulfilled if the given etag or date matches the remote resource. Used to prevent downloading two ranges from incompatible version of the resource.</li>
<li>Content-Range: Indicates where in a full body message a partial message belongs.</li>
</ul>
<h2 id="HTTP1-0-rfc1945"><a href="#HTTP1-0-rfc1945" class="headerlink" title="HTTP1.0 rfc1945"></a>HTTP1.0 <a href="https://tools.ietf.org/html/rfc1945" target="_blank" rel="noopener">rfc1945</a></h2><h3 id="方法3种-GET-HEAD-POST"><a href="#方法3种-GET-HEAD-POST" class="headerlink" title="方法3种 GET, HEAD, POST"></a>方法3种 GET, HEAD, POST</h3><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>GET方法意味着检索由Request-URI标识的任何信息（以实体的形式）。 如果Request-URI引用数据生成过程，则生成的数据应作为响应中的实体而不是过程的源文本返回，除非该文本恰好是过程的输出。 如果请求消息包括<code>If-Modified-Since</code>头字段，则GET方法的语义变为“条件GET”。 条件GET方法请求<strong>仅在</strong>自<code>If-Modified-Since</code>标头给出的<strong>日期之后修改标识的资源时才传输</strong>，如第10.9节所述。 条件GET方法旨在通过允许刷新缓存实体而不需要多个请求或传输不必要的数据来减少网络使用。</p>
<h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>此方法通常用于测试超文本链接的有效性，可访问性和最近的修改。 没有类似于条件GET的“条件HEAD”请求。 如果HEAD请求包含<code>If-Modified-Since</code>标头字段，则应<strong>忽略</strong>该字段。</p>
<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>所有HTTP / 1.0 POST请求都需要有效的<code>Content-Length</code>。 一个HTTP / 1.0服务器应该无法确定请求消息内容的长度时应该响应400（错误请求）消息。</p>
<p>应用程序不能缓存对POST请求的响应，因为应用程序无法知道服务器将在以后的某个请求中返回等效响应。</p>
<h2 id="1-0-目录"><a href="#1-0-目录" class="headerlink" title="1.0 目录"></a>1.0 目录</h2><ol>
<li>Introduction ……………………………………….  4<br>1.1  Purpose ……………………………………….  4       Uniform Resource Identifier (URI)<br>1.2  Terminology ……………………………………  4       666<br>1.3  Overall Operation ………………………………  6       6666<br>1.4  HTTP and MIME ………………………………….  8</li>
<li>Notational Conventions and Generic Grammar …………….  8<br>2.1  Augmented BNF ………………………………….  8<br>2.2  Basic Rules …………………………………… 10</li>
<li>Protocol Parameters ………………………………… 12<br>3.1  HTTP Version ………………………………….. 12<br>3.2  Uniform Resource Identifiers ……………………. 14<pre><code> 3.2.1  General Syntax ................................ 14
 3.2.2  http URL ...................................... 15
</code></pre>3.3  Date/Time Formats ……………………………… 15<br>3.4  Character Sets ………………………………… 17<br>3.5  Content Codings ……………………………….. 18<br>3.6  Media Types …………………………………… 19<pre><code> 3.6.1  Canonicalization and Text Defaults ............ 19
 3.6.2  Multipart Types ............................... 20
</code></pre>3.7  Product Tokens ………………………………… 20</li>
<li>HTTP Message ………………………………………. 21<br>4.1  Message Types …………………………………. 21<br>4.2  Message Headers ……………………………….. 22<br>4.3  General Header Fields ………………………….. 23</li>
<li>Request …………………………………………… 23<br>5.1  Request-Line ………………………………….. 23<pre><code> 5.1.1  Method ........................................ 24
 5.1.2  Request-URI ................................... 24
</code></pre>5.2  Request Header Fields ………………………….. 25</li>
<li>Response ………………………………………….. 25<br>6.1  Status-Line …………………………………… 26<pre><code> 6.1.1  Status Code and Reason Phrase ................. 26
</code></pre>6.2  Response Header Fields …………………………. 28</li>
<li>Entity ……………………………………………. 28<br>7.1  Entity Header Fields …………………………… 29<br>7.2  Entity Body …………………………………… 29<pre><code> 7.2.1  Type .......................................... 29
 7.2.2  Length ........................................ 30
</code></pre></li>
<li>Method Definitions …………………………………. 30<br>8.1  GET ………………………………………….. 31<br>8.2  HEAD …………………………………………. 31<br>8.3  POST …………………………………………. 31</li>
<li>Status Code Definitions …………………………….. 32<br>9.1  Informational 1xx ……………………………… 32<br>9.2  Successful 2xx ………………………………… 32<br>9.3  Redirection 3xx ……………………………….. 34<br>9.4  Client Error 4xx ………………………………. 35<br>9.5  Server Error 5xx ………………………………. 37</li>
<li>Header Field Definitions ……………………………. 37<br>10.1  Allow ……………………………………….. 38<br>10.2  Authorization ………………………………… 38<br>10.3  Content-Encoding ……………………………… 39<br>10.4  Content-Length ……………………………….. 39<br>10.5  Content-Type …………………………………. 40<br>10.6  Date ………………………………………… 40<br>10.7  Expires ……………………………………… 41<br>10.8  From ………………………………………… 42<br>10.9  If-Modified-Since …………………………….. 42<br>10.10 Last-Modified ………………………………… 43<br>10.11 Location …………………………………….. 44<br>10.12 Pragma ………………………………………. 44<br>10.13 Referer ……………………………………… 44<br>10.14 Server ………………………………………. 45<br>10.15 User-Agent …………………………………… 46<br>10.16 WWW-Authenticate ……………………………… 46</li>
<li>Access Authentication ………………………………. 47<br>11.1  Basic Authentication Scheme ……………………. 48</li>
<li>Security Considerations …………………………….. 49<br>12.1  Authentication of Clients ……………………… 49<br>12.2  Safe Methods …………………………………. 49<br>12.3  Abuse of Server Log Information ………………… 50<br>12.4  Transfer of Sensitive Information ………………. 50<br>12.5  Attacks Based On File and Path Names ……………. 51</li>
<li>Acknowledgments </li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000018668190" target="_blank" rel="noopener">全面分析前端的网络请求方式</a><br><a href="https://juejin.im/post/58ddb636ac502e0063992865" target="_blank" rel="noopener">HTTP最强资料大全 66</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers" target="_blank" rel="noopener">HTTP Headers MDN</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/30/vim配置/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/30/vim配置/" itemprop="url">vim配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-30T16:23:59+08:00">2019-03-30</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/后端教程/" itemprop="url" rel="index"><span itemprop="name">后端教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h1><p>主要讲下<code>~/.vimrc</code>的配置, 然后还有一些插件的使用</p>
<p>大致划分的话，我们通过 vimrc 告诉 vim 如下几类信息：</p>
<ul>
<li>插件</li>
<li>界面设置</li>
<li>操作定义</li>
</ul>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>三本基础的书, 按阶段看</p>
<ul>
<li>vimtutor.</li>
<li>Pratical Vim</li>
<li>Learn Vimscript the Hard Way</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>缓冲区的<br><a href="https://harttle.land/2015/11/17/vim-buffer.html" target="_blank" rel="noopener">Vim 多文件编辑：缓冲区</a></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">c</span>+i&gt;</span><br><span class="line">&lt;<span class="keyword">c</span>+<span class="keyword">o</span>&gt;</span><br><span class="line"></span><br><span class="line">:<span class="keyword">ls</span></span><br><span class="line">:<span class="keyword">bn</span> :<span class="keyword">bp</span></span><br><span class="line">:b123</span><br></pre></td></tr></table></figure>
<h2 id="操作定义"><a href="#操作定义" class="headerlink" title="操作定义"></a>操作定义</h2><p><a href="https://vimzijun.net/2016/07/16/vim-mode/#fn:2" target="_blank" rel="noopener">vim 入坑指南（二）— vim 的模式</a></p>
<p>公式一：[数字] + operator + motion<br>公式二：operator + [数字] + operator (前后均为同一个 operator）</p>
<h3 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h3><p>删除键没用, 删不掉上一行, 用<code>set backspace=2</code><br><a href="https://www.smslit.top/2016/11/27/vim-backspace-invalid/" target="_blank" rel="noopener">vim中delete（backspace）键不能向左删除</a></p>
<p>对于在插入模式下按方向键结果出来OAOBOCOD这种, 设置了<code>set nocp</code>即<code>set nocompatible</code>情况下还是这种效果的, 因为我用了<code>inoremap &lt;esc&gt; &lt;nop&gt;</code><br><a href="https://github.com/garybernhardt/selecta/issues/76#issuecomment-72739612" target="_blank" rel="noopener">Arrow keys type OA, OB, OC, and OD</a><br>当然还有更厉害的<code>ESC O D</code></p>
<h2 id="界面设置"><a href="#界面设置" class="headerlink" title="界面设置"></a>界面设置</h2><p>vim自带有一些基本的色彩主题，一般在<code>/usr/share/vim/vim74/colors/</code>中</p>
<p>然后你可以下载使用, 一般放在在<code>~/.vim/colors</code>,然后在<code>~/.vimrc</code>中设置<code>colorscheme xxx</code></p>
<p><a href="http://vimcolors.com/?utf8=%E2%9C%93&amp;bg=dark&amp;order=**newest**" target="_blank" rel="noopener">参考：Vim Colors - Online Preview</a><br><a href="https://www.vim.org/scripts/script_search_results.php?keywords=&amp;script_type=color+scheme&amp;order_by=creation_date&amp;direction=descending&amp;search=search" target="_blank" rel="noopener">参考：vim官方收集的各种主题包：Vim.org色彩主题集</a></p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>流行的有4种吧, Vundle, NeoBundle, VimPlug, Pathogen</p>
<p>我暂时用<code>vim-plug</code></p>
<p>基本上看建议是<a href="https://www.zhihu.com/question/24294358/answer/27362814" target="_blank" rel="noopener">vim有哪些插件管理程序？都有些什么特点？ - LiTuX的回答 - 知乎</a></p>
<p>基本使用方式<a href="https://linux.cn/article-9751-1.html" target="_blank" rel="noopener">Vim-plug：极简 Vim 插件管理器</a>或者<a href="https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/" target="_blank" rel="noopener">VIM 插件管理工具 vim-plug 简明教程</a></p>
<p>在这个网站上找到一个插件后使用<a href="https://vimawesome.com/plugin/fugitive-vim" target="_blank" rel="noopener">fugitive.vim</a></p>
<p>基本上就是这么方便</p>
<h3 id="再讲下使用吧"><a href="#再讲下使用吧" class="headerlink" title="再讲下使用吧"></a>再讲下使用吧</h3><p>安装后在<code>~/.vimrc</code>中配置</p>
<p>记住，当你在配置文件中声明插件时，列表应该以 <code>call plug#begin(PLUGIN_DIRECTORY)</code> 开始，并以 <code>plug#end()</code> 结束。 所有的在<a href="https://vimawesome.com/" target="_blank" rel="noopener">VimAwesome</a>上找到的插件使用的时候都要放在这个里面</p>
<p>下面是一个普遍的例子</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">'~/.vim/plugged'</span>)</span><br><span class="line">Plug <span class="string">'scrooloose/nerdtree'</span>, &#123; <span class="string">'on'</span>:  <span class="string">'NERDTreeToggle'</span> &#125;</span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure>
<p>增加后用<code>:source ~/.vimrc</code>来, 或者不退出, 用<code>:source %</code></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" 看插件状态</span></span><br><span class="line">:PlugStatus</span><br><span class="line"></span><br><span class="line"><span class="comment">" 按配置安装插件, 安装时也会有插件状态提示信息</span></span><br><span class="line">:PlugInstall</span><br><span class="line"></span><br><span class="line"><span class="comment">" 更新插件</span></span><br><span class="line">:PlugUpdate</span><br><span class="line"></span><br><span class="line"><span class="comment">" 查看不同, 这货没啥用</span></span><br><span class="line">:PlugDiff</span><br><span class="line"></span><br><span class="line"><span class="comment">" 删除插件是记得不仅要在vimrc中删了, 也要运行命令, 防止在~/.vim/plugged/中还有</span></span><br><span class="line">:PlugClean</span><br><span class="line"></span><br><span class="line"><span class="comment">" 升级VimPlug</span></span><br><span class="line">:PlugUpgrade</span><br></pre></td></tr></table></figure>
<h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><p>vim-cheat40</p>
<h2 id="emacs"><a href="#emacs" class="headerlink" title="emacs"></a>emacs</h2><p>两者可以共同使用<br><a href="https://www.gowhich.com/blog/617" target="_blank" rel="noopener">mac 终端光标的快捷键操作</a><br><a href="https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org#%E8%8F%9C%E9%B8%9F%E6%80%8E%E4%B9%88%E5%BC%80%E5%A7%8B" target="_blank" rel="noopener">一年成为 Emacs 高手 (像神一样使用编辑器)</a></p>
<h3 id="终端中的快捷键操作"><a href="#终端中的快捷键操作" class="headerlink" title="终端中的快捷键操作"></a>终端中的快捷键操作</h3><p>常用的快捷键：<br>Ctrl + d        删除一个字符，相当于通常的Delete键（命令行若无所有字符，则相当于exit；处理多行标准输入时也表示eof）<br>Ctrl + h        退格删除一个字符，相当于通常的Backspace键<br>Ctrl + u        删除光标之前到行首的字符<br>Ctrl + k        删除光标之前到行尾的字符<br>Ctrl + c        取消当前行输入的命令，相当于Ctrl + Break<br>Ctrl + a        光标移动到行首（Ahead of line），相当于通常的Home键<br>Ctrl + e        光标移动到行尾（End of line）<br>Ctrl + f        光标向前(Forward)移动一个字符位置<br>Ctrl + b        光标往回(Backward)移动一个字符位置<br>Ctrl + l        清屏，相当于执行clear命令<br>Ctrl + p        调出命令历史中的前一条（Previous）命令，相当于通常的上箭头<br>Ctrl + n        调出命令历史中的下一条（Next）命令，相当于通常的上箭头<br>Ctrl + r        显示：号提示，根据用户输入查找相关历史命令（reverse-i-search）</p>
<p>次常用快捷键：<br>Alt + f         光标向前（Forward）移动到下一个单词<br>Alt + b         光标往回（Backward）移动到前一个单词<br>Ctrl + w        删除从光标位置前到当前所处单词（Word）的开头<br>Alt + d         删除从光标位置到当前所处单词的末尾<br>Ctrl + y        粘贴最后一次被删除的单词</p>
<p>移动就是f,b, a,e<br>删除u, k, w, d, d, h<br>粘贴y<br>历史r</p>
<blockquote>
<p>关闭mac上按option输出字符<a href="https://blog.csdn.net/gubenpeiyuan/article/details/52877603" target="_blank" rel="noopener">MacOS中如何关闭或禁用Option（Alt）+ 键盘输出特殊字符(解决oh my zsh 使option f b 失效)</a> 就是改下items2的key为+Esc</p>
</blockquote>
<h3 id="开启emacs入门"><a href="#开启emacs入门" class="headerlink" title="开启emacs入门"></a>开启emacs入门</h3><p>先安装再配置<a href="https://www.gnu.org/software/emacs/download.html#macos" target="_blank" rel="noopener">GNU Emacs Download &amp; installation</a></p>
<p>然而brew没有<code>--with-cocoa</code>的参数, 当你用<code>brew install emacs</code>后, 用<code>emacs --version</code>却看到版本不对诶</p>
<p>因为mac自带emacs在<code>/usr/bin/emacs</code><br>删不掉这个自带的emacs<br><a href="https://superuser.com/questions/1018810/delete-usr-bin-emacs-operation-not-permitted" target="_blank" rel="noopener">Delete /usr/bin/emacs - Operation not permitted</a><br><a href="https://apple.stackexchange.com/a/108753" target="_blank" rel="noopener">Who installed this Emacs?</a></p>
<p>在使用brew安装完之后 <a href="https://www.kancloud.cn/chandler/mac_os/480609" target="_blank" rel="noopener">更改系统自带旧版本</a></p>
<p>在<code>~/.zshrc</code>中添加<code>alias emacs=&quot;/usr/local/Cellar/emacs/26.1_1/bin/emacs-26.1&quot;</code></p>
<p>看教程学下基本的知识<a href="https://github.com/redguardtoo/emacs.d#checklist" target="_blank" rel="noopener">Fast and robust Emacs setup.</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>操作定义<br><a href="https://www.v2ex.com/amp/t/432528/1" target="_blank" rel="noopener">从零学习 vim 一个多月, 感觉最有用的三个教程</a><br><a href="http://learnvimscriptthehardway.stevelosh.com/" target="_blank" rel="noopener">Learn Vimscript the Hard Way</a><br><a href="http://learnvimscriptthehardway.onefloweroneworld.com/" target="_blank" rel="noopener">Learn Vimscript the Hard Way 中文版</a></p>
<p><a href="https://vimzijun.net/2016/07/16/vim-mode/#fn:2" target="_blank" rel="noopener">vim 入坑指南（二）— vim 的模式</a><br><a href="http://billsedison.github.io/2015/09/25/mac-vim-ABCD/" target="_blank" rel="noopener">mac-vim 按上下左右出现ABCD</a><br>插件<br><a href="https://vimzijun.net/2016/09/21/vim-plug/" target="_blank" rel="noopener">vim 入坑指南（五）插件 Vim-Plug</a><br><a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">Minimalist Vim Plugin Manager</a><br>界面</p>
<p>集合<br><a href="https://harttle.land/2015/11/04/vim-ide.html" target="_blank" rel="noopener">如何用Vim搭建IDE？</a><br><a href="https://zhuanlan.zhihu.com/p/30022074" target="_blank" rel="noopener">Vim - 配置IDE一般的python环境</a><br><a href="http://vim.spf13.com/" target="_blank" rel="noopener">spf13</a><br><a href="https://cloud.tencent.com/developer/article/1058322" target="_blank" rel="noopener">超级强大的vim配置（vimplus）</a><br><a href="https://github.com/solomonxie/solomonxie.github.io/issues/25" target="_blank" rel="noopener">Vim成长之路</a><br><a href="https://blog.csdn.net/ajian005/article/details/39700981" target="_blank" rel="noopener">把VIM配置成IDE开发环境</a><br><a href="https://github.com/yangyangwithgnu/use_vim_as_ide" target="_blank" rel="noopener">所需即所获：像 IDE 一样使用 vim</a><br><a href="https://github.com/amix/vimrc" target="_blank" rel="noopener">The Ultimate vimrc</a><br><a href="https://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">简明 VIM 练级攻略</a><br><a href="http://yuez.me/jiang-ni-de-vim-da-zao-cheng-qing-qiao-qiang-da-de-ide/" target="_blank" rel="noopener">将你的Vim 打造成轻巧强大的IDE</a></p>
<p>ecmas<br><a href="https://www.gowhich.com/blog/617" target="_blank" rel="noopener">mac 终端光标的快捷键操作</a><br><a href="https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org#%E8%8F%9C%E9%B8%9F%E6%80%8E%E4%B9%88%E5%BC%80%E5%A7%8B" target="_blank" rel="noopener">一年成为 Emacs 高手 (像神一样使用编辑器)</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/npm简单入门/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/15/npm简单入门/" itemprop="url">npm简单入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-15T22:50:30+08:00">2019-03-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="npm简单入门"><a href="#npm简单入门" class="headerlink" title="npm简单入门"></a>npm简单入门</h1><h2 id="总结下"><a href="#总结下" class="headerlink" title="总结下"></a>总结下</h2><h3 id="npm的命令"><a href="#npm的命令" class="headerlink" title="npm的命令"></a>npm的命令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 "npm -v" 来测试是否成功安装</span></span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下：</span></span><br><span class="line">$ sudo npm install npm -g</span><br><span class="line"></span><br><span class="line"><span class="comment">// npm 安装 Node.js 模块语法格式如下：</span></span><br><span class="line">$ npm install &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>
<p>npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有<code>-g</code>而已，比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install express         <span class="comment"># 本地安装到./node_modules</span></span><br><span class="line">npm install express -g      <span class="comment"># 全局安装到/usr/local 下或者你 node 的安装目录, nvm这种</span></span><br><span class="line"></span><br><span class="line">npm install &lt;package_name&gt; --save       <span class="comment"># 本地安装后, 把包信息加入package.json的dependencies字段</span></span><br><span class="line">npm install &lt;package_name&gt; --save-dev   <span class="comment"># 本地安装后, 把包信息加入package.json的devDependencies字段</span></span><br><span class="line"></span><br><span class="line">npm install                 <span class="comment"># 是根据package.json的dependencies和devDependencies信息, 根据不同的环境安装不同的包到./node_modules下</span></span><br></pre></td></tr></table></figure>
<p>本地安装</p>
<ol>
<li>将安装包放在 <code>./node_modules</code> 下（运行 <code>npm</code> 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。(并不会在<code>package.json</code>中填入)</li>
<li>可以通过 <code>require()</code> 来引入本地安装的包。</li>
</ol>
<p>全局安装</p>
<ol>
<li>将安装包放在 <code>/usr/local</code> 下或者你 node 的安装目录。</li>
<li>可以直接在命令行里使用。</li>
</ol>
<p>而后面加参数 <code>--save-dev</code> 和 <code>--save</code> 表示的是<code>dependencies</code>和<code>devDependencies</code>，分别对应<strong>生产环境</strong>需要的安装包和<strong>开发环境</strong>需要的安装包。</p>
<p><strong>同样在安装模块的时候，可以通过指定参数来修改<code>package.json</code>文件</strong></p>
<p>查看安装信息</p>
<p>你可以使用以下命令来查看所有全局安装的模块：</p>
<p>$ npm list -g</p>
<p>如果要查看某个模块的版本号，可以使用命令如下：</p>
<p>$ npm list grunt</p>
<p>也可以npm list</p>
<p>卸载模块, 同理分3个地方</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall express</span><br></pre></td></tr></table></figure>
<p>卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ls</span><br></pre></td></tr></table></figure>
<p>更新模块<br>我们可以使用以下命令更新模块：</p>
<p>$ npm update express<br>搜索模块<br>使用以下来搜索模块：</p>
<p>$ npm search express</p>
<p>接下来我们可以使用以下命令在 npm 资源库中注册用户（使用邮箱注册）：</p>
<p>$ npm adduser<br>接下来我们就用以下命令来发布模块：</p>
<p>$ npm publish</p>
<p>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。</p>
<p>使用<code>npm help &lt;command&gt;</code>可查看某条命令的详细帮助，例如npm help install。</p>
<p>在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。</p>
<p>使用<code>npm update &lt;package&gt;</code>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。</p>
<p>使用<code>npm update &lt;package&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</p>
<p>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</p>
<p>使用<code>npm unpublish &lt;package&gt;@&lt;version&gt;</code>可以撤销发布自己发布过的某个版本代码。</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><p>当尝试全局安装某个包得时候，你可能会收到<code>EACCES</code>错误。这说明你<strong>没有权限</strong>写入npm用于存储全局包和命令的目录。</p>
<p>你可以用下面三种方法解决此问题：</p>
<ul>
<li>修改npm默认目录的权限；</li>
<li>将npm默认目录定向到其他你具有读写权限的目录；</li>
<li>使用某个包管理器来安装node，它会为你处理好权限问题。</li>
</ul>
<p>知道有这么个就好了</p>
<p>1、找到npm的目录路径：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure>
<p>2、配置npm使用这个新目录：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix <span class="string">'~/.npm-global'</span></span><br></pre></td></tr></table></figure>
<h2 id="本地安装npm"><a href="#本地安装npm" class="headerlink" title="本地安装npm"></a>本地安装npm</h2><p>安装npm包有<strong>两种方式</strong>：本地安装或全局安装。根据你想如何使用包，你可以选择安装方式。</p>
<p>如果你想要<strong>从你自己的模块中</strong>通过使用Node.js的<code>require</code>方法来依赖某个包，那你可以<strong>本地安装</strong>这个包，这是npm安装的默认行为。<br>另外，如果你想<strong>当做命令行工具</strong>使用它，比如grunt CLI，那你应该<strong>全局安装</strong>这个包。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;package_name&gt;</span><br></pre></td></tr></table></figure>
<p>此命令将在你的当前目录创建<code>node_modules</code>目录（若还未安装任何包），并将下载此包到这个目录。</p>
<h3 id="安装的是哪个版本的包？"><a href="#安装的是哪个版本的包？" class="headerlink" title="安装的是哪个版本的包？"></a>安装的是哪个版本的包？</h3><p>如果在本地目录中<strong>没有</strong><code>package.json</code>文件，那该包的<strong>最新版本</strong>会被安装了。</p>
<p>如果有<code>package.json</code>文件，那么在<code>package.json</code>中声明的满足semver（语义化版本）规则的最新版本会被安装。</p>
<h3 id="使用已安装的包"><a href="#使用已安装的包" class="headerlink" title="使用已安装的包"></a>使用已安装的包</h3><p>一旦包被安装在<code>node_modules</code>，你就可以在你的代码中使用它了。比如，当你创建Node.js模块是，你可以引入它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> lodash = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> output = lodash.without([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(output);</span><br></pre></td></tr></table></figure>
<h2 id="5-使用package-json配置文件"><a href="#5-使用package-json配置文件" class="headerlink" title="5. 使用package.json配置文件"></a>5. 使用package.json配置文件</h2><p>管理本地安装的包的最好方法是创建一个<code>package.json</code>文件。</p>
<p><code>package.json</code>文件会给你提供很多好东西：</p>
<ul>
<li>它用<strong>作你的项目的包依赖管理文档</strong>。</li>
<li>它允许你使用<strong>语义化版本</strong>管理规则，<strong>指定</strong>项目中能使用的<strong>包的版本</strong>。</li>
<li>使你的<strong>构建版本可以重新生成</strong>，这意味着你可以更易于与其他开发者<strong>分享代码</strong>。</li>
</ul>
<h3 id="创建package-json文件"><a href="#创建package-json文件" class="headerlink" title="创建package.json文件"></a>创建package.json文件</h3><p>要创建package.json文件，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
<p>此为初始化项目命令，会在你运行此命令的文件夹根目录下创建项目配置文件：package.json。<strong>同时每行会出现一个问题</strong>，你输入答案后会出来另一个问题。这些问题最终会记录到package.json文件中。</p>
<p><strong>“—yes”标签</strong><br>扩展的命令行问答式流程不是必须的。通常你可以轻松地使用package.json文件快速配置项目。</p>
<p>你可以运行带<code>--yes</code>或<code>-y</code>标签的<code>npm init</code>命令，来生成默认的package.json文件：</p>
<p>这样<strong>name是默认的文件夹名</strong>。其他的问题都是用默认值填充的：</p>
<p>内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"testnpm"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>name：默认为目录名字，除非在git目录中，它会是git仓库的名字；</li>
<li>version：版本号，刚初始化的项目总是1.0.0；</li>
<li>description - 包的描述。</li>
<li>main：总是index.js；</li>
<li>scripts：默认创建一行空的测试脚本；</li>
<li>keywords：关键字</li>
<li>author：作者</li>
<li>contributors - 包的其他贡献者姓名。</li>
<li>license：ISC开源证书</li>
<li>dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</li>
<li>devDependencies</li>
<li>repository: will pull in info from the current directory, if present</li>
<li>bugs: will pull in info from the current directory, if present</li>
<li>homepage: 包的官网 url 。</li>
</ul>
<p>你也可以通过set命令来设置一些配置项。比如下边的这些：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="built_in">set</span> init.author.email <span class="string">"xxx@xx.com"</span></span><br><span class="line">npm <span class="built_in">set</span> init.author.name <span class="string">"example user"</span></span><br><span class="line">npm <span class="built_in">set</span> init.license <span class="string">"MIT"</span></span><br></pre></td></tr></table></figure>
<h3 id="指定依赖包"><a href="#指定依赖包" class="headerlink" title="指定依赖包"></a>指定依赖包</h3><ul>
<li>“dependencies”: these packages are required by your application in <code>production</code>  这货线上</li>
<li>“devDependencies”: these packages are only needed for <code>development</code> and <code>testing</code> 这个本地开发和测试</li>
</ul>
<h3 id="save-和-save-dev安装标记"><a href="#save-和-save-dev安装标记" class="headerlink" title="--save 和 --save-dev安装标记"></a><code>--save</code> 和 <code>--save-dev</code>安装标记</h3><p>在命令行中使用这两个标记，是添加依赖到你的package.json文件的更简单（也更酷）的方式。</p>
<p>添加package.json依赖的入口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;package_name&gt; --save</span><br></pre></td></tr></table></figure>
<p>添加package.json<strong>开发环境依赖</strong>的入口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;package_name&gt; --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="管理依赖包的版本"><a href="#管理依赖包的版本" class="headerlink" title="管理依赖包的版本"></a>管理依赖包的版本</h3><p>npm使用<strong>语义化版本</strong>管理依赖包，也就是我们常说的“SemVer”。</p>
<p>如果在项目文件夹下有package.json文件，你在此文件夹下运行命令<code>npm install</code>，npm就会<strong>检查文件中列出的依赖包</strong>，并<strong>下载所有满足语义化规则的最新版本的依赖包</strong>。</p>
<p>一开始<code>npm install &lt;package_name&gt;</code>的时候会在<code>package.json</code>中的<code>dependencies</code>或<code>devDependencies</code>中填入相关信息, 然后再本路径目录下下载包到<code>node_modules</code>中<br>直接<code>npm install</code> 会读取<code>package.json</code> 中信息, 然后下载包到<code>node_modules</code></p>
<h2 id="6、更新本地包"><a href="#6、更新本地包" class="headerlink" title="6、更新本地包"></a>6、更新本地包</h2><p>很多时候，你需要<strong>升级项目中的依赖包</strong>，以获得上游源代码的更新。</p>
<p>运在package.json同级目录下，运行<code>npm update</code>命令，来实现<strong>依赖包的更新</strong>。</p>
<p>测试：运行<code>npm outdated</code>命令，包都是最新版的话应该不会有什么结果。</p>
<h2 id="7、卸载本地包"><a href="#7、卸载本地包" class="headerlink" title="7、卸载本地包"></a>7、卸载本地包</h2><p>通过<code>npm uninstall &lt;package&gt;</code>命令，你可以将<code>node_modules</code>目录下的某个依赖包移除：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall lodash</span><br></pre></td></tr></table></figure>
<p>要从<code>package.json</code>文件的依赖列表中移除，你需要使用<code>--save</code>标签：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall --save lodash</span><br></pre></td></tr></table></figure>
<p>注意：如果你是以开发依赖包（<code>devDependency</code>）的方式安装的（即安装时待<code>--dave -dev</code>标签），那用—save将无法从package.json中移除，你必须用<code>--save -dev</code>标签。</p>
<blockquote>
<p>有3种方式哦</p>
</blockquote>
<h2 id="8、全局安装npm包"><a href="#8、全局安装npm包" class="headerlink" title="8、全局安装npm包"></a>8、全局安装npm包</h2><p>安装npm包有两种方法：<strong>本地安装和全局安装</strong>。如何选择安装方式取决于你想如何使用这些依赖包。</p>
<p>译注：所谓“本地安装”，就是在项目文件夹中安装npm依赖包，以便此项目调用；“全局安装”相反，安装之后可以供所有项目直接调用，可以免去重复安装的步骤和空间。</p>
<p>如果你期望将包当作命令行工具来使用，比如grunt命令行工具，那你就需要全局安装。<br>相反地，如果你期望在你自己的模块中引入依赖包，比如用Node的 require 方法，那么你需要将它本地安装。</p>
<p>要全局下载依赖包的话，添加<code>-g</code>标识符就好了哦，<code>npm install -g &lt;package&gt;</code>，像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g jshint</span><br></pre></td></tr></table></figure>
<p>如果出现EACCES错误，你就修复一下权限。逼不得已的时候，你也可以试试 sudo：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g jshint</span><br></pre></td></tr></table></figure>
<h2 id="9、更新全局包"><a href="#9、更新全局包" class="headerlink" title="9、更新全局包"></a>9、更新全局包</h2><p>要更新全局包的话，那<strong>就再全局安装一下</strong>：<code>npm install -g &lt;package&gt;</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g jshint</span><br></pre></td></tr></table></figure>
<p>如果想要找出哪些包需要更新，你可以使用 <code>npm outdated -g --depth=0</code> 命令帮忙。</p>
<p>译注：</p>
<p>有时候，在项目文件夹中直接 <code>npm install</code>，通过<code>package.json</code>的依赖声明中<strong>重新安装所有包</strong>，给人感觉挺Low B的。这个时候就需要找出哪些包已经过时了，需要更新。<br>而且，有时候<strong>有些依赖包没被声明</strong>在package.json文件中，那<code>npm install</code>就对他不起作用了。<br><code>--depth=0</code> 的意思是依赖包的深度，<strong>只检查顶层依赖包</strong>。(因为存在一个包依赖另一个包, 比如<code>tslint</code>)<br><strong>更新所有全局包</strong>，你可以使用 <code>npm update -g</code>。（译注：这可能会很慢，因为你装了太多依赖了）<br>注意：npm版本低于2.6.1的话，此命令被建议用来更新所有过时的全局包。</p>
<h2 id="10、卸载全局包"><a href="#10、卸载全局包" class="headerlink" title="10、卸载全局包"></a>10、卸载全局包</h2><p>卸载全局包使用 <code>npm uninstall -g &lt;package&gt;</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall -g jshint</span><br></pre></td></tr></table></figure>
<h2 id="11、创建Node-js模块"><a href="#11、创建Node-js模块" class="headerlink" title="11、创建Node.js模块"></a>11、创建Node.js模块</h2><p>Node.js模块是一种可以<strong>发布</strong>到npm的包。当你创建一个新模块的时候，你将从 <code>package.json</code> 文件开始。</p>
<p>使用 <code>npm init</code> 命令创建 <code>package.json</code> 文件。命令行中将会弹出<code>package.json</code>字段中要你输入的值。两个必填字段：名称（name）和版本（version）。你可能也需要输入主文件字段（main），可以使用默认值 index.js。</p>
<p>如果你想为作者（author）字段添加信息，你可以使用以下格式（邮箱、网站都是选填的）：</p>
<p>一旦<code>package.json</code>文件创建好了，你将想要创建模块的入口文件，如果使用默认值，他将会是 <code>index.js</code>。</p>
<p>在此文件中，添加一个函数，作为 <code>exports</code> 对象的一个属性。这样，require此文件之后，这个函数在其他代码中就可以使用了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.printMsg = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"This is a message from the demo package"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<p>将你的包发布到npm<br>在你的项目外新建一个目录，然后 cd 过去<br>运行 <code>npm install &lt;package&gt;</code><br>创建一个test.js文件，require这个包，并调用此方法（函数）<br>运行 node test.js。终端将会输出：This is a message from the demo package<br>恭喜你，你的第一个npm包创建成功了。</p>
<h2 id="12、发布npm包"><a href="#12、发布npm包" class="headerlink" title="12、发布npm包"></a>12、发布npm包</h2><p>你可以发布任何包含package.json文件的目录，比如Nodejs模块。</p>
<p>创建用户<br>发布包之前，你必须创建一个npm用户账号。如果还没有，你可以用<code>npm adduser</code>创建一个。如果已经注册了，使用<code>npm login</code>命令将账号信息存储到本地客户端。</p>
<p>测试：使用<code>npm config ls</code>确认账号信息已经存储到您的客户端。访问<a href="https://npmjs.com/~" target="_blank" rel="noopener">https://npmjs.com/~</a> 以确保信息正确。</p>
<h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><p>使用<code>npm publish</code>来发布程序包。</p>
<p>注意，目录下的所有文件都将被包含进去，除非目录下有<code>.gitignore</code> 或 <code>.npmignore</code> 文件（详情请看npm-developers）将其排除。</p>
<p>同时，请确保npm上没有别的开发者提交的同名都包存在。</p>
<h3 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h3><p>当你<strong>修改了你的包文件</strong>，你可以用<code>npm version &lt;update_type&gt;</code>更新它。<br><code>update_type</code>是指语义化版本管理的发布类型的一种：补丁版本（patch）、次版本（minor）或主版本（major）。<br>此命令会更改package.json中的<strong>版本号</strong>。注意哦，如果你<strong>有此包的git仓库</strong>，那么此命令也会向git仓库添加此版本的一个标签。</p>
<p>更新版本号之后，你就可以再次 <code>npm publish</code> 了。</p>
<p>站点下的README文件是不会更新，除非你的包的新版本发布成功。所以你需要运行<code>npm version patch</code>和<code>npm publish</code>命令来修复站点下的文档。</p>
<h2 id="13、语义化版本号"><a href="#13、语义化版本号" class="headerlink" title="13、语义化版本号"></a>13、语义化版本号</h2><p>语义化版本控制是一种标准，许多项目都用它来标识新版本是何种更改。这是非常重要的，因为有时这些更改会破坏依赖这个包的代码。</p>
<h3 id="语义化版本对于发布者"><a href="#语义化版本对于发布者" class="headerlink" title="语义化版本对于发布者"></a>语义化版本对于发布者</h3><p>如果项目将要与他人分享，那它的版本应该始于1.0.0，尽管npm上有些项目不遵循此规则。<br>之后，所有更改应该按如下方法处理：</p>
<ul>
<li>Bug修复和其他小版本修改：用<code>Patch</code>版本，增加<strong>最后</strong>的版本数，如：1.0.1；</li>
<li>不会破坏已有特性的新特性：用<code>Minor</code>版本，增加<strong>中间</strong>的版本数，如：1.1.0；</li>
<li>会破坏向后兼容的更改：用<code>Majo</code>版本，增加<strong>第一个</strong>版本数，如：2.0.0.</li>
</ul>
<h3 id="语义化版本对于使用者"><a href="#语义化版本对于使用者" class="headerlink" title="语义化版本对于使用者"></a>语义化版本对于使用者</h3><p>如果你是包的使用者，你可以在package.json文件中指定你的app能接受哪种版本。</p>
<p>如果你用某包的1.0.4版本开始开发的，你可以按下面方式指定版本范围：</p>
<ul>
<li>补丁版本（Patch releases）: 1.0 or 1.0.x or ~1.0.4</li>
<li>次版本（Minor releases）: 1 or 1.x or ^1.0.4</li>
<li>主版本（Major releases）: * or x</li>
</ul>
<h2 id="14、使用局部包-私有包"><a href="#14、使用局部包-私有包" class="headerlink" title="14、使用局部包, 私有包"></a>14、使用局部包, 私有包</h2><p>对npm的包而言, scope就像一个命名空间, 如果一个包的名字前带有<code>@</code>, 那么这就是一个<code>scoped package</code>, scopes是在<code>@</code>和<code>/</code>之间的所有东西</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@scope/project-name</span><br></pre></td></tr></table></figure>
<p>每一个npm 用户都有他们自己的scope</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@username/project-name</span><br></pre></td></tr></table></figure>
<h3 id="更新npm并登录"><a href="#更新npm并登录" class="headerlink" title="更新npm并登录"></a>更新npm并登录</h3><p>你的npm包版本要大于2.7.0的, 然后第一个使用scoped modules要先登录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g npm</span><br><span class="line">npm login</span><br></pre></td></tr></table></figure>
<h3 id="初始化局部包"><a href="#初始化局部包" class="headerlink" title="初始化局部包"></a>初始化局部包</h3><p>只需要如下在一个包名前带上你的名字就好</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"@username/project-name"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你用<code>npm init</code>来初始化, 可以带一个<code>--scope</code>来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init --scope=username</span><br></pre></td></tr></table></figure>
<p>如果你想一直用同一个scope, 可以在<code>.npmrc</code>中设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> scope username</span><br></pre></td></tr></table></figure>
<h3 id="发布局部包"><a href="#发布局部包" class="headerlink" title="发布局部包"></a>发布局部包</h3><p>scoped包默认是私有的, 要发布的话, 你得付费买一个私有模块账户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish --access=public</span><br></pre></td></tr></table></figure>
<h3 id="使用局部包"><a href="#使用局部包" class="headerlink" title="使用局部包"></a>使用局部包</h3><p>一样的用法<br>In package.json:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"@username/project-name"</span>: <span class="string">"^1.0.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>On the command line:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @username/project-name --save</span><br></pre></td></tr></table></figure>
<p>In a require statement:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> projectName = <span class="built_in">require</span>(<span class="string">"@username/project-name"</span>)</span><br></pre></td></tr></table></figure>
<p>For information about using scoped private modules, visit npmjs.com/private-modules.</p>
<h2 id="15、使用标签"><a href="#15、使用标签" class="headerlink" title="15、使用标签"></a>15、使用标签</h2><p>为了更可读, 和git一样</p>
<h3 id="添加标签（tag）"><a href="#添加标签（tag）" class="headerlink" title="添加标签（tag）"></a>添加标签（tag）</h3><p>To add a tag to a specific version of your package, use <code>npm dist-tag add @ []</code>. See the CLI docs for more information.</p>
<h3 id="使用标签（tag）发布"><a href="#使用标签（tag）发布" class="headerlink" title="使用标签（tag）发布"></a>使用标签（tag）发布</h3><p>默认情况下, <code>npm publish</code> 给你的包打上 <code>latest</code> tag. 使用 <code>--tag</code> , 你可以指定当前发布的包的tag是beta</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish --tag beta</span><br></pre></td></tr></table></figure>
<h3 id="使用标签（tag）安装"><a href="#使用标签（tag）安装" class="headerlink" title="使用标签（tag）安装"></a>使用标签（tag）安装</h3><p>Like <code>npm publish</code>, <code>npm install</code> will use the <code>latest</code> tag by default.<br>To override this behavior, use <code>npm install @</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install somepkg@beta</span><br></pre></td></tr></table></figure>
<h3 id="Caveats-警告"><a href="#Caveats-警告" class="headerlink" title="Caveats 警告"></a>Caveats 警告</h3><p>Because <code>dist-tags</code> share the same namespace with <code>semver</code>, avoid using any tag names that may cause a conflict.<br>最好就是不要在打tag前加上<code>v</code>, 防止和<code>semver</code>语义化的冲突</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.kancloud.cn/shellway/npm-doc/199981" target="_blank" rel="noopener">NPM文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/k8s集群的简单安装和使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/k8s集群的简单安装和使用/" itemprop="url">k8s集群的简单安装和使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T17:55:09+08:00">2019-03-06</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/后端教程/" itemprop="url" rel="index"><span itemprop="name">后端教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="k8s集群的简单安装和使用"><a href="#k8s集群的简单安装和使用" class="headerlink" title="k8s集群的简单安装和使用"></a>k8s集群的简单安装和使用</h1><h2 id="什么是kubernetes"><a href="#什么是kubernetes" class="headerlink" title="什么是kubernetes"></a>什么是kubernetes</h2><p><a href="https://kubernetes.feisky.xyz/ji-chu-ru-men/index" target="_blank" rel="noopener">Kubernetes 是一个平台</a></p>
<p>Kubernetes 提供了很多的功能，它可以<strong>简化应用程序的工作流</strong>，加快开发速度。通常，一个成功的<strong>应用编排系统</strong>需要有较强的自动化能力，这也是为什么 Kubernetes 被设计作为构建组件和工具的生态系统平台，以便更轻松地部署、扩展和管理应用程序(Kubernetes 是一个容器编排平台)。</p>
<p><a href="https://caicloud.io/blog/5a90db21ea51874faccead25" target="_blank" rel="noopener">编排的艺术| K8S 中的容器编排和应用编排 6666</a></p>
<p>在传统的单体式架构的应用中，我们开发、测试、交付、部署等都是针对单个组件，我们很少听到编排这个概念。而在云的时代，微服务和容器大行其道，除了为我们显示出了它们在敏捷性，可移植性等方面的巨大优势以外，也为我们的交付和运维带来了新的挑战：我们将单体式的架构拆分成越来越多细小的服务，运行在各自的容器中，那么该如何解决它们之间的依赖管理，服务发现，资源管理，高可用等问题呢？</p>
<p>在容器环境中，编排通常涉及到三个方面:</p>
<ul>
<li>资源编排 - 负责资源的分配，如限制 <code>namespace</code> 的可用资源，<code>scheduler</code> 针对资源的不同调度策略；</li>
<li>工作负载编排 - 负责在资源之间共享工作负载，如 Kubernetes 通过不同的 <code>controller</code> 将 <code>Pod</code> 调度到合适的 <code>node</code> 上，并且负责管理它们的生命周期；</li>
<li>服务编排 - 负责服务发现和高可用等，如 Kubernetes 中可用通过 <code>Service</code> 来对内暴露服务，通过 <code>Ingress</code> 来对外暴露服务。</li>
</ul>
<p>在 Kubernetes 中有 5 种我们经常会用到的控制器来帮助我们进行容器编排，它们分别是 <code>Deployment</code>, <code>StatefulSet</code>, <code>DaemonSet</code>, <code>CronJob</code>, <code>Job</code>。</p>
<p>在这 5 种常见资源中</p>
<ul>
<li><code>Deployment</code> 经常被作为无状态实例控制器使用;</li>
<li><code>StatefulSet</code> 是一个有状态实例控制器;</li>
<li><code>DaemonSet</code> 可以指定在选定的 <code>Node</code> 上跑，每个 <code>Node</code> 上会跑一个副本，它有一个特点是它的 <code>Pod</code> 的调度不经过调度器，在 <code>Pod</code> 创建的时候就直接绑定 <code>NodeName</code>；</li>
<li>最后一个是<code>CronJob</code>定时任务，它是一个上级控制器，和 <code>Deployment</code> 有些类似，当一个定时任务触发的时候，它会去创建一个 <code>Job</code> ，具体的任务实际上是由 <code>Job</code> 来负责执行的。</li>
</ul>
<p>他们之间的关系如下图：</p>
<p><img src="controllers.jpeg" alt="controllers.jpeg"></p>
<p>一个简单的例子</p>
<p>我们来考虑这么一个简单的例子，一<strong>个需要使用到数据库</strong>的 <code>API</code> 服务在 Kubernetes 中应该如何表示: </p>
<p>客户端程序通过 <code>Ingress</code> 来访问到内部的 <code>API Service</code>, <code>API Service</code> 将流量导流到 <code>API Server Deployment</code> 管理的其中一个 <code>Pod</code> 中，这个 <code>Server</code> 还需要访问数据库服务，它通过 <code>DB Service</code> 来访问 <code>DataBase StatefulSet</code> 的有状态副本。由定时任务 <code>CronJob</code> 来定期备份数据库，通过 <code>DaemonSet</code> 的 <code>Logging</code> 来采集日志，<code>Monitoring</code> 来负责收集监控指标。</p>
<p><img src="example1.jpeg" alt="example1.jpeg"></p>
<h3 id="容器编排的困境"><a href="#容器编排的困境" class="headerlink" title="容器编排的困境"></a>容器编排的困境</h3><h4 id="Kubernetes-为我们带来了什么？"><a href="#Kubernetes-为我们带来了什么？" class="headerlink" title="Kubernetes 为我们带来了什么？"></a>Kubernetes 为我们带来了什么？</h4><p>通过上面的例子，我们发现 Kubernetes 已经为我们对大量常用的基础资源进行了<strong>抽象和封装</strong>，我们可以非常灵活地组合、使用这些资源来解决问题，同时它还提供了一系列自动化运维的机制:如 HPA, VPA, Rollback, Rolling Update 等帮助我们进行弹性伸缩和滚动更新，而且上述所有的功能都可以用 <code>YAML</code> 声明式进行部署。</p>
<h4 id="困境"><a href="#困境" class="headerlink" title="困境"></a>困境</h4><p>但是这些抽象<strong>还是在容器层面</strong>的，对于一个大型的应用而言，需要组合大量的 Kubernetes 原生资源，需要非常多的 Services, Deployments, StatefulSets 等，这里面用起来就会比较繁琐，而且其中服务之间的依赖关系需要用户自己解决，<strong>缺乏统一的依赖管理机制</strong>。</p>
<h3 id="应用编排"><a href="#应用编排" class="headerlink" title="应用编排"></a>应用编排</h3><h4 id="什么是应用？"><a href="#什么是应用？" class="headerlink" title="什么是应用？"></a>什么是应用？</h4><p>一个对外提供服务的应用，</p>
<ul>
<li>首先它需要一个能够与外部通讯的网络，</li>
<li>其次还需要能运行这个服务的载体 (Pods)，</li>
<li>如果这个应用需要存储数据，这还需要配套的存储，</li>
</ul>
<p>所以我们可以认为:</p>
<p>应用单元 = 网络 + 服务载体 +存储 </p>
<p><img src="service1.jpeg" alt="service1.jpeg"></p>
<p>那么我们很容易地可以将 Kubernetes 的资源联系起来，然后将他们划分为 4 种类型的应用：</p>
<ul>
<li>无状态应用 = Services + Volumes + <code>Deployment</code></li>
<li>有状态应用 = Services + Volumes + <code>StatefulSet</code></li>
<li>守护型应用 = Services + Volumes + <code>DaemonSet</code></li>
<li>批处理应用 = Services + Volumes + <code>CronJob/Job</code></li>
</ul>
<p>我们来重新审视一下之前的例子：</p>
<p><img src="example2.jpeg" alt="example2.jpeg"></p>
<h4 id="应用层面的四个问题"><a href="#应用层面的四个问题" class="headerlink" title="应用层面的四个问题"></a>应用层面的四个问题</h4><p>通过前面的探索，我们可以引出应用层面的<strong>四个问题</strong>：</p>
<ol>
<li>应用包的定义</li>
<li>应用依赖管理</li>
<li>包存储</li>
<li>运行时管理</li>
</ol>
<p>在社区中，这四个方面的问题分别由<strong>三个组件</strong>或者项目来解决:</p>
<ol>
<li><code>Helm Charts</code>: 定义了应用包的结构以及依赖关系；</li>
<li><code>Helm Registry</code>: 解决了包存储；</li>
<li><code>HelmTiller</code>: 负责将包运行在 Kubernetes 集群中。</li>
</ol>
<p>Helm是一个kubernetes应用的包管理工具. 但有很多问题, 也有很多年代替的东西.</p>
<h2 id="k8s核心架构介绍"><a href="#k8s核心架构介绍" class="headerlink" title="k8s核心架构介绍"></a>k8s核心架构介绍</h2><p><a href="https://clsn.io/clsn/lx8.html" target="_blank" rel="noopener">Kubernetes 编排系统 666</a></p>
<p>下面是kubernetes的架构图, 核心组件, 可以看个大概, 记住的话很有用.</p>
<p><img src="framework2.png" alt="framework2.png"><br><img src="framework1.png" alt="framework1.png"></p>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Kubernetes的<strong>基本调度单元</strong>称为“pod”。它可以把更高级别的抽象内容增加到容器化组件。<strong>一个pod一般包含一个或多个容器</strong>，这样可以保证它们一直位于主机上，并且可以共享资源。Kubernetes中的每个pod都被分配一个唯一的（在集群内的）IP地址这样就可以允许应用程序使用端口，而不会有冲突的风险。</p>
<p>Pod可以定义一个卷，例如本地磁盘目录或网络磁盘，并将其暴露在pod中的一个容器之中。pod可以通过Kubernetes API手动管理，也可以委托给控制器来管理。</p>
<h3 id="标签和选择器"><a href="#标签和选择器" class="headerlink" title="标签和选择器"></a>标签和选择器</h3><p>标签和选择器是Kubernetes中的主要分组机制，用于确定操作适用的组件。</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>控制器是将实际集群状态转移到所需集群状态的对帐循环。它通过<strong>管理一组pod来实现</strong>。</p>
<p>其它控制器，是核心Kubernetes系统的一部分包括一个“DaemonSet控制器”为每一台机器（或机器的一些子集）上运行的恰好一个pod，和一个“作业控制器”用于运行pod运行到完成，例如作为批处理作业的一部分。控制器管理的一组pod由作为控制器定义的一部分的标签选择器确定。</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>Kubernetes<strong>服务是一组协同工作的pod</strong>，就像多层架构应用中的一层。构成服务的pod组通过标签选择器来定义。</p>
<h2 id="Kubernetes核心组件"><a href="#Kubernetes核心组件" class="headerlink" title="Kubernetes核心组件"></a>Kubernetes核心组件</h2><p>再重复一遍核心组件架构图.</p>
<p><img src="framework2.png" alt="framework2.png"><br><img src="framework1.png" alt="framework1.png"></p>
<p>Kubernetes遵循<code>master-slave architecture</code>。Kubernetes的组件可以分为管理单个的 node 组件和控制平面的一部分的组件。</p>
<p>Kubernetes <code>Master</code>是集群的<strong>主要控制单元</strong>，用于管理其工作负载并指导整个系统的通信。<br>Kubernetes控制平面由各自的进程组成，每个组件都可以在<strong>单个主节点node</strong>上运行，也可以在支持high-availability clusters的多个主节点上运行。</p>
<p>Kubernetes主要由以下几个核心组件组成：如上图</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组件名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>etcd</td>
<td>保存了整个集群的状态；</td>
</tr>
<tr>
<td>apiserver</td>
<td>提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</td>
</tr>
<tr>
<td>controller manager</td>
<td>负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</td>
</tr>
<tr>
<td>scheduler</td>
<td>负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</td>
</tr>
<tr>
<td>kubelet</td>
<td>负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；</td>
</tr>
<tr>
<td>Container runtime</td>
<td>负责镜像管理以及Pod和容器的真正运行（CRI）；</td>
</tr>
<tr>
<td>kube-proxy</td>
<td>负责为Service提供cluster内部的服务发现和负载均衡；</td>
</tr>
</tbody>
</table>
</div>
<p>除了核心组件，还有一些推荐的<code>Add-ons</code>：addons</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组件名称</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>kube-dns</td>
<td>负责为整个集群提供DNS服务</td>
</tr>
<tr>
<td>Ingress Controller</td>
<td>为服务提供外网入口</td>
<td>有看过</td>
</tr>
<tr>
<td>Heapster</td>
<td>提供资源监控</td>
</tr>
<tr>
<td>Dashboard</td>
<td>提供GUI</td>
<td>有用到</td>
</tr>
<tr>
<td>Federation</td>
<td>提供跨可用区的集群</td>
</tr>
<tr>
<td>Fluentd-elasticsearch</td>
<td>提供集群日志采集、存储与查询</td>
</tr>
</tbody>
</table>
</div>
<h2 id="使用docker来安装单节点k8s集群"><a href="#使用docker来安装单节点k8s集群" class="headerlink" title="使用docker来安装单节点k8s集群"></a>使用docker来安装单节点k8s集群</h2><p>直接下载最新版的docker, 然后找到kubernetes选项, 勾上<code>enable kubernetes</code>等待安装上就好.</p>
<p><img src="enablek8s.png" alt="enablek8s.png"></p>
<p>安装完会顺便自动安装上<code>kubectl</code>控制命令</p>
<p>运行<code>kubectl version</code>查看安装成功否.</p>
<h3 id="部署kubernetes-dashboard服务-方便查看k8s的配置"><a href="#部署kubernetes-dashboard服务-方便查看k8s的配置" class="headerlink" title="部署kubernetes-dashboard服务, 方便查看k8s的配置"></a>部署kubernetes-dashboard服务, 方便查看k8s的配置</h3><p>要想启动 Kubernetes Dashboard，还得在集群中<strong>部署</strong>一下 <code>kubernetes-dashboard.yaml</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure>
<p>部署成功后，我们进行启动 <code>proxy</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl proxy</span><br><span class="line"></span><br><span class="line">Starting to serve on 127.0.0.1:8001</span><br></pre></td></tr></table></figure>
<p>这时候，打开浏览器，访问 Kubernetes Dashboard</p>
<p><img src="dashboard1.webp" alt="dashboard1.webp"></p>
<p>通过以下脚本，填写 <code>kubeconfig</code> 的 <code>Token</code> 信息（如果不操作这一步，就会提示 config 信息不全）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">TOKEN=$(kubectl -n kube-system describe secret default| awk <span class="string">'$1=="token:"&#123;print $2&#125;'</span>)</span><br><span class="line">kubectl config <span class="built_in">set</span>-credentials docker-for-desktop --token=<span class="string">"<span class="variable">$&#123;TOKEN&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>选择 <code>kubeconfig</code> 文件，使用“<code>shift + command + .</code>”打开 <code>$HOME</code> 下隐藏目录文件 <code>./kube/config</code>，点击“登录”，就可以认证成功，进入首页了。</p>
<p><img src="home1.webp" alt="home1.webp"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>第一部分: dockerhe k8s, 如何设置k8s集群,以及运行一个小程序</li>
<li>第二部分: 在k8s中运行应用必须理解的关键技术</li>
<li>第三部分: 深入研究k8s内部, 介绍一些额外的概念</li>
</ul>
<p>本来应用是开发给运维, 运维部署在监控.<br>微服务, 大型单体应用, 到微服务.大应用分解成小的, </p>
<p>k8s使开发者可以自主部署应用, 并控制部署的频率<br>抽象数据中心的硬件基础设施.</p>
<p>开发和运维在一起的一个团队中DevOps<br>kubernetes 使用linux容器技术来提供应用的隔离.</p>
<p>Docker: </p>
<ul>
<li>镜像</li>
<li>镜像仓库</li>
<li>容器</li>
</ul>
<p>流程是:</p>
<ol>
<li>先开发者操作docker构建和推送镜像,</li>
<li>开发机器上docker构建镜像</li>
<li>然后推送到镜像仓库中,开发者可以在生产机器中拉取</li>
<li>生产机器上拉取镜像中心的docker, 然后基于容器运行.</li>
</ol>
<p>kubernetes是一个软件系统, 允许你在其上很容易部署和管理容器化的应用.</p>
<p>开发者开发开发了一个应用, 然后交给kubernetes master, 他会控制成为一个个工作节点.  架构</p>
<p>kubernetes分2种节点,</p>
<ul>
<li>主节点master: 控制和管理</li>
<li>工作节点node: 运行用户实际部署的应用.</li>
</ul>
<p>主节点中: </p>
<ul>
<li>kubernetes API: 控制和其他控制面板组件都要和他通信.</li>
<li>scheduler: 调度应用</li>
<li>controller manager: 执行集群级别的功能, 如复制组件, 持续跟踪node, 处理节点失败</li>
<li>etcd开考的分布式数据存储, 持久化存储集群配置.</li>
</ul>
<p>工作节点中node:</p>
<ul>
<li>docker: 或其他容器</li>
<li>kubelet: 和API通信, 并管理它所在节点的容器.</li>
<li>kubernetes service proxy: 负责组件之间的负载均衡网络流量</li>
</ul>
<p>跑应用的话要先把应用大包进一个或多个容器镜像, 再把这些镜像推动到镜像仓库中, 然后把应用的<strong>描述</strong>发布到kubernetes API中.<br>图1.10很不错: </p>
<p>APP descriptor描述了4个容器, 并分为3组(叫3个pod), 前2个pod中一个容器, 后一个2个容器.表示这两个容器要协同工作, 不要隔离.旁边的数字表示要运行每个pod的副本数量.</p>
<blockquote>
<p>pod在node中</p>
</blockquote>
<p>例子: 如何创建一个简单的应用, 并把它打包成容器镜像并在远端的kubernetes集群中或本地的单节点集群中运行</p>
<ol>
<li>安装docker并运行一个hello容器</li>
<li>创建一个简单的node.js应用并部署在kubernetes中</li>
<li>把应用打包成可以独立运行的容器镜像</li>
<li>基于镜像运行容器</li>
<li>把镜像推送到docker hub中.</li>
</ol>
<p>docker build看图2.2<br>镜像的构建不是在docker客户端而是在docker的守护进程daemon. 两者可以不要求在同一台机器上.<br>没有的镜像会从docker hub中下.<br>镜像是分层的, 只有本地没有的镜像才会去hub上下.<br>Dockerfile是每一条语句创建一个层.<br>最后一层也就是最上面一层标记为<code>kubia:latest</code><br>构建完成后, 新的镜像存储在本地.</p>
<p>访问下<br>一些列docker操作后, 就可以push到docker hub了</p>
<p>然后是一些kubernetes的操作. 设置一个完整的多节点的kubernetes集群是很麻烦的额, 暂时就用docker的自带enable kubernetes. 最简单的 比用<code>minikube</code>还方便.</p>
<p>安装完后用<code>kubectl cluster-info</code>看集群状况. 下面还没有装<code>dashboard</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https:<span class="comment">//localhost:6443</span></span><br><span class="line">KubeDNS is running at https:<span class="comment">//localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span></span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use <span class="string">'kubectl cluster-info dump'</span>.</span><br></pre></td></tr></table></figure>
<p>使用GKE托管 kubernetes 集群</p>
<p>暂时不用了, 自己看下好了</p>
<p><code>kubectl get nodes</code>看节点的状况, <code>kubectl get</code>用来看kubernetes中对象情况</p>
<p>更详细的是用<code>kubectl describe node docker-for-desktop</code> 看节点的详情.</p>
<p>设置别名<code>kubectl</code>为<code>k</code></p>
<p>超实用的不全, 在<code>bash</code>或<code>zsh shell</code>中</p>
<p>在kubernetes上运行第一个应用.</p>
<p><code>kubectl run</code>来部署<br>运行一个前面推到 docker hub 的上那个. 本地的那个kubia</p>
<p><code>kubectl run kubia --image=ximage/kubia --port=8080 --generator=run/v1</code></p>
<p>kubia是kubernetes中的名字,<br>—image= 指定要运行的image,<br>—port= 指定kubernete应用监听哪个端口<br>—generator= 创建一个<code>ReplicationController</code>而不是Deployment. 以后不会用到这个命令.</p>
<p>pod的信息. 这里你会想是不是有一个kubectl的命令来看pod, 但是没有, kubernetes不是干这个活. 他不直接处理单个容器. 使用的是多容器共存的概念, 就是pod.</p>
<p>每个pod类似一个独立逻辑机器, 有自己的ip, 主机名这种, 运行一个独立的应用程序.<br>应用程序可以是单进程, 运行在单容器中, 也可以是一个主应用进程或其他支持进程.</p>
<p>容器, pod, node的关系看图2.5<br><code>kubectl get pods</code> 然后等status为running才行.</p>
<p>ImagePullBackOff的情况会等一会才成功的. 具体就用describe看</p>
<p>那么如何访问正在运行的pod的呢</p>
<p>前面说过每个pod都有自己的IP地址, 但这个地址是集群内部的, 不能从外部访问, 所以为了能从外部访问, 需要用服务对象公开他. 需要创建一个特殊的<code>LoadBalancer</code>类型的服务. 如果是一个常规服务的话(一个<code>ClusterIP</code>服务)还是只能在内部访问.<br><code>LoadBalancer</code>将创建一个外部的负载均衡, 通过负载均衡的公共IP来访问pod</p>
<h3 id="开始创建一个服务对象"><a href="#开始创建一个服务对象" class="headerlink" title="开始创建一个服务对象."></a>开始创建一个服务对象.</h3><p>告知kubernetes对外暴露之前创建的<code>ReplicationController</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl expose rc kubia --type=LoadBalancer --name kubia-http</span><br><span class="line">service &quot;kubia-http&quot; exposed</span><br></pre></td></tr></table></figure>
<ul>
<li>rc是名字<code>ReplicationController</code>的缩写, 不用写全称. pods是po, service是svc</li>
<li>kubia是前面<code>kubectl run</code>的名字,</li>
<li>—type=LoadBalancer是服务类型</li>
<li>—name kubia-http一个新的名字</li>
</ul>
<h3 id="列出服务"><a href="#列出服务" class="headerlink" title="列出服务"></a>列出服务</h3><p>用<code>kubectl get</code> 到目前为止有<code>nodes pods services</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get services</span><br><span class="line">NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          1d</span><br><span class="line">kubia-http   LoadBalancer   10.110.207.73   localhost     8080:32391/TCP   3m</span><br></pre></td></tr></table></figure>
<p>可以看到新创建的<code>kubia-http</code>并没有外部IP,是<code>localhost</code>, 如果是<code>&lt;none&gt;</code>的话,这是因为kubernetes创建负载均衡是要一段时间的, 过一会看.</p>
<p><code>kubectl get svc kubia-http</code> 看</p>
<p>还是用<code>curl localhost:8080</code>来看, 其实在用<code>docker ps</code>可以看到运行的容器哦.</p>
<p>仔细看应用将<code>pod</code>的名字当做主机名.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubia-m9zfv   1/1       Running   0          32m</span><br><span class="line"></span><br><span class="line">$ curl localhost:8080</span><br><span class="line">You&apos;ve hit kubia-m9zfv</span><br></pre></td></tr></table></figure>
<p>我们只需要记得, 我单点访问<code>master</code>节点就好了.</p>
<p><code>ReplicationController</code>和<code>pod</code>和服务是如何组合在一起的.</p>
<p>我们没有直接创建和使用容器, kubernetes的基本构建又是pod. 我们也没有真正直接创建pod, 是通过<code>kubectl run</code> 创建了一个<code>ReplicationController</code>, 这个是用来创建pod实例的. 为了能够外部访问, kubernetes将<code>ReplicationController</code>管理的所有pod有一个服务对外暴露.</p>
<p>图2.7看看</p>
<h3 id="最终要你的组件是pod和它的容器"><a href="#最终要你的组件是pod和它的容器" class="headerlink" title="最终要你的组件是pod和它的容器"></a>最终要你的组件是pod和它的容器</h3><p>第一个组件是: pod的的容器是node进程,</p>
<p>第二个组件是: <code>ReplicationController</code>是用来确保始终存在一个运行中的pod实例, 通常<code>ReplicationController</code>用于复制pod并让他们保持运行.</p>
<p>第三个组件是: <code>kubia-http</code>服务. 为什么要有服务, 因为pod是短暂存在的,  或故障, 或误操作. 虽然<code>ReplicationController</code>会复制一个新的, 但和原来的pod有个一区别就是<strong>IP地址不一样</strong>, 解决不断变化的IP问题, 这就是需要服务的地方. 还有就是搞定一个IP和端口对上对外暴露多个pod.<br>当一个服务创建时, 他会得到一个静态的IP, 服务生命周期内这个IP地址都不会发生改变. 客户端是通过固定IP地址来连接到服务. 而不是直接连接pod</p>
<h3 id="水平伸缩应用"><a href="#水平伸缩应用" class="headerlink" title="水平伸缩应用"></a>水平伸缩应用</h3><p>有前面3个组件基础后, 搞事情咯</p>
<p>用kubernetes一个主要好处就是可以简单扩展部署, 例子🌰</p>
<p>把运行实例增加到3个.</p>
<p>现在是一个</p>
<figure class="highlight k"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">get</span> replicationcontrollers</span><br><span class="line">NAME      DESIRED   CURRENT   READY     AGE</span><br><span class="line">kubia     <span class="number">1</span>         <span class="number">1</span>         <span class="number">1</span>         <span class="number">1</span>h</span><br></pre></td></tr></table></figure>
<p>名为kubia的单 <code>ReplicationControllers</code> . <code>DESIRED</code>表示希望保持的pod的副本数, <code>CURRENT</code>是当前的pod副本数.</p>
<h4 id="增加期望副本数DESIRED"><a href="#增加期望副本数DESIRED" class="headerlink" title="增加期望副本数DESIRED"></a>增加期望副本数DESIRED</h4><figure class="highlight k"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl scale rc kubia --replicas=<span class="number">3</span></span><br><span class="line">replicationcontroller <span class="string">"kubia"</span> scaled</span><br></pre></td></tr></table></figure>
<p>只是告诉kubernetes我期望的数量, kubernetes会自己去做.</p>
<figure class="highlight k"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">get</span> rc</span><br><span class="line">NAME      DESIRED   CURRENT   READY     AGE</span><br><span class="line">kubia     <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>         <span class="number">1</span>h</span><br></pre></td></tr></table></figure>
<p>同时看下pod</p>
<figure class="highlight k"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">get</span> po</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubia-m9zfv   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>h</span><br><span class="line">kubia-q89qr   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>m</span><br><span class="line">kubia-w22k7   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>m</span><br></pre></td></tr></table></figure>
<p>然后重新访问下哦,多试几次可以看到访问不同的主机, <code>pod</code></p>
<figure class="highlight k"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:<span class="number">8080</span></span><br><span class="line">You've hit kubia-m9zfv</span><br><span class="line"></span><br><span class="line">$ curl localhost:<span class="number">8080</span></span><br><span class="line">You've hit kubia-q89qr</span><br><span class="line"></span><br><span class="line">$ curl localhost:<span class="number">8080</span></span><br><span class="line">You've hit kubia-w22k7</span><br></pre></td></tr></table></figure>
<h3 id="查看应用运行在哪个节点上"><a href="#查看应用运行在哪个节点上" class="headerlink" title="查看应用运行在哪个节点上"></a>查看应用运行在哪个节点上</h3><p>kubernetes中不需要管这个.</p>
<p>想要看就用加参数<code>-o wide</code> 多了2列</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po -o wide</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE       IP          NODE</span><br><span class="line">kubia-m9zfv   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>h        <span class="number">10.1</span><span class="number">.0</span><span class="number">.8</span>    docker-<span class="keyword">for</span>-desktop</span><br><span class="line">kubia-q89qr   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">6</span>m        <span class="number">10.1</span><span class="number">.0</span><span class="number">.10</span>   docker-<span class="keyword">for</span>-desktop</span><br><span class="line">kubia-w22k7   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">6</span>m        <span class="number">10.1</span><span class="number">.0</span><span class="number">.9</span>    docker-<span class="keyword">for</span>-desktop</span><br></pre></td></tr></table></figure>
<h3 id="还有使用dashboard"><a href="#还有使用dashboard" class="headerlink" title="还有使用dashboard"></a>还有使用dashboard</h3><p>暂时不管了, 2步</p>
<h2 id="pod这个kubernetes的核心"><a href="#pod这个kubernetes的核心" class="headerlink" title="pod这个kubernetes的核心"></a>pod这个kubernetes的核心</h2><p>其他对象只是在管理, 暴露pod或被pod使用.</p>
<h3 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h3><p>pod是一组并置的容器, 代表kubernetes中基本构建模块. 实际应用中并不会单独部署容器, 而是针对一组pod中的容器进行部署和操作.<br>这并不意味这一个pod中总要包含多个容器.<br>pod也不会跨越多个工作节点.</p>
<p>由于不能将多个进程都聚集在一个单独的容器中, 所以产生pod, 对他们当做一个单元进行管理.</p>
<p><strong>在docker中 知道容器间是隔离的, 但在pod中我们要共享</strong>, 所以kubernetes是配置docker让一个pod中的容器都在一个namespace中. 而不是每一个容器都一个命名空间.<br>所以他们也共享相同的主机名和网络接口, 一个namespace的好处,<br>由于现在pod中容器都共享相同的IP和端口, 所以要注意容器中的进程不能绑定到相同的port中. 这个只涉及一个pod中. 不同的pod间不会冲突.<br>同时一个pod中的所有容器都具有相同的loopback网络接口, 因此容器可以通过localhost与同一个pod的其他容器进行通信.</p>
<p><strong>集群中的所有pod都在一个共享网络地址空间</strong>, 意味着每个pod可以和其他pod进行相互访问, 包括不同node间的pod, 不用NAT</p>
<p>通过pod合理管理容器, 就是前后端应用服务器, 数据库的都放不同的pod中.<br>还有 <strong>扩容是基于pod的</strong><br>何时在一个pod中用多个容器呢, 主要是主进程和辅进程.</p>
<h4 id="何时在pod中放多个容器"><a href="#何时在pod中放多个容器" class="headerlink" title="何时在pod中放多个容器"></a>何时在pod中放多个容器</h4><ul>
<li>他们需要一起运行还是可以在不同的主机上运行</li>
<li>他们代表一个整体还是相互独立的组件</li>
<li>他们必须一起进行扩容还是可以分别进行</li>
</ul>
<p>图3.4哈哈哈 </p>
<ul>
<li>前后端在一个容器,一个pod中</li>
<li>前后端在不同容器, 但在一个pod中</li>
<li>前后端不同容器, 不容pod中</li>
</ul>
<h4 id="以YAML或JSON格式描述文件来创建pod"><a href="#以YAML或JSON格式描述文件来创建pod" class="headerlink" title="以YAML或JSON格式描述文件来创建pod"></a>以YAML或JSON格式描述文件来创建pod</h4><p>前面的命令行只允许你配置一组有限的属性. 通过YAML可以利用版本控制系统哦.</p>
<p>使用<code>kuberctl get po kubia-xxx -o yaml</code>来查看这个pod的YAML格式</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>                                  <span class="comment"># kubernetes API版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                                       <span class="comment"># kubernetes对象/资源</span></span><br><span class="line"><span class="attr">metadata:</span>                                       <span class="comment"># pod元数据(名称, 标签, 注解)</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T08:39:21Z</span></span><br><span class="line"><span class="attr">  generateName:</span> <span class="string">kubia-</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    run:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-m9zfv</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  ownerReferences:</span></span><br><span class="line"><span class="attr">  - apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">    blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    controller:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    uid:</span> <span class="string">ab300f02-417d-11e9-ae46-025000000001</span></span><br><span class="line"><span class="attr">  resourceVersion:</span> <span class="string">"82915"</span></span><br><span class="line"><span class="attr">  selfLink:</span> <span class="string">/api/v1/namespaces/default/pods/kubia-m9zfv</span></span><br><span class="line"><span class="attr">  uid:</span> <span class="string">ab4e1d22-417d-11e9-ae46-025000000001</span></span><br><span class="line"><span class="attr">spec:</span>                                           <span class="comment"># pod规格 / 内容(pod的容器列表, volume等)</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">ximage/kubia</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">    terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line"><span class="attr">    terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - mountPath:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">default-token-xgtvp</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line"><span class="attr">  nodeName:</span> <span class="string">docker-for-desktop</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">  schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line"><span class="attr">  securityContext:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  serviceAccount:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  serviceAccountName:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">  tolerations:</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoExecute</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">node.kubernetes.io/not-ready</span></span><br><span class="line"><span class="attr">    operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="attr">    tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoExecute</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">node.kubernetes.io/unreachable</span></span><br><span class="line"><span class="attr">    operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="attr">    tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">default-token-xgtvp</span></span><br><span class="line"><span class="attr">    secret:</span></span><br><span class="line"><span class="attr">      defaultMode:</span> <span class="number">420</span></span><br><span class="line"><span class="attr">      secretName:</span> <span class="string">default-token-xgtvp</span></span><br><span class="line"><span class="attr">status:</span>                                             <span class="comment"># pod及其内部容器的详细状态</span></span><br><span class="line"><span class="attr">  conditions:</span></span><br><span class="line"><span class="attr">  - lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    lastTransitionTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T08:39:21Z</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Initialized</span></span><br><span class="line"><span class="attr">  - lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    lastTransitionTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T08:48:18Z</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Ready</span></span><br><span class="line"><span class="attr">  - lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    lastTransitionTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T08:39:21Z</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">PodScheduled</span></span><br><span class="line"><span class="attr">  containerStatuses:</span></span><br><span class="line"><span class="attr">  - containerID:</span> <span class="attr">docker://14a88ed822997fea0d94d0a19366082c6cdaf648510f56b6221bd9bd7fc38c2e</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">kubia:latest</span></span><br><span class="line"><span class="attr">    imageID:</span> <span class="attr">docker-pullable://ximage/kubia@sha256:11b82b25e898ed75b9436654a243198d1c4e1e133d930f1c9dffed7c22a80aa4</span></span><br><span class="line"><span class="attr">    lastState:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    ready:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    restartCount:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    state:</span></span><br><span class="line"><span class="attr">      running:</span></span><br><span class="line"><span class="attr">        startedAt:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T08:48:18Z</span></span><br><span class="line"><span class="attr">  hostIP:</span> <span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br><span class="line"><span class="attr">  phase:</span> <span class="string">Running</span></span><br><span class="line"><span class="attr">  podIP:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.8</span></span><br><span class="line"><span class="attr">  qosClass:</span> <span class="string">BestEffort</span></span><br><span class="line"><span class="attr">  startTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T08:39:21Z)</span></span><br></pre></td></tr></table></figure>
<h5 id="介绍pod定义的主要部分"><a href="#介绍pod定义的主要部分" class="headerlink" title="介绍pod定义的主要部分"></a>介绍pod定义的主要部分</h5><ul>
<li>首先是YAML中使用的kubernetes API 版本和 YAML中用来描述的资源类型</li>
<li>其次是几乎在所有kubernetes资源中都可以找到的3大重要部分<ul>
<li>metadata 包括名称, 命名空间, 标签和关于该容器的其他信息</li>
<li>spec 包含pod内容的实际说明, 例如pod的容器, 卷和其他数据</li>
<li>status 包含<strong>运行中</strong>的pod的当前信息(新建时不需要的), 例如pod所处的条件, 每个容器的描述状态, 以及内部IP和其他基本信息</li>
</ul>
</li>
</ul>
<h5 id="创建一个简答的pod的YAML描述文件"><a href="#创建一个简答的pod的YAML描述文件" class="headerlink" title="创建一个简答的pod的YAML描述文件"></a>创建一个简答的pod的YAML描述文件</h5><p>kubia-manual.yaml 可以在任意目录下哦</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>              <span class="comment"># kubernetes API v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                   <span class="comment"># 是一个pod</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment"># </span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-manual</span>        <span class="comment"># pod名称</span></span><br><span class="line"><span class="attr">spec:</span>                       <span class="comment"># pod规格 / 内容(pod的容器列表, volume等)</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">ximage/kubia</span>     <span class="comment"># 容器所用镜像</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span>             <span class="comment"># 容器名</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span>   <span class="comment"># 监听端口</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<p>上面在pod中指定port是展示性的, 客户端能否通过端口链接到pod和这个并没有多大关系, 只不过这个明确指定很有用, 后面还可以用来允许你为每个端口指定一个名称.</p>
<p>可以用<code>kubectl explain pod</code>来查看怎么写. 对象含有那些属性. <code>kubectl explain pod.spec</code></p>
<p>使用<code>kuberctl create</code>命令从YAML文件中创建pod</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f kubia-manual.yaml </span><br><span class="line">pod <span class="string">"kubia-manual"</span> created</span><br></pre></td></tr></table></figure>
<p><code>kubectl create -f</code>用户从YAML或JSON中创建任何资源(不只是pod)</p>
<p>然后再看创建好的pod的yaml格式</p>
<p><code>kubectl get po kubia-manual -o yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T12:13:05Z</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-manual</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  resourceVersion:</span> <span class="string">"95408"</span></span><br><span class="line"><span class="attr">  selfLink:</span> <span class="string">/api/v1/namespaces/default/pods/kubia-manual</span></span><br><span class="line"><span class="attr">  uid:</span> <span class="number">8767870</span><span class="string">d-419b-11e9-ae46-025000000001</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">ximage/kubia</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">    terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line"><span class="attr">    terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - mountPath:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">default-token-xgtvp</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line"><span class="attr">  nodeName:</span> <span class="string">docker-for-desktop</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">  schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line"><span class="attr">  securityContext:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  serviceAccount:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  serviceAccountName:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">  tolerations:</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoExecute</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">node.kubernetes.io/not-ready</span></span><br><span class="line"><span class="attr">    operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="attr">    tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoExecute</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">node.kubernetes.io/unreachable</span></span><br><span class="line"><span class="attr">    operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="attr">    tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">default-token-xgtvp</span></span><br><span class="line"><span class="attr">    secret:</span></span><br><span class="line"><span class="attr">      defaultMode:</span> <span class="number">420</span></span><br><span class="line"><span class="attr">      secretName:</span> <span class="string">default-token-xgtvp</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line"><span class="attr">  conditions:</span></span><br><span class="line"><span class="attr">  - lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    lastTransitionTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T12:13:05Z</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Initialized</span></span><br><span class="line"><span class="attr">  - lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    lastTransitionTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T12:13:09Z</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Ready</span></span><br><span class="line"><span class="attr">  - lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    lastTransitionTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T12:13:05Z</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">PodScheduled</span></span><br><span class="line"><span class="attr">  containerStatuses:</span></span><br><span class="line"><span class="attr">  - containerID:</span> <span class="attr">docker://2c04c4f7551ac2e2e862722a780a4befe28d9037df0b74b8d0116c66ff4e1352</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">kubia:latest</span></span><br><span class="line"><span class="attr">    imageID:</span> <span class="attr">docker-pullable://ximage/kubia@sha256:11b82b25e898ed75b9436654a243198d1c4e1e133d930f1c9dffed7c22a80aa4</span></span><br><span class="line"><span class="attr">    lastState:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    ready:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    restartCount:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    state:</span></span><br><span class="line"><span class="attr">      running:</span></span><br><span class="line"><span class="attr">        startedAt:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T12:13:08Z</span></span><br><span class="line"><span class="attr">  hostIP:</span> <span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br><span class="line"><span class="attr">  phase:</span> <span class="string">Running</span></span><br><span class="line"><span class="attr">  podIP:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.11</span></span><br><span class="line"><span class="attr">  qosClass:</span> <span class="string">BestEffort</span></span><br><span class="line"><span class="attr">  startTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T12:13:05Z</span></span><br></pre></td></tr></table></figure>
<p>虽然看<code>kubectl get po</code>可以知道pod运不运行, 但还有是需求, 通过与pod的时机通信来确定其正在运行. 后面讨论</p>
<p>现在看下应用的日志来检查错误.</p>
<h4 id="查看应用程序日志"><a href="#查看应用程序日志" class="headerlink" title="查看应用程序日志"></a>查看应用程序日志</h4><p>容器化的应用程序通常会把日志记录到标准输出和标准错误流, 而不是将其写入文件.</p>
<p><code>docker logs &lt;cid&gt;</code> 这种可以用</p>
<p>在kubernetes中可以用更方便的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs kubia-manual</span><br><span class="line">Kubia server starting ......</span><br><span class="line"></span><br><span class="line">$ kubectl logs kubia-m9zfv </span><br><span class="line">Kubia server starting ......</span><br><span class="line">Received request <span class="keyword">from</span>::ffff:<span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br><span class="line">Received request <span class="keyword">from</span>::ffff:<span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br><span class="line">Received request <span class="keyword">from</span>::ffff:<span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br><span class="line">Received request <span class="keyword">from</span>::ffff:<span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br><span class="line">Received request <span class="keyword">from</span>::ffff:<span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br><span class="line">Received request <span class="keyword">from</span>::ffff:<span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>
<p>在我们向nodejs中的程序发送web请求前, 日志只显示一条<code>Kubia server starting ......</code></p>
<p>获取多容器pod的日志时指定容器名称要加<code>-c &lt;容器名&gt;</code> 这个名称不能用<code>docker ps</code>看到, 而是你YAML文件中的<code>spec.containers.name</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs kubia-manual -c kubia       </span><br><span class="line">Kubia server starting ......</span><br></pre></td></tr></table></figure>
<p><strong>注意我们只能获取到仍然存在的pod的日志</strong>, 当一个pod被删除时, 他的日志也会被删除. 如果希望pod在删除之后也能获取到日志, 那么我们需要设置中心化吗集群范围的日志系统.</p>
<h4 id="向pod中发送请求"><a href="#向pod中发送请求" class="headerlink" title="向pod中发送请求"></a>向pod中发送请求</h4><p><code>kubectl get</code>和日志显示该pod正在运行, 但我们如何在实际操作用看到该状态呢.<br>前一章用<code>kubectl expose</code>创建一个service, 以便在外部访问pod.<br>还有其他链接到pod以进行测试和调试的方法. 其中之一就是<strong>端口转发</strong></p>
<h5 id="将本地网络端口转发到pod中的端口"><a href="#将本地网络端口转发到pod中的端口" class="headerlink" title="将本地网络端口转发到pod中的端口"></a>将本地网络端口转发到pod中的端口</h5><p>不通过service, 用端口 <code>kubectl port-forward</code>来</p>
<p><strong>如将本地端口8888转发到我们的kubia-manual pod中的8080端口</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl port-forward kubia-manual <span class="number">8888</span>:<span class="number">8080</span></span><br><span class="line">Forwarding <span class="keyword">from</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8888</span> -&gt; <span class="number">8080</span></span><br><span class="line">Forwarding <span class="keyword">from</span> [::<span class="number">1</span>]:<span class="number">8888</span> -&gt; <span class="number">8080</span></span><br><span class="line"></span><br><span class="line">$ curl localhost:<span class="number">8888</span></span><br><span class="line">You<span class="string">'ve hit kubia-manual</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ kubectl port-forward kubia-manual 8888:8080</span></span><br><span class="line"><span class="string">Forwarding from 127.0.0.1:8888 -&gt; 8080</span></span><br><span class="line"><span class="string">Forwarding from [::1]:8888 -&gt; 8080</span></span><br><span class="line"><span class="string">Handling connection for 8888</span></span><br></pre></td></tr></table></figure>
<p>图3.5</p>
<p>是一种测试特定pod有效的方法.</p>
<h4 id="用标签组织pod"><a href="#用标签组织pod" class="headerlink" title="用标签组织pod"></a>用标签组织pod</h4><p>在node中有很多pod的时候, 打标签分类就很有用了.</p>
<p>标签不仅可以用来组织pod, 也可以组织kubernetes的其他资源,</p>
<p>只要标签的key在资源内是唯一的, 一个资源就可以拥有多个标签. <strong>通常在我们创建资源的时候就会将标签附加到资源上</strong>, 后面也可以再打标签上去.</p>
<p>比如每个pod有2个标签</p>
<ul>
<li>app: 指定pod属于哪个应用, 组件或微服务</li>
<li>rel: 显示在pod中运行的应用程序版本是stable, beta还是canary</li>
</ul>
<p>这样就可以对原来的pod组织成2个维度, 从app角度和从版本角度.<br>图3.7</p>
<p>例子 在创建yaml文件时给pod带上标签.</p>
<p>一个<code>kubia-manual-with-labels.yaml</code></p>
<p>只是多了label</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>              <span class="comment"># kubernetes API v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                   <span class="comment"># 是一个pod</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment"># </span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-manual-v2</span>     <span class="comment"># pod名称</span></span><br><span class="line"><span class="attr">  labels:</span>                     <span class="comment"># 这里是新增的labels</span></span><br><span class="line"><span class="attr">    creation_method:</span> <span class="string">manual</span></span><br><span class="line"><span class="attr">    env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">spec:</span>                       <span class="comment"># pod规格 / 内容(pod的容器列表, volume等)</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">ximage/kubia</span>     <span class="comment"># 容器所用镜像</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span>             <span class="comment"># 容器名</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span>   <span class="comment"># 监听端口</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<p>使用命令创建后</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f kubia-manual-<span class="keyword">with</span>-labels.yaml</span><br><span class="line">pod <span class="string">"kubia-manual-v2"</span> created</span><br></pre></td></tr></table></figure>
<p>使用带上标签的可以看pod各自标签</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po --show-labels</span><br><span class="line">NAME              READY     STATUS    RESTARTS   AGE       LABELS</span><br><span class="line">kubia-m9zfv       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">17</span>h       run=kubia</span><br><span class="line">kubia-manual      <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>h       &lt;none&gt;</span><br><span class="line">kubia-manual-v2   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>m        creation_method=manual,env=prod</span><br><span class="line">kubia-q89qr       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h       run=kubia</span><br><span class="line">kubia-w22k7       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h       run=kubia</span><br></pre></td></tr></table></figure>
<p>用 -L 来显示指定标签列.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po -L creation_method,env</span><br><span class="line">NAME              READY     STATUS    RESTARTS   AGE       CREATION_METHOD   ENV</span><br><span class="line">kubia-m9zfv       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">17</span>h</span><br><span class="line">kubia-manual      <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>h</span><br><span class="line">kubia-manual-v2   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">3</span>m        manual            prod</span><br><span class="line">kubia-q89qr       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h</span><br><span class="line">kubia-w22k7       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h</span><br></pre></td></tr></table></figure>
<h4 id="修改现有pod的标签"><a href="#修改现有pod的标签" class="headerlink" title="修改现有pod的标签"></a>修改现有pod的标签</h4><p>给原来的 kubia-manual 添加上一个标签.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl label po kubia-manual creation_method=manual</span><br><span class="line">pod <span class="string">"kubia-manual"</span> labeled</span><br></pre></td></tr></table></figure>
<p>给 kubia-manual-v2 修改 env 的标签为 debug</p>
<p>就是比前面加标签多一个 <code>--overwrite</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl label po kubia-manual-v2 end=debug --overwrite</span><br><span class="line">pod <span class="string">"kubia-manual-v2"</span> labeled</span><br><span class="line"></span><br><span class="line">$ kubectl get po -L creation_method,env</span><br><span class="line">NAME              READY     STATUS    RESTARTS   AGE       CREATION_METHOD   ENV</span><br><span class="line">kubia-m9zfv       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">17</span>h</span><br><span class="line">kubia-manual      <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>h       manual</span><br><span class="line">kubia-manual-v2   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">7</span>m        manual            prod</span><br><span class="line">kubia-q89qr       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h</span><br><span class="line">kubia-w22k7       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h</span><br></pre></td></tr></table></figure>
<h3 id="前面只是看pod有啥标签-刷选具体标签的值-这里用标签选择器来过滤pod子集"><a href="#前面只是看pod有啥标签-刷选具体标签的值-这里用标签选择器来过滤pod子集" class="headerlink" title="前面只是看pod有啥标签, 刷选具体标签的值, 这里用标签选择器来过滤pod子集"></a>前面只是看pod有啥标签, 刷选具体标签的值, 这里用标签选择器来过滤pod子集</h3><p><strong>标签要和标签选择器一起用哦</strong>, 刷选的条件如下(就是key 和 value)</p>
<ul>
<li>包含或不包含使用特定键的标签  (in notin)</li>
<li>包含具有特定键和值的标签  =</li>
<li>包含有特定key的, 但value和我们指定的不同 !=</li>
</ul>
<h4 id="使用下-列出pod"><a href="#使用下-列出pod" class="headerlink" title="使用下 ,列出pod"></a>使用下 ,列出pod</h4><p>这里用<code>get</code> 的命令</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po -l creation_method=manual</span><br><span class="line">NAME              READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubia-manual      <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>h</span><br><span class="line">kubia-manual-v2   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">12</span>m</span><br><span class="line"></span><br><span class="line">$ kubectl get po -l env</span><br><span class="line">NAME              READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubia-manual-v2   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">13</span>m</span><br><span class="line"></span><br><span class="line">$ kubectl get po -l <span class="string">'!env'</span></span><br><span class="line">NAME           READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubia-m9zfv    <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">17</span>h</span><br><span class="line">kubia-manual   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>h</span><br><span class="line">kubia-q89qr    <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h</span><br><span class="line">kubia-w22k7    <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h</span><br></pre></td></tr></table></figure>
<p>就是 -l 后面的值</p>
<ul>
<li>creatin_method!=manual</li>
<li>env in (prod, devel)</li>
<li>env notin (prod, devel)</li>
</ul>
<h4 id="在标签中使用多个条件"><a href="#在标签中使用多个条件" class="headerlink" title="在标签中使用多个条件"></a>在标签中使用多个条件</h4><p>使用逗号, 来分隔多个条件. 这个标签还能用来一次性删除多个pod</p>
<h3 id="使用标签来约束调度pod"><a href="#使用标签来约束调度pod" class="headerlink" title="使用标签来约束调度pod"></a>使用标签来约束调度pod</h3><p>不约束正是kubernetes的正确方式. 但某些情况下你想要约束下, 比如垃圾的机器上跑小应用, 高级的机器上跑大应用.<br>GPU, CPU机器区别对待. 但还是不会特别说明这个pod去哪个node上.</p>
<h4 id="使用标签分类工作节点node"><a href="#使用标签分类工作节点node" class="headerlink" title="使用标签分类工作节点node"></a>使用标签分类工作节点node</h4><p>比如新建一个node, 这个node是一个计算节点. 所以我们可以打label</p>
<p>用法还是同pod上打标签的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node &lt;node name&gt; gpu=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>              <span class="comment"># kubernetes API v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                   <span class="comment"># 是一个pod</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment">#</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-gpu</span>           <span class="comment"># pod名称</span></span><br><span class="line"><span class="attr">spec:</span>                       <span class="comment"># pod规格 / 内容(pod的容器列表, volume等)</span></span><br><span class="line"><span class="attr">  nodeSelector:</span>   <span class="comment"># 添加节点选择器,</span></span><br><span class="line"><span class="attr">    gpu:</span> <span class="string">"true"</span>   <span class="comment"># 要求pod部署到包含标签gpu=true的节点上</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">ximage/kubia</span>     <span class="comment"># 容器所用镜像</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span>             <span class="comment"># 容器名</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span>   <span class="comment"># 监听端口</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<p>创建pod的时候, 调度器会只在包含标签gpu=true的节点node上找, 然后在里面部署pod</p>
<h4 id="调度pod到某一个node"><a href="#调度pod到某一个node" class="headerlink" title="调度pod到某一个node"></a>调度pod到某一个node</h4><p>每一个node有一个唯一的标签, key是<code>kubernetes.io/hostname</code> value是节点的实际主机名</p>
<p>但我们不考虑单节点, 而是考虑一个逻辑上的节点组, 保证能够pod调度成功</p>
<h3 id="注解pod"><a href="#注解pod" class="headerlink" title="注解pod"></a>注解pod</h3><p>除了标签, 其他都可以注解. 也没有注解选择器哦.<br>kubernetes也会自动添加一些注解的, 比如新特性.</p>
<h4 id="查看对象的注解"><a href="#查看对象的注解" class="headerlink" title="查看对象的注解"></a>查看对象的注解</h4><p>现在看不到了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get po kubia-manual -o yaml</span><br></pre></td></tr></table></figure>
<h4 id="添加和修改注解"><a href="#添加和修改注解" class="headerlink" title="添加和修改注解"></a>添加和修改注解</h4><p>和标签一样的操作, 创建时可以添加, 也可以在之后对现有的pod进行操作.</p>
<p>用<code>kubectl annotate</code> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl annotate pod kubia-manual mycompany.com.someannotation=<span class="string">'foo bar'</span></span><br><span class="line">pod <span class="string">"kubia-manual"</span> annotated</span><br></pre></td></tr></table></figure>
<p>mycompany.com.someannotation=’foo bar’ 是一个key: value</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">describe</span> <span class="string">pod</span> <span class="string">kubia-manual</span></span><br><span class="line"><span class="attr">Name:</span>         <span class="string">kubia-manual</span></span><br><span class="line"><span class="attr">Namespace:</span>    <span class="string">default</span></span><br><span class="line"><span class="attr">Node:</span>         <span class="string">docker-for-desktop/192.168.65.3</span></span><br><span class="line"><span class="string">Start</span> <span class="attr">Time:</span>   <span class="string">Fri,</span> <span class="number">08</span> <span class="string">Mar</span> <span class="number">2019</span> <span class="number">20</span><span class="string">:13:05</span> <span class="string">+0800</span></span><br><span class="line"><span class="attr">Labels:</span>       <span class="string">creation_method=manual</span></span><br><span class="line"><span class="attr">Annotations:</span>  <span class="string">mycompany.com.someannotation=foo</span> <span class="string">bar</span>      <span class="comment"># 这条</span></span><br><span class="line"><span class="attr">Status:</span>       <span class="string">Running</span></span><br><span class="line"><span class="attr">IP:</span>           <span class="number">10.1</span><span class="number">.0</span><span class="number">.11</span></span><br><span class="line"><span class="attr">Containers:</span></span><br><span class="line"><span class="attr">  kubia:</span></span><br><span class="line">    <span class="string">Container</span> <span class="attr">ID:</span>   <span class="attr">docker://2c04c4f7551ac2e2e862722a780a4befe28d9037df0b74b8d0116c66ff4e1352</span></span><br><span class="line"><span class="attr">    Image:</span>          <span class="string">ximage/kubia</span></span><br><span class="line">    <span class="string">Image</span> <span class="attr">ID:</span>       <span class="attr">docker-pullable://ximage/kubia@sha256:11b82b25e898ed75b9436654a243198d1c4e1e133d930f1c9dffed7c22a80aa4</span></span><br><span class="line"><span class="attr">    Port:</span>           <span class="number">8080</span><span class="string">/TCP</span></span><br><span class="line">    <span class="string">Host</span> <span class="attr">Port:</span>      <span class="number">0</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">    State:</span>          <span class="string">Running</span></span><br><span class="line"><span class="attr">      Started:</span>      <span class="string">Fri,</span> <span class="number">08</span> <span class="string">Mar</span> <span class="number">2019</span> <span class="number">20</span><span class="string">:13:08</span> <span class="string">+0800</span></span><br><span class="line"><span class="attr">    Ready:</span>          <span class="literal">True</span></span><br><span class="line">    <span class="string">Restart</span> <span class="attr">Count:</span>  <span class="number">0</span></span><br><span class="line"><span class="attr">    Environment:</span>    <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">    Mounts:</span></span><br><span class="line">      <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span> <span class="string">from</span> <span class="string">default-token-xgtvp</span> <span class="string">(ro)</span></span><br><span class="line"><span class="attr">Conditions:</span></span><br><span class="line">  <span class="string">Type</span>           <span class="string">Status</span></span><br><span class="line">  <span class="string">Initialized</span>    <span class="literal">True</span></span><br><span class="line">  <span class="string">Ready</span>          <span class="literal">True</span></span><br><span class="line">  <span class="string">PodScheduled</span>   <span class="literal">True</span></span><br><span class="line"><span class="attr">Volumes:</span></span><br><span class="line"><span class="attr">  default-token-xgtvp:</span></span><br><span class="line"><span class="attr">    Type:</span>        <span class="string">Secret</span> <span class="string">(a</span> <span class="string">volume</span> <span class="string">populated</span> <span class="string">by</span> <span class="string">a</span> <span class="string">Secret)</span></span><br><span class="line"><span class="attr">    SecretName:</span>  <span class="string">default-token-xgtvp</span></span><br><span class="line"><span class="attr">    Optional:</span>    <span class="literal">false</span></span><br><span class="line"><span class="string">QoS</span> <span class="attr">Class:</span>       <span class="string">BestEffort</span></span><br><span class="line"><span class="attr">Node-Selectors:</span>  <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Tolerations:</span>     <span class="string">node.kubernetes.io/not-ready:NoExecute</span> <span class="string">for</span> <span class="number">300</span><span class="string">s</span></span><br><span class="line">                 <span class="string">node.kubernetes.io/unreachable:NoExecute</span> <span class="string">for</span> <span class="number">300</span><span class="string">s</span></span><br><span class="line"><span class="attr">Events:</span>          <span class="string">&lt;none&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-7-使用命名空间对资源进行分组"><a href="#3-7-使用命名空间对资源进行分组" class="headerlink" title="3.7 使用命名空间对资源进行分组"></a>3.7 使用命名空间对资源进行分组</h3><p>回到标签. 看到标签是如何将pod和其他对象组织成组的, 每个对象可以有多个标签, 当然可以分成多个组. 在集群中, 如果我们没有明确指定标签选择器, 那么能够看到所有对象.</p>
<p>当你想将对象分隔成完全独立但有不重叠的组时, kubernetes提供一个命名空间, 但这个和linux的命名空间不一样, kubernetes中的命名空间只是简单地为对象名称提供了一个作用域.</p>
<p>所以我们不会讲所有的资源都放在一个命名空间中, 而是多个命名空间中, 这样可以允许我们多次使用相同的资源名称.跨不同的命名空间.</p>
<h4 id="可以将大组件大系统接着拆"><a href="#可以将大组件大系统接着拆" class="headerlink" title="可以将大组件大系统接着拆"></a>可以将大组件大系统接着拆</h4><h4 id="列出集群中所有命名空间及其pod"><a href="#列出集群中所有命名空间及其pod" class="headerlink" title="列出集群中所有命名空间及其pod"></a>列出集群中所有命名空间及其pod</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get ns</span><br><span class="line">NAME          STATUS    AGE</span><br><span class="line"><span class="keyword">default</span>       Active    <span class="number">2</span>d</span><br><span class="line">docker        Active    <span class="number">2</span>d</span><br><span class="line">kube-public   Active    <span class="number">2</span>d</span><br><span class="line">kube-system   Active    <span class="number">2</span>d</span><br></pre></td></tr></table></figure>
<p>目前为止只是在<code>default</code>命名空间中操作. 使用<code>kubectl get</code>的时候并没有明确指定命名空间, 所以默认是<code>default</code>命名空间</p>
<p>看下其他命令空间的pod   <code>--namespace/-n</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po --namespace kube-system</span><br><span class="line">NAME                                         READY     STATUS    RESTARTS   AGE</span><br><span class="line">etcd-docker-<span class="keyword">for</span>-desktop                      <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">2</span>d</span><br><span class="line">kube-apiserver-docker-<span class="keyword">for</span>-desktop            <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">2</span>d</span><br><span class="line">kube-controller-manager-docker-<span class="keyword">for</span>-desktop   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">2</span>d</span><br><span class="line">kube-dns<span class="number">-86</span>f4d74b45<span class="number">-46</span>hx7                    <span class="number">3</span>/<span class="number">3</span>       Running   <span class="number">0</span>          <span class="number">2</span>d</span><br><span class="line">kube-proxy-ffc8d                             <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">2</span>d</span><br><span class="line">kube-scheduler-docker-<span class="keyword">for</span>-desktop            <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">2</span>d</span><br></pre></td></tr></table></figure>
<p>保持区分不同的pod</p>
<h4 id="创建一个命名空间"><a href="#创建一个命名空间" class="headerlink" title="创建一个命名空间"></a>创建一个命名空间</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>              <span class="comment"># kubernetes API v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span>             <span class="comment"># 表示定义一个namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">custom-namespace</span>    <span class="comment">#  命名空间的名字</span></span><br></pre></td></tr></table></figure>
<p>还是用原来的命令</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f custom-namespace.yaml</span><br><span class="line">namespace <span class="string">"custom-namespace"</span> created</span><br></pre></td></tr></table></figure>
<p>更方便的是使用命令咯 <code>kubectl create namespace custom-namespace</code></p>
<blockquote>
<p>只是要注意命名规范</p>
</blockquote>
<h4 id="管理其他命名空间中的对象"><a href="#管理其他命名空间中的对象" class="headerlink" title="管理其他命名空间中的对象"></a>管理其他命名空间中的对象</h4><p>如果想在刚创建的命名空间中创建资源, 可以选择在<code>yaml</code>文件的<code>metadata</code>字段添加一个<code>namespace: custom-namespace</code>属性, 也可以使用<code>kubectl create -f kubia-manual.yaml -n custom-namespace</code> 指定</p>
<p>这事我们有两个pod, 一个在<code>default</code>命名空间, 一个在<code>custom-namespace</code>命名空间</p>
<p><code>kubectl config</code>可以配置</p>
<h4 id="命名空间的隔离"><a href="#命名空间的隔离" class="headerlink" title="命名空间的隔离"></a>命名空间的隔离</h4><p>不提供,至少不是开箱即用/ 尽管命名空间将对象分隔到不同的组, 只允许你对属于特定命名空间的对象进行操作, 但实际上命名空间之间并不提供对正在运行的对象的任何隔离.</p>
<p>比如不同对象在不同命名空间中部署pod, 你觉得他们是隔离的, 但这个取决于kubernetes所使用的网络解决方案.</p>
<h3 id="停止和移除pod"><a href="#停止和移除pod" class="headerlink" title="停止和移除pod"></a>停止和移除pod</h3><h4 id="按名称删除"><a href="#按名称删除" class="headerlink" title="按名称删除"></a>按名称删除</h4><p>实际上是告诉kubernetes终止该pod中的所有容器. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="keyword">delete</span> po kubia-w22k7 <span class="comment">// 还能通过空格删多个</span></span><br><span class="line">pod <span class="string">"kubia-w22k7"</span> deleted</span><br></pre></td></tr></table></figure>
<h4 id="使用标签选择器来删pod"><a href="#使用标签选择器来删pod" class="headerlink" title="使用标签选择器来删pod"></a>使用标签选择器来删pod</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po --show-labels</span><br><span class="line">NAME              READY     STATUS    RESTARTS   AGE       LABELS</span><br><span class="line">kubia-drw74       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>m        run=kubia</span><br><span class="line">kubia-m9zfv       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">19</span>h       run=kubia</span><br><span class="line">kubia-manual      <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">15</span>h       creation_method=manual</span><br><span class="line">kubia-manual-v2   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>h        creation_method=manual,end=debug,env=prod</span><br><span class="line">kubia-q89qr       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">18</span>h       run=kubia</span><br><span class="line"></span><br><span class="line">$ kubectl <span class="keyword">delete</span> po -l creation_method</span><br><span class="line">pod <span class="string">"kubia-manual"</span> deleted</span><br><span class="line">pod <span class="string">"kubia-manual-v2"</span> deleted</span><br><span class="line"></span><br><span class="line">$ kubectl get po --show-labels      <span class="comment">// 状态变了, 正在停止</span></span><br><span class="line">NAME              READY     STATUS        RESTARTS   AGE       LABELS</span><br><span class="line">kubia-drw74       <span class="number">1</span>/<span class="number">1</span>       Running       <span class="number">0</span>          <span class="number">2</span>m        run=kubia</span><br><span class="line">kubia-m9zfv       <span class="number">1</span>/<span class="number">1</span>       Running       <span class="number">0</span>          <span class="number">19</span>h       run=kubia</span><br><span class="line">kubia-manual      <span class="number">1</span>/<span class="number">1</span>       Terminating   <span class="number">0</span>          <span class="number">15</span>h       creation_method=manual</span><br><span class="line">kubia-manual-v2   <span class="number">1</span>/<span class="number">1</span>       Terminating   <span class="number">0</span>          <span class="number">1</span>h        creation_method=manual,end=debug,env=prod</span><br><span class="line">kubia-q89qr       <span class="number">1</span>/<span class="number">1</span>       Running       <span class="number">0</span>          <span class="number">18</span>h       run=kubia</span><br></pre></td></tr></table></figure>
<h4 id="通过删除整个命名空间删pod"><a href="#通过删除整个命名空间删pod" class="headerlink" title="通过删除整个命名空间删pod"></a>通过删除整个命名空间删pod</h4><p><code>kubectl delete ns custom-namespace</code></p>
<h4 id="删除命名空间所有pod-但命名空间要留着"><a href="#删除命名空间所有pod-但命名空间要留着" class="headerlink" title="删除命名空间所有pod, 但命名空间要留着"></a>删除命名空间所有pod, 但命名空间要留着</h4><p>通过<code>--all</code>删除当前命名空间的素有pod</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubia-drw74   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">4</span>m</span><br><span class="line">kubia-m9zfv   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">19</span>h</span><br><span class="line">kubia-q89qr   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">18</span>h</span><br><span class="line"></span><br><span class="line">$ kubectl <span class="keyword">delete</span> po --all</span><br><span class="line">pod <span class="string">"kubia-drw74"</span> deleted</span><br><span class="line">pod <span class="string">"kubia-m9zfv"</span> deleted</span><br><span class="line">pod <span class="string">"kubia-q89qr"</span> deleted</span><br></pre></td></tr></table></figure>
<p>但是鸡儿还有3个, 但不是原来的名字的pod, 看AGE还是新建的. 问题是一开始我们用<code>ReplicationController</code>的问题, 她会保持3个配额的. 所以删除整个<code>ReplicationController</code>先</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubia<span class="number">-7</span>xgdg   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">46</span>s</span><br><span class="line">kubia-rh2vj   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">46</span>s</span><br><span class="line">kubia-xkm76   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">46</span>s</span><br></pre></td></tr></table></figure>
<h4 id="删除命名空间中几乎所有资源"><a href="#删除命名空间中几乎所有资源" class="headerlink" title="删除命名空间中几乎所有资源"></a>删除命名空间中几乎所有资源</h4><p>直接是<code>all -all</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="keyword">delete</span> all --all</span><br><span class="line">pod <span class="string">"kubia-7xgdg"</span> deleted</span><br><span class="line">pod <span class="string">"kubia-rh2vj"</span> deleted</span><br><span class="line">pod <span class="string">"kubia-xkm76"</span> deleted</span><br><span class="line">replicationcontroller <span class="string">"kubia"</span> deleted</span><br><span class="line">service <span class="string">"kubernetes"</span> deleted</span><br><span class="line">service <span class="string">"kubia-http"</span> deleted</span><br></pre></td></tr></table></figure>
<p>第一个all是所有资源类型<br>第二个all是所有资源实例(并不是完全删, 还有一些会剩下)</p>
<h3 id="4-章-副本机制和其他控制器"><a href="#4-章-副本机制和其他控制器" class="headerlink" title="4 章 副本机制和其他控制器"></a>4 章 副本机制和其他控制器</h3><p>kubernetes的主要好处就是可一个kubernetes一个容器列表来由其保持容器在集群中的运行.</p>
<p>只要将pod调度到某个节点, 该节点上的kubelet就会运行pod的容器, 从此只要该pod存在, 就会保持运行.</p>
<h4 id="4-1-存活探针"><a href="#4-1-存活探针" class="headerlink" title="4.1 存活探针"></a>4.1 存活探针</h4><p>kubernetes可以通过使用探针 liveness probe 检查容器是否还在运行. 可以为pod中的每个容器单独指定存活探针, 如果探测失败, kubernetes将定期执行探针并重新启动容器.</p>
<blockquote>
<p>还支持就绪探针 readiness probe 不要搞混.</p>
</blockquote>
<p>有3种探测容器的机制</p>
<ul>
<li>HTTP GET 探针对容器的IP地址(你指定的端口和路径)执行HTTP GET请求.</li>
<li>TCP 套接字探针尝试与容器指定端口建立TCP连接.</li>
<li>Exec 探针在容器内执行任意命令, 并检查命令的退出状态码.</li>
</ul>
<h5 id="创建HTTP的存活探针"><a href="#创建HTTP的存活探针" class="headerlink" title="创建HTTP的存活探针"></a>创建HTTP的存活探针</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>              <span class="comment"># kubernetes API v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                   <span class="comment"># 是一个pod</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment"># </span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-liveness</span>     <span class="comment"># pod名称</span></span><br><span class="line"><span class="attr">spec:</span>                       <span class="comment"># pod规格 / 内容(pod的容器列表, volume等)</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">luksa/kubia-unhealthy</span>     <span class="comment"># 容器所用镜像</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span>             <span class="comment"># 容器名</span></span><br><span class="line"><span class="attr">    livenessProbe:</span>          <span class="comment"># 一个存活探针</span></span><br><span class="line"><span class="attr">      httpGet:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/</span>             <span class="comment"># http请求路径</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p>然后就是创建, 接着查看pod</p>
<p>还有查看log, 加上—previous可以看前一个容器的日志.</p>
<p>在用describe中可以看到错误码 Exit code 137这种. 还有附加信息显示. 在yaml中也可以配置<br>137是128+x</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>              <span class="comment"># kubernetes API v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                   <span class="comment"># 是一个pod</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment"># </span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-liveness</span>     <span class="comment"># pod名称</span></span><br><span class="line"><span class="attr">spec:</span>                       <span class="comment"># pod规格 / 内容(pod的容器列表, volume等)</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">luksa/kubia-unhealthy</span>     <span class="comment"># 容器所用镜像</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span>             <span class="comment"># 容器名</span></span><br><span class="line"><span class="attr">    livenessProbe:</span>          <span class="comment"># 一个存活探针</span></span><br><span class="line"><span class="attr">      httpGet:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/</span>             <span class="comment"># http请求路径</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      initialDelaySeconds:</span> <span class="number">15</span>   <span class="comment"># 会在第一次探测前等待15秒</span></span><br></pre></td></tr></table></figure>
<p>一般都会设置延迟, 保证应用程序已经启动了running的状态</p>
<h4 id="4-2-了解ReplicationController"><a href="#4-2-了解ReplicationController" class="headerlink" title="4.2 了解ReplicationController"></a>4.2 了解ReplicationController</h4><p>ReplicationController是一种 kubernetes 资源, 可确保它的pod始终保持运行.</p>
<p>图4.1</p>
<h5 id="ReplicationController的操作"><a href="#ReplicationController的操作" class="headerlink" title="ReplicationController的操作"></a>ReplicationController的操作</h5><p>ReplicationController不是根据pod类型来操作的, 而是根据pod是否匹配某个标签选择器<br>他的工作是确保pod的数量始终与其标签选择器匹配.</p>
<p>有3个部分:</p>
<ul>
<li>label selector: 用于确定 ReplicationController 作用域中有哪些pod</li>
<li>replica count: 指定运行的pod数量</li>
<li>pod template: 用于创建新的pod副本模板</li>
</ul>
<p>图4.3</p>
<p>都可以随时修改, 只有副本数会影响现有的pod, 更改标签和模板不会对于现有pod没有影响. 更改标签只是会使现有的pod脱离ReplicationController的范围, ReplicationController也不影响pod的内容, 在模板影响的是ReplicationController创建新的pod</p>
<p>使用ReplicationController的好处是:</p>
<ul>
<li>确保一个pod持续运行, 现有的pod丢失时会重启一个新的pod</li>
<li>集群节点故障时, 会为故障节点上运行的所有pod创建替代副本</li>
<li>能轻松实现pod的水平伸缩</li>
</ul>
<p>4.2.2 创建一个ReplicationController</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>              <span class="comment"># kubernetes API v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span> <span class="comment"># 是一个ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment">#</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia</span>               <span class="comment"># 名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span>                 <span class="comment"># pod选择器决定了RC的操作对象</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span>               <span class="comment"># 这里的标签要和selector的对应</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">kubia</span>             <span class="comment"># 容器名</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">ximage/kubia</span>     <span class="comment"># 容器所用镜像</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8080</span>   <span class="comment"># 监听端口</span></span><br></pre></td></tr></table></figure>
<p>kubernetes会创建一个名为kubia的新的 ReplicationController , 确保符合标签选择器<code>app: kubia</code>的pod实例始终未3个.<br>模板中的pod标签显然必须和 ReplicationController 的标签选择器匹配, 否则会无休止地创建地新的容器. API服务也会校验的.<br>不需要指定pod选择器</p>
<p>4.2.3 使用 ReplicationController</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line">kubectl <span class="keyword">delete</span> pod &lt;pod名&gt; 看下ReplicationController生效没</span><br><span class="line"></span><br><span class="line">kubectl get rc</span><br><span class="line"></span><br><span class="line">kubectl describe rc kubia</span><br></pre></td></tr></table></figure>
<p>控制器对删除操作的反应是新建一个, 但他没有对删除本身做出反应, 而是针对由此产生的状态 - pod数量不足.<br>虽然ReplicationController会立即收到删除pod的通知, 但这个不是他创建替代pod的原因, 改通知会触发控制器检查实际的pod数量并采取适当的措施.</p>
<p>模拟节点故障, 多个节点的情况下, minikube和docker不性, 用<code>sudo ifconfig eht0 down</code>关网卡</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node    # 看status NotReady 因为网断开了</span><br><span class="line">kubectl get pods    # 看status 变unknown 因为无法访问</span><br></pre></td></tr></table></figure>
<p>4.2.4 将pod移入或移出ReplicationController的作用域</p>
<p>由ReplicationController创建的pod并不是绑定到ReplicationController, 而是管理与标签选择器匹配的pod, 所以通过selector</p>
<blockquote>
<p>虽然一个pod没有绑定到ReplicationController, 但该pod的<code>meta.ownerReference</code>中引用了, 同个这个字段找pod属于哪个ReplicationController</p>
</blockquote>
<p>在你改了一个pod的标签后, 就不归原来的ReplicationController管了, 只不过ReplicationController发现它少了一个pod后, 会重新启一个新的pod</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl label pod kubia-dmdck type=special</span><br><span class="line"></span><br><span class="line">kubectl get pods --show-labels</span><br><span class="line"></span><br><span class="line">kubectl label pod kubia-dmdck app=foo --overwrite</span><br></pre></td></tr></table></figure>
<p><code>--overwrite</code>是必要的, 防止你错改标签, 记住该标签只是第一步</p>
<p>如果直接改了ReplicationController的标签选择器呢, 相当于原来的pod都脱离控制, 但还是运行, 然后ReplicationController再创建副本数量的新的pod</p>
<p>4.2.5 修改pod模板</p>
<p>ReplicationController的pod模板可以随时修改, 更改pod的模板只会影响后面创建的pod, 不会影响原来的, 不要原来的你可以删掉.<br>图4.6</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit rc kubia     # 弹出一个yaml配置的, 修改</span><br></pre></td></tr></table></figure>
<p>配置<code>KUBE_EDITOR</code>环境变量来告诉kubectl你要用的文本编辑器</p>
<p>4.2.6 水平缩放pod</p>
<p>扩容缩容的意思</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale rc kubia --replicas=<span class="number">10</span></span><br><span class="line"></span><br><span class="line">kubectl edit rc kubia   # 通过编辑定义 找到spec.replicas</span><br><span class="line"></span><br><span class="line">kubectl get rc</span><br></pre></td></tr></table></figure>
<p>4.2.7 删除</p>
<p>通过<code>kubectl delete</code> 删除ReplicationController时, pod也会被删除, 但由于由 ReplicationController 创建的pod不是 ReplicationController 的组成部分, 只是由其所管理, 因此可以只删除 ReplicationController 而保持pod运行.</p>
<p>在<code>kubectl delete</code>时增加<code>--cascade=false</code>来保持pod的运行.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">delete</span> rc kubia --cascade=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="4-3-使用ReplicaSet而不是ReplicationController"><a href="#4-3-使用ReplicaSet而不是ReplicationController" class="headerlink" title="4.3 使用ReplicaSet而不是ReplicationController"></a>4.3 使用ReplicaSet而不是ReplicationController</h4><p>新一代的ReplicationController. 通常不会直接创建他, 而是在创建更高层级的<code>Deployment</code>资源时自动创建他们.</p>
<p>ReplicaSet的行为和ReplicationController完全相同, 但pod选择器的表达能力更强.<br>ReplicationController的标签选择器只允许包含某个标签的匹配pod, <strong>但ReplicaSet的选择器还允许匹配缺少某个标签的pod, 或包含特定签名的pod, 不管其值如何.</strong></p>
<p>如ReplicationController不能同时匹配env=1和env=2的, 只能2选1, 但ReplicaSet可以<br>ReplicationController不能基于标签名字来, 可以理解为env=*</p>
<p>定义</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span>    <span class="comment"># 新的版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationSet</span>        <span class="comment"># 是一个ReplicationSet</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment">#</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia</span>               <span class="comment"># 名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">kubia</span>              <span class="comment"># 使用了更简单的matchLabels选择器</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">kubia</span>             <span class="comment"># 容器名</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">ximage/kubia</span>     <span class="comment"># 容器所用镜像</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8080</span>   <span class="comment"># 监听端口</span></span><br></pre></td></tr></table></figure>
<p>注意这里不是v1 API的一部分, 因此在创建资源时要指定正确的apiVersion<br>还有唯一区别就是在选择器上, 不必在selector属性中直接列出pod需要的标签, 而是在selector.matchLabels下指定他们</p>
<p>关于API版本的属性<br>apiVersion属性指定两件事情</p>
<ul>
<li>API组(apps)</li>
<li>实际的API版本(v1beta2)</li>
</ul>
<p>后面会看到某些kubernetes资源位于所谓的核心API组中, 改组不需要在APIVersion字段中指定<br>有好几个API组.</p>
<p>也是一样通过<code>kubectl create</code>创建后通过<code>kubectl get rs</code>和<code>kubectl describe rs</code>来检查</p>
<p>前面的matchLabels没啥区别, 用matchExpressions属性来重写选择器.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">  marchExpressions:</span></span><br><span class="line"><span class="attr">    - key:</span> <span class="string">app</span>        <span class="comment"># 选择器要求该pod包含名为app的标签</span></span><br><span class="line"><span class="attr">      operator:</span> <span class="string">In</span></span><br><span class="line"><span class="attr">      values:</span>         <span class="comment"># 标签的值必须是kubia</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure>
<p>这里给选择器添加额外的表达式, 每个表达式必须包含一个key, 一个operator, 可能还有一个values(取决于运算符)<br>4个有效的运算符</p>
<ul>
<li>In: label的值必须与其中一个指定的values匹配.</li>
<li>NotIn: label值与任何指定的values不匹配</li>
<li>Exists: pod必须包含一个指定名称的标签, 值不重要, 使用这个运算符时, 不应指定values字段</li>
<li>DoesNotExist: pod不得包含指定名称的标签, values也不能有.</li>
</ul>
<p>指定了多个表达式时, 这些所有的运算符都得为true时才能使选择器和pod匹配.<br>如果同时指定了matchLabels和matchExpressions, 则所有标签必须要匹配, 表达式也要匹配.</p>
<p>删除也一样, <code>kubectl delete rs kubia</code></p>
<h4 id="4-4-使用DaemonSet在每一个节点上运行一个pod"><a href="#4-4-使用DaemonSet在每一个节点上运行一个pod" class="headerlink" title="4.4 使用DaemonSet在每一个节点上运行一个pod"></a>4.4 使用DaemonSet在每一个节点上运行一个pod</h4><p>ReplicaSet的行为和ReplicationController在kubernetes集群上运行部署特定数量的pod, 当你希望pod在每个节点上运行时.<br>这些情况包括pod执行系统级别的与基础结构相关的操作. 例如希望在每个节点上运行日志收集器和资源监控器, 另一个例子是kubernetes的<code>kube-proxy</code>进程<br>在kubernetes之外, 此类进程通常在节点启动期间, 通过系统初始化脚本或<code>systemd</code>守护进程启动. 当然可以在kubernetes节点上用<code>systemd</code>运行系统进程, 但这样就不能利用所有的kubernetes特性了.</p>
<p>用DaemonSet好了, 除了又DaemonSet创建的pod, 已经有一个指定的目标节点并跳过kubernetes调度程序.<br>DaemonSet确保能够创建足够的pod, 并在自己的节点上部署每个pod<br>图4.8</p>
<blockquote>
<p>尽管ReplicaSet确保集群中存在期望数量的pod副本, 但DaemonSet并没有期望的副本数的概念, 他不需要, 因为他的工作是确保一个pod匹配它的选择器并在每个节点上运行.</p>
</blockquote>
<p>如果节点下线, DaemonSet不会在其他地方重新创建pod, 如果新节点加入或删了pod, 那么会重新创建一个新的pod</p>
<p>4.4.2 使用DaemonSet只在特定节点上运行pod</p>
<p>通过在pod模板的<code>nodeSelector</code>属性上知道你个</p>
<p>后面可以设置节点为不可调度, 防止pod被部署到节点上. 但DaemonSet可以将节点部署到这些不可调度的节点上, 因为无法调度的属性只会被调度器使用, 而DaemonSet管理的pod则完全绕过调度器, 这是预期的, 因为DaemonSet的目的是运行系统服务, 即使是在不可调度的节点上, 系统服务通常也需要运行.</p>
<p>图4.9是一个ssd-monitor的例子</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span>    <span class="comment"># 新的版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span>             <span class="comment"># 是一个DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment">#</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ssd-monitor</span>         <span class="comment"># 名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">ssd-monitor</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">ssd-monitor</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      nodeSelector:</span>         <span class="comment"># pod模板会包含一个节点选择器, 会选择有disk=ssd标签的节点</span></span><br><span class="line"><span class="attr">        disk:</span> <span class="string">ssd</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">main</span>                <span class="comment"># 容器名</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">luksa/ssd-monitor</span>  <span class="comment"># 容器所用镜像</span></span><br></pre></td></tr></table></figure>
<p>这个DaemonSet将运行一个基于luksa/ssd-monitor容器镜像的单容器pod, 该pod的实例在每个具有disk=ssd标签的节点上创建</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f ssd-monitor.yaml</span><br><span class="line"></span><br><span class="line">kubectl get ds</span><br><span class="line"></span><br><span class="line">kubectl get po</span><br></pre></td></tr></table></figure>
<p>这事并没有pod, 还需要给节点打上disk=ssd的标签, 打上标签后, DaemonSet将检测到节点的标签已经更改, 并将pod部署到有匹配标签的所有节点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node minikube disk=ssd</span><br></pre></td></tr></table></figure>
<p>删除节点, 就改下标签名</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node minikube disk=hdd --overwrite</span><br></pre></td></tr></table></figure>
<p>删除DaemonSet也会删除pod的</p>
<blockquote>
<p>目前为止的都是持续运行的pod, ReplicationController和ReplicaSet和DaemonSet都是持续运行, 永远不会达到完成状态, pod退出后再重新启动, 一个可完成任务是进程终止后不应该再重新启动的.</p>
</blockquote>
<p>后面就是job资源, 允许你运行一种pod, 改pod在内部进程成功结束时, 不重启容器, 一旦任务完成, pod就被认为处于完成状态.<br>如果是异常退出, 可以按照ReplicaSet的pod方式重新安排到其他节点, 如果是进程本身异常退出, 错误退出码, 可以将job配置为重新启动容器<br>对临时任务很有用, 关键是任务要以正确的方式结束.</p>
<p>4.5 job</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span>        <span class="comment"># 新的版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span>                   <span class="comment"># 是一个DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment">#</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">batch-job</span>           <span class="comment"># 名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span>                 <span class="comment"># 没有指定pod选择器, 根据模板创建</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">batch-job</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">OnFailure</span>  <span class="comment"># job不能使用Always为默认的重新启动策略, 三种还有Never</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">main</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">luksa/batch-job</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl get jobs</span><br><span class="line"></span><br><span class="line">kubectl get po</span><br><span class="line"></span><br><span class="line">kubectl get po -a   # --show-all 显示completed</span><br><span class="line"></span><br><span class="line">kubectl logs batch-job<span class="number">-28</span></span><br></pre></td></tr></table></figure>
<p>作业可以配置创建多个pod实例, 并可以串行或并行来运行他们, 通过配置<code>completions</code>和<code>parallelism</code>属性</p>
<p>顺序运行job pod</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span>        <span class="comment"># 新的版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span>                   <span class="comment"># 是一个DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment">#</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">multi-completino-batch-job</span>           <span class="comment"># 名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  completions:</span> <span class="number">5</span>            <span class="comment"># 在这里指定次作业顺序运行5个pod</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">batch-job</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">OnFailure</span>  <span class="comment"># job不能使用Always为默认的重新启动策略, 三种还有Never</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">main</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">luksa/batch-job</span></span><br></pre></td></tr></table></figure>
<p>是指正确运行5个, 如果pod有失败的, 会重新启动</p>
<p>下面可以指定同时有2个可以并行, 一共完成5个</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span>        <span class="comment"># 新的版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span>                   <span class="comment"># 是一个DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment">#</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">multi-completino-batch-job</span>           <span class="comment"># 名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  completions:</span> <span class="number">5</span>            <span class="comment"># 在这里指定次作业顺序运行5个pod</span></span><br><span class="line"><span class="attr">  parallelism:</span> <span class="number">2</span>            <span class="comment"># 最多两个pod可以并行运行</span></span><br></pre></td></tr></table></figure>
<p>缩放也是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale job multi-completion-batch-job --replicas <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>设置完成时间 用<code>activeDeadlineSeconds</code>属性 设置超时时间, 并标记为失败</p>
<blockquote>
<p>可以配置job manifest的<code>spec.backoffLimit</code>字段来配置失败前的重试次数, 默认6次</p>
</blockquote>
<p>4.6 安排定期运行或在将来运行一次</p>
<p>job一般是在创建时立即运行pod, 有些批处理的, 需要在特定时间运行或在指定时间间隔内重复运行. 在linux系统内这些任务称为cron任务</p>
<p>kubernetes的cron任务通过CronJob资源进行配置. 用cron格式指定.<br>在配置时间时, kubernetes将根据在CronJob对象中配置的job模板创建job资源, 创建job资源时, 将根据任务的pod模板创建并启动一个或多个pod副本</p>
<p>例如</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span>         <span class="comment"># 新的版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span>                     <span class="comment"># 是一个CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">batch-job-every-fifteen-minutes</span>          <span class="comment"># 名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  schedule:</span> <span class="string">"0,15,30,45 * * * *"</span>  <span class="comment"># 在每天每小时的15, 30, 45, 分钟运行</span></span><br><span class="line"><span class="attr">  jobTemplate:</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      template:</span></span><br><span class="line"><span class="attr">        metadata:</span></span><br><span class="line"><span class="attr">          labels:</span></span><br><span class="line"><span class="attr">            app:</span> <span class="string">periodic-batch-job</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">          restartPolicy:</span> <span class="string">OnFailure</span>  <span class="comment"># job不能使用Always为默认的重新启动策略, 三种还有Never</span></span><br><span class="line"><span class="attr">          containers:</span></span><br><span class="line"><span class="attr">          - name:</span> <span class="string">main</span></span><br><span class="line"><span class="attr">            image:</span> <span class="string">luksa/batch-job</span></span><br></pre></td></tr></table></figure>
<p>并不是特别复杂</p>
<p>cron时间格式表<br>从左到右包含5个</p>
<ul>
<li>分钟</li>
<li>小时</li>
<li>每月中的第几天</li>
<li>月</li>
<li>星期几</li>
</ul>
<p><code>&quot;0,15,30,45 * * * *&quot;</code> 看星号</p>
<p>在计划的时间内, CronJob资源会创建job资源, 然后job创建pod<br>可能发生job或pod创建并运行得相对较晚的情况, 可以有要求, 任务开始不能落后预定的时间过多, 通过<code>startingDeadlineSeconds</code>来指定截止日期</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span>         <span class="comment"># 新的版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span>                     <span class="comment"># 是一个CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">batch-job-every-fifteen-minutes</span>          <span class="comment"># 名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  schedule:</span> <span class="string">"0,15,30,45 * * * *"</span>  <span class="comment"># 在每天每小时的15, 30, 45, 分钟运行</span></span><br><span class="line"><span class="attr">  startingDeadlineSeconds:</span> <span class="number">15</span>     <span class="comment"># pod最迟必须在预定时间后15秒开始运行</span></span><br><span class="line"><span class="attr">  jobTemplate:</span></span><br></pre></td></tr></table></figure>
<h3 id="第5章-服务-让客户端发现pod并与之通信"><a href="#第5章-服务-让客户端发现pod并与之通信" class="headerlink" title="第5章:服务 让客户端发现pod并与之通信"></a>第5章:服务 让客户端发现pod并与之通信</h3><ul>
<li>创建服务资源, 利用单个地址访问一组pod</li>
<li>发现集群中的服务</li>
<li>将服务公开给外部客户端</li>
<li>从集群内部连接外部服务</li>
<li>控制pod是与服务关联</li>
<li>排除服务故障</li>
</ul>
<p>现在已经学习过了pod, 以及如何通过ReplicaSet和类似资源部署运行.尽管特定的pod可以独立地应对外部刺激, <strong>现在大多数应用都需要根据外部请求做出响应.</strong>例如就微服务而言, pod通常需要对来自集群内部其他pod,以及来自集群外部的客户端HTTP请求做出响应.</p>
<p>pod需要一种寻求其他pod的方法来使用其他pod提供的服务, 不像在没有kubernetes的世界, 没有那种指定IP地址的方法</p>
<ul>
<li>pod是短暂的: 他们会随时启动或者关闭, 无论为了给其他pod提供空间而从节点中被移除 或者是减少了pod的数量, 又或者是因为集群中存在节点异常</li>
<li>kubernetes在pod启动前会给已经调度到节点上的pod分配IP地址: 因此客户端不能提前知道提供服务的pod的IP地址</li>
<li>水平伸缩意味着多个pod可能会提供相同的服务: 每个pod都有自己的IP地址, 客户端无需关心后端提供服务pod的数量, 以及各自应对的IP地址, 他们无须记录每个pod的IP地址, 相反, 所有的pod可以通过一个单一的IP地址进行访问.</li>
</ul>
<p>解决上述问题, kubernetes提供了一种资源, 叫服务service</p>
<p>服务是一种为一组功能相同的pod提供单一不变的接入点的资源. 当服务存在时, 它的IP地址和端口不会改变.<br>图5.1</p>
<p>服务的后端可以有不止一个pod, 服务的连接对所有的后端pod是负载均衡的.</p>
<p>使用<code>kubectl expose</code>来创建服务, 还可以用yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span>          <span class="comment"># 该服务的可用端口</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8080</span>  <span class="comment"># 服务将连接转发到容器端口</span></span><br><span class="line"><span class="attr">  selector:</span>           <span class="comment"># 具有app=kubia标签的pod都属于该服务</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure>
<p>创建了一个叫kubia的服务, 他将在端口80接受请求并将连接路由到具有标签选择器是app=kubia的pod的8080端口上</p>
<p>用<code>kubectl create</code>创建后, <code>kubectl get svc</code>看下服务</p>
<p>会分配一个集群内的IP地址, 只能在集群内部可以被访问. 服务的主要目标就是使用集群内部的其他pod可以访问当前这组pod, 但通常也希望对外暴露服务.</p>
<p>从内部集群测试服务</p>
<ul>
<li>显而易见的方法是创建一个pod, 他将请求发送到服务的集群IP并记录响应, 可以通过查看pod日志检查服务的响应</li>
<li>可使用ssh远程登录到其中一个kubernetes节点上, 然后使用curl命令</li>
<li>可以通过<code>kubectl exec</code>命令在一个已经存在的pod中执行<code>curl</code>命令</li>
</ul>
<p>使用<code>kubectl get pod</code>列出所有pod, 选择其中一个作为exec的执行目标</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec kubia<span class="number">-7</span>nog -- curl -s http:<span class="comment">//10.111.249.154</span></span><br></pre></td></tr></table></figure>
<p><code>--</code>双横杠代表kubectl命令项的结束, 在两个横杠之后的内容是指在pod内部需要执行的命令.<br><code>-s</code>表示需要连接一个不同的API服务器而不是默认的<br>图5.3</p>
<p>通常如果多次执行同样的命令, 每次调用执行应该在不同的pod上, 因为服务代理通常将每个连接随机指向选中的后端pod中的一个, 即使连接来自同一个客户端.<br>如果希望特定客户端产生的所有请求每次都指向同一个pod, 可以设置服务的<code>sessionAffinity</code>属性为<code>ClientIP</code>而不是None默认值</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  sessionAffinity:</span> <span class="string">ClientIP</span></span><br></pre></td></tr></table></figure>
<p>kubernetes仅支持两种形式的会话亲和性服务: None和ClientIP, 不支持cookie的会话哦, 因为kubernetes不是在HTTP层面上.服务处理TCP和UDP包,并不关心其中的内容, cookie是HTTP的一部分, 所有服务并不知道他们.</p>
<p>创建一个服务可暴露一个端口, 也可以暴露多个端口. 通过一个集群IP, 使用一个服务就可以将多个端口全部暴露出来.</p>
<blockquote>
<p>创建一个有多个端口的服务的时候, 必须给每个端口指定名字</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure>
<p>标签选择器应用于整个服务, 不能对每个端口做单独的配置. 如果不同的pod有不同的端口映射关系, 需要创建两个服务.</p>
<p>使用命名的端口</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span>          <span class="comment"># 端口8080被命名为http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="string">http</span>  <span class="comment"># 将端口80映射到容器中被称为http的端口</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure>
<p>最大的好处就是即使更换端口号也无需更改服务spec</p>
<h4 id="5-1-2服务发现"><a href="#5-1-2服务发现" class="headerlink" title="5.1.2服务发现"></a>5.1.2服务发现</h4><p>通过创建服务, 现在就可以通过一个单一稳定的IP地址访问到pod.<br>客户端pod如何知道服务的IP和端口, 是否需要先建服务, 然后手动, 不是, kubernetes还为客户端提供了发现服务的IP和端口的方式</p>
<p>通过环境变量发现服务: 在pod开始运行的时候,  kubernetes会初始化一系列的环境变量指向现有存在的服务.如果你创建的服务早于客户端pod的创建, pod上的进程可以根据环境变量获得服务的IP地址和端口号.</p>
<p>在一个运行pod上检查环境, 去了解这些环境变量. 比如现在已经了解到了通过<code>kubectl exec</code>在pod上运行一个命令, 但由于服务的创建晚于pod的创建, 所有有关服务的变量并没有设置. 要解决这个问题.</p>
<p>在查看服务的环境变量之前, 首先需要删除所有的pod使ReplicationController创建全新的pod, 在无须知道pod的名字下删除所有pod</p>
<p><code>kubectl delete po --all</code></p>
<p>然后列出所有的新pod, 然后选择一个运行<code>kubectl exec</code>进入, 运行<code>env</code>列出所有的环境变量.</p>
<p><code>kubectl exec kubia-1ni env</code></p>
<p>会有</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KUBIA_SERVICE_HOST=10.111.249.153   # 服务的集群IP</span><br><span class="line">KUBIA_SERVICE_PORT=80               # 服务所在端口</span><br></pre></td></tr></table></figure>
<p>通过<code>kubectl get svc</code>可以看有哪些服务, 用env看服务都是名字开头的, 代表KUBIA服务的IP地址和端口号.</p>
<p>比如前面的前端获取后端的, 就是靠这个知道访问的IP和端口.</p>
<blockquote>
<p>服务是 下划线, 全大写.</p>
</blockquote>
<p>环境变量是获得服务IP地址和端口号的一种方式, 还有DNS</p>
<p>在<code>kube-system</code>命名空间下列出所有的名称, 有一个pod被称为<code>kube-dns</code>, 这个pod就运行DNS服务, 在集群中的其他pod都被配置成使用其作为dns(可以通过修改每个容器的<code>/etc/resolv.conf</code>文件来实现)<br>运行在pod上的进程DNS查询都会被kubernetes自身的DNS服务器响应, 该服务器知道系统中运行的所有服务.</p>
<blockquote>
<p>pod是否使用内部的DNS服务器是根据pod中spec的dnsPolicy属性来定义的.</p>
</blockquote>
<p>通过FQDN连接服务</p>
<p>前端的pod可以通过打开以下FQDN的链接来访问后端数据库服务<code>backend-database.default.svc.cluster.local</code><br>backend-database对应于服务名称, default表示服务在其中定义的名称空间, svc.cluster.local是在所有集群本地服务名称中使用的可配置集群域后缀.</p>
<blockquote>
<p>注意, 客户端仍然必须知道服务的端口号, 如果服务使用标准端口号(比如HTTP 80, Postgres 5432),这样没问题, 如果并不是标准端口, 客户端可以从环境变量中获取端口号.</p>
</blockquote>
<p>连接一个服务可能比这更简单, 如果前端pod和数据库pod在同一个命名空间下, 可以省略<code>svc.cluster.local</code>后缀, 甚至命名空间.因此可以使用<code>backend-database</code>来指代服务</p>
<p>在pod容器中运行shell</p>
<p>通过<code>kubectl exec</code>在一个pod容器上运行bash, 加上<code>-it</code></p>
<p><code>kubectl exec -it kubia-3inly bash</code> 进入后再使用<code>curl http://kubia.default.svc.cluster.local</code></p>
<p><code>curl http://kubia.default</code>, <code>curl http://kubia</code></p>
<p>在请求的URL中, 可以将服务的名称作为主机名来访问服务, 因为根据每个pod容器DNS解析器配置的方法, 可以将命名空间和<code>svc.cluster.local</code>后缀省略掉, 看容器的<code>/etc/resilv/conf</code>文件</p>
<blockquote>
<p><strong>无法ping通服务IP的原因</strong>, curl是可以的, ping不行, 因为服务的集群IP是一个虚拟IP, 并且只有在于服务端口结合时才有意义.</p>
</blockquote>
<p>5.2 连接集群外部的服务</p>
<p>希望通过kubernetes服务特性暴露外部服务的情况, 不要让服务将连接重定向到集群中的pod, 而是让他重定向到外部IP和端口.<br>这样做可以让你充分利用服务负载平衡和服务发现. 在集群中运行的客户端pod可以像连接到内部服务一样连接到外部服务.</p>
<p>5.2.1 服务endpoint</p>
<p>再说下服务, 服务并不是和pod直接相连的,相反, 有一种资源介于两者之间, 他就是<code>endpoint</code>, 用<code>kubectl describe svc kubia</code>可以看到有个<code>Endpoints</code></p>
<p>Endpoint资源就是暴露一个服务的IP地址和端口列表, 和其他kubernetes资源一样, 都可以用<code>kubectl info</code>来看 <code>kubectl get endpoint kubia</code><br>尽管在spec服务中定义了pod选择器, 但在重定向传入连接时不会直接使用它, 相反, 选择器用于构建IP和端口列表, 然后存储在Endpoint资源中. 当客户端连接到服务器时, 服务代理选择这些IP和端口对中的一个, 并将传入连接重定向到该位置监听的服务器.</p>
<p>5.2.2 手动配置服务的endpoint</p>
<p>服务的endpoint与服务解耦后, 可以分别手动配置和更新他们.</p>
<p>5.3 将服务暴露给外部客户端</p>
<p>3种</p>
<ul>
<li>将服务的类型设置成NodePort</li>
<li>将服务的类型设置为LoadBalance</li>
<li>创建一个Ingress资源</li>
</ul>
<p>5.4 通过Ingress暴露服务</p>
<p>图5.9</p>
<p>要有Ingress控制器才能控制Ingress资源</p>
<p><code>kubectl get po --all-namespace</code></p>
<p><code>kubectl get ingresses</code></p>
<p>配置Ingress处理TLS传输 HTTPS</p>
<p><code>kubectl apply -f kubia-ingress-tls.yaml</code>使用文件中指定内容来更新Ingress资源, 而不是通过删除并从新文件重新创建的方式.</p>
<p>就绪探针</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1120412" target="_blank" rel="noopener">基于Docker for macOS的Kubernetes本地环境搭建与应用部署</a><br><a href="https://cloud.tencent.com/developer/article/1077486" target="_blank" rel="noopener">Docker集群编排工具之Kubernetes（K8s）介绍、安装及使用</a><br><a href="https://blog.docker.com/2018/01/docker-mac-kubernetes/" target="_blank" rel="noopener">DOCKER FOR MAC WITH KUBERNETES</a><br><a href="http://docs.kubernetes.org.cn/" target="_blank" rel="noopener">Kubernetes中文社区 | 中文文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/yarn的使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/yarn的使用/" itemprop="url">yarn的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T19:32:25+08:00">2019-03-05</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端教程/" itemprop="url" rel="index"><span itemprop="name">前端教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="yarn的使用"><a href="#yarn的使用" class="headerlink" title="yarn的使用"></a>yarn的使用</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化新项目</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn init</span><br></pre></td></tr></table></figure>
<p>添加依赖包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add [package]</span><br><span class="line">yarn add [package]@[version]</span><br><span class="line">yarn add [package]@[tag]</span><br></pre></td></tr></table></figure>
<p>将依赖项添加到不同依赖项类别</p>
<p>分别添加到 <code>devDependencies</code>、<code>peerDependencies</code> 和 <code>optionalDependencies</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add [package] --dev/-D</span><br><span class="line">yarn add [package] --peer/-P</span><br><span class="line">yarn add [package] --optional/-O</span><br></pre></td></tr></table></figure>
<p>全局安装</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add &lt;package...&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>yarn add global &lt;package...&gt;</code>会变成本地安装，注意顺序。</p>
</blockquote>
<p>升级依赖包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn upgrade [package]</span><br><span class="line">yarn upgrade [package]@[version]</span><br><span class="line">yarn upgrade [package]@[tag]</span><br></pre></td></tr></table></figure>
<p>移除依赖包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn remove [package]</span><br></pre></td></tr></table></figure>
<p>安装项目的全部依赖</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">yarn install</span><br></pre></td></tr></table></figure>
<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><h4 id="yarn-cache"><a href="#yarn-cache" class="headerlink" title="yarn cache"></a>yarn cache</h4><p>运行 <code>yarn cache dir</code>会打印出当前的 yarn 全局缓存在哪里。</p>
<p><code>yarn cache list --pattern &lt;pattern&gt;</code> 将列出匹配指定模式的已缓存的包。</p>
<p>示例：<code>yarn cache list --pattern &quot;gulp-(match|newer)&quot;</code></p>
<p><code>yarn cache clean</code>运行此命令将清除全局缓存。</p>
<p>将在下次运行 <code>yarn</code> 或 <code>yarn install</code> 时重新填充。</p>
<h4 id="yarn-list"><a href="#yarn-list" class="headerlink" title="yarn list"></a>yarn list</h4><p><code>yarn list [--depth] [--pattern]</code></p>
<p>默认情况下，所有包和它们的依赖会被显示。 <strong>要限制依赖的深度</strong>，你可以给 <code>list</code> 命令添加一个标志 <code>--depth</code> 所需的深度。<br>示例: <code>yarn list --depth=0</code></p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><h4 id="yarn-run"><a href="#yarn-run" class="headerlink" title="yarn run"></a>yarn run</h4><p><code>yarn run [script] [&lt;args&gt;]</code></p>
<p>如果你已经在你的包里定义了 <code>scripts</code>，这个命令会运行指定的 <code>[script]</code>。例如：<br>运行这个命令会执行你的 <code>package.json</code> 里名为 <code>&quot;test&quot;</code> 的脚本。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yarnpkg.com/zh-Hans/docs/usage" target="_blank" rel="noopener">官网使用</a><br><a href="https://www.jianshu.com/p/f5d85e541a99" target="_blank" rel="noopener">yarn 常用命令</a><br><a href="https://www.kancloud.cn/shellway/yarn-notes/262504" target="_blank" rel="noopener">命令列表</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/travis配置文件的编写/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/travis配置文件的编写/" itemprop="url">travis配置文件的编写</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T14:08:21+08:00">2019-03-05</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端教程/" itemprop="url" rel="index"><span itemprop="name">前端教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="travis配置文件的编写"><a href="#travis配置文件的编写" class="headerlink" title="travis配置文件的编写"></a>travis配置文件的编写</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">dist:</span> <span class="string">trusty</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="string">required</span></span><br><span class="line"><span class="attr">matrix:</span></span><br><span class="line"><span class="attr">  include:</span></span><br><span class="line"><span class="attr">    - language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">      node_js:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">8.15</span><span class="number">.0</span></span><br><span class="line"><span class="attr">      env:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">TRAVIS_SECURE_ENV_VARS=false</span></span><br><span class="line"><span class="attr">      addons:</span></span><br><span class="line"><span class="attr">        apt:</span></span><br><span class="line"><span class="attr">          sources:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">ubuntu-toolchain-r-test</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">mysql-5.7-trusty</span></span><br><span class="line"><span class="attr">          packages:</span></span><br><span class="line"><span class="attr">      branches:</span></span><br><span class="line"><span class="attr">        only:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">master</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">      before_install:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">echo</span> <span class="bullet">-e</span> <span class="string">"machine github.com\n login $CI_USER_TOKEN\n password x-oauth-basic"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.netrc</span></span><br><span class="line">        <span class="comment"># Repo for Yarn</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">sudo</span> <span class="string">apt-key</span> <span class="string">adv</span> <span class="bullet">--fetch-keys</span> <span class="attr">http://dl.yarnpkg.com/debian/pubkey.gpg</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">echo</span> <span class="string">"deb http://dl.yarnpkg.com/debian/ stable main"</span> <span class="string">| sudo tee /etc/apt/sources.list.d/yarn.list</span></span><br><span class="line"><span class="string">        - sudo apt-get update -qq</span></span><br><span class="line"><span class="string">        - sudo apt-get install -y -qq yarn=1.12.3-1</span></span><br><span class="line"><span class="string"></span><span class="attr">      script:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">node</span> <span class="bullet">-v</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">yarn</span> <span class="bullet">-v</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">./travis-script.sh</span></span><br><span class="line"><span class="attr">      cache:</span></span><br><span class="line"><span class="attr">        yarn:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        directories:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">$TRAVIS_BUILD_DIR/project-template/client/node_modules</span></span><br></pre></td></tr></table></figure>
<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>需不需要<code>sudo</code>权限 一般是要的<code>require</code></p>
<h3 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h3><p>相当于就是一个几乘几的各种情况, 自动给你跑, 也可以<code>include</code>, 也可以<code>exclude</code>下.</p>
<p>exclude的要精确匹配 env 这种</p>
<h3 id="addons"><a href="#addons" class="headerlink" title="addons"></a>addons</h3><p>额外的软件包</p>
<h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><p>就是环境咯, <code>TRAVIS_SECURE_ENV_VARS=false</code>不加密</p>
<h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><p>要进行CI的分支, 可以写safelist<code>only</code>和blocklist<code>except</code></p>
<h3 id="在before-install下"><a href="#在before-install下" class="headerlink" title="在before_install下"></a>在<code>before_install</code>下</h3><p>第一条命令: <code>echo -e &quot;machine github.com\n  login $CI_USER_TOKEN&quot; &gt; ~/.netrc</code>, 用来将登陆配置信息追加写入<code>~/.netrc</code>中, 方便以后登录不用填用户名密码.<br><a href="https://docs.travis-ci.com/user/private-dependencies/#api-token" target="_blank" rel="noopener">travis API Token machine github.com\n</a></p>
<p>第二条命令: <code>apt-key adv --fetch-keys</code> will only fetch one key from the URL, and if the URL contains multiple keys, please use <code>wget | apt-key add instead</code>.</p>
<p>第三条命令: <code>tee</code>用来从标准输入中读, 然后便准输出. 就是一个复制粘贴的功能. 所以后面就是将 <code>deb http://dl.yarnpkg.com/debian/ stable main</code> 写入 <code>yarn.list</code> 中</p>
<p>第四第五条命令: 就是更新软件库表, 然后安装上 <code>yarn</code></p>
<blockquote>
<p>整个第2-5条命令就是在安装<code>yarn</code> <a href="https://yarnpkg.com/en/docs/install#debian-stable" target="_blank" rel="noopener">https://yarnpkg.com/en/docs/install#debian-stable</a></p>
</blockquote>
<h3 id="script"><a href="#script" class="headerlink" title="script"></a><code>script</code></h3><p>就是这个travis要跑的脚本.</p>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>就是cache, 看教程就是这么写的, <code>$TRAVIS_BUILD_DIR</code>就是当前<code>.travis.yml</code>所在的目录.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html" target="_blank" rel="noopener">持续集成服务 Travis CI 教程 阮一峰 666</a></p>
<p><a href="https://docs.travis-ci.com/user/languages/javascript-with-nodejs/" target="_blank" rel="noopener">Building a JavaScript and Node.js project</a></p>
<p><a href="https://docs.travis-ci.com/user/private-dependencies/#api-token" target="_blank" rel="noopener">travis API Token machine github.com\n</a><br><a href="https://blog.csdn.net/du_chao_qun/article/details/53464454" target="_blank" rel="noopener">.netrc文件简单使用</a><br><a href="http://lujun9972.github.io/blog/2017/05/25/%E4%BD%BF%E7%94%A8auth-source%E5%BA%93%E8%AF%BB%E5%8F%96netrc%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81/" target="_blank" rel="noopener">使用auth-source库读取Netrc文件中的用户名和密码</a><br><a href="https://blog.csdn.net/wenxuechaozhe/article/details/52564394" target="_blank" rel="noopener">linux &gt;和&gt;&gt;的区别</a></p>
<p><a href="http://blog.51yip.com/linux/1176.html" target="_blank" rel="noopener">apt-get 命令详解(中文),以及实例</a><br><a href="https://yarnpkg.com/en/docs/install#debian-stable" target="_blank" rel="noopener">https://yarnpkg.com/en/docs/install#debian-stable</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/20/prettier代码格式美化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/20/prettier代码格式美化/" itemprop="url">prettier代码格式美化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-20T20:39:17+08:00">2019-02-20</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/vsc插件/" itemprop="url" rel="index"><span itemprop="name">vsc插件</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="prettier代码格式美化"><a href="#prettier代码格式美化" class="headerlink" title="prettier代码格式美化"></a>prettier代码格式美化</h1><p>从<code>EditorConfig</code>到各种<code>***Lint</code>, 再到 <code>prettier</code>。 其实就是一起用</p>
<p>为什么要用Prettier</p>
<p>用来替代<code>*lint</code>中的一些场景，比如说分号/tab缩进/空格/引号，这些在lint工具检查出问题之后<strong>还需要手动修改</strong>，而通常这样的错误都是空格或者符号之类的，这样相对来说不太优雅，利用格式化工具自动生成省时省力。</p>
<h2 id="搞起"><a href="#搞起" class="headerlink" title="搞起"></a>搞起</h2><h2 id="在项目中"><a href="#在项目中" class="headerlink" title="在项目中"></a>在项目中</h2><p><a href="https://juejin.im/post/59ddc2a751882578c17e9ccf" target="_blank" rel="noopener">为什么用Prettier 66</a></p>
<p>安装完依赖, <code>npm install --save-dev prettier</code>后, 执行常见的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prettier --single-quote --trailing-comma es5 --write <span class="string">"&#123;app,__&#123;tests,mocks&#125;__&#125;/**/*.js"</span></span><br><span class="line">或</span><br><span class="line">prettier -l --write <span class="string">'src/**/*.&#123;ts,tsx,less,css&#125;'</span> --no-semi --single-quote</span><br></pre></td></tr></table></figure>
<h3 id="在vscode中"><a href="#在vscode中" class="headerlink" title="在vscode中"></a>在vscode中</h3><p>首先安装<code>vscode</code>的插件<code>Prettier-Code formatter</code></p>
<p>安装成功后，编辑器默认的格式化处理就会被<code>prettier</code>代替， 默认快捷键是<code>alt + shift + f</code></p>
<p>插件安装成功后，按<code>cmd+,</code>调出编辑器的配置,会出现<code>prettier</code>插件的相关配置节点，同时也能看到一些默认的配置信息, 在<code>setting.json</code>中也可以自己定义。  </p>
<p>更多的配置方式<br><a href="https://prettier.io/docs/en/configuration.html" target="_blank" rel="noopener">Configuration File</a></p>
<h2 id="其他的prettier"><a href="#其他的prettier" class="headerlink" title="其他的prettier"></a>其他的prettier</h2><p>除了直接用<code>prettier</code>, 还有像<code>tslint-config-prettier</code>这种prettier</p>
<h2 id="typescript配置prettier"><a href="#typescript配置prettier" class="headerlink" title="typescript配置prettier"></a>typescript配置prettier</h2><ul>
<li>文件保存时执行一次格式化</li>
<li>迁移已有代码的格式</li>
<li>代码提交前进行一次格式化</li>
</ul>
<p>首先确认了 <code>Prettier</code> 对 <code>TypeScript</code> 有良好的支持.</p>
<h3 id="保存时格式化"><a href="#保存时格式化" class="headerlink" title="保存时格式化"></a>保存时格式化</h3><p>但我更喜欢保存时只是做一点比如去掉多余的空格, 按<code>alt + shift + f</code>才进行格式化.</p>
<p>在vsc中安装完插件后, 配置<code>prettierrc</code> 文件, 临时的配置比如:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tabWidth"</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">"useTabs"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多配置文件方式<br><a href="https://prettier.io/docs/en/configuration.html" target="_blank" rel="noopener">Configuration File</a></p>
<p>然后<code>cmd+,</code>调出编辑器的配置, 设置<code>editor.formatOnSave</code> 选项.把值设置为 <code>true</code>.</p>
<h3 id="代码提交前"><a href="#代码提交前" class="headerlink" title="代码提交前"></a>代码提交前</h3><p><a href="https://juejin.im/post/59ddc2a751882578c17e9ccf" target="_blank" rel="noopener">为什么用Prettier 66</a></p>
<h2 id="已经有了ESlint下"><a href="#已经有了ESlint下" class="headerlink" title="已经有了ESlint下"></a>已经有了ESlint下</h2><p><a href="https://juejin.im/post/5ae91143f265da0ba60f97ea" target="_blank" rel="noopener">Prettier 介绍与基本用法 6</a></p>
<h3 id="使用ESLint运行Prettier"><a href="#使用ESLint运行Prettier" class="headerlink" title="使用ESLint运行Prettier"></a>使用ESLint运行Prettier</h3><p>如果你已经在你的项目中使用<code>ESLint</code>并且想要只通过<strong>单独一条命令</strong>来执行你的所有的代码检查的话，你可以使用<code>ESLint</code>来为你运行<code>Prettier</code>。</p>
<p>只需要使用<code>eslint-plugin-prettier</code>来添加<code>Prettier</code>作为<code>ESLint</code>的<strong>规则配置</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev prettier eslint-plugin-prettier</span><br></pre></td></tr></table></figure>
<p><strong>.eslintrc.json</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"prettier"</span>],</span><br><span class="line">  <span class="string">"rules"</span>: &#123;</span><br><span class="line">    <span class="string">"prettier/prettier"</span>: <span class="string">"error"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关闭ESLint的格式规则"><a href="#关闭ESLint的格式规则" class="headerlink" title="关闭ESLint的格式规则"></a>关闭ESLint的格式规则</h3><p><strong>你是否通过<code>ESLint</code>来运行<code>Prettier</code>，又或者是单独运行两个工具</strong>，那你大概<strong>只想要每个格式问题只出现一次</strong>，而且你特别不想要<code>ESLint</code>仅仅是和<code>Prettier</code>有简单的不同和偏好而报出“问题”。</p>
<p>所以你大概想要<strong>禁用冲突的规则</strong>（当保留其他<code>Prettier</code>不关心的规则时）最简单的方式是使用<code>eslint-config-prettier</code>。它可以添加到任何<code>ESLint</code>配置上面。</p>
<h2 id="345345总"><a href="#345345总" class="headerlink" title="345345总"></a>345345总</h2><p>目标是有两个setting,<br>一个是user的setting, 设置好自己对常用的语言的一些代码规范<br>一个是workspace的setting, 是读取要工作的项目文件中的文件, 来保持项目的代码规范<br>(先设置自己的user, 在读取项目中的<code>setting</code>)</p>
<p>然后自己对于<code>cmd+s</code>的情况是只去掉空格, 而不格式化,用<code>alt+shift+f</code>是来手动格式化, 然后<code>pre-commit</code>前会最好自动格式化下</p>
<p>从EditorConfig到xxLint, 到prettier.  prettier只暴力格式化, xxlint是检查</p>
<p>安装prettier的话有2种, 一种是在vsc中安装插件<code>prettier code format</code><br>一种是在项目中用<code>npm</code>或<code>yarn</code>安装dev依赖, <strong>依赖项目, 不依赖编辑器</strong><br>2者略有不同.</p>
<h3 id="项目npm-yarn中后"><a href="#项目npm-yarn中后" class="headerlink" title="项目npm, yarn中后"></a>项目npm, yarn中后</h3><p>项目中的就是比如<code>npm</code>安装完后, 就可以在script中写个prettier的格式命令, 然后<code>yarn prettier</code>下</p>
<p>常见的命令是<code>prettier --write --config .prettierrc src/*.ts</code> 当然还要一些prettier的参数等会看 比如<code>{}</code>, <code>[]</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这个是对前端的, 后面不加分号</span><br><span class="line">prettier -l --write 'src/**/*.&#123;ts,tsx,less,css&#125;' --no-semi --single-quote</span><br><span class="line"># 这个是后端的js 加分号</span><br><span class="line">prettier -l --write 'app/**/*.js' --single-quote</span><br><span class="line"># 这个是按.prettierrc中的格式</span><br><span class="line">prettier --write --config .prettierrc src/*.ts</span><br></pre></td></tr></table></figure>
<p>当然可以在<code>package.json</code>中的<code>script</code>写<code>prettier</code>搞定.<br>而在<code>package.json</code>中的<code>prettier</code>写是自定义格式选项. 一般不会用这个</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"prettier": &#123;</span><br><span class="line">    "singleQuote": true,</span><br><span class="line">    "semi": false,</span><br><span class="line">    "printWidth": 120,</span><br><span class="line">    "proseWrap": "never"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>查看prettier中内置的一些<code>formatter</code></p>
<h3 id="vsc中"><a href="#vsc中" class="headerlink" title="vsc中"></a>vsc中</h3><p>在vsc中多说下, 首先vsc有自己的格式方式, 按<code>cmd+k m</code>可以查看到许多语言, 然后是你可以自己配置<code>Configure &#39;language_name&#39; language based settings.</code>, 跳转到<code>setting.json</code> 中写这种(和你用<code>cmd+shift+p</code>在输入<code>preferences: config</code>这种快多了)</p>
<p>这里的保存后格式化是对当前文件吧, 而不是本项目中所有的.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Set the default</span><br><span class="line">"editor.formatOnSave": false,</span><br><span class="line">// Enable per-language</span><br><span class="line">"[javascript]": &#123;</span><br><span class="line">    "editor.formatOnSave": true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在<code>cmd+,</code>中看<code>setting.json</code> 中可以自己直接改</p>
<p>vsc的配置, workspace setting在项目根目录<code>.vscode</code>中, 但我找不到. 一般我在里面写debug的文件, 比如egg的那个配置</p>
<h3 id="各种不同的prettier"><a href="#各种不同的prettier" class="headerlink" title="各种不同的prettier"></a>各种不同的prettier</h3><p>常见的<a href="https://prettier.io/docs/en/configuration.html" target="_blank" rel="noopener">prettier文件</a></p>
<ul>
<li>A <code>.prettierrc</code> file, written in YAML or JSON, with optional extensions: <code>.yaml/.yml/.json</code>.</li>
<li>A <code>.prettierrc.toml</code> file, written in TOML (the .toml extension is required).</li>
<li>A <code>prettier.config.js</code> or <code>.prettierrc.js</code> file that exports an object.</li>
<li>A <code>&quot;prettier&quot;</code> key in your <code>package.json</code> file.</li>
</ul>
<p>常见的4种吧, 首先是<code>.prettierrc</code>, 你可以在里面用<code>YAML or JSON</code>格式来写, 其次是<code>.prettierrc.toml</code>, 用<code>TOML</code>格式来写 算一类吧, 我们常见的事用<code>JSON</code>写<br>还有就是用<code>prettier.config.js</code> or <code>.prettierrc.js</code>这种导出一个对象来写<br>最后就是在<code>package.json</code>中的<code>&quot;prettier&quot;</code>, 一般就是在<code>script</code>中写呗, 不会单独搞一个属性</p>
<p>当然<code>.editorconfig, .babelrc, .eslintrc, .prettierrc</code> 都挺常见的</p>
<h3 id="对于我常用的配置"><a href="#对于我常用的配置" class="headerlink" title="对于我常用的配置"></a>对于我常用的配置</h3><p>ts, tsx, js, jsx, md这些文件, 在setting.json中可以单独配置user的, 还有css, less 都可以</p>
<p>但是不能配合<code>prettier</code>用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  // js</span><br><span class="line">"[javascript]": &#123;</span><br><span class="line">  "editor.formatOnSave": true,</span><br><span class="line">  "editor.formatOnPaste": false</span><br><span class="line">&#125;,</span><br><span class="line">// jsx</span><br><span class="line">"[javascriptreact]": &#123;</span><br><span class="line">  "editor.formatOnSave": true,</span><br><span class="line">  "editor.formatOnPaste": false</span><br><span class="line">&#125;,</span><br><span class="line">// ts</span><br><span class="line">"[typescript]": &#123;</span><br><span class="line">  "editor.formatOnSave": true,</span><br><span class="line">  "editor.formatOnPaste": false</span><br><span class="line">&#125;,</span><br><span class="line">// tsx</span><br><span class="line">"[typescriptreact]": &#123;</span><br><span class="line">  "editor.formatOnSave": true,</span><br><span class="line">  "editor.formatOnPaste": false</span><br><span class="line">&#125;</span><br><span class="line">// md</span><br><span class="line">"[markdown]": &#123;&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="下面链接中讲了详细使用prettier"><a href="#下面链接中讲了详细使用prettier" class="headerlink" title="下面链接中讲了详细使用prettier"></a>下面链接中讲了详细使用prettier</h3><p><a href="https://survivejs.com/maintenance/code-quality/code-formatting/" target="_blank" rel="noopener">Code Formatting 6666 各种配置</a></p>
<h3 id="读取顺序"><a href="#读取顺序" class="headerlink" title="读取顺序"></a>读取顺序</h3><p>先从vsc的市场中可以看到, setting会先从</p>
<ol>
<li>prettier 的配置文件读, 也就是前面说的4种</li>
<li>没有的话从<code>.editorconfig</code>这个小老鼠读</li>
<li>最后才是从默认的vsc的prettier setting</li>
</ol>
<p>再说下一下默认在vsc中插件prettier设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 一行最大80个字符</span><br><span class="line">prettier.printWidth (default: 80)</span><br><span class="line"></span><br><span class="line">// 使用tab代表几个空格</span><br><span class="line">prettier.tabWidth (default: 2)</span><br><span class="line"></span><br><span class="line">// 是否使用单引号代替双引号</span><br><span class="line">prettier.singleQuote (default: false)</span><br><span class="line"></span><br><span class="line">// 末尾的逗号, 3个选项, "none"就是无, "es5"会在例如对象和数组, "all"是包括函数参数</span><br><span class="line">prettier.trailingComma (default: 'none')</span><br><span class="line"></span><br><span class="line">// 控制对象字面量里面的空格</span><br><span class="line">prettier.bracketSpacing (default: true)</span><br><span class="line"></span><br><span class="line">// 如果为true, 在多行的jsx元素中, 最后的 &gt; 单独一行,而不是跟在最后一样的末尾</span><br><span class="line">prettier.jsxBracketSameLine (default: false)</span><br><span class="line"></span><br><span class="line">// 用什么 parser .只有 'flow' 和 'babylon'.</span><br><span class="line">prettier.parser (default: 'babylon') - JavaScript only</span><br><span class="line"></span><br><span class="line">// 在每行的末尾加上分号 true. false就是用ASI, 看链接参考</span><br><span class="line">prettier.semi (default: true)</span><br><span class="line"></span><br><span class="line">// 缩进用不用tab</span><br><span class="line">prettier.useTabs (default: false)</span><br><span class="line"></span><br><span class="line">// (Markdown) wrap prose over multiple lines.</span><br><span class="line">prettier.proseWrap (default: 'preserve')</span><br><span class="line"></span><br><span class="line">// 对只有一个参数的箭头函数的这个参数, 用不用圆括号包上</span><br><span class="line">prettier.arrowParens (default: 'avoid')</span><br><span class="line"></span><br><span class="line">// 在jsx中用单引号而不是双引号</span><br><span class="line">prettier.jsxSingleQuote (default: false)</span><br><span class="line"></span><br><span class="line">// 对html文件空格敏感, 有更多选项</span><br><span class="line">prettier.htmlWhitespaceSensitivity (default: 'css')</span><br><span class="line"></span><br><span class="line">// 对每行末尾通过prettier自己设定, 有更多选项</span><br><span class="line">prettier.endOfLine (default: 'auto')</span><br></pre></td></tr></table></figure>
<p>然后是vsc中特殊指定的, 通过<code>setting.json</code>可以改 <a href="https://code.visualstudio.com/docs/getstarted/settings" target="_blank" rel="noopener">User and Workspace Settings</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 使用 prettier-eslint 代替 prettier.</span><br><span class="line">prettier.eslintIntegration (default: false) - JavaScript and TypeScript only</span><br><span class="line"></span><br><span class="line">// 使用 prettier-tslint 代替 prettier.</span><br><span class="line">prettier.tslintIntegration (default: false) - JavaScript and TypeScript only</span><br><span class="line"></span><br><span class="line">// 使用 prettier-stylelint 代替 prettier.</span><br><span class="line">prettier.stylelintIntegration (default: false) - CSS, SCSS and LESS only</span><br><span class="line"></span><br><span class="line">// 需要一个 a 'prettierconfig' 文件来格式化</span><br><span class="line">prettier.requireConfig (default: false)</span><br><span class="line"></span><br><span class="line">// 支持写一个 .gitignore 或 .prettierignore 这样的文件来忽略项目中哪些路径下的不进行格式化. 需要重启下vsc</span><br><span class="line">prettier.ignorePath (default: .prettierignore)</span><br><span class="line"></span><br><span class="line">// 对一些特定语言不进行用prettier的格式化. 在父目录下设置也会组织所有子目录下的配置</span><br><span class="line">prettier.disableLanguages (default: ["vue"])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>vsc中的<code>prettier</code>插件也是会依赖项目中的本地依赖, 就是前面的优先级.</p>
</blockquote>
<h4 id="vsc中的setting"><a href="#vsc中的setting" class="headerlink" title="vsc中的setting"></a>vsc中的setting</h4><p>按<code>cmd+,</code>打开, 有两种不同的设定</p>
<ul>
<li>User Settings - 这是全局的设定</li>
<li>Workspace Settings - 指定的workspace打开才会应用, 这个优先级高. 常用在小组中分享项目设定. 在<code>.vscode</code>文件中de <code>.settings.json</code>,  <code>launch.json</code>是用来debug的</li>
</ul>
<p>改变会需要重启下vsc, 也有不需要重启的, 自己点着试试, 先看Commonly Userd =&gt; workbench  看下去</p>
<p>对于workspace setting在一个文件下当然可以加一个<code>.vacode</code>文件夹, 但当有一个根文件下有很多项目时呢. 比如ava<br>那就在根目录下写一个<code>Global Workspace settings</code> 叫<code>.code-workspace</code>文件</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"folders"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"vscode"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"vscode-docs"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"vscode-generator-code"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"window.zoomLevel"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"files.autoSave"</span>: <span class="string">"afterDelay"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如debugging的东西就写在<code>.vscode</code>文件夹下的<code>lounch.json</code>中</p>
<p>然后就是语言指定配置, 这个在前面讲过<code>cmd+k, m</code></p>
<h3 id="prettier的默认配置"><a href="#prettier的默认配置" class="headerlink" title="prettier的默认配置"></a>prettier的默认配置</h3><p><a href="https://prettier.io/docs/en/options.html" target="_blank" rel="noopener">options.</a></p>
<h3 id="prettierc常用命令参数"><a href="#prettierc常用命令参数" class="headerlink" title="prettierc常用命令参数"></a>prettierc常用命令参数</h3><p>基本命令就是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prettier [opts] [filename ...]</span><br></pre></td></tr></table></figure>
<p>实际中常用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prettier --single-quote --trailing-comma es5 --write <span class="string">"&#123;app,__&#123;tests,mocks&#125;__&#125;/**/*.js"</span></span><br></pre></td></tr></table></figure>
<p>默认是不会访问<code>node_modules</code>文件夹中的, 需要访问的话加参数<code>--with-node-modules</code></p>
<h4 id="CLI的一些其他参数"><a href="#CLI的一些其他参数" class="headerlink" title="CLI的一些其他参数"></a>CLI的一些其他参数</h4><p>讲的主要是比<code>option</code>多一点的东西.</p>
<h5 id="check或-c"><a href="#check或-c" class="headerlink" title="--check或-c"></a><code>--check</code>或<code>-c</code></h5><p>就是check下文件是否格式化了, 也经常配合在<code>pre-commit hook</code>前使用,<br>如果是想讲这些没格式化的文件输出给下一个命令, 就用<code>--list-different</code>. 两者还是有区别的</p>
<h5 id="debug-check"><a href="#debug-check" class="headerlink" title="--debug-check"></a><code>--debug-check</code></h5><p>如果你怕<code>prettier</code>改变你正确的代码, 那么用这个. 当然<code>--write</code>是不能配合这个用了.</p>
<h5 id="find-config-path-和-config"><a href="#find-config-path-和-config" class="headerlink" title="--find-config-path 和 --config"></a><code>--find-config-path</code> 和 <code>--config</code></h5><p>当你经常去格式化那些指定目录的文件时, <code>prettier</code>会先尝试读取配置文件的信息, <strong>造成性能有点缺失</strong>, 所以你可以用这个命令配置好, 先读第一次, 之后就重用第一次的配置.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prettier --find-config-path ./my/file.js</span><br><span class="line">./my/.prettierrc  <span class="comment">// 这是配置文件</span></span><br></pre></td></tr></table></figure>
<p>而这里是, 直接提供一个配置文件路径<code>--config</code>, 当然可以任意指定配置文件在哪了.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prettier --config ./my/.prettierrc --write ./my/file.js</span><br></pre></td></tr></table></figure>
<p>不想要配置文件用<code>--no-config</code>, 默认配置就是不查找.</p>
<h5 id="ignore-path"><a href="#ignore-path" class="headerlink" title="--ignore-path"></a><code>--ignore-path</code></h5><p>用来忽略一些不需要格式化的目录中的文件, 比如 <code>./.prettierignore</code></p>
<h5 id="require-pragma"><a href="#require-pragma" class="headerlink" title="--require-pragma"></a><code>--require-pragma</code></h5><p>pragma指需要一些特别的comment.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @prettier  // @prettier 或 @format</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h5 id="insert-pragma"><a href="#insert-pragma" class="headerlink" title="--insert-pragma"></a><code>--insert-pragma</code></h5><p>在没有pragma的时候会插入<code>@format</code>这种pragma到格式化文件最顶端, 配合<code>--require-pragma</code>一起用</p>
<h5 id="list-different或-l"><a href="#list-different或-l" class="headerlink" title="--list-different或-l"></a><code>--list-different</code>或<code>-l</code></h5><p>这是另一个常用的flag, 会打印出prettier格式化前后不同的文件名.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prettier --single-quote --list-different <span class="string">"src/**/*.js"</span></span><br></pre></td></tr></table></figure>
<p>也可以用<code>--check</code>, 这个打印出跟人性化的信息</p>
<h5 id="config-precedence"><a href="#config-precedence" class="headerlink" title="--config-precedence"></a><code>--config-precedence</code></h5><p>config file文件中的配置优先级高还是 CLI options中的高</p>
<ul>
<li>config file 指的是配置文件</li>
<li><p>CLI options 指的是输入的命令参数</p>
</li>
<li><p>cli-override (default)</p>
<ul>
<li>默认cli中高, 也就是默认的prettier的配置高</li>
</ul>
</li>
<li>file-override<ul>
<li>config file中的高</li>
</ul>
</li>
<li>prefer-file<ul>
<li>如果配置文件找到了, 就按配置文件, 没找到就用CLI的</li>
</ul>
</li>
</ul>
<p>常用来整合编辑器中的, 比如用户定义了自己的配置, 但还是尊重项目的定的配置.</p>
<h5 id="no-editorconfig"><a href="#no-editorconfig" class="headerlink" title="--no-editorconfig"></a><code>--no-editorconfig</code></h5><p>不考虑小老鼠了, 具体看<a href="https://prettier.io/docs/en/api.html" target="_blank" rel="noopener">API</a>中的信息</p>
<h5 id="with-node-modules"><a href="#with-node-modules" class="headerlink" title="--with-node-modules"></a><code>--with-node-modules</code></h5><p>默认不会访问, 加了后就去访问格式化咯.</p>
<h5 id="write"><a href="#write" class="headerlink" title="--write"></a><code>--write</code></h5><p>就地改正, 按prettier的格式</p>
<h5 id="loglevel"><a href="#loglevel" class="headerlink" title="--loglevel"></a><code>--loglevel</code></h5><p>改一下CLI的log等级</p>
<ul>
<li>error</li>
<li>warn</li>
<li>log (default)</li>
<li>debug</li>
<li>silent</li>
</ul>
<h5 id="stdin-filepath"><a href="#stdin-filepath" class="headerlink" title="--stdin-filepath"></a><code>--stdin-filepath</code></h5><p>prettier CLI当做<code>stdin</code>的文件路径, 比如</p>
<p>abc.css</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.name</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat abc.css | prettier --stdin-filepath abc.css</span></span><br><span class="line">.name &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="API-用来setting-json中的"><a href="#API-用来setting-json中的" class="headerlink" title="API 用来setting.json中的"></a>API 用来setting.json中的</h4><p>不推荐, 就是直接在js中写</p>
<h4 id="默认的option"><a href="#默认的option" class="headerlink" title="默认的option"></a>默认的option</h4><p><a href="https://segmentfault.com/a/1190000012909159" target="_blank" rel="noopener">prettier的配置选项（参数）官网直译</a></p>
<p>总结下就是</p>
<ul>
<li>一行超过多少个字符换行, markdown也需要强制换行么. 末尾加不加分号, 换行后<code>&gt;</code>在哪</li>
<li>对象字面量前后加空格么, 最后一个属性加逗号么, 单引号代替双引号么, 箭头寒素参数括号么.</li>
<li>缩进用tab还是空格, 一个tab几个空格</li>
<li>html默认, endOfLine默认, parser, filePath, pragma. range默认</li>
<li><strong>关注点还是末尾js加分号, tsx不加,多一个—no-semi, 然后都用单引号</strong> 比vsc的配置多一点点</li>
</ul>
<h5 id="Print-Width"><a href="#Print-Width" class="headerlink" title="Print Width"></a>Print Width</h5><p>指定一行不能超过多少长, 长了换行, 报错是xxlint的事</p>
<p>为了可读写, 建议不要超过80个字符的, 因为人阅读的时候一般不会超过100-120的, <code>prettier</code>的话倒是希望每行越长越好.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>80</td>
<td><code>--print-width &lt;int&gt;</code></td>
<td><code>printWidth: &lt;int&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>如果你不想在<code>markdown</code>中限定换行, 可以用<code>Prose Wrap</code>来关闭它, 默认<code>preserve</code>是保持<code>markdown</code>的<code>as-is</code></p>
</blockquote>
<h5 id="Tab-Width"><a href="#Tab-Width" class="headerlink" title="Tab Width"></a>Tab Width</h5><p>一个缩进等级代表几个空格</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td><code>--tab-width &lt;int&gt;</code></td>
<td><code>tabWidth: &lt;int&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h5><p>缩进的行用tab而不是用空格</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td><code>--use-tabs</code></td>
<td><code>useTabs: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<p>tab常用来缩进,但在prettier中tab是用来align的</p>
<h5 id="Semicolons"><a href="#Semicolons" class="headerlink" title="Semicolons"></a>Semicolons</h5><p>每行后面带不带分号</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>true</td>
<td><code>--no-semi</code></td>
<td><code>semi: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<p>true是在每行末尾加<br>false是在每行开头加,但会引入ASI问题.</p>
<h5 id="Quotes"><a href="#Quotes" class="headerlink" title="Quotes"></a>Quotes</h5><p>使用单引号而不是双引号:</p>
<p>注意:</p>
<ul>
<li>jsx的会忽略这个配置, 用的是<code>jsx-single-quote.</code></li>
<li>如果在一个用字符串包上字符串的情况下, <code>&quot;I&#39;m double quoted&quot;</code>变<code>&quot;I&#39;m double quoted&quot;</code>. <code>&quot;This \&quot;example\&quot; is single quoted&quot;</code>变<code>&#39;This &quot;example&quot; is single quoted&#39;</code></li>
<li>更多信息看<code>strings rationale</code></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td><code>--single-quote</code></td>
<td><code>singleQuote: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="JSX-Quotes"><a href="#JSX-Quotes" class="headerlink" title="JSX Quotes"></a>JSX Quotes</h5><p>在jsx中用单引号代替双引号</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td><code>--jsx-single-quote</code></td>
<td><code>jsxSingleQuote: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Trailing-Commas"><a href="#Trailing-Commas" class="headerlink" title="Trailing Commas"></a>Trailing Commas</h5><p>多行的时候在末尾打印逗号. 单行数组是不会有末尾逗号的.<br>尾逗号<code>[a,b,c,d,]</code> 数组项d后面的逗号就是尾逗号</p>
<p>可选项:</p>
<ul>
<li><code>none</code>, 不加</li>
<li><code>es5</code>: 在es5中某些加, 比如(objects, arrays, etc.)</li>
<li><code>all</code>: 甚至在函数参数中也加</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>“none”</td>
<td>`—trailing-comma &lt;none</td>
<td>es5</td>
<td>all&gt;`</td>
<td>`trailingComma: “&lt;none</td>
<td>es5</td>
<td>all&gt;”`</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Bracket-Spacing"><a href="#Bracket-Spacing" class="headerlink" title="Bracket Spacing"></a>Bracket Spacing</h5><p>在一个对象字面量中加空格</p>
<p><code>true</code> - Example: <code>{ foo: bar }</code>.<br><code>false</code> - Example: <code>{foo: bar}</code>.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>true</td>
<td><code>--no-bracket-spacing</code></td>
<td><code>bracketSpacing: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="JSX-Brackets"><a href="#JSX-Brackets" class="headerlink" title="JSX Brackets"></a>JSX Brackets</h5><p>对一个jsx元素而言,<code>&gt;</code>是加在最后一样还是换新行</p>
<p>Valid options:</p>
<p><code>true</code> - Example:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button</span><br><span class="line">  className=<span class="string">"prettier-class"</span></span><br><span class="line">  id=<span class="string">"prettier-id"</span></span><br><span class="line">  onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">  Click Here</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>false</code> - Example:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button</span><br><span class="line">  className=<span class="string">"prettier-class"</span></span><br><span class="line">  id=<span class="string">"prettier-id"</span></span><br><span class="line">  onClick=&#123;<span class="keyword">this</span>.handleClick&#125;</span><br><span class="line">&gt;</span><br><span class="line">  Click Here</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td><code>--jsx-bracket-same-line</code></td>
<td><code>jsxBracketSameLine: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Arrow-Function-Parentheses"><a href="#Arrow-Function-Parentheses" class="headerlink" title="Arrow Function Parentheses"></a>Arrow Function Parentheses</h5><p>箭头函数的参数, 在只有一个的情况下加不加圆括号<code>()</code></p>
<p>Valid options:</p>
<p><code>&quot;avoid&quot;</code> - 忽略. Example: <code>x =&gt; x</code><br><code>&quot;always&quot;</code> - 加上. Example: <code>(x) =&gt; x</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>“avoid”</td>
<td>`—arrow-parens &lt;avoid</td>
<td>always&gt;`</td>
<td>`arrowParens: “&lt;avoid</td>
<td>always&gt;”`</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h5><p>只format文件中的一段, <code>[)</code> 选一个偏移范围</p>
<p>不能和<code>cursorOffset</code>一起用</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>--range-start &lt;int&gt;</code></td>
<td><code>rangeStart: &lt;int&gt;</code></td>
</tr>
<tr>
<td>Infinity</td>
<td><code>--range-end &lt;int&gt;</code></td>
<td><code>rangeEnd: &lt;int&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h5><p>指定用什么parse, <code>prettier</code>会自动从输入的文件目录中读取, 你不需要配置这个.</p>
<p>但 <code>babel</code> 和 <code>flow</code>对一个js集来说是不同的两种, 所以可以选.</p>
<p>当然还要其他选项.</p>
<h5 id="File-Path"><a href="#File-Path" class="headerlink" title="File Path"></a>File Path</h5><p>指定前面parser的路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat foo | prettier --stdin-filepath foo.css</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>--stdin-filepath &lt;string&gt;</code></td>
<td><code>filepath: &quot;&lt;string&gt;&quot;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Require-pragma"><a href="#Require-pragma" class="headerlink" title="Require pragma"></a>Require pragma</h5><p><code>prettier</code>可以按照这个标志来严格指定format 文件, 只需要在每个文件前面加上<code>pramga</code></p>
<p>例如文件中带上下面的参数后, 使用<code>--require-pragma</code>就会format</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @prettier</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @format</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td><code>--require-pragma</code></td>
<td><code>requirePragma: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Insert-Pragma"><a href="#Insert-Pragma" class="headerlink" title="Insert Pragma"></a>Insert Pragma</h5><p>prettier可以在用prettier进行format的时候在文件的开头插入<code>@format</code>, 如果已经有其他的<code>docblock</code>的时候会加入一行的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td><code>--insert-pragma</code></td>
<td><code>insertPragma: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Prose-Wrap"><a href="#Prose-Wrap" class="headerlink" title="Prose Wrap"></a>Prose Wrap</h5><p>换行问题, 最开始的是超过多少字符提示, 但不换行的.</p>
<p>Valid options:</p>
<ul>
<li><code>&quot;always&quot;</code> - Wrap prose if it exceeds the <code>print width</code>.</li>
<li><code>&quot;never&quot;</code> - Do not wrap prose.</li>
<li><code>&quot;preserve&quot;</code> - Wrap prose as-is. First available in v1.9.0</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;preserve&quot;</code></td>
<td>`—prose-wrap &lt;always</td>
<td>never</td>
<td>preserve&gt;</td>
<td>`</td>
<td>`proseWrap: “&lt;always</td>
<td>never</td>
<td>preserve&gt;”`</td>
</tr>
</tbody>
</table>
</div>
<h5 id="HTML-Whitespace-Sensitivity"><a href="#HTML-Whitespace-Sensitivity" class="headerlink" title="HTML Whitespace Sensitivity"></a>HTML Whitespace Sensitivity</h5><p>HTML文件全局空格敏感问题, 详细看<code>whitespace-sensitive formatting</code></p>
<p>就是空格会影响布局, 就按css的display来</p>
<p>Valid options:</p>
<ul>
<li><code>&quot;css&quot;</code> - Respect the default value of CSS <code>display</code> property.</li>
<li><code>&quot;strict&quot;</code> - Whitespaces are considered sensitive.</li>
<li><code>&quot;ignore&quot;</code> - Whitespaces are considered insensitive.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;css&quot;</code></td>
<td>`—html-whitespace-sensitivity &lt;css</td>
<td>strict</td>
<td>ignore&gt;`</td>
<td>`htmlWhitespaceSensitivity: “&lt;css</td>
<td>strict</td>
<td>ignore&gt;”`</td>
</tr>
</tbody>
</table>
</div>
<h5 id="End-of-Line"><a href="#End-of-Line" class="headerlink" title="End of Line"></a>End of Line</h5><p>历史原因, 有两种, That is <code>\n</code> (or <code>LF</code> for Line Feed) and <code>\r\n</code> (or <code>CRLF</code> for Carriage Return + Line Feed).</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/3dda4756eca5" target="_blank" rel="noopener">Visual Studio Code入门(译)</a><br><a href="https://blog.csdn.net/u013304372/article/details/78917536" target="_blank" rel="noopener">VS Code使用之基本设置与配置详解</a><br><a href="https://juejin.im/post/5b27a326e51d45588a7dac57" target="_blank" rel="noopener">使用ESLint+Prettier来统一前端代码风格</a><br><a href="https://www.jeffjade.com/2019/02/02/150-prettier-quickapp-plugin/" target="_blank" rel="noopener">Prettier 插件为更漂亮快应用代码</a><br><a href="http://www.valarvo.com/edwardvoon/587.html" target="_blank" rel="noopener">使用Prettier美化JavaScript代码，让编程更舒心</a><br><a href="https://juejin.im/post/5a791d566fb9a0634853400e" target="_blank" rel="noopener">vscode + prettier 专治代码洁癖（一）</a><br><a href="https://segmentfault.com/a/1190000011122443" target="_blank" rel="noopener">笔记, TypeScript 配置 Prettier 6</a><br><a href="https://juejin.im/post/5ae91143f265da0ba60f97ea" target="_blank" rel="noopener">Prettier 介绍与基本用法 6</a><br><a href="https://juejin.im/post/59ddc2a751882578c17e9ccf" target="_blank" rel="noopener">为什么用Prettier 66</a><br><a href="https://blog.fundebug.com/2017/10/23/format-code-use-Prettier/" target="_blank" rel="noopener">我为什么推荐Prettier来统一代码风格 6</a><br><a href="https://survivejs.com/maintenance/code-quality/code-formatting/" target="_blank" rel="noopener">Code Formatting 6666 各种配置</a><br><a href="https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi" target="_blank" rel="noopener">What are the rules for JavaScript’s automatic semicolon insertion (ASI)?</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatarMogu.jpg" alt="Henry x">
            
              <p class="site-author-name" itemprop="name">Henry x</p>
              <p class="site-description motion-element" itemprop="description">this is description</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">117</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">121</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="weibo" target="_blank">weibo</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Henry x</span>

  

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.1"></script>



  



	





  





  










  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  

</body>
</html>
