<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.1',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  
  <meta name="keywords" content="Hexo, NexT">


<meta name="description" content="this is description">
<meta property="og:type" content="website">
<meta property="og:title" content="Little H title">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="Little H title">
<meta property="og:description" content="this is description">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Little H title">
<meta name="twitter:description" content="this is description">






  <link rel="canonical" href="http://yoursite.com/page/10/">


  <title>Little H title</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Little H title</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">this is subtitle</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益404</a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/10/pacman源添加及yaourt安装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/10/pacman源添加及yaourt安装/" itemprop="url">pacman源添加及yaourt安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-10T11:54:50+08:00">2018-06-10</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="pacman的介绍"><a href="#pacman的介绍" class="headerlink" title="pacman的介绍"></a>pacman的介绍</h1><p>在linux系统中安装一个新应用，主要有三部分，<strong>软件包文件、库、依赖关系</strong>。<br><strong>软件包</strong>是程序本身的数据文件。<strong>库</strong>是各种函数封装存放的地方。<strong>依赖关系</strong>是各个程序之间共用的数据和函数库形成的联系。<br>所以，要安装一个软件不光要安装软件本身，还要依据依赖关系安装其他用到的库和软件。</p>
<h2 id="1-添加源"><a href="#1-添加源" class="headerlink" title="1.添加源"></a>1.添加源</h2><p><strong>源</strong>，是软件源的简称，是互联网上存放软件包和库的<strong>服务器</strong>，这些服务器一般都是由官方维护，不少高校、互联网公司等权威机构有自己的镜像源，也有开发者自己的社区软件源。</p>
<p><strong>软件包工具</strong>，是使用这些源的工具，多是终端里的一种命令，如apt-get 、yum、dpkg、pacman等，在这些工具中，分为高级和低级，低级工具（dpkg、rpm）执行<strong>安装删除</strong>等任务，高级工具（apt-get、yum、pacman）提供<strong>依赖关系解决</strong>等功能。每种工具都有相对应的软件包格式、相对应的源。</p>
<p>pacman源的设置在<code>/etc/pacman.conf</code>和<code>/etc/pacman.d/mirrorlist</code>里</p>
<p>1)在<code>/etc/pacman.conf</code>类似这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">SigLevel = PackageRequired</span><br><span class="line">Include = <span class="regexp">/etc/</span>pacman.d/mirrorlist</span><br><span class="line"></span><br><span class="line">[extra]</span><br><span class="line">SigLevel = PackageRequired</span><br><span class="line">Include = <span class="regexp">/etc/</span>pacman.d/mirrorlist</span><br><span class="line"></span><br><span class="line">[community]</span><br><span class="line">SigLevel = PackageRequired</span><br><span class="line">Include = <span class="regexp">/etc/</span>pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>
<p>2)在<code>/etc/pacman.d/mirrorlist</code>类似这样<br>mirrorlist文件默认的源都在国外, 速度慢,需要添加国内镜像地址作为源，添加内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Server = https:<span class="comment">//mirrors.ustc.edu.cn/archlinux/$repo/os/$arch  </span></span><br><span class="line">Server = https:<span class="comment">//mirrors.aliyun.com/archlinux/$repo/os/$arch</span></span><br><span class="line">Server = https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch  </span></span><br><span class="line">Server = https:<span class="comment">//mirrors.163.com/archlinux/$repo/os/$arch</span></span><br></pre></td></tr></table></figure>
<p>上面是大概的,下面是要做的<br>1.根据软件源的速度排列源(在终端输入）也就不用在上面手动添加了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -g</span><br></pre></td></tr></table></figure>
<p>一步到位</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -c China</span><br></pre></td></tr></table></figure>
<p>2.Wiki上一个优化机械硬盘的命令，类似于磁盘整理（固态硬盘跳过这步,固态不要用,虚拟机也不要用）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-optimize &amp;&amp; sync</span><br></pre></td></tr></table></figure>
<p>3.更新系统(后面添加完USTC源之后也要一次更新)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure>
<p>4.完成以上步骤后，可添加archlinuxCN源，方便我们安装等软件(比如google-chrome)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/pacman.conf</span><br></pre></td></tr></table></figure>
<p>在打开的文件最后黏贴上以下几行：（这里用的中科大的源,用了可以搜到chrome的哦）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># USTC</span><br><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel = Optional TrustedOnly</span><br><span class="line">Server = https:<span class="comment">//mirrors.ustc.edu.cn/archlinuxcn/$arch</span></span><br></pre></td></tr></table></figure>
<p>5.导入 GPG key(这个必须要有哦,会自动签名的)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure>
<p>//这块暂时不用<br>（2）运行sudopacman -Syyu提示Keys错误，GPG啥的，依次运行以下命令：<br>sudo rm -r /etc/pacman.d/gnupg（移除旧的keys）<br>sudo pacman -Sy gnupg archlinux-keyring manjaro-keyring（重新安装最新keys）<br>sudo pacman-key —init（初始化pacman的keys）<br>sudo pacman-key —populate archlinux manjaro（加载签名的keys）<br>sudo pacman-key –refresh-keys（刷新升级已签名keys）<br>sudo pacman -Sc（清空并下载新数据）<br>最后运行： </p>
<p>sudo pacman -Syyu</p>
<h2 id="pacman的使用"><a href="#pacman的使用" class="headerlink" title="pacman的使用"></a>pacman的使用</h2><p><a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">pacman</a>)软件包管理器是 Arch Linux 的一大亮点。它将一个简单的二进制包格式和易用的构建系统结合了起来(参见makepkg和ABS)。不管软件包是来自官方的 Arch 库还是用户自己创建，pacman 都能方便地管理。</p>
<p>pacman 通过和主服务器同步软件包列表来进行系统更新。这种服务器/客户端模式可以使用一条命令就下载或安装软件包，同时安装必需的依赖包。</p>
<p>pacman 用 C 语言编写，使用tar打包格式。</p>
<p>我们可以在机子上使用<code>pacman -h</code>来看基本参数或者<code>man pacman</code>来查看具体使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[abc@manjaro ~]$ pacman -h  </span><br><span class="line">usage:  pacman &lt;operation&gt; [...]</span><br><span class="line">operations:</span><br><span class="line">    pacman &#123;-h --help&#125;      <span class="comment">//帮助</span></span><br><span class="line">    pacman &#123;-V --version&#125;   <span class="comment">//查看版本</span></span><br><span class="line">    pacman &#123;-D --database&#125; &lt;options&gt; <span class="xml"><span class="tag">&lt;<span class="name">package(s)</span>&gt;</span>   //数据库选项</span></span><br><span class="line"><span class="xml">    pacman &#123;-F --files&#125;    [options] [package(s)]   </span></span><br><span class="line"><span class="xml">    pacman &#123;-Q --query&#125;    [options] [package(s)]   //列出本机中安装的所有的包</span></span><br><span class="line">    pacman &#123;-R --remove&#125;   [options] &lt;package(s)&gt;   //删除包</span><br><span class="line">    pacman &#123;-S --sync&#125;     [options] [package(s)]   //安装包</span><br><span class="line">    pacman &#123;-T --deptest&#125;  [options] [package(s)]   //</span><br><span class="line">    pacman &#123;-U --upgrade&#125;  [options] &lt;file(s)&gt;      //更新</span><br><span class="line"></span><br><span class="line">use 'pacman &#123;-h --help&#125;' with an operation for available options</span><br></pre></td></tr></table></figure>
<p>主要看 SRUD 这几个参数的意思</p>
<p>　　同步与升级<br>　　安装和升级软件包前，先让本地的包数据库和远程的软件仓库同步是个好习惯。<br>　　pacman -Syy<br>　　也可以使用一句命令同时进行同步软件库并更新系统到最新状态<br>　　pacman -Syu<br>　　安装软件包<br>　　安装或者升级单个软件包，或者一列软件包（包含依赖包），使用如下命令：<br>　　pacman -S package_name1 package_name2<br>　　有时候在不同的软件仓库中，一个软件包有多个版本（比如extra和testing）。你可以选择一个来安装：<br>　　pacman -S extra/package_name<br>　　pacman -S testing/package_name<br>　　你也可以在一个命令里同步包数据库并且安装一个软件包：<br>　　pacman -Sy package_name<br>　　卸载软件包<br>　　删除单个软件包，保留其全部已经安装的依赖关系<br>　　pacman -R package_name<br>　　删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系：<br>　　pacman -Rs package_name<br>　　包数据库查询<br>　　可以使用 -Q 标志搜索和查询本地包数据库。详情参见<br>　　pacman -Q —help<br>　　可以使用-S 标志搜索和查询远程同步的包数据库。详情参见<br>　　pacman -S —help<br>　　其它<br>　　下载包而不安装它：<br>　　pacman -Sw package_name<br>　　安装一个本地包（不从源里）：<br>　　pacman -U /path/to/package/package_name-version.pkg.tar.gz<br>　　完全清理包缓存(/var/cache/pacman/pkg)：<br>　　pacman -Scc　</p>
<p>pacman：</p>
<p>pacman -S   ：安装</p>
<p>pacman -Syu ：升级系统的包</p>
<p>pacman -Ss ：查询</p>
<p>pacman -R   ：删除</p>
<p>pacman -Rs ：删除包和其依赖</p>
<p>pacman -Qs ：查询已安装包</p>
<p>pacman -Qi ：显示查找的包的信息</p>
<p>pacman -Ql：显示包的文件安装位置</p>
<p>pacman -Sw ：下载包但不安装</p>
<p>pacman -U  path/。。。 ： 安装本地的包</p>
<p>pacman -Scc ： 清除缓存</p>
<p>pacman -Sy abc                    和源同步后安装名为abc的包<br>pacman -S abc                     从本地数据库中得到abc的信息，下载安装abc包<br>pacman -Sf abc                    强制安装包abc<br>pacman -Ss abc                   搜索有关abc信息的包<br>pacman -Si abc                    从数据库中搜索包abc的信息<br>pacman -Syu                        同步源，并更新系统<br>pacman -Sy                          仅同步源<br>pacman -R abc                     删除abc包<br>pacman -Rc abc                   删除abc包和依赖abc的包<br>pacman -Rsn abc                 移除包所有不需要的依赖包并删除其配置文件<br>pacman -Sc                          清理/var/cache/pacman/pkg目录下的旧包<br>pacman -Scc                        清除所有下载的包和数据库<br>pacman -Sd abc                   忽略依赖性问题，安装包abc<br>pacman -Su —ignore foo       升级时不升级包foo<br>pacman -Sg abc                   查询abc这个包组包含的软件包<br>pacman -Q                           列出系统中所有的包<br>pacman -Q package             在本地包数据库搜索(查询)指定软件包<br>pacman -Qi package            在本地包数据库搜索(查询)指定软件包并列出相关信息<br>pacman -Q | wc -l                  统计当前系统中的包数量<br>pacman -Qdt                         找出孤立包<br>pacman -Rs $(pacman -Qtdq) 删除孤立软件包（递归的,小心用)</p>
<p>不要开启AUR</p>
<p>yaourt安装暂时不用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/04/ubuntu重装后要做的事/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/04/ubuntu重装后要做的事/" itemprop="url">ubuntu重装后要做的事</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-04T21:16:38+08:00">2018-06-04</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ubuntu重装后要做的事-manjaro看其他"><a href="#ubuntu重装后要做的事-manjaro看其他" class="headerlink" title="ubuntu重装后要做的事(manjaro看其他)"></a>ubuntu重装后要做的事(manjaro看其他)</h1><p>如何安装看<a href="">ubuntu上安装软件方法</a>3种方式安装</p>
<p>重点说下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update  更新源</span><br><span class="line"></span><br><span class="line">sudo apt-get upgrade 更新已安装的包</span><br></pre></td></tr></table></figure>
<p>当然是先安装玩ubuntu18.04咯,当然也有别的版本如voyagerlive和haiku OS<br>还是用ukylin18.04(我的天 这界面xp时代的吧)<br>Manjaro吧,不是Arch,不过这个gnome不好用吧<br>下个debian吧</p>
<h2 id="web专业人员工具"><a href="#web专业人员工具" class="headerlink" title="web专业人员工具"></a>web专业人员工具</h2><h3 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h3><p>Windows MAC Linux 这里说Linux了</p>
<h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>vim sublime vscode<br>atom brackets webstorm</p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>chrome Firefox Safari opera edge ie</p>
<h3 id="图片编辑器"><a href="#图片编辑器" class="headerlink" title="图片编辑器"></a>图片编辑器</h3><p>photoshop gimp</p>
<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>git</p>
<h3 id="自动化构建工具"><a href="#自动化构建工具" class="headerlink" title="自动化构建工具"></a>自动化构建工具</h3><p>grunt glup</p>
<h2 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h2><h3 id="首先删除一些不用的东西"><a href="#首先删除一些不用的东西" class="headerlink" title="首先删除一些不用的东西"></a>首先删除一些不用的东西</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove packageName</span><br></pre></td></tr></table></figure>
<ul>
<li>unity-webapps-common 亚马逊链接  18.04中不是这个名字了,用右键查看细节去删除<ul>
<li><img src="Amazon1.jpg" alt="Amazon1"></li>
</ul>
</li>
<li>rhythmbox 音乐,换网易云16.04,18.04的暂时用不了</li>
<li>libreoffice-common   libreoffice换wps.deb</li>
<li>empathy 聊天软件, 18.04也没这个 没用（系统没这个) 有微信就可以了 github搜 Electronic WeChat  也有wechat这个版本</li>
<li>deja-dup 备份,虚拟机中用不到</li>
<li>thunderbird 自带邮件</li>
<li>transmission-common 自带的bt下载客户端</li>
</ul>
<p>下面这些随意了</p>
<ul>
<li>gnome-mahjongg 对对碰游戏，麻将</li>
<li>simple-scan（扫描器删了，又不是打印，也不是用不到）</li>
<li>aisleriot 纸牌</li>
<li>gnome-mines 扫雷</li>
<li>cheese 相机</li>
<li>gnome-orca 屏幕阅读</li>
<li>webbrowser-app 自带浏览器</li>
<li>gnome-sudoku   数独</li>
<li>onboard 屏幕键盘（虚拟键盘）</li>
<li>landscape-client-ui-install  管理服务</li>
</ul>
<h3 id="换下源-建议先删除不要的东西后再换源-防止不要的软件更新"><a href="#换下源-建议先删除不要的东西后再换源-防止不要的软件更新" class="headerlink" title="换下源(建议先删除不要的东西后再换源,防止不要的软件更新)"></a>换下源(建议先删除不要的东西后再换源,防止不要的软件更新)</h3><p>software&amp;updates中选择切换,虽然大家都选aliyun, 我选了ustc的,当然你可以自动选.<br><img src="yuan1.jpg" alt="yuan1"></p>
<p>然后更新下源和包</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update  更新源,换源后要执行</span><br><span class="line"></span><br><span class="line">sudo apt-get upgrade 更新已安装的包,旧的软件升级</span><br></pre></td></tr></table></figure>
<p>然后就是安装你想要的东西了.</p>
<p>解释下上面为什么<br>首先第一条更新源,其实我们的源,这些地址都保存在<br><code>sudo cat /etc/apt/sources.list</code><br>当然你可以直接修改这里, 也可以按上面说的在software&amp;updates修改.只不过修改完后要执行<br><code>sudo apt-get update</code>来更新, 就这么回事, 不然还是旧的,有缓存到本地软件列表.<br>而第二条<code>sudo apt-get upgrade</code><br>这个命令，会把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。<br><strong>总结下 update是更新本地软件列表，upgrade是升级本地软件</strong></p>
<h3 id="桌面整理"><a href="#桌面整理" class="headerlink" title="桌面整理"></a>桌面整理</h3><h4 id="Dock"><a href="#Dock" class="headerlink" title="Dock"></a>Dock</h4><p>dock换到下面,并且设置自动隐藏<br><img src="dock1.jpg" alt="dock1"></p>
<p>Ubuntu Dock 启用最小化操作：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock click-action 'minimize'</span><br></pre></td></tr></table></figure>
<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>时区修改下,为上海.在setting &gt; detail中<br><img src="time1.jpg" alt="time1"></p>
<h4 id="背景及锁屏和头像"><a href="#背景及锁屏和头像" class="headerlink" title="背景及锁屏和头像"></a>背景及锁屏和头像</h4><p>背景和锁屏在setting中修改<br><img src="background1.jpg" alt="background1"></p>
<p>头像在detail中<br><img src="avatar1.jpg" alt="avatar1"></p>
<h4 id="vm上的工具"><a href="#vm上的工具" class="headerlink" title="vm上的工具"></a>vm上的工具</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install open-vm-tools open-vm-tools-desktop</span><br></pre></td></tr></table></figure>
<h4 id="解锁’Tweaks’隐藏的设置"><a href="#解锁’Tweaks’隐藏的设置" class="headerlink" title="解锁’Tweaks’隐藏的设置"></a>解锁’Tweaks’隐藏的设置</h4><p>安装gnome-tweak-tool</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnome-tweak-tool</span><br></pre></td></tr></table></figure>
<p>1.打开软件，extensions<br>2.启动两个插件 appindicators  dock<br>3.打开软件商城，附加组件<br>4安装  ??</p>
<blockquote>
<p>user themes<br>dash to dock<br>Hide Top Bar<br>weather in the clock</p>
</blockquote>
<h2 id="开始安装web专业人员工具"><a href="#开始安装web专业人员工具" class="headerlink" title="开始安装web专业人员工具"></a>开始安装web专业人员工具</h2><p>先vim git 用apt-get安装好,剩下的用.deb双击好了,要么tar.gz解压好了</p>
<h3 id="编程工具"><a href="#编程工具" class="headerlink" title="编程工具"></a>编程工具</h3><p>都只要解压后 export就行.export PATH=$PATH:/usr/local/go/bin<br>前端</p>
<ul>
<li>chrome</li>
<li>vscode</li>
<li>nvm nodejs nrm</li>
<li>mongodb+robo3T/nosqlbooster4mongo-4.5.2.AppImage</li>
</ul>
<p>其他</p>
<ul>
<li>gcc</li>
<li>IDEA+jdk10</li>
<li>go</li>
<li>jq 处理JSON格式的工具</li>
<li>GIMP</li>
</ul>
<h3 id="终端工具"><a href="#终端工具" class="headerlink" title="终端工具"></a>终端工具</h3><ul>
<li>guake</li>
<li>terminator</li>
<li>tmux</li>
</ul>
<p>shell</p>
<ul>
<li>zsh</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh</span><br><span class="line"><span class="comment">// 然后安装oh-my-zsh, 要先有git 下面二选一</span></span><br><span class="line">sh -c <span class="string">"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</span></span><br><span class="line">sudo wget https:<span class="comment">//github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span></span><br><span class="line"><span class="comment">//在.zshrc中修改自己喜欢的主题 ys</span></span><br><span class="line"><span class="comment">//切换shell为, chsh 命令是改变登陆shell，需要重启才能看到效果。</span></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看本机有哪些shell</span></span><br><span class="line">cat /etc/shells</span><br><span class="line"><span class="comment">// 查看本机用了那个shell用env</span></span><br><span class="line">env | grep SHELL</span><br></pre></td></tr></table></figure>
<p>配置zsh<br>此时已经看到shell已经改变（关了shell重开），默认主题为robbyrussell，接下来我们还要再安装一些插件，更改外观让他变得更强大更好看。<br>zsh的配置文件在用户目录下的.zshrc里面<br>主题配置<br>更改主题只需在~/.zshrc 文件中 修改ZSH_THEME=”设置为你的主题”<br>而在~/.oh-my-zsh/themes下是各种的自带的主题(博主的是ys)。<br>设置方法如下如更改ZSH_THEME为自己的主题名即可<br>ZSH_THEME=”ys”</p>
<p>当然要更新下配置文件<br>source ~/.zshrc</p>
<p><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="noopener">查看主题截图请戳这里</a><br>插件配置<br>添加插件只需在~/.zshrc 文件中<br>~/.oh-my-zsh/plugins里面有默认自带的近百的插件 </p>
<p>powerline的配置</p>
<p>zsh: corrupt history file /home/floodlight/.zsh_history</p>
<p>mv .zsh_history .zsh_history_bad<br>strings .zsh_history_bad &gt; .zsh_history<br>fc -R .zsh_history</p>
<h3 id="文字工具"><a href="#文字工具" class="headerlink" title="文字工具"></a>文字工具</h3><ul>
<li>vim</li>
<li>sublime</li>
<li>wps</li>
<li>typora</li>
</ul>
<h3 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h3><ul>
<li>搜狗</li>
</ul>
<h3 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h3><ul>
<li>htop</li>
<li>shutter</li>
</ul>
<p>触摸屏</p>
<ul>
<li>自带synaptics</li>
<li>Touchégg</li>
<li>Fusuma</li>
</ul>
<p>Indicator-Multiload，(这货有时候你开的多了 gnome桌面就崩了,所以卸载它就好了)<br>是一个很不错的系统指示器，可以显示CPU、内存、网络状态、SWAP交换空间、加载程序、硬盘使用等情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:indicator-multiload/stable-daily</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install indicator-multiload</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/y277an/article/details/51514284" target="_blank" rel="noopener">Psensor 温度传感器 ??</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lm-sensors</span><br><span class="line">sudo sensors-detect</span><br><span class="line">sudo apt-add-repository ppa:jfi/ppa</span><br><span class="line">sudo apt-get update </span><br><span class="line">sudo apt-get install psensor</span><br></pre></td></tr></table></figure>
<p>lm-sensors是一款软件工具，可以借助嵌入在硬件的传感器，监测温度、电压、湿度和风扇运行状况。hddtemp这款工具可以通过S.M.A.R.T.数值，测量硬盘的温度。psensor是一款用于监测温度的图形化前端程序</p>
<p>Linux下Albert 相当于launchy</p>
<h3 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h3><ul>
<li>curl</li>
<li>tsocks 代理</li>
</ul>
<hr>
<h2 id="一些linux上遇到的问题"><a href="#一些linux上遇到的问题" class="headerlink" title="一些linux上遇到的问题"></a>一些linux上遇到的问题</h2><h3 id="vm中"><a href="#vm中" class="headerlink" title="vm中"></a>vm中</h3><p>一旦在任务管理器中终止了VMware导致打不开虚拟机或电脑了，直接把所有的vmware的进程都给结束，然后打开虚拟机就可以了。<br>吓死我了，那个文件只有3K了<br><img src="vm1.png" alt="vm1.png"><br>以后删除快照都要暂停机子搞<br>但这里出现问题，虚拟机中的机子都上不了网了，处理办法：<br>（”我的电脑”）右键—管理—服务，然后启动<br><a href="https://jingyan.baidu.com/article/066074d668155bc3c21cb0ca.html" target="_blank" rel="noopener">VMware Workstation虚拟机不能联网的解决办法</a><br><img src="vm2.png" alt="vm2"></p>
<h3 id="左键失效"><a href="#左键失效" class="headerlink" title="左键失效"></a>左键失效</h3><p><img src="zuojian.png" alt="zuojian.png"><br>虚拟机中的ubuntu菜单栏 这个都点不开，特么这是触摸屏不能按 直接按触摸屏的左键就行</p>
<p>拖动图标，只要左键按住1秒就行<br><img src="zuojian2.png" alt="zuojian2.png"></p>
<p>在18.04中如果点击左键还是失效,显示一个小手,那就按下win键.这个和16.04中按alt拖动不同. 这其实就是老是meta键触发,气死.</p>
<h3 id="无法对下载下来的sublime固定dock上"><a href="#无法对下载下来的sublime固定dock上" class="headerlink" title="无法对下载下来的sublime固定dock上"></a>无法对下载下来的sublime固定dock上</h3><p>就是右键没有add to favorites</p>
<h3 id="小瑕疵"><a href="#小瑕疵" class="headerlink" title="小瑕疵"></a>小瑕疵</h3><p>sublime没有pacman的版本.chrome也是. 当我用tar.gz的用之后怎么把他们都加到all applications中去?</p>
<p>怎么查看我的pacman中有这个软件包,用pacman -Q 不怎么好用</p>
<h3 id="直接下来的原码包怎么用"><a href="#直接下来的原码包怎么用" class="headerlink" title="直接下来的原码包怎么用"></a>直接下来的原码包怎么用</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/30/牛客JS能力评测/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/牛客JS能力评测/" itemprop="url">牛客JS能力评测</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T21:29:19+08:00">2018-05-30</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="牛客JS能力评测"><a href="#牛客JS能力评测" class="headerlink" title="牛客JS能力评测"></a>牛客JS能力评测</h1><h2 id="查找数组元素位置"><a href="#查找数组元素位置" class="headerlink" title="查找数组元素位置"></a>查找数组元素位置</h2><p>题目描述<br>找出元素 item 在给定数组 arr 中的位置<br>输出描述:<br>如果数组中存在 item，则返回元素在数组中的位置，否则返回 -1<br>示例1<br>输入<br>[ 1, 2, 3, 4 ], 3<br>输出<br>2</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">indexOf</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(item) <span class="comment">//indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置，若未找到，则返回-1。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">indexOf</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == item) &#123;</span><br><span class="line">           <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结合两种,</span><br><span class="line">第二种：如果浏览器不支持indexOf怎么办呢？</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">indexOf</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.prototype.indexOf)&#123;   <span class="comment">//判断当前浏览器是否支持</span></span><br><span class="line">      <span class="keyword">return</span> arr.indexOf(item);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[i] === item)&#123;</span><br><span class="line">              <span class="keyword">return</span> i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;     <span class="comment">//总是把return -1暴漏在最外层</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用forEach的话用到return break continue是不会退出的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">indexOf</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">        arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">ele,index</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ele === item)&#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3333</span>,ele);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">indexOf</span>(<span class="params">arr, item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">-1</span>;</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">res,i</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res === item &amp;&amp; index === <span class="number">-1</span>)&#123;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">提供另外一种解法，支持数组arr中的数据类型为对象, 数组, 等。</span><br><span class="line">eg: <span class="keyword">var</span> arr = [&#123;<span class="attr">age</span>: <span class="number">1</span>&#125;, <span class="string">'1'</span>, <span class="number">2</span>, <span class="literal">true</span>, [<span class="number">1</span>,<span class="number">2</span>]], 依然可以测试。</span><br><span class="line"><span class="comment">/** 获取元素位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">indexOf</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr || !arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 支持 arr[i] 为对象，数组等</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">JSON</span>.stringify(arr[i]) === <span class="built_in">JSON</span>.stringify(item)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h2><p>题目描述<br>计算给定数组 arr 中所有元素的总和<br>输入描述:<br>数组中的元素均为 Number 类型<br>示例1<br>输入<br>[ 1, 2, 3, 4 ]<br>输出<br>10</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5种</span></span><br><span class="line"><span class="comment">//常规循环：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i--) &#123;</span><br><span class="line">        s += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//     for (var i=arr.length-1; i&gt;=0; i--) &#123;</span></span><br><span class="line"><span class="comment">//         s += arr[i];</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数式编程 map-reduce：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, curr, idx, arr</span>)</span>&#123;  <span class="comment">//reduce也有个0咯 同forEach</span></span><br><span class="line">        <span class="keyword">return</span> prev + curr;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//forEach遍历：  也可以map,用法同forEach 就是返回一个新数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="number">0</span>;</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val, idx, arr</span>) </span>&#123; <span class="comment">//array.forEach(function(currentValue, index, arr), thisValue)</span></span><br><span class="line">        s += val;</span><br><span class="line">        <span class="comment">//s+=arr[idx]</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不考虑算法复杂度，用递归做：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>] + sum(arr.slice(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//return arr[0] + arguments.callee(arr.slice(1));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//eval：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(arr.join(<span class="string">"+"</span>));</span><br><span class="line"><span class="comment">//eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。</span></span><br><span class="line"><span class="comment">//语法：eval(string)</span></span><br><span class="line"><span class="comment">//参数string：必需。要计算的字符串，其中含有要计算的 JavaScript 表达式或要执行的语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//join() 方法用于把数组中的所有元素放入一个字符串。</span></span><br><span class="line"><span class="comment">//语法：arrayObject.join(separator)</span></span><br><span class="line"><span class="comment">//参数separator：可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//看得懂上面的中文的前提下你的例子就可以这么解释：</span></span><br><span class="line"><span class="comment">//join方法在arr数组的每一个元素之间插入一个 + 号，变成 "1+2+3+4+5+6"，然后eval()函数执行"1+2+3+4+5+6"，最后将结果复制给value。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="移除数组中的元素"><a href="#移除数组中的元素" class="headerlink" title="移除数组中的元素"></a>移除数组中的元素</h2><p>移除数组 arr 中的所有值与 item 相等的元素。<strong>不要直接修改数组 arr，结果返回新的数组</strong><br>示例1<br>输入<br>[1, 2, 3, 4, 2], 2<br>输出<br>[1, 3, 4]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用filter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return arr.filter(function(value, idx, arr) &#123;</span></span><br><span class="line">    <span class="comment">//     if(arr[idx]!=item)&#123;</span></span><br><span class="line">    <span class="comment">//         return value</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value, idx, arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value!=item)&#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return arr.filter(function(value, idx, arr) &#123;</span></span><br><span class="line">    <span class="comment">//     return value!=item</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用push</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; arr.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] != item) &#123;</span><br><span class="line">            newArr.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr,item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == item)&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;;</span><br><span class="line">       newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用splice</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.slice(<span class="number">0</span>);  <span class="comment">//复制一份原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; newArr.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(newArr[i] == item)&#123;</span><br><span class="line">            newArr.splice(i,<span class="number">1</span>)</span><br><span class="line">            i--;    <span class="comment">//这很重要,记得要去掉一个长度哦,返回一步i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒着检测到是不用考虑位置i--</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.slice(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = newArr.length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(newArr[i] == item)&#123;</span><br><span class="line">            newArr.splice(i,<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="移除数组中的元素-1"><a href="#移除数组中的元素-1" class="headerlink" title="移除数组中的元素"></a>移除数组中的元素</h2><p>移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果返回<br>示例1<br>输入<br>[1, 2, 2, 3, 4, 2, 2], 2<br>输出<br>[1, 3, 4]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用splice</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeWithoutCopy</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == item) &#123;</span><br><span class="line">            arr.splice(i, <span class="number">1</span>)</span><br><span class="line">            i--;    <span class="comment">//缺了这个就变成forEach的了,forEach也不是for in</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 倒着检测；不用考虑；位置影响</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeWithoutCopy</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=arr.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">       <span class="keyword">if</span>(arr[i]==item)&#123;</span><br><span class="line">            arr.splice(i,<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用for in就不用考虑i--了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeWithoutCopy</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[i]==item)&#123;</span><br><span class="line">            arr.splice(i,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用forEach有点不对,forEach遍历每一项, 只不过不能控制i--</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeWithoutCopy</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value == item) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">continue</span>; <span class="comment">//没return continue break这种</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个while循环就出来了，判断是否存在，存在了就删掉，不存在return</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeWithoutCopy</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr.indexOf(item) != <span class="number">-1</span>)&#123;         <span class="comment">//一直到找不到item 就不删了</span></span><br><span class="line">        arr.splice(arr.indexOf(item),<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当然也可以这么循环下去写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeWithoutCopy</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> a=arr.indexOf(item);</span><br><span class="line">      arr.splice(a,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用es6的set去重,然后删一次好了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeWithoutCopy</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    arr=<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">    <span class="keyword">var</span> a=arr.indexOf(item);</span><br><span class="line">    arr.splice(a,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个就厉害了,将每次判断第一个是不是和item同,不是就插入末尾,然后删除第一个,是的话直接删除.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeWithoutCopy</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>] !== item)&#123;</span><br><span class="line">            arr.push(arr[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        arr.splice(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>在数组 arr 末尾添加元素 item。不要直接修改数组 arr，结果返回新的数组<br>示例1<br>输入<br>[1, 2, 3, 4],  10<br>输出<br>[1, 2, 3, 4, 10]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用concat将传入的数组或非数组值与原数组合并,组成一个新的数组并返回</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param item</span></span><br><span class="line"><span class="comment"> * @returns &#123;Array.&lt;T&gt;|string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.concat(item);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通的迭代拷贝</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param item</span></span><br><span class="line"><span class="comment"> * @returns &#123;Array&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; arr.length; ++i) &#123;</span><br><span class="line">        newArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    newArr.push(item);</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用slice浅拷贝+push组合</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param item</span></span><br><span class="line"><span class="comment"> * @returns &#123;Blob|ArrayBuffer|Array.&lt;T&gt;|string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> append2 = <span class="function"><span class="keyword">function</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.slice(<span class="number">0</span>);  <span class="comment">// slice(start, end)浅拷贝数组</span></span><br><span class="line">    newArr.push(item);</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用join+split+push组合</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param item</span></span><br><span class="line"><span class="comment"> * @returns &#123;Array&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=arr.join().split(<span class="string">','</span>);  <span class="comment">//就是转了一圈</span></span><br><span class="line">    newArr.push(item);</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//blog.csdn.net/u013005050/article/details/78565636</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用unshift.apply</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param item</span></span><br><span class="line"><span class="comment"> * @returns &#123;Array&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=[item];</span><br><span class="line">    [].unshift.apply(newArr, arr);</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用JSON的parse和stringify</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr))</span><br><span class="line">    result.push(item);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组转化成字符串，然后再使用+号连接item</span></span><br><span class="line"><span class="comment">// 最后分割字符串形成新数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> str = arr.join() + <span class="string">","</span> + item;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">","</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除数组最后一个元素"><a href="#删除数组最后一个元素" class="headerlink" title="删除数组最后一个元素"></a>删除数组最后一个元素</h2><p>删除数组 arr 最后一个元素。不要直接修改数组 arr，结果返回<strong>新的数组</strong><br>示例1<br>输入<br>[1, 2, 3, 4]<br>输出<br>[1, 2, 3]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用slice</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.slice(<span class="number">0</span>, arr.length<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">//return arr.slice(0, -1)   //-1会自动加上length</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通的迭代拷贝for+push</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=arr.length<span class="number">-2</span>;i++)&#123;</span><br><span class="line">        newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制一个新数组(slice或for或concat或join+split或push.apply或JSON.parse(JSON.stringify(arr))),然后pop</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.slice(<span class="number">0</span>)</span><br><span class="line">    newArr.pop()</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用concat+pop</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.concat();</span><br><span class="line">    newArr.pop();</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用join+split+pop    注意！！！：数据类型会变成字符型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.join().split(<span class="string">','</span>);</span><br><span class="line">    newArr.pop();</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用push.apply+pop</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=[];</span><br><span class="line">    [].push.apply(newArr, arr);</span><br><span class="line">    newArr.pop();</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr))</span><br><span class="line">    newArr.pop();</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//复制一个,然后用splice</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.slice(<span class="number">0</span>)</span><br><span class="line">    newArr.splice(newArr.length<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用length改大小</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">arr, item</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> newArr = arr.slice(<span class="number">0</span>);</span><br><span class="line">     newArr.length --;</span><br><span class="line">     <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">总结 复制一个新数组(slice或<span class="keyword">for</span>或concat或join+split或push.apply或<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr)))</span><br><span class="line">出来用pop或splice或length改</span><br></pre></td></tr></table></figure>
<h2 id="添加元素-1"><a href="#添加元素-1" class="headerlink" title="添加元素"></a>添加元素</h2><p>在数组 arr 开头添加元素 item。不要直接修改数组 arr，结果返回新的数组<br>示例1<br>输入<br>[1, 2, 3, 4], 10<br>输出<br>[10, 1, 2, 3, 4]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复制一个新数组(slice或for或concat或join+split或push.apply或JSON.parse(JSON.stringify(arr)),filter和map都可以复制数组)</span></span><br><span class="line"><span class="comment">//用unshift进,splice</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepend</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.slice(<span class="number">0</span>);</span><br><span class="line">    newArr.unshift(item);</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepend</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.slice(<span class="number">0</span>);</span><br><span class="line">    newArr.splice(<span class="number">0</span>, <span class="number">0</span>, item);</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//看顺序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepend</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [item].concat(arr);</span><br><span class="line">    <span class="comment">//return [].concat(item, arr)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用push.apply</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepend</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=[item];</span><br><span class="line">    [].push.apply(newArr, arr);</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除数组第一个元素"><a href="#删除数组第一个元素" class="headerlink" title="删除数组第一个元素"></a>删除数组第一个元素</h2><p>删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组<br>示例1<br>输入<br>[1, 2, 3, 4]<br>输出<br>[2, 3, 4]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接从1开始复制 slice</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curtail</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通的迭代拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curtail</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制后用shift()出</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curtail</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.slice(<span class="number">0</span>)</span><br><span class="line">    newArr.shift();</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//filter也可以复制新数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curtail</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value,index, arr</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// return arr</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;);</span><br><span class="line">    newArr.shift();</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map也可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curtail</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">value,index, arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;);</span><br><span class="line">    newArr.shift();</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用filter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curtail</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value,index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index!==<span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h2><p>合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组<br>示例1<br>输入<br>[1, 2, 3, 4], [‘a’, ‘b’, ‘c’, 1]<br>输出<br>[1, 2, 3, 4, ‘a’, ‘b’, ‘c’, 1]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接concat,   主要就是理解了apply的用法  es6的...</span></span><br><span class="line"><span class="comment">// [].concat.apply([],[[1,2,3],[4,5,6],[7,8,9]])，然后你得到的是[1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr1.concat(arr2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//都用for循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; arr1.length; ++i) &#123;</span><br><span class="line">        newArr.push(arr1[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j&lt; arr2.length; ++j) &#123;</span><br><span class="line">        newArr.push(arr2[j])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用slice+push.apply</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=arr1.slice(<span class="number">0</span>);</span><br><span class="line">    [].push.apply(newArr, arr2);</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用slice+push</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=arr1.slice(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr2.length;i++)&#123;</span><br><span class="line">        newArr.push(arr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用字符串转,也就是join也可以啊</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str=arr1.toString()+<span class="string">","</span>+arr2.toString();</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//es6的...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...arr1, ...arr2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加元素-2"><a href="#添加元素-2" class="headerlink" title="添加元素"></a>添加元素</h2><p>在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组<br>示例1<br>输入<br>[1, 2, 3, 4], ‘z’, 2<br>输出<br>[1, 2, ‘z’, 3, 4]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新数组 复制的话有for slice concat join+split push.apply JSON filter map</span></span><br><span class="line"><span class="comment">//插入用splice,</span></span><br><span class="line"><span class="comment">//或者用slice+concat+slice连上来</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr, item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.slice(<span class="number">0</span>)</span><br><span class="line">    newArr.splice(index, <span class="number">0</span>, item)</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//return arr.slice(0).splice(index,0,item);不行 因为splice的方法当插入使用时，不返回值，只有当删除功能使用时，才有返回值，并且返回值为其删除的数值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用slice+concat,这是分段连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr, item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.slice(<span class="number">0</span>,index).concat(item,arr.slice(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有丶意思 到了index处就push两个</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr, item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i === index)&#123;</span><br><span class="line">            <span class="keyword">var</span> n = [item,arr[i]];</span><br><span class="line">            [].push.apply(m,n);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><p>统计数组 arr 中值等于 item 的元素出现的次数<br>示例1<br>输入<br>[1, 2, 4, 4, 3, 4, 3], 4<br>输出<br>3</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用filter,map也对啊,forEach,要么for</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value ==  item) &#123;</span><br><span class="line">            num ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == item) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有丶意思 用长度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i === item);</span><br><span class="line">    &#125;).length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也是长度,存在就一直push进去</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = [];</span><br><span class="line">    <span class="keyword">var</span> pos = arr.indexOf(item);</span><br><span class="line">    <span class="keyword">while</span>(pos &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">        count.push(pos);</span><br><span class="line">        pos= arr.indexOf(item, pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce()--&gt;从数组的第一项开始，逐个遍历到最后；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, curr, index, arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curr === item ? prev+<span class="number">1</span> : prev;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正则</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.toString().match(<span class="keyword">new</span> <span class="built_in">RegExp</span>(item,<span class="string">"g"</span>)).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找重复元素"><a href="#查找重复元素" class="headerlink" title="查找重复元素"></a>查找重复元素</h2><p>找出数组 arr 中重复出现过的元素<br>示例1<br>输入<br>[1, 2, 4, 4, 3, 3, 1, 5, 3]<br>输出<br>[1, 3, 4]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set数据结构，它类似于数组，其成员的值都是唯一的。</span></span><br><span class="line"><span class="comment">// 利用Array.from将Set结构转换成数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接用...</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> resultarr = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="built_in">console</span>.log(resultarr); <span class="comment">//[1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先用原数组的indexOf+lastIndexOf来判断读取重复的(这里还没用到去重,而是用到读重复),</span></span><br><span class="line"><span class="comment">//在对新数组用indexOf == -1来去重,只不过顺序不一样了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">duplicates</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = [];</span><br><span class="line">    arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.indexOf(value) != arr.lastIndexOf(value) &amp;&amp; newArr.indexOf(value) == <span class="number">-1</span>) &#123;</span><br><span class="line">            newArr.push(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重点在数组去重了</span></span><br><span class="line"><span class="comment">//数组下标判断法, 遍历数组，利用indexOf判断元素的值是否与当前索引相等，如相等则加入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    result = []</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.indexOf(value) == index) &#123;       <span class="comment">//第2中用indexOf了,</span></span><br><span class="line">            result.push(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//典型的循环判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> repeat = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; res.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == res[j]) &#123;</span><br><span class="line">                repeat = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次按顺序判断原数组的第1个,第2个与新数组数组中的所有元素有没有相同的,没有相同就把原数组的当前加入新数组.</span></span><br><span class="line">        <span class="keyword">if</span> (!repeat) &#123;</span><br><span class="line">            res.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双层循环，外层循环元素，内层循环时比较值</span></span><br><span class="line"><span class="comment">// 如果有相同的值则跳过，不相同则push进数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = []</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">                j = ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双层循环，外层循环元素，内层循环时比较值</span></span><br><span class="line"><span class="comment">// 值相同时，则删去这个值</span></span><br><span class="line"><span class="comment">// 注意点:删除元素之后，需要将数组的长度也减1.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">                arr.splice(j, <span class="number">1</span>);</span><br><span class="line">                arr.length--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//还有就是利用sort,再次判断原数组中的第i个元素与新数组中的最后一个元素,因为已经排好序了,所以,重复的都是在相邻,容易比出来</span></span><br><span class="line"><span class="comment">//就是一头一尾进行去重</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    arr.sort(); <span class="comment">//先排序,不需要从大到小 只需要相同的在一起</span></span><br><span class="line">    <span class="comment">// arr.sort(function(a,b)&#123;  //对数组进行排序才能方便比较</span></span><br><span class="line">    <span class="comment">// return a - b;</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] !== result[result.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            result.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去重,用hash对象,</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [], hash = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, elem; i &lt; arr.length; i++) &#123;</span><br><span class="line">        elem = arr[i];  <span class="comment">// hash[arr[i]] != null</span></span><br><span class="line">        <span class="keyword">if</span> (!hash[elem]) &#123;</span><br><span class="line">            result.push(elem);</span><br><span class="line">            hash[elem] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (var i = 0, elem; (elem = arr[i]) != null; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     if (!hash[elem]) &#123;  //判断hasn对象中有没有这个elem属性,没有就加入result</span></span><br><span class="line">    <span class="comment">//         result.push(elem);</span></span><br><span class="line">    <span class="comment">//         hash[elem] = true;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//还有利用下标的 因为number,只不过最后都变成string了,因为对象的属性名就是string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [], hash = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        hash[arr[i]] = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用for in得 key</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> hash) &#123;</span><br><span class="line">        result.push(key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求二次方"><a href="#求二次方" class="headerlink" title="求二次方"></a>求二次方</h2><p>为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组<br>示例1<br>输入<br>[1, 2, 3, 4]<br>输出<br>[1, 4, 9, 16]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接使用map</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value = value*value</span><br><span class="line">        <span class="comment">//return Math.pow(value,2)</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制一个shuzu</span></span><br><span class="line"><span class="comment">//在for</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.slice(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> newArr) &#123;</span><br><span class="line">        newArr[i] = newArr[i]*newArr[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找元素位置"><a href="#查找元素位置" class="headerlink" title="查找元素位置"></a>查找元素位置</h2><p>在数组 arr 中，查找值与 item 相等的元素出现的所有位置<br>示例1<br>输入<br>‘abcdefabc’<br>输出<br>[0, 6]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这题没给出target 所以自己假设有这么个target而且要返回是一个数组 新的.</span></span><br><span class="line"><span class="comment">//filter和map都可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findAllOccurrences</span>(<span class="params">arr, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = []</span><br><span class="line">    arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> newArr.push(index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findAllOccurrences</span>(<span class="params">arr, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == target) &#123;</span><br><span class="line">            newArr.push(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lastIndexOf+slice/splice</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findAllOccurrences</span>(<span class="params">arr, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result=[],index=arr.lastIndexOf(target);</span><br><span class="line">    <span class="keyword">while</span>(index&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">        result.push(index);</span><br><span class="line">        arr.splice(index,<span class="number">1</span>);<span class="comment">//arr=arr.slice(0,index);</span></span><br><span class="line">        index=arr.lastIndexOf(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//indexOf</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findAllOccurrences</span>(<span class="params">arr, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result=[],index=arr.indexOf(target);</span><br><span class="line">    <span class="keyword">while</span>(index&gt;<span class="number">-1</span>)&#123;        <span class="comment">//!=-1</span></span><br><span class="line">        result.push(index);</span><br><span class="line">        index=arr.indexOf(target,index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免全局变量"><a href="#避免全局变量" class="headerlink" title="避免全局变量"></a>避免全局变量</h2><p>给定的 js 代码中存在全局变量，请修复</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globals</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    myObject = &#123;</span><br><span class="line">      name : <span class="string">'Jory'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> myObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globals</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myObject = &#123;</span><br><span class="line">      name : <span class="string">'Jory'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> myObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正确的函数定义"><a href="#正确的函数定义" class="headerlink" title="正确的函数定义"></a>正确的函数定义</h2><p>请修复给定的 js 代码中，函数定义存在的问题<br>示例1<br>输入<br>true<br>输出<br>a</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functions</span>(<span class="params">flag</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'a'</span>; &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'b'</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functions</span>(<span class="params">flag</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> getValue</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'a'</span>; &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'b'</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正确的使用-parseInt"><a href="#正确的使用-parseInt" class="headerlink" title="正确的使用 parseInt"></a>正确的使用 parseInt</h2><p>修改 js 代码中 parseInt 的调用方式，使之通过全部测试用例<br>示例1<br>输入<br>‘12’<br>输出<br>12<br>示例2<br>输入<br>‘12px’<br>输出<br>12<br>示例3<br>输入<br>‘0x12’<br>输出<br>0</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse2Int</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse2Int</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(num, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全等同"><a href="#完全等同" class="headerlink" title="完全等同"></a>完全等同</h2><p>判断 val1 和 val2 是否完全等同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">val1, val2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val1===val2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><p>实现一个打点计时器，要求<br>1、从 start 到 end（包含 start 和 end），每隔 100 毫秒 console.log 一个数字，每次数字增幅为 1<br>2、返回的对象中需要包含一个 cancel 方法，用于停止定时操作<br>3、第一个数需要立即输出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用setInterval clearInterval</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//立即输出第一个值</span></span><br><span class="line">    <span class="built_in">console</span>.log(start++);</span><br><span class="line">    <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(start++);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">//返回一个对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        cancel: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用setTimeout clearTimeout</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(start);</span><br><span class="line">        start++;</span><br><span class="line">        st = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            count(start, end)</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        cancel: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            clearTimeout(st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>实现 fizzBuzz 函数，参数 num 与返回值的关系如下：<br>1、如果 num 能同时被 3 和 5 整除，返回字符串 fizzbuzz<br>2、如果 num 能被 3 整除，返回字符串 fizz<br>3、如果 num 能被 5 整除，返回字符串 buzz<br>4、如果参数为空或者不是 Number 类型，返回 false<br>5、其余情况，返回参数 num</p>
<p>示例1<br>输入<br>15<br>输出<br>fizzbuzz</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fizzBuzz</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num % <span class="number">3</span> ==<span class="number">0</span> &amp;&amp; num % <span class="number">5</span> == <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'fizzbuzz'</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'fizz'</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'buzz'</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> num == <span class="literal">undefined</span> || <span class="keyword">typeof</span> num != <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fizzBuzz</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num % <span class="number">3</span> ==<span class="number">0</span> &amp;&amp; num % <span class="number">5</span> == <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'fizzbuzz'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'fizz'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'buzz'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="literal">null</span> || <span class="keyword">typeof</span> num != <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fizzBuzz</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> num == <span class="literal">null</span> || <span class="keyword">typeof</span>(num) != <span class="string">"number"</span> :<span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> num%<span class="number">3</span>==<span class="number">0</span>&amp;&amp;num%<span class="number">5</span>==<span class="number">0</span> :<span class="keyword">return</span> <span class="string">"fizzbuzz"</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> num%<span class="number">3</span>==<span class="number">0</span> :<span class="keyword">return</span> <span class="string">"fizz"</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> num%<span class="number">5</span>==<span class="number">0</span> :<span class="keyword">return</span> <span class="string">"buzz"</span>;<span class="keyword">break</span>;      </span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">return</span> num;           </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高程明确定义 Number类型下两种表示: var num = 120 or var num1 = new Number(120)</span></span><br><span class="line"><span class="comment">// 高票第一回答下需要考虑一个问题new Number(120)也是Number类型。</span></span><br><span class="line"><span class="comment">// 前者typeof num === 'number', 后者typeof num1 = 'object';</span></span><br><span class="line"><span class="comment">// 最精确的判断方法向来是Object.prototype.toString.call(args) === '[object ' + type + ]';</span></span><br><span class="line"><span class="comment">// 这里type可取[ 'Array', 'Number', 'Object', 'String', 'Undefined', 'null' ]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fizzBuzz</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="literal">undefined</span> || <span class="built_in">Object</span>.prototype.toString.call(num) !== <span class="string">'[object Number]'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">3</span> === <span class="number">0</span> &amp;&amp; num % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'fizzbuzz'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num % <span class="number">3</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'fizz'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'buzz'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h2><p>将数组 arr 中的元素作为调用函数 fn 的参数<br>示例1<br>输入<br>function (greeting, name, punctuation) {return greeting + ‘, ‘ + name + (punctuation || ‘!’);}, [‘Hello’, ‘Ellie’, ‘!’]<br>输出<br>Hello, Ellie!</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用函数可以使用call或者apply这两个方法，区别在于call需要将传递给函数的参数明确写出来，是多少参数就需要写多少参数。而apply则将传递给函数的参数放入一个数组中，传入参数数组即可。</span></span><br><span class="line"><span class="comment">// 调用函数有3种方式：</span></span><br><span class="line"><span class="comment">// obj.func();</span></span><br><span class="line"><span class="comment">// func.call(obj,args);//参数列出</span></span><br><span class="line"><span class="comment">// func.apply(obj,[m,n......]);//参数数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argsAsArray</span>(<span class="params">fn, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 笨办法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argsAsArray</span>(<span class="params">fn, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn(arr[<span class="number">0</span>],arr[<span class="number">1</span>],arr[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用apply</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argsAsArray</span>(<span class="params">fn, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.apply(fn, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argsAsArray</span>(<span class="params">fn, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者不要随便绑定this</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argsAsArray</span>(<span class="params">fn, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用call</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argsAsArray</span>(<span class="params">fn, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.call(fn, arr[<span class="number">0</span>],arr[<span class="number">1</span>],arr[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argsAsArray</span>(<span class="params">fn, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, arr[<span class="number">0</span>],arr[<span class="number">1</span>],arr[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argsAsArray</span>(<span class="params">fn, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn(...arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数的上下文"><a href="#函数的上下文" class="headerlink" title="函数的上下文"></a>函数的上下文</h2><p>将函数 fn 的执行上下文改为 obj 对象<br>示例1<br>输入<br>function () {return this.greeting + ‘, ‘ + this.name + ‘!!!’;}, {greeting: ‘Hello’, name: ‘Rebecca’}<br>输出<br>Hello, Rebecca!!!</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://www.cnblogs.com/libin-1/p/6069031.html</span></span><br><span class="line"><span class="comment">//用apply或call</span></span><br><span class="line"><span class="comment">//还有bind</span></span><br><span class="line"><span class="comment">//bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.bind(obj)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p>实现函数 functionFunction，调用之后满足如下条件：<br>1、返回值为一个函数 f<br>2、调用返回的函数 f，返回值为按照调用顺序的参数拼接，拼接字符为英文逗号加一个空格，即 ‘, ‘<br>3、所有函数的参数数量为 1，且均为 String 类型<br>示例1<br>输入<br>functionFunction(‘Hello’)(‘world’)<br>输出<br>Hello, world</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先传入str,然后返回函数执行,再传入s</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionFunction</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str+<span class="string">', '</span>+s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionFunction</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">newStr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [str, newStr].join(<span class="string">', '</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionFunction</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)).join(<span class="string">', '</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a>使用闭包</h2><p>实现函数 makeClosures，调用之后满足如下条件：<br>1、返回一个函数数组 result，长度与 arr 相同<br>2、运行 result 中第 i 个函数，即 result<a href="">i</a>，结果与 fn(arr[i]) 相同<br>示例1<br>输入<br>[1, 2, 3], function (x) {<br>    return x * x;<br>}<br>输出<br>4</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">简单的描述闭包：如果在函数func内部声明函数inner，然后在函数外部调用inner，这个过程即产生了一个闭包。</span><br><span class="line">题目要求的是返回一个函数数组，如果在循环中直接写result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> fn(arr[i]);&#125;或者result.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> fn(arr[i]);&#125;)，最终的结果是不正确的，因为在每次迭代的时候，那样的语句后面的方法并没有执行，只是创建了一个函数体为“<span class="keyword">return</span> fn(arr[i]);”的函数对象而已，当迭代停止时，i为最终迭代停止的值，在函数被调用时，i依旧为最终迭代停止的值，因此无法返回正确的结果。</span><br><span class="line">为了解决这个问题，需要声明一个匿名函数，并立即执行它。</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> fn(arr[num]); &#125;; &#125;(i)，函数执行后，i立即传入并被内部函数访问到，因此就能得到正确的结果。闭包允许你引用存在于外部函数中的变量。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClosures</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>)</span>&#123;</span><br><span class="line">        result.push(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> fn(num);</span><br><span class="line">            &#125;;</span><br><span class="line">            &#125;(value));  <span class="comment">//只要给fn传递的是arr中的项就行了。我上面用的forEach，迭代的参数就是arr中的每一项,value就是每一项</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClosures</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>)</span>&#123;</span><br><span class="line">        result.push(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> fn(arr[i]) <span class="comment">//只要包上一个函数,传入相应参数就好</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(index));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接用es6的let就不用闭包了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClosures</span>(<span class="params">arr, fn</span>) </span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn(arr[i]); <span class="comment">//let声明的变量只在let所在代码块内有效，因此每次循环的i都是一个新的变量</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//var 这种是错误的写法会导致result中每个函数的参数都是arr[arr.length]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClosures</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn(arr[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参考《JavaScript高级程序设计》的典型方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClosures</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> fn(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此外ES5提供了bind方法，apply(),call(),bind()方法在使用时如果已经对参数进行了定义</span></span><br><span class="line"><span class="comment">//使用ES5的bind()方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClosures</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        result[i] = fn.bind(<span class="literal">null</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还是喜欢直接匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClosures</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; ++i)&#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">            result[v] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> fn.call(<span class="literal">null</span>,arr[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二次封装函数"><a href="#二次封装函数" class="headerlink" title="二次封装函数"></a>二次封装函数</h2><p>已知函数 fn 执行需要 3 个参数。请实现函数 partial，调用之后满足如下条件：<br>1、返回一个函数 result，该函数接受一个参数<br>2、执行 result(str3) ，返回的结果与 fn(str1, str2, str3) 一致<br>示例1<br>输入<br>var sayIt = function(greeting, name, punctuation) {     return greeting + ‘, ‘ + name + (punctuation || ‘!’); };  partial(sayIt, ‘Hello’, ‘Ellie’)(‘!!!’);<br>输出<br>Hello, Ellie!!!</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call和apply必须显式地调用str3，立即执行</span></span><br><span class="line"><span class="comment">// bind不是立即执行，未传入str3时，并未执行，只是返回一个函数，等待参数传入</span></span><br><span class="line"><span class="comment">// this用于上下文不确定的情况</span></span><br><span class="line"></span><br><span class="line">因为这题传入的函数没有用到传入的<span class="keyword">this</span>，所以不管传的是什么，都没有影响。<span class="keyword">this</span>可以改成任何东西</span><br><span class="line"><span class="comment">// call</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">result</span>(<span class="params">str3</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, str1, str2, str3);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// apply（这里只是为了对照）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">result</span>(<span class="params">str3</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, [str1, str2, str3]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个bind会生成一个新函数（对象）, 它的str1, str2参数都定死了, str3未传入, 一旦传入就会执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.bind(<span class="keyword">this</span>, str1, str2); <span class="comment">// 或 return fn.bind(null, str1, str2);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// bind同上, 多了一步, 把str3传入的过程写在另一个函数里面,</span></span><br><span class="line"><span class="comment">// 而另一个函数也有str1, str2参数</span></span><br><span class="line"><span class="comment">// 此法有种多次一举的感觉，但是表示出了后续的调用。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">result</span>(<span class="params">str3</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.bind(<span class="keyword">this</span>, str1, str2)(str3);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 匿名函数，默认this绑定global，与bind的第一个参数为this时效果一样。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">str3</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn(str1, str2, str3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ES6。this指向undefined.</span></span><br><span class="line"><span class="keyword">const</span> partial = <span class="function">(<span class="params">fn, str1, str2</span>) =&gt;</span> str3 =&gt; fn(str1, str2, str3);</span><br></pre></td></tr></table></figure>
<h2 id="使用-arguments"><a href="#使用-arguments" class="headerlink" title="使用 arguments"></a>使用 arguments</h2><p>函数 useArguments 可以接收 1 个及以上的参数。请实现函数 useArguments，返回所有调用参数相加后的结果。本题的测试参数全部为 Number 类型，不需考虑参数转换。<br>示例1<br>输入<br>1, 2, 3, 4<br>输出<br>10</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里重点就是类数组对象：arguments -- 接收所有传入函数的参数值的类数组对象，它有两个特点跟数组很像，1.可以用下标访问每个元素2.具有length属性。</span></span><br><span class="line"><span class="comment">// 这里最好先通过Array.prototype.slice.call(我们的类数组对象) 将其转换成一个真正的数组对象，然后再遍历求和即可。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; ++i) &#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里从类数组转成真的数组,可以用使用数组的迭代方法,不然只要length属性和[]下标可以用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里也是一样,只不过求和方式不同,3种求和方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr=<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)<span class="comment">//把arguments类数组转化为数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(arr.join(<span class="string">"+"</span>));<span class="comment">//求和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-apply-调用函数"><a href="#使用-apply-调用函数" class="headerlink" title="使用 apply 调用函数"></a>使用 apply 调用函数</h2><p>实现函数 callIt，调用之后满足如下条件<br>1、返回的结果为调用 fn 之后的结果<br>2、fn 的调用参数为 callIt 的第一个参数之后的全部参数<br>示例1<br>输入<br>无<br>输出<br>无</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">要注意<span class="built_in">arguments</span>本身不存在slice方法，需要借用<span class="built_in">Array</span>.prototype.slice进行类数组到数组的转换</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callIt</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//将arguments转化为数组后，截取第一个元素之后的所有元素</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//调用fn</span></span><br><span class="line">    <span class="keyword">var</span> result = fn.apply(<span class="literal">null</span>,args);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice (不改变数组)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callIt</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// shift (会改变数组)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callIt</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].shift.call(<span class="built_in">arguments</span>).apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反正就是复制一份arguments</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callIt</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">        args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> result=fn.apply(<span class="literal">null</span>,args);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二次封装函数-1"><a href="#二次封装函数-1" class="headerlink" title="二次封装函数"></a>二次封装函数</h2><p>实现函数 partialUsingArguments，调用之后满足如下条件：<br>1、返回一个函数 result<br>2、调用 result 之后，返回的结果与调用函数 fn 的结果一致<br>3、fn 的调用参数为 partialUsingArguments 的第一个参数之后的全部参数以及 result 的调用参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialUsingArguments</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//先获取p函数第一个参数之后的全部参数</span></span><br><span class="line">     <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">     <span class="comment">//声明result函数</span></span><br><span class="line">     <span class="keyword">var</span> result = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="comment">//使用concat合并两个或多个数组中的元素</span></span><br><span class="line">         <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args.concat([].slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialUsingArguments</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//得到partialUsingArguments方法第一个参数后面的参数组成的数组</span></span><br><span class="line">    <span class="keyword">var</span> args=<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">var</span> result=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//将上面的args和result的参数组合成一个数组argss</span></span><br><span class="line">        <span class="keyword">var</span> argss=args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="comment">//fn调用这个参数数组</span></span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>,argss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>已知 fn 为一个预定义函数，实现函数 curryIt，调用之后满足如下条件：<br>1、返回一个函数 a，a 的 length 属性值为 1（即显式声明 a 接收一个参数）<br>2、调用 a 之后，返回一个函数 b, b 的 length 属性值为 1<br>3、调用 b 之后，返回一个函数 c, c 的 length 属性值为 1<br>4、调用 c 之后，返回的结果与调用 fn 的返回值一致<br>5、fn 的参数依次为函数 a, b, c 的调用参数<br>示例1<br>输入<br>var fn = function (a, b, c) {return a + b + c}; curryIt(fn)(1)(2)(3);<br>输出<br>6</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">柯里化是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。简单理解题目意思，就是指，我们将预定义的函数的参数逐一传入到curryIt中，当参数全部传入之后，就执行预定义函数。于是，我们首先要获得预定义函数的参数个数fn.length，然后声明一个空数组去存放这些参数。返回一个匿名函数接收参数并执行，当参数个数小于fn.length，则再次返回该匿名函数，继续接收参数并执行，直至参数个数等于fn.length。最后，调用apply执行预定义函数。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryIt</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//获取fn参数的数量,总的实参参数个数</span></span><br><span class="line">     <span class="keyword">var</span> n = fn.length;</span><br><span class="line">     <span class="comment">//声明一个数组args</span></span><br><span class="line">     <span class="keyword">var</span> args = [];</span><br><span class="line">     <span class="comment">//返回一个匿名函数</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">         <span class="comment">//将curryIt后面括号中的参数放入数组,这类事返回的,少了一个参数的总参数</span></span><br><span class="line">         args.push(arg);</span><br><span class="line">         <span class="comment">//如果args中的参数个数小于fn函数的参数个数，</span></span><br><span class="line">         <span class="comment">//则执行arguments.callee（其作用是引用当前正在执行的函数，这里是返回的当前匿名函数）。</span></span><br><span class="line">         <span class="comment">//否则，返回fn的调用结果</span></span><br><span class="line">         <span class="keyword">if</span>(args.length &lt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="string">""</span>,args);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryIt</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = fn.length,</span><br><span class="line">        args = [];</span><br><span class="line">    <span class="keyword">var</span> result =  <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>)</span>&#123;</span><br><span class="line">        args.push(arg);</span><br><span class="line">        length --;</span><br><span class="line">        <span class="keyword">if</span>(length &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _args = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, _args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Array</span>.prototype.push.apply(_args, [].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h2><p>返回参数 a 和 b 的逻辑或运算结果<br>示例1<br>输入<br>false, true<br>输出<br>true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">or</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a||b;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="且运算"><a href="#且运算" class="headerlink" title="且运算"></a>且运算</h2><p>返回参数 a 和 b 的逻辑且运算结果<br>示例1<br>输入<br>false, true<br>输出<br>false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">and</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &amp;&amp; b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>完成函数 createModule，调用之后满足如下要求：<br>1、返回一个对象<br>2、对象的 greeting 属性值等于 str1， name 属性值等于 str2<br>3、对象存在一个 sayIt 方法，该方法返回的字符串为 greeting属性值 + ‘, ‘ + name属性值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量模式：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createModule</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> obj = &#123;</span><br><span class="line">         greeting : str1,</span><br><span class="line">         name     : str2,</span><br><span class="line">         sayIt    : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">this</span>.greeting+<span class="string">", "</span>+<span class="keyword">this</span>.name</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> obj</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型模式：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createModule</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting = str1;</span><br><span class="line">        <span class="keyword">this</span>.name = str2;</span><br><span class="line">    &#125;</span><br><span class="line">    Obj.prototype.sayIt = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.greeting + <span class="string">", "</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Obj();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数模式：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createModule</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting = str1;</span><br><span class="line">        <span class="keyword">this</span>.name = str2;</span><br><span class="line">        <span class="keyword">this</span>.sayIt = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.greeting + <span class="string">", "</span> + <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Obj();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象模式：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createModule</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obj = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">        obj.greeting = str1;</span><br><span class="line">        obj.name = str2;</span><br><span class="line">        obj.sayIt = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.greeting + <span class="string">", "</span> + <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CreateObj();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制转换"><a href="#二进制转换" class="headerlink" title="二进制转换"></a>二进制转换</h2><p>获取数字 num 二进制形式第 bit 位的值。注意：<br>1、bit 从 1 开始<br>2、返回 0 或 1<br>3、举例：2 的二进制为 10，第 1 位为 0，第 2 位为 1<br>示例1<br>输入<br>128, 8<br>输出<br>1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//才不是parseInt(num, 2) 这个是把num按基数为2当做, 表示为10进制是多少,而不是转成2进制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">valueAtBit</span>(<span class="params">num, bit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (num &gt;&gt; (bit <span class="number">-1</span>)) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">valueAtBit</span>(<span class="params">num, bit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = num.toString(<span class="number">2</span>);</span><br><span class="line">     <span class="keyword">return</span> s[s.length - bit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">valueAtBit</span>(<span class="params">num, bit</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//toString转化为二进制，split将二进制转化为数组，reverse()将数组颠倒顺序</span></span><br><span class="line">    <span class="keyword">var</span> arr = num.toString(<span class="number">2</span>).split(<span class="string">""</span>).reverse();</span><br><span class="line">    <span class="keyword">return</span> arr[bit<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法多多 就是不知道每个方法的优点与缺点</span></span><br><span class="line"><span class="comment">// 我的是按位与运算 看结果是不是0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">valueAtBit</span>(<span class="params">num, bit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (num&amp;<span class="built_in">Math</span>.pow(<span class="number">2</span>,bit<span class="number">-1</span>))==<span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制转换-1"><a href="#二进制转换-1" class="headerlink" title="二进制转换"></a>二进制转换</h2><p>给定二进制字符串，将其换算成对应的十进制数字<br>示例1<br>输入<br>‘11000000’<br>输出<br>192</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base10</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        其它进制转十进制</span></span><br><span class="line"><span class="comment">        parseInt(str,2)</span></span><br><span class="line"><span class="comment">        parseInt(str,8)</span></span><br><span class="line"><span class="comment">        parseInt(str,16)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(str,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base10</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res=str.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">var</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;res.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=res[i]*<span class="built_in">Math</span>.pow(<span class="number">2</span>,res.length-i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制转换-2"><a href="#二进制转换-2" class="headerlink" title="二进制转换"></a>二进制转换</h2><p>将给定数字转换成二进制字符串。如果字符串长度不足 8 位，则在前面补 0 到满8位。<br>示例1<br>输入<br>65<br>输出<br>01000001</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // 首先通过toString方法将num转为2进制数形式，然后判断其长度是否足够8位。如不足8位，则声明一个“0000000”字符串用于补0，因为目标的2进制数形式最少为一位，因此最多只需要7个0；通过slice方法对“0000000”进行截取，然后将其结果加在目标前面即可。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToBinary</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//转换为2进制格式</span></span><br><span class="line">     <span class="keyword">var</span> s = num.toString(<span class="number">2</span>);</span><br><span class="line">     <span class="comment">//获得2进制数长度</span></span><br><span class="line">     <span class="keyword">var</span> l = s.length;</span><br><span class="line">     <span class="keyword">if</span>(l&lt;<span class="number">8</span>)&#123;</span><br><span class="line">         <span class="comment">//声明一个字符串用于补满0</span></span><br><span class="line">         <span class="keyword">var</span> s1 = <span class="string">"0000000"</span>;</span><br><span class="line">         <span class="keyword">var</span> s2 = s1.slice(<span class="number">0</span>,<span class="number">8</span>-l);</span><br><span class="line">         s = s2+s; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> s;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToBinary</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = num.toString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(str.length &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        str = <span class="string">"0"</span> + str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToBinary</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = num.toString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> res.length &gt; <span class="number">8</span> ? res : (<span class="string">'00000000'</span> + res).slice(<span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>求 a 和 b 相乘的值，a 和 b 可能是小数，需要注意结果的精度问题<br>示例1<br>输入<br>3, 0.0001<br>输出<br>0.0003</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="改变上下文"><a href="#改变上下文" class="headerlink" title="改变上下文"></a>改变上下文</h2><p>将函数 fn 的执行上下文改为 obj，返回 fn 执行后的值<br>示例1<br>输入<br>alterContext(function() {return this.greeting + ‘, ‘ + this.name + ‘!’; }, {name: ‘Rebecca’, greeting: ‘Yo’ })<br>输出<br>Yo, Rebecca!</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//apply  call  bind</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alterContext</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(obj)</span><br><span class="line">    <span class="comment">// return fn.call(obj)</span></span><br><span class="line">    <span class="comment">// return fn.bind(obj)()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="批量改变对象的属性"><a href="#批量改变对象的属性" class="headerlink" title="批量改变对象的属性"></a>批量改变对象的属性</h2><p>给定一个构造函数 constructor，请完成 alterObjects 方法，将 constructor 的所有实例的 greeting 属性指向给定的 greeting 变量。<br>示例1<br>输入<br>var C = function(name) {this.name = name; return this;};<br>var obj1 = new C(‘Rebecca’);<br>alterObjects(C, ‘What\’s up’); obj1.greeting;<br>输出<br>What’s up</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alterObjects</span>(<span class="params">constructor, greeting</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>.prototype.greeting = greeting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性遍历"><a href="#属性遍历" class="headerlink" title="属性遍历"></a>属性遍历</h2><p>找出对象 obj 不在原型链上的属性(注意这题测试例子的冒号后面也有一个空格~)<br>1、返回数组，格式为 key: value<br>2、结果数组不要求顺序<br>示例1<br>输入<br>var C = function() {this.foo = ‘bar’; this.baz = ‘bim’;};<br>C.prototype.bop = ‘bip’;<br>iterate(new C());<br>输出<br>[“foo: bar”, “baz: bim”]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> arr = [];</span><br><span class="line">     <span class="comment">//使用for-in遍历对象属性</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">         <span class="comment">//判断key是否为对象本身的属性</span></span><br><span class="line">         <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">             <span class="comment">//将属性和值按格式存入数组</span></span><br><span class="line">             arr.push(key+<span class="string">": "</span>+obj[key]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyNames(obj).map(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key+<span class="string">": "</span>+obj[key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.keys 只收集自身属性名，不继承自原型链上的属性，所以可以直接这么写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr=<span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    <span class="keyword">var</span> arrs=[];</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        arrs.push(item+<span class="string">': '</span>+obj[item])</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arrs</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/23/vim和shell命令脚本/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/23/vim和shell命令脚本/" itemprop="url">vim和shell命令脚本</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-23T13:42:14+08:00">2018-04-23</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vim-和-shell-命令脚本"><a href="#vim-和-shell-命令脚本" class="headerlink" title="vim 和 shell 命令脚本"></a>vim 和 shell 命令脚本</h1><p>本章首先讲解如何使用<code>Vim编辑器</code>来编写、修改文档，然后通过逐个配置主机名称、系统网卡以及 Yum 软件仓库参数文件等实验，帮助读者加深 Vim 编辑器中诸多命令、快捷键、模式切换方法的理解。<strong>然后把前面章节中讲解的 Linux 命令、命令语法与 Shell 脚本中的各种流程控制语句通过 Vim 编辑器写到 Shell 脚本中结合到一起</strong>，实现最终能够自动化工作的脚本文件。本章最后演示了怎样通过 at 命令与 crond 计划任务服务来分别实现一次性的系统任务设置和长期性的系统任务设置，从而让日常的工作更加高效，更自动化。</p>
<h2 id="Vim-文本编辑器"><a href="#Vim-文本编辑器" class="headerlink" title="Vim 文本编辑器"></a>Vim 文本编辑器</h2><p>“在 Linux 系统中一切都是文件，而配置一个服务就是在修改其配置文件的参数”。而且在日常工作中大家也肯定免不了要编写文档，这些工作都是通过文本编辑器来完成的。<br>Vim 之所以能得到广大厂商与用户的认可，原因在于 Vim 编辑器中设置了<strong>三种模式</strong>—命令模式、末行模式和编辑模式，每种模式分别又支持多种不同的命令快捷键，这大大提高了工作效率，而且用户在习惯之后也会觉得相当顺手。要想高效率地操作文本，就必须先搞清这三种模式的操作区别以及模式之间的切换方法</p>
<blockquote>
<p>命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p>
<p>输入模式：正常的文本录入。</p>
<p>末行模式：保存或退出文档，以及设置编辑环境。</p>
</blockquote>
<p><img src="vim不同模式间的切换.png" alt="vim不同模式间的切换.png"></p>
<p>在每次运行 Vim 编辑器时，<strong>默认进入命令模式</strong>，此时需要先切换到输入模式后再进行文档编写工作，而每次在编写完文档后需要先返回命令模式，然后再进入末行模式，执行文档的保存或退出操作。在 Vim 中，无法直接从输入模式切换到末行模式。Vim 编辑器中内置的命令有成百上千种用法，为了能够帮助读者更快地掌握 Vim 编辑器，</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>dd</td>
<td>删除（剪切）光标所在整行</td>
</tr>
<tr>
<td>5dd</td>
<td>删除（剪切）从光标处开始的 5 行 往下删除 5 行</td>
</tr>
<tr>
<td>yy</td>
<td>复制光标所在整行</td>
</tr>
<tr>
<td>5yy</td>
<td>复制从光标处开始的 5 行</td>
</tr>
<tr>
<td>n</td>
<td>显示搜索命令定位到的下一个字符串</td>
</tr>
<tr>
<td>N</td>
<td>显示搜索命令定位到的上一个字符串</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步的操作 那么回去呢?</td>
</tr>
<tr>
<td>p</td>
<td>将之前<strong>删除</strong>（dd）或复制（yy）过的数据粘贴到光标后面</td>
</tr>
</tbody>
</table>
</div>
<p><strong>末行模式主要用于保存或退出文件</strong>，以及设置 Vim 编辑器的工作环境，还可以让用户执行外部的 Linux 命令或跳转到所编写文档的特定行数。要想切换到末行模式，在命令模式中输入一个冒号就可以了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>保存</td>
</tr>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出（放弃对文档的修改内容）</td>
</tr>
<tr>
<td>:wq!</td>
<td>强制保存退出</td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>不显示行号</td>
</tr>
<tr>
<td>:命令</td>
<td>执行该命令</td>
</tr>
<tr>
<td>:整数</td>
<td>跳转到该行</td>
</tr>
<tr>
<td>:s/one/two</td>
<td>将当前光标所在行的第一个 one 替换成 two</td>
</tr>
<tr>
<td>:s/one/two/g</td>
<td>将当前光标所在行的所有 one 替换成 two</td>
</tr>
<tr>
<td>:%s/one/two/g</td>
<td>将全文中的所有 one 替换成 two</td>
</tr>
<tr>
<td>?字符串</td>
<td>在文本中从下至上搜索该字符串</td>
</tr>
<tr>
<td>/字符串</td>
<td>在文本中从上至下搜索该字符串</td>
</tr>
</tbody>
</table>
</div>
<h2 id="编写简单文档"><a href="#编写简单文档" class="headerlink" title="编写简单文档"></a>编写简单文档</h2><p>编写脚本文档的第 1 步就是给文档取个名字，这里将其命名为 practice.txt。如果存在该文档，则是打开它。如果不存在，则是创建一个临时的输入文件，如图所示。</p>
<p><img src="第1步：创建文档.png" alt="第1步：创建文档.png"></p>
<p>打开 practice.txt 文档后，默认进入的是 Vim 编辑器的<strong>命令模式</strong>。此时只能执行该模式下的命令，而不能随意输入文本内容，我们需要<strong>切换到输入模式</strong>才可以编写文档。</p>
<p>在图 4-1 中提到，可以分别使用<code>a、i、o</code>三个键从命令模式切换到输入模式。其中，a 键与 i 键分别是在<strong>光标后面一位</strong>和<strong>光标当前位置</strong>切换到输入模式，而 o 键则是在<strong>光标的下面再创建一个空行</strong>，此时可敲击 a 键进入到编辑器的输入模式.<br>进入输入模式后，可以随意输入文本内容，Vim 编辑器不会把您输入的文本内容当作命令而执行<br>在编写完之后，想要保存并退出，必须先敲击键盘 Esc 键从输入模式返回命令模式，如图所示。然后再输入:wq!切换到末行模式才能完成保存退出操作</p>
<p><img src="第5步：敲击“：wq”，保存并退出.png" alt="第5步：敲击“：wq”，保存并退出.png"></p>
<p>当在末行模式中输入:wq!命令时，就意味着强制保存并退出文档。然后便可以用 cat 命令查看保存后的文档内容了.</p>
<p>是不是很简单？！继续编辑这个文档。因为要在原有文本内容的下面追加内容，所以在命令模式中敲击 o 键进入输入模式更会高效.</p>
<p>因为此时已经修改了文本内容，所以 Vim 编辑器在我们尝试直接退出文档而不保存的时候就会拒绝我们的操作了。此时只能强制退出才可以结束本次输入操作，</p>
<p>大家在学完了理论知识之后又自己动手编写了一个文本，现在是否感觉成就满满呢？接下来将会由浅入深为读者安排三个小任务。为了彻底掌握 Vim 编辑器的使用，大家一定要逐个完成不许偷懒，如果在完成这三个任务期间忘记了相关命令，可返回前文进一步复习掌握。</p>
<h2 id="配置主机名称"><a href="#配置主机名称" class="headerlink" title="配置主机名称"></a>配置主机名称</h2><p>为了便于在局域网中查找某台特定的主机，或者对主机进行区分，除了要有 IP 地址外，还要为主机配置一个主机名，主机之间可以通过这个类似于域名的名称来相互访问。在 Linux 系统中，主机名大多保存在/etc/hostname 文件中，接下来将/etc/hostname 文件的内容修改为“linuxprobe.com”</p>
<blockquote>
<p>第 1 步：使用 Vim 编辑器修改“<code>/etc/hostname</code>”主机名称文件。</p>
<p>第 2 步：把原始主机名称删除后<strong>追加</strong>“linuxprobe.com”。注意，使用 Vim 编辑器修改主机名称文件后，要在末行模式下执行:wq!命令才能保存并退出文档。</p>
<p>第 3 步：保存并退出文档，然后使用<strong>hostname</strong>命令检查是否修改成功。</p>
</blockquote>
<h2 id="配置网卡信息"><a href="#配置网卡信息" class="headerlink" title="配置网卡信息"></a>配置网卡信息</h2><p>网卡 IP 地址配置的是否正确是两台服务器是否可以<strong>相互通信的前提</strong>。在 Linux 系统中，一切都是文件，因此配置网络服务的工作其实就是在编辑网卡配置文件，因此这个小任务不仅可以帮助您练习使用 Vim 编辑器，而且也为您后面学习 Linux 中的各种服务配置打下了坚实的基础。当您认真学习完本书后，一定会特别有成就感，因为本书前面的基础部分非常扎实，而后面内容则具有几乎一致的网卡 IP 地址和运行环境，从而确保您全身心地投入到各类服务程序的学习上，而不用操心系统环境的问题。</p>
<p>现在有一个名称为 ifcfg-eno16777736 的网卡设备，我们将其配置为开机自启动，并且 IP 地址、子网、网关等信息由人工指定，其步骤应该如下所示。</p>
<p><strong>第 1 步：</strong>首先切换到<code>/etc/sysconfig/network-scripts</code>目录中（存放着网卡的配置文件）。</p>
<p><strong>第 2 步：</strong>使用 Vim 编辑器修改网卡文件 ifcfg-eno16777736，逐项写入下面的配置参数并保存退出。由于每台设备的硬件及架构是不一样的，因此请读者使用 ifconfig 命令自行确认各自网卡的默认名称。</p>
<blockquote>
<p>设备类型：TYPE=Ethernet</p>
<p>地址分配模式：BOOTPROTO=static</p>
<p>网卡名称：NAME=eno16777736</p>
<p>是否启动：ONBOOT=yes</p>
<p>IP 地址：IPADDR=192.168.10.10</p>
<p>子网掩码：NETMASK=255.255.255.0</p>
<p>网关地址：GATEWAY=192.168.10.1</p>
<p>DNS 地址：DNS1=192.168.10.1</p>
</blockquote>
<p><strong>第 3 步：</strong>重启网络服务并测试网络是否联通。</p>
<p>进入到网卡配置文件所在的目录，然后编辑网卡配置文件，在其中填入下面的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># cd /etc/sysconfig/network-scripts/</span></span><br><span class="line">[root@linuxprobe network-scripts]<span class="meta"># vim ifcfg-eno16777736</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=<span class="keyword">static</span></span><br><span class="line">NAME=eno16777736</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=<span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span></span><br><span class="line">NETMASK=<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">GATEWAY=<span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span></span><br><span class="line">DNS1=<span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<p>执行重启网卡设备的命令（在正常情况下不会有提示信息），然后通过 ping 命令测试网络能否联通。由于在 Linux 系统中 ping 命令不会自动终止，因此需要手动按下 Ctrl-c 键来强行结束进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe network-scripts]<span class="meta"># systemctl restart network</span></span><br><span class="line">[root@linuxprobe network-scripts]<span class="meta"># ping 192.168.10.10</span></span><br><span class="line">PING <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> (<span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.081</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">64</span> time=<span class="number">0.083</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">64</span> time=<span class="number">0.059</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">64</span> time=<span class="number">0.097</span> ms</span><br><span class="line">^C</span><br><span class="line">--- <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> ping statistics ---</span><br><span class="line"><span class="number">4</span> packets transmitted, <span class="number">4</span> received, <span class="number">0</span>% packet loss, time <span class="number">2999</span>ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">0.059</span>/<span class="number">0.080</span>/<span class="number">0.097</span>/<span class="number">0.013</span> ms</span><br></pre></td></tr></table></figure>
<h2 id="配置-Yum-仓库"><a href="#配置-Yum-仓库" class="headerlink" title="配置 Yum 仓库"></a>配置 Yum 仓库</h2><p>本书前面讲到，Yum 软件仓库的作用是为了进一步简化 RPM 管理软件的难度以及自动分析所需软件包及其依赖关系的技术。可以把 Yum 想象成是一个硕大的软件仓库，里面保存有几乎所有常用的工具，而且只需要说出所需的软件包名称，系统就会自动为您搞定一切。</p>
<p>既然要使用 Yum 软件仓库，就要先把它搭建起来，然后将其配置规则确定好才行。鉴于第 6 章才会讲解 Linux 的存储结构和设备挂载操作，所以我们当前还是将重心放到 Vim 编辑器的学习上。如果遇到看不懂的参数也不要紧，后面章节会单独讲解。搭建并配置 Yum 软件仓库的大致步骤如下所示</p>
<h2 id="编写-Shell-脚本"><a href="#编写-Shell-脚本" class="headerlink" title="编写 Shell 脚本"></a>编写 Shell 脚本</h2><p><a href="https://zhuanlan.zhihu.com/p/35465182" target="_blank" rel="noopener">Linux shell 编程基础，一看就能入门</a></p>
<p>可以将 Shell 终端解释器当作<strong>人与计算机硬件之间</strong>的“翻译官”，它作为用户与 Linux 系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如<strong>循环、分支</strong>等高级编程语言才有的控制结构特性。要想正确使用 Shell 中的这些功能特性，准确下达命令尤为重要。Shell 脚本命令的工作方式有两种：交互式和批处理。</p>
<blockquote>
<p>交互式（Interactive）：用户每输入一条命令就立即执行。</p>
<p>批处理（Batch）：由用户事先编写好一个完整的 Shell 脚本，Shell 会一次性执行脚本中诸多的命令。</p>
</blockquote>
<p>在 Shell 脚本中不仅会用到前面学习过的很多 Linux 命令以及<strong>正则表达式、管道符、数据流重定向等语法规则</strong>，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的 Shell 脚本。</p>
<p>查看 SHELL 变量可以发现当前系统已经默认使用 Bash 作为命令行终端解释器了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<h2 id="编写简单的脚本"><a href="#编写简单的脚本" class="headerlink" title="编写简单的脚本"></a>编写简单的脚本</h2><p>估计读者在看完上文中有关 Shell 脚本的复杂描述后，会累觉不爱吧。但是，上文指的是一个高级 Shell 脚本的编写原则，其实使用 Vim 编辑器把 Linux 命令按照顺序依次写入到一个文件中，这就是一个简单的脚本了。</p>
<p>例如，如果想查看当前所在工作路径并列出当前目录下所有的文件及属性信息，实现这个功能的脚本应该类似于下面这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim example.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">#For Example BY linuxprobe.com</span><br><span class="line">pwd</span><br><span class="line">ls -al</span><br></pre></td></tr></table></figure>
<p>Shell 脚本文件的名称可以任意，<strong>但为了避免被误以为是普通文件</strong>，建议将<code>.sh</code>后缀加上，以表示是一个脚本文件。在上面的这个 example.sh 脚本中实际上出现了<strong>三种</strong>不同的元素：<br>第一行的脚本声明（<code>#!</code>）用来告诉系统使用哪种 Shell 解释器来执行该脚本；<br>第二行的注释信息（<code>#</code>）是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的作用或一些警告信息；<br>第三、四行的可执行语句也就是我们平时执行的 Linux 命令了。什么？！你们不相信这么简单就编写出来了一个脚本程序，那我们来执行一下看看结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ bash example.sh</span><br><span class="line">/root/Desktop</span><br><span class="line">total <span class="number">8</span></span><br><span class="line">drwxr-xr-x. <span class="number">2</span> root root <span class="number">23</span> Jul <span class="number">23</span> <span class="number">17</span>:<span class="number">31</span> .</span><br><span class="line">dr-xr-x---. <span class="number">14</span> root root <span class="number">4096</span> Jul <span class="number">23</span> <span class="number">17</span>:<span class="number">31</span> ..</span><br><span class="line">-rwxr--r--. <span class="number">1</span> root root <span class="number">55</span> Jul <span class="number">23</span> <span class="number">17</span>:<span class="number">31</span> example.sh</span><br></pre></td></tr></table></figure>
<p>除了上面<strong>用 bash 解释器命令直接运行 Shell 脚本文件外</strong>，第二种运行脚本程序的方法是通过<strong>输入完整路径</strong>的方式来执行。但默认会因为权限不足而提示报错信息，此时只需要为脚本文件<strong>增加执行权限即可</strong>（详见第 5 章）。初次学习 Linux 系统的读者不用心急，等下一章学完用户身份和权限后再来做这个实验也不迟：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# ./example.sh</span><br><span class="line">bash: ./Example.sh: Permission denied</span><br><span class="line">[root@linuxprobe ~]<span class="meta"># chmod u+x example.sh</span></span><br><span class="line">[root@linuxprobe ~]# ./example.sh</span><br><span class="line">/root/Desktop</span><br><span class="line">total <span class="number">8</span></span><br><span class="line">drwxr-xr-x. <span class="number">2</span> root root <span class="number">23</span> Jul <span class="number">23</span> <span class="number">17</span>:<span class="number">31</span> .</span><br><span class="line">dr-xr-x---. <span class="number">14</span> root root <span class="number">4096</span> Jul <span class="number">23</span> <span class="number">17</span>:<span class="number">31</span> ..</span><br><span class="line">-rwxr--r--. <span class="number">1</span> root root <span class="number">55</span> Jul <span class="number">23</span> <span class="number">17</span>:<span class="number">31</span> example.sh</span><br></pre></td></tr></table></figure>
<h2 id="接收用户的参数"><a href="#接收用户的参数" class="headerlink" title="接收用户的参数"></a>接收用户的参数</h2><p>但是，像上面这样的脚本程序只能执行一些预先定义好的功能，未免太过死板了。为了让 Shell 脚本程序更好地满足用户的一些实时需求，以便<strong>灵活</strong>完成工作，必须要让脚本程序能够像之前执行命令时那样，接收用户输入的参数。<br>其实，Linux 系统中的 Shell 脚本语言早就考虑到了这些，已经内设了<strong>用于接收参数的变量</strong>，变量之间可以使用<strong>空格间隔</strong>。例如$0 对应的是当前 Shell 脚本程序的名称，<code>$#</code>对应的是总共有几个参数，<code>$*</code>对应的是所有位置的参数值，<code>$?</code>对应的是显示上一次命令的执行返回值，而$1、$2、$3……则分别对应着第 N 个位置的参数值，如图 4-15 所示。</p>
<p><img src="Shell脚本程序中的参数位置变量.png" alt="Shell脚本程序中的参数位置变量.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># vim example.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">"当前脚本名称为$0"</span></span><br><span class="line">echo <span class="string">"总共有$#个参数，分别是$*。"</span></span><br><span class="line">echo <span class="string">"第1个参数为$1，第5个为$5。"</span></span><br><span class="line">[root@linuxprobe ~]<span class="meta"># sh example.sh one two three four five six</span></span><br><span class="line">当前脚本名称为example.sh</span><br><span class="line">总共有<span class="number">6</span>个参数，分别是one two three four five six。</span><br><span class="line">第<span class="number">1</span>个参数为one，第<span class="number">5</span>个为five。</span><br></pre></td></tr></table></figure>
<h2 id="判断用户的参数"><a href="#判断用户的参数" class="headerlink" title="判断用户的参数"></a>判断用户的参数</h2><p>学习是一个登堂入室、由浅入深的过程。在学习完 Linux 命令、掌握 Shell 脚本语法变量和接收用户输入的信息之后，就要踏上新的高度—能够进一步处理接收到的用户参数。</p>
<p>在本书前面章节中讲到，系统在执行 mkdir 命令时会判断用户输入的信息，即判断用户指定的文件夹名称是否已经存在，如果存在则提示报错；反之则自动创建。Shell 脚本中的<strong>条件测试语法</strong>可以判断表达式是否成立，<strong>若条件成立则返回数字 0，否则便返回其他随机数值</strong>。条件测试语法的执行格式如图 4-16 所示。切记，条件表达式两边均应有一个空格。</p>
<p><img src="测试语句格式.png" alt="测试语句格式.png"></p>
<p>按照测试对象来划分，条件测试语句可以分为 4 种：</p>
<blockquote>
<p>文件测试语句；</p>
<p>逻辑测试语句；</p>
<p>整数值比较语句；</p>
<p>字符串比较语句。</p>
</blockquote>
<p>文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符，具体的参数如表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e</td>
<td>测试文件是否存在</td>
</tr>
<tr>
<td>-f</td>
<td>判断是否为一般文件</td>
</tr>
<tr>
<td>-d</td>
<td>测试文件是否为目录类型</td>
</tr>
<tr>
<td>-r</td>
<td>测试当前用户是否有权限读取</td>
</tr>
<tr>
<td>-w</td>
<td>测试当前用户是否有权限写入</td>
</tr>
<tr>
<td>-x</td>
<td>测试当前用户是否有权限执行</td>
</tr>
</tbody>
</table>
</div>
<p>下面使用文件测试语句来判断/etc/fstab 是否为一个<strong>目录类型</strong>的文件，然后通过 Shell 解释器的内设$?变量显示上一条命令执行后的返回值。如果返回值为 0，则目录存在；如果返回值为非零的值，则意味着目录不存在：(2 步)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# [ -d /etc/fstab ]</span><br><span class="line">[root@linuxprobe ~]<span class="meta"># echo $?</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>再使用文件测试语句来判断/etc/fstab 是否为一般文件，如果返回值为 0，则代表文件存在，且为一般文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# [ -f /etc/fstab ]</span><br><span class="line">[root@linuxprobe ~]<span class="meta"># echo $?</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>逻辑语句</strong>用于对测试结果进行逻辑分析，根据测试结果可实现不同的效果。例如在 Shell 终端中逻辑“与”的运算符号是<code>&amp;&amp;</code>，<strong>它表示当前面的命令执行成功后才会执行它后面的命令</strong>，因此可以用来判断/dev/cdrom 文件是否存在，若存在则输出 Exist 字样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# [ -e /dev/cdrom ] &amp;&amp; echo <span class="string">"Exist"</span></span><br><span class="line">Exist</span><br></pre></td></tr></table></figure>
<p>除了逻辑“与”外，还有逻辑“或”，它在 Linux 系统中的运算符号为<code>||</code>，<strong>表示当前面的命令执行失败后才会执行它后面的命令</strong>，因此可以用来结合系统环境变量 USER 来判断当前登录的用户是否为非管理员身份</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># echo $USER</span></span><br><span class="line">root</span><br><span class="line">[root@linuxprobe ~]# [ $USER = root ] || echo <span class="string">"user"</span></span><br><span class="line">[root@linuxprobe ~]# su - linuxprobe</span><br><span class="line">[linuxprobe@linuxprobe ~]$ [ $USER = root ] || echo <span class="string">"user"</span></span><br><span class="line">user</span><br></pre></td></tr></table></figure>
<p>第三种逻辑语句是“非”，在 Linux 系统中的运算符号是一个叹号（<code>！</code>），它表示把条件测试中的判断结果取相反值。也就是说，如果原本测试的结果是正确的，则将其变成错误的；原本测试错误的结果则将其变成正确的。</p>
<p>我们现在切换回到 root 管理员身份，再判断当前用户是否为一个非管理员的用户。由于判断结果因为两次否定而变成正确，因此会正常地输出预设信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[linuxprobe@linuxprobe ~]$ <span class="built_in">exit</span></span><br><span class="line">logout</span><br><span class="line">[root@linuxprobe root]# [ $USER != root ] || echo <span class="string">"administrator"</span></span><br><span class="line">administrator</span><br></pre></td></tr></table></figure>
<p>当前我们正在登录的即为管理员用户—root。下面这个示例的执行顺序是，先判断当前登录用户的 USER 变量名称是否等于 root，然后用逻辑运算符“非”进行取反操作，效果就变成了判断当前登录的用户是否为非管理员用户了。最后若条件成立则会根据逻辑“与”运算符输出 user 字样；或条件不满足则会通过逻辑“或”运算符输出 root 字样，而如果前面的&amp;&amp;不成立才会执行后面的||符号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# [ $USER != root ] &amp;&amp; echo <span class="string">"user"</span> || echo <span class="string">"root"</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure>
<p>整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且不能想当然地使用日常生活中的<strong>等号、大于号、小于号</strong>等来判断。<strong>因为等号与赋值命令符冲突，大于号和小于号分别与输出重定向命令符和输入重定向命令符冲突</strong>。因此一定要使用规范的整数比较运算符来进行操作。可用的整数比较运算符如表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>是否等于</td>
</tr>
<tr>
<td>-ne</td>
<td>是否不等于</td>
</tr>
<tr>
<td>-gt</td>
<td>是否大于</td>
</tr>
<tr>
<td>-lt</td>
<td>是否小于</td>
</tr>
<tr>
<td>-le</td>
<td>是否等于或小于</td>
</tr>
<tr>
<td>-ge</td>
<td>是否大于或等于</td>
</tr>
</tbody>
</table>
</div>
<p>接下来小试牛刀。我们先测试一下 10 是否大于 10 以及 10 是否等于 10（通过输出的返回值内容来判断）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# [ <span class="number">10</span> -gt <span class="number">10</span> ]</span><br><span class="line">[root@linuxprobe ~]<span class="meta"># echo $?</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[root@linuxprobe ~]# [ <span class="number">10</span> -eq <span class="number">10</span> ]</span><br><span class="line">[root@linuxprobe ~]<span class="meta"># echo $?</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在 2.4 节曾经讲过<code>free</code>命令，它可以用来获取当前系统正在使用及可用的内存量信息。接下来先使用<code>free -m</code>命令查看内存使用量情况（单位为 MB），然后通过<code>grep Mem</code>:命令过滤出剩余内存量的行，再用<code>awk &#39;{print $4}&#39;</code>命令只保留第四列，最后用<code>FreeMem=\</code>语句``的方式把语句内执行的结果赋值给变量。</p>
<p>这个演示确实有些难度，但看懂后会觉得很有意思，没准在运维工作中也会用得上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># free -m</span></span><br><span class="line">            total     used     <span class="built_in">free</span>     shared     buffers     cached</span><br><span class="line">Mem:        <span class="number">1826</span>      <span class="number">1244</span>     <span class="number">582</span>      <span class="number">9</span>          <span class="number">1</span>           <span class="number">413</span></span><br><span class="line">-/+ buffers/cache:    <span class="number">830</span> <span class="number">996</span></span><br><span class="line">Swap:       <span class="number">2047</span>      <span class="number">0</span>        <span class="number">2047</span></span><br><span class="line">[root@linuxprobe ~]<span class="meta"># free -m | grep Mem:</span></span><br><span class="line">Mem:        <span class="number">1826</span>      <span class="number">1244</span>     <span class="number">582</span>      <span class="number">9</span></span><br><span class="line">[root@linuxprobe ~]# free -m | grep Mem: | awk '&#123;print $4&#125;'</span><br><span class="line"><span class="number">582</span></span><br><span class="line">[root@linuxprobe ~]# FreeMem=`free -m | grep Mem: | awk '&#123;print $4&#125;'`</span><br><span class="line">[root@linuxprobe ~]<span class="meta"># echo $FreeMem</span></span><br><span class="line"><span class="number">582</span></span><br></pre></td></tr></table></figure>
<p>上面用于获取内存可用量的命令以及步骤可能有些“超纲”了，如果不能理解领会也不用担心，接下来才是重点。我们使用整数运算符来判断内存可用量的值是否小于 1024，若小于则会提示“Insufficient Memory”（内存不足）的字样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# [ $FreeMem -lt <span class="number">1024</span> ] &amp;&amp; echo <span class="string">"Insufficient Memory"</span></span><br><span class="line">Insufficient Memory</span><br></pre></td></tr></table></figure>
<p><strong>字符串比较语句用于判断测试字符串是否为空值</strong>，或两个字符串是否相同。它经常用来判断某个变量是否未被定义（即内容为空值），理解起来也比较简单。字符串比较中常见的运算符如表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>比较字符串内容是否相同</td>
</tr>
<tr>
<td>!=</td>
<td>比较字符串内容是否不同</td>
</tr>
<tr>
<td>-z</td>
<td>判断字符串内容是否为空</td>
</tr>
</tbody>
</table>
</div>
<p>接下来通过判断 String 变量是否为空值，进而判断是否定义了这个变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# [ -z $String ]</span><br><span class="line">[root@linuxprobe ~]<span class="meta"># echo $?</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>再尝试引入逻辑运算符来试一下。当用于保存当前语系的环境变量值 LANG 不是英语（en.US）时，则会满足逻辑测试条件并输出“Not en.US”（非英语）的字样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># echo $LANG</span></span><br><span class="line">en_US.UTF<span class="number">-8</span></span><br><span class="line">[root@linuxprobe ~]# [ $LANG != <span class="string">"en.US"</span> ] &amp;&amp; echo <span class="string">"Not en.US"</span></span><br><span class="line">Not en.US</span><br></pre></td></tr></table></figure>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>尽管此时可以通过使用 Linux 命令、管道符、重定向以及条件测试语句来编写最基本的 Shell 脚本，但是这种脚本并不适用于生产环境。原因是它不能根据真实的工作需求来调整具体的执行命令，也不能根据某些条件实现自动循环执行。例如，我们需要批量创建 1000 位用户，首先要判断这些用户是否已经存在；若不存在，则通过循环语句让脚本自动且依次创建他们。</p>
<p>接下来我们通过<code>if、for、while、case</code>这 4 种流程控制语句来学习编写难度更大、功能更强的 Shell 脚本。为了保证下文的实用性和趣味性，做到寓教于乐，我会尽可能多地讲解各种不同功能的 Shell 脚本示例，而不是逮住一个脚本不放，在它原有内容的基础上修修补补。尽管这种修补式的示例教学也可以让读者明白理论知识，但是却无法开放思路，不利于日后的工作</p>
<h3 id="if-条件测试语句"><a href="#if-条件测试语句" class="headerlink" title="if 条件测试语句"></a>if 条件测试语句</h3><p>if 条件测试语句可以让脚本根据实际情况自动执行相应的命令。从技术角度来讲，if 语句分为<strong>单分支结构、双分支结构、多分支结构</strong>；其复杂度随着灵活度一起逐级上升。</p>
<p>if 条件语句的单分支结构由<code>if、then、fi</code>关键词组成，而且只在条件成立后才执行预设的命令，相当于口语的“如果……那么……”。单分支的 if 语句属于最简单的一种条件判断结构，语法格式如图</p>
<p><img src="单分支结构-2.png" alt="单分支结构-2.png"></p>
<p>下面使用单分支的 if 条件语句来判断/media/cdrom 文件是否存在，若存在就结束条件判断和整个 Shell 脚本，反之则去创建这个目录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># vim mkcdrom.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">DIR=<span class="string">"/media/cdrom"</span></span><br><span class="line"><span class="keyword">if</span> [ ! -e $DIR ]</span><br><span class="line">then</span><br><span class="line">mkdir -p $DIR</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>由于第 5 章才讲解用户身份与权限，因此这里继续用“bash 脚本名称”的方式来执行脚本。在正常情况下，顺利执行完脚本文件后没有任何输出信息，但是可以使用<code>ls命令验证/media/cdrom</code>目录是否已经成功创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># bash mkcdrom.sh</span></span><br><span class="line">[root@linuxprobe ~]<span class="meta"># ls -d /media/cdrom</span></span><br><span class="line">/media/cdrom</span><br></pre></td></tr></table></figure>
<p>if 条件语句的双分支结构由<code>if、then、else、fi</code>关键词组成，它进行一次条件匹配判断，如果与条件匹配，则去执行相应的预设命令；反之则去执行不匹配时的预设命令，相当于口语的“如果……那么……或者……那么……”。if 条件语句的双分支结构也是一种很简单的判断结构，语法格式如图</p>
<p><img src="双分支结构-1.png" alt="双分支结构-1.png"></p>
<p>下面使用<strong>双分支的 if 条件语句来验证某台主机是否在线</strong>，然后根据返回值的结果，要么显示主机在线信息，要么显示主机不在线信息。这里的脚本主要使用<code>ping</code>命令来测试与对方主机的网络联通性，而 Linux 系统中的 ping 命令不像 Windows 一样尝试 4 次就结束，因此为了避免用户等待时间过长，需要通过<code>-c</code>参数来规定尝试的次数，并使用<code>-i</code>参数定义每个数据包的发送间隔，以及使用<code>-W</code>参数定义等待超时时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># vim chkhost.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">ping -c <span class="number">3</span> -i <span class="number">0.2</span> -W <span class="number">3</span> $<span class="number">1</span> &amp;&gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq <span class="number">0</span> ]</span><br><span class="line">then</span><br><span class="line">echo <span class="string">"Host $1 is On-line."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">echo <span class="string">"Host $1 is Off-line."</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>我们在 4.2.3 小节中用过<code>$?</code>变量，作用是<strong>显示上一次命令的执行返回值</strong>。若前面的那条语句成功执行，则$?变量会显示数字0，反之则显示一个非零的数字（可能为1，也可能为2，取决于系统版本）。因此可以使用整数比较运算符来判断$?变量是否为 0，从而获知那条语句的最终判断情况。这里的服务器 IP 地址为 192.168.10.10，我们来验证一下脚本的效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># bash chkhost.sh 192.168.10.10</span></span><br><span class="line">Host <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> is On-line.</span><br><span class="line">[root@linuxprobe ~]<span class="meta"># bash chkhost.sh 192.168.10.20</span></span><br><span class="line">Host <span class="number">192.168</span><span class="number">.10</span><span class="number">.20</span> is Off-line.</span><br></pre></td></tr></table></figure>
<p>if 条件语句的<code>多分支结构由if、then、else、elif、fi</code>关键词组成，它进行多次条件匹配判断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令，相当于口语的“如果……那么……如果……那么……”。if 条件语句的多分支结构是工作中最常使用的一种条件判断结构，尽管相对复杂但是更加灵活，语法格式如图</p>
<p><img src="多分支结构-2.png" alt="多分支结构-2.png"></p>
<p>下面使用多分支的 if 条件语句来判断用户输入的分数在哪个成绩区间内，然后输出如 Excellent、Pass、Fail 等提示信息。在 Linux 系统中，<code>read</code>是用来读取用户输入信息的命令，能够把接收到的用户输入信息赋值给后面的指定变量，<code>-p</code>参数用于向用户显示一定的提示信息。在下面的脚本示例中，只有当用户输入的分数大于等于 85 分且小于等于 100 分，才输出 Excellent 字样；若分数不满足该条件（即匹配不成功），则继续判断分数是否大于等于 70 分且小于等于 84 分，如果是，则输出 Pass 字样；若两次都落空（即两次的匹配操作都失败了），则输出 Fail 字样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># vim chkscore.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p <span class="string">"Enter your score（0-100）："</span> GRADE</span><br><span class="line"><span class="keyword">if</span> [ $GRADE -ge <span class="number">85</span> ] &amp;&amp; [ $GRADE -le <span class="number">100</span> ] ; then</span><br><span class="line">echo <span class="string">"$GRADE is Excellent"</span></span><br><span class="line">elif [ $GRADE -ge <span class="number">70</span> ] &amp;&amp; [ $GRADE -le <span class="number">84</span> ] ; then</span><br><span class="line">echo <span class="string">"$GRADE is Pass"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">echo <span class="string">"$GRADE is Fail"</span></span><br><span class="line">fi</span><br><span class="line">[root@linuxprobe ~]# bash chkscore.sh</span><br><span class="line">Enter your score（<span class="number">0</span><span class="number">-100</span>）：<span class="number">88</span></span><br><span class="line"><span class="number">88</span> is Excellent</span><br><span class="line">[root@linuxprobe ~]# bash chkscore.sh</span><br><span class="line">Enter your score（<span class="number">0</span><span class="number">-100</span>）：<span class="number">80</span></span><br><span class="line"><span class="number">80</span> is Pass</span><br></pre></td></tr></table></figure>
<p>下面执行该脚本。当用户输入的分数分别为 30 和 200 时，其结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># bash chkscore.sh</span></span><br><span class="line">Enter your score（<span class="number">0</span><span class="number">-100</span>）：<span class="number">30</span></span><br><span class="line"><span class="number">30</span> is Fail</span><br><span class="line">[root@linuxprobe ~]<span class="meta"># bash chkscore.sh</span></span><br><span class="line">Enter your score（<span class="number">0</span><span class="number">-100</span>）：<span class="number">200</span></span><br><span class="line"><span class="number">200</span> is Fail</span><br></pre></td></tr></table></figure>
<p>为什么输入的分数为 200 时，依然显示 Fail 呢？原因很简单—没有成功匹配脚本中的两个条件判断语句，因此自动执行了<strong>最终的兜底策略</strong>。可见，这个脚本还不是很完美，建议读者自行完善这个脚本，使得用户在输入大于 100 或小于 0 的分数时，给予 Error 报错字样的提示。</p>
<h3 id="for-条件循环语句"><a href="#for-条件循环语句" class="headerlink" title="for 条件循环语句"></a>for 条件循环语句</h3><p>for 循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理，当要处理的数据有范围时，使用 for 循环语句再适合不过了。for 循环语句的语法格式如图</p>
<p><img src="for条件语句-1.png" alt="for条件语句-1.png"></p>
<p>下面使用 for 循环语句从列表文件中<strong>读取多个用户名</strong>，然后为其逐一创建用户账户并设置密码。首先创建用户名称的列表文件 users.txt，每个用户名称单独一行。读者可以自行决定具体的用户名称和个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># vim users.txt</span></span><br><span class="line">andy</span><br><span class="line">barry</span><br><span class="line">carl</span><br><span class="line">duke</span><br><span class="line">eric</span><br><span class="line">george</span><br></pre></td></tr></table></figure>
<p>接下来编写 Shell 脚本<strong>Example.sh</strong>。在脚本中使用<code>read</code>命令读取用户输入的密码值，然后赋值给 PASSWD 变量，并通过<code>-p</code>参数向用户显示一段提示信息，告诉用户正在输入的内容即将作为账户密码。在执行该脚本后，会自动使用从列表文件 users.txt 中获取到所有的用户名称，然后逐一使用“id 用户名”命令查看用户的信息，并使用<code>$?</code>判断这条命令是否执行成功，也就是判断该用户是否已经存在。</p>
<p>需要多说一句，<strong>/dev/null 是一个被称作 Linux 黑洞的文件</strong>，把输出信息重定向到这个文件<strong>等同于删除数据</strong>（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># vim Example.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p <span class="string">"Enter The Users Password : "</span> PASSWD</span><br><span class="line"><span class="keyword">for</span> UNAME in `cat users.txt`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">id $UNAME &amp;&gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq <span class="number">0</span> ]</span><br><span class="line">then</span><br><span class="line">echo <span class="string">"Already exists"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">useradd $UNAME &amp;&gt; /dev/null</span><br><span class="line">echo <span class="string">"$PASSWD"</span> | passwd --<span class="built_in">stdin</span> $UNAME &amp;&gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq <span class="number">0</span> ]</span><br><span class="line">then</span><br><span class="line">echo <span class="string">"$UNAME , Create success"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">echo <span class="string">"$UNAME , Create failure"</span></span><br><span class="line">fi</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>执行批量创建用户的 Shell 脚本 Example.sh，在输入为账户设定的密码后将由脚本自动检查并创建这些账户。由于已经将多余的信息通过输出重定向符转移到了/dev/null 黑洞文件中，因此在正常情况下屏幕窗口除了“用户账户创建成功”（Create success）的提示后不会有其他内容。</p>
<p>在 Linux 系统中，<strong>/etc/passwd 是用来保存用户账户信息的文件</strong>。如果想确认这个脚本是否成功创建了用户账户，可以打开这个文件，看其中是否有这些新创建的用户信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># bash Example.sh</span></span><br><span class="line">Enter The Users Password : linuxprobe</span><br><span class="line">andy , Create success</span><br><span class="line">barry , Create success</span><br><span class="line">carl , Create success</span><br><span class="line">duke , Create success</span><br><span class="line">eric , Create success</span><br><span class="line">george , Create success</span><br><span class="line">[root@linuxprobe ~]<span class="meta"># tail -6 /etc/passwd</span></span><br><span class="line">andy:x:<span class="number">1001</span>:<span class="number">1001</span>::/home/andy:/bin/bash</span><br><span class="line">barry:x:<span class="number">1002</span>:<span class="number">1002</span>::/home/barry:/bin/bash</span><br><span class="line">carl:x:<span class="number">1003</span>:<span class="number">1003</span>::/home/carl:/bin/bash</span><br><span class="line">duke:x:<span class="number">1004</span>:<span class="number">1004</span>::/home/duke:/bin/bash</span><br><span class="line">eric:x:<span class="number">1005</span>:<span class="number">1005</span>::/home/eric:/bin/bash</span><br><span class="line">george:x:<span class="number">1006</span>:<span class="number">1006</span>::/home/george:/bin/bash</span><br></pre></td></tr></table></figure>
<p>您还记得在学习双分支 if 条件语句时，用到的那个<strong>测试主机是否在线的脚本么</strong>？既然我们现在已经掌握了 for 循环语句，不妨做些更酷的事情，比如尝试让脚本从文本中自动读取主机列表，然后自动逐个测试这些主机是否在线。</p>
<p>首先创建一个主机列表文件 ipadds.txt：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># vim ipadds.txt</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.10</span><span class="number">.12</span></span><br></pre></td></tr></table></figure>
<p>然后前面的双分支 if 条件语句与 for 循环语句相结合，让脚本从主机列表文件 ipadds.txt 中自动读取 IP 地址（用来表示主机）并将其赋值给 HLIST 变量，从而通过判断 ping 命令执行后的返回值来逐个测试主机是否在线。脚本中出现的$（命令）是一种完全类似于第 3 章的转义字符中反引号<code>命令</code>的 Shell 操作符，效果同样是执行括号或双引号括起来的字符串中的命令。大家在编写脚本时，多学习几种类似的新方法，可在工作中大显身手：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># vim CheckHosts.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">HLIST=$(cat ~/ipadds.txt)</span><br><span class="line"><span class="keyword">for</span> IP in $HLIST</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">ping -c <span class="number">3</span> -i <span class="number">0.2</span> -W <span class="number">3</span> $IP &amp;&gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq <span class="number">0</span> ] ; then</span><br><span class="line">echo <span class="string">"Host $IP is On-line."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">echo <span class="string">"Host $IP is Off-line."</span></span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">[root@linuxprobe ~]# ./CheckHosts.sh</span><br><span class="line">Host <span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> is On-line.</span><br><span class="line">Host <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span> is Off-line.</span><br><span class="line">Host <span class="number">192.168</span><span class="number">.10</span><span class="number">.12</span> is Off-line.</span><br></pre></td></tr></table></figure>
<h3 id="while-条件循环语句"><a href="#while-条件循环语句" class="headerlink" title="while 条件循环语句"></a>while 条件循环语句</h3><p>while 条件循环语句是一种让脚本根据某些条件来重复执行命令的语句，它的循环结构往往在执行前并<strong>不确定最终执行的次数</strong>，完全不同于 for 循环语句中有目标、有范围的使用场景。while 循环语句通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执行，为假就结束循环。while 语句的语法格式如图 4-21 所示。</p>
<p><img src="while条件语句-1.png" alt="while条件语句-1.png"></p>
<p>接下来结合使用多分支的 if 条件测试语句与 while 条件循环语句，编写一个用来猜测数值大小的脚本 Guess.sh。该脚本使用$RANDOM 变量来调取出一个随机的数值（范围为 0 ～ 32767），将这个随机数对 1000 进行取余操作，并使用 expr 命令取得其结果，再用这个数值与用户通过 read 命令输入的数值进行比较判断。这个判断语句分为三种情况，分别是判断用户输入的数值是等于、大于还是小于使用 expr 命令取得的数值。当前，现在这些内容不是重点，我们当前要关注的是 while 条件循环语句中的条件测试始终为 true，因此判断语句会无限执行下去，直到用户输入的数值等于 expr 命令取得的数值后，这两者相等之后才运行 exit 0 命令，终止脚本的执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># vim Guess.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">PRICE=$(expr $RANDOM % <span class="number">1000</span>)</span><br><span class="line">TIMES=<span class="number">0</span></span><br><span class="line">echo <span class="string">"商品实际价格为0-999之间，猜猜看是多少？"</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">read -p <span class="string">"请输入您猜测的价格数目："</span> INT</span><br><span class="line">let TIMES++</span><br><span class="line"><span class="keyword">if</span> [ $INT -eq $PRICE ] ; then</span><br><span class="line">echo <span class="string">"恭喜您答对了，实际价格是 $PRICE"</span></span><br><span class="line">echo <span class="string">"您总共猜测了 $TIMES 次"</span></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br><span class="line">elif [ $INT -gt $PRICE ] ; then</span><br><span class="line">echo <span class="string">"太高了！"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">echo <span class="string">"太低了！"</span></span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>在这个 Guess.sh 脚本中，我们添加了一些交互式的信息，从而使得用户与系统的互动性得以增强。而且每当循环到 let TIMES++命令时都会让 TIMES 变量内的数值加 1，用来统计循环总计执行了多少次。<strong>这可以让用户得知总共猜测了多少次之后，才猜对价格</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># bash Guess.sh</span></span><br><span class="line">商品实际价格为<span class="number">0</span><span class="number">-999</span>之间，猜猜看是多少？</span><br><span class="line">请输入您猜测的价格数目：<span class="number">500</span></span><br><span class="line">太低了！</span><br><span class="line">请输入您猜测的价格数目：<span class="number">800</span></span><br><span class="line">太高了！</span><br><span class="line">请输入您猜测的价格数目：<span class="number">650</span></span><br><span class="line">太低了！</span><br><span class="line">请输入您猜测的价格数目：<span class="number">720</span></span><br><span class="line">太高了！</span><br><span class="line">请输入您猜测的价格数目：<span class="number">690</span></span><br><span class="line">太低了！</span><br><span class="line">请输入您猜测的价格数目：<span class="number">700</span></span><br><span class="line">太高了！</span><br><span class="line">请输入您猜测的价格数目：<span class="number">695</span></span><br><span class="line">太高了！</span><br><span class="line">请输入您猜测的价格数目：<span class="number">692</span></span><br><span class="line">太高了！</span><br><span class="line">请输入您猜测的价格数目：<span class="number">691</span></span><br><span class="line">恭喜您答对了，实际价格是 <span class="number">691</span></span><br><span class="line">您总共猜测了 <span class="number">9</span> 次</span><br></pre></td></tr></table></figure>
<h3 id="case-条件测试语句"><a href="#case-条件测试语句" class="headerlink" title="case 条件测试语句"></a>case 条件测试语句</h3><p>如果您之前学习过 C 语言，看到这一小节的标题肯定会会心一笑“这不就是 switch 语句嘛！”是的，case 条件测试语句和 switch 语句的功能非常相似！case 语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；而如果数据不在所列出的范围内，则会去执行星号（*）中所定义的默认命令。case 语句的语法结构如图</p>
<p><img src="case条件语句-1.png" alt="case条件语句-1.png"></p>
<p>在前文介绍的<strong>Guess.sh 脚本中有一个致命的弱点—只能接受数字！</strong>您可以尝试输入一个字母，会发现脚本立即就崩溃了。原因是字母无法与数字进行大小比较，例如，“a 是否大于等于 3”这样的命题是完全错误的。我们必须有一定的措施来判断用户的输入内容，当用户输入的内容不是数字时，脚本能予以提示，从而免于崩溃。</p>
<p>通过在脚本中组合使用 case 条件测试语句和<strong>通配符</strong>（详见第 3 章），完全可以满足这里的需求。接下来我们编写脚本 Checkkeys.sh，提示用户输入一个字符并将其赋值给变量 KEY，然后根据变量 KEY 的值向用户显示其值是字母、数字还是其他字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># vim Checkkeys.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p <span class="string">"请输入一个字符，并按Enter键确认："</span> KEY</span><br><span class="line"><span class="keyword">case</span> <span class="string">"$KEY"</span> in</span><br><span class="line">[a-z]|[A-Z])</span><br><span class="line">echo <span class="string">"您输入的是 字母。"</span></span><br><span class="line">;;</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>])</span><br><span class="line">echo <span class="string">"您输入的是 数字。"</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo <span class="string">"您输入的是 空格、功能键或其他控制字符。"</span></span><br><span class="line">esac</span><br><span class="line">[root@linuxprobe ~]<span class="meta"># bash Checkkeys.sh</span></span><br><span class="line">请输入一个字符，并按Enter键确认：<span class="number">6</span></span><br><span class="line">您输入的是 数字。</span><br><span class="line">[root@linuxprobe ~]<span class="meta"># bash Checkkeys.sh</span></span><br><span class="line">请输入一个字符，并按Enter键确认：p</span><br><span class="line">您输入的是 字母。</span><br><span class="line">[root@linuxprobe ~]<span class="meta"># bash Checkkeys.sh</span></span><br><span class="line">请输入一个字符，并按Enter键确认：^[[<span class="number">15</span>~</span><br><span class="line">您输入的是 空格、功能键或其他控制字符。</span><br></pre></td></tr></table></figure>
<h2 id="计划任务服务程序"><a href="#计划任务服务程序" class="headerlink" title="计划任务服务程序"></a>计划任务服务程序</h2><p>经验丰富的系统运维工程师可以使得 Linux 在<strong>无需人为介入</strong>的情况下，在指定的时间段自动启用或停止某些服务或命令，从而实现运维的自动化。尽管我们现在已经有了功能彪悍的脚本程序来执行一些批处理工作，但是，如果仍然需要在每天凌晨两点敲击键盘回车键来执行这个脚本程序，这简直太痛苦了（当然，也可以训练您的小猫在半夜按下回车键）。接下来，刘遄老师将向大家讲解如何设置服务器的计划任务服务，把<strong>周期性、规律性</strong>的工作交给系统自动完成。</p>
<p><strong>计划任务分为一次性计划任务与长期性计划任务，大家可以按照如下方式理解。</strong></p>
<blockquote>
<p>一次性计划任务：今晚 11 点 30 分开启网站服务。</p>
<p>长期性计划任务：每周一的凌晨 3 点 25 分把/home/wwwroot 目录打包备份为 backup.tar.gz。</p>
</blockquote>
<p>顾名思义，<strong>一次性计划任务只执行一次</strong>，一般用于满足临时的工作需求。我们可以用<code>at</code>命令实现这种功能，只需要写成“<code>at 时间</code>”的形式就可以。如果想要查看已设置好但还未执行的一次性计划任务，可以使用“<code>at -l</code>”命令；要想将其删除，可以用“<code>atrm 任务序号</code>”。在使用 at 命令来设置一次性计划任务时，<strong>默认采用的是交互式方法</strong>。例如，使用下述命令将系统设置为在今晚 23:30 分自动重启网站服务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># at 23:30</span></span><br><span class="line">at &gt; systemctl restart httpd</span><br><span class="line">at &gt; 此处请同时按下Ctrl+d来结束编写计划任务</span><br><span class="line">job <span class="number">3</span> at Mon Apr <span class="number">27</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">00</span> <span class="number">2015</span></span><br><span class="line">[root@linuxprobe ~]<span class="meta"># at -l</span></span><br><span class="line"><span class="number">3</span> Mon Apr <span class="number">27</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">00</span> <span class="number">2016</span> a root</span><br></pre></td></tr></table></figure>
<p>如果读者想挑战一下难度更大但简捷性更高的方式，可以把前面学习的管道符（任意门）放到两条命令之间，让 at 命令接收前面 echo 命令的输出信息，以达到通过非交互式的方式创建计划一次性任务的目的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># echo <span class="meta-string">"systemctl restart httpd"</span> | at 23:30</span></span><br><span class="line">job <span class="number">4</span> at Mon Apr <span class="number">27</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">00</span> <span class="number">2015</span></span><br><span class="line">[root@linuxprobe ~]<span class="meta"># at -l</span></span><br><span class="line"><span class="number">3</span> Mon Apr <span class="number">27</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">00</span> <span class="number">2016</span> a root</span><br><span class="line"><span class="number">4</span> Mon Apr <span class="number">27</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">00</span> <span class="number">2016</span> a root</span><br></pre></td></tr></table></figure>
<p>如果我们不小心设置了两个一次性计划任务，可以使用下面的命令轻松删除其中一个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># atrm 3</span></span><br><span class="line">[root@linuxprobe ~]<span class="meta"># at -l</span></span><br><span class="line"><span class="number">4</span> Mon Apr <span class="number">27</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">00</span> <span class="number">2016</span> a root</span><br></pre></td></tr></table></figure>
<p>如果我们希望 Linux 系统能够周期性地、有规律地执行某些具体的任务，那么 Linux 系统中默认启用的<code>crond</code>服务简直再适合不过了。创建、编辑计划任务的命令为“<code>crontab -e</code>”，查看当前计划任务的命令为“<code>crontab -l</code>”，删除某条计划任务的命令为“<code>crontab -r</code>”。另外，如果您是以管理员的身份登录的系统，还可以在 crontab 命令中加上<code>-u</code>参数来编辑他人的计划任务。</p>
<p>在正式部署计划任务前，请先跟刘遄老师念一下口诀“<strong>分、时、日、月、星期 命令</strong>”。这是使用 crond 服务设置任务的参数格式（其格式见表 4-6）。需要注意的是，如果有些字段没有设置，则需要使用星号（*）占位，如图</p>
<p><img src="cron计划任务的参数.png" alt="cron计划任务的参数.png"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>分钟</td>
<td>取值为 0 ～ 59 的整数</td>
</tr>
<tr>
<td>小时</td>
<td>取值为 0 ～ 23 的任意整数</td>
</tr>
<tr>
<td>日期</td>
<td>取值为 1 ～ 31 的任意整数</td>
</tr>
<tr>
<td>月份</td>
<td>取值为 1 ～ 12 的任意整数</td>
</tr>
<tr>
<td>星期</td>
<td>取值为 0 ～ 7 的任意整数，其中 0 与 7 均为星期日</td>
</tr>
<tr>
<td>命令</td>
<td>要执行的命令或程序脚本</td>
</tr>
</tbody>
</table>
</div>
<p>假设在每周一、三、五的凌晨 3 点 25 分，都需要使用 tar 命令把某个网站的数据目录进行打包处理，使其作为一个备份文件。我们可以使用 crontab -e 命令来创建计划任务。为自己创建计划任务无需使用-u 参数，具体的实现效果的参数如 crontab -l 命令结果所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># crontab -e</span></span><br><span class="line">no crontab <span class="keyword">for</span> root - <span class="keyword">using</span> an empty one</span><br><span class="line">crontab: installing <span class="keyword">new</span> crontab</span><br><span class="line">[root@linuxprobe ~]# crontab -l</span><br><span class="line"><span class="number">25</span> <span class="number">3</span> * * <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span> /usr/bin/tar -czvf backup.tar.gz /home/wwwroot</span><br></pre></td></tr></table></figure>
<p>需要说明的是，除了用<strong>逗号（,）</strong>来分别表示多个时间段，例如“8,9,12”表示 8 月、9 月和 12 月。还可以用<strong>减号（-）</strong>来表示一段连续的时间周期（例如字段“日”的取值为“12-15”，则表示每月的 12 ～ 15 日）。以及用<strong>除号（/）</strong>表示执行任务的间隔时间（例如“*/2”表示每隔 2 分钟执行一次任务）。</p>
<p>如果在 crond 服务中需要同时包含多条计划任务的命令语句，应每行仅写一条。例如我们再添加一条计划任务，它的功能是每周一至周五的凌晨 1 点钟自动清空/tmp 目录内的所有文件。尤其需要注意的是，在 crond 服务的计划任务参数中，所有命令一定要用绝对路径的方式来写，如果不知道绝对路径，请用 whereis 命令进行查询，rm 命令路径为下面输出信息中加粗部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="meta"># whereis rm</span></span><br><span class="line">rm: /usr/bin/rm /usr/share/man/man1/rm<span class="number">.1</span>.gz /usr/share/man/man1p/rm<span class="number">.1</span>p.gz</span><br><span class="line">[root@linuxprobe ~]<span class="meta"># crontab -e</span></span><br><span class="line">crontab: installing <span class="keyword">new</span> crontab</span><br><span class="line">[root@linuxprobe ~]# crontab -l</span><br><span class="line"><span class="number">25</span> <span class="number">3</span> * * <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span> /usr/bin/tar -czvf backup.tar.gz /home/wwwroot</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> * * <span class="number">1</span><span class="number">-5</span> /usr/bin/rm -rf /tmp<span class="comment">/*</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 crond 服务的配置参数中，可以像 Shell 脚本那样以<strong>#号开头写上注释信息</strong>，这样在日后回顾这段命令代码时可以快速了解其功能、需求以及编写人员等重要信息。</p>
<p>计划任务中的<strong>“分”字段必须有数值，绝对不能为空或是*号，而“日”和“星期”字段不能同时使用</strong>，否则就会发生冲突。</p>
</blockquote>
<p>最后再啰嗦一句，想必读者也已经发现了，<strong>诸如 crond 在内的很多服务默认调用的是 Vim 编辑器</strong>，相信大家现在能进一步体会到在 Linux 系统中掌握 Vim 文本编辑器的好处了吧。所以请大家一定要在彻底掌握 Vim 编码器之后再学习下一章</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/35465182" target="_blank" rel="noopener">Linux shell 编程基础，一看就能入门</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/管道符-重定向与环境变量/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/管道符-重定向与环境变量/" itemprop="url">管道符,重定向与环境变量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-22T09:53:42+08:00">2018-04-22</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>输入输出重定向<ol>
<li>&lt; &lt;&lt; Delimiter</li>
<li>> >>追加 </li>
<li>2&gt; 2&gt;&gt; </li>
<li>$&gt;&gt;</li>
</ol>
</li>
<li>管道命令符<ol>
<li>|</li>
</ol>
</li>
<li>命令行的通配符<ol>
<li>*</li>
<li>?</li>
<li>[0-9]</li>
</ol>
</li>
<li>常用哦转义字符<ol>
<li>\</li>
<li>‘’</li>
<li>“”</li>
<li>``</li>
</ol>
</li>
<li>重要的环境变量<ol>
<li>判断用户是否以<strong>绝对路径或相对路径</strong>的方式输入命令</li>
<li>Linux系统检查用户输入的命令是否为“<strong>别名命令</strong>”</li>
<li>Bash解释器判断用户输入的是<strong>内部命令还是外部命令</strong></li>
<li>系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫作<strong>PATH</strong></li>
</ol>
</li>
</ul>
<h1 id="管道符-重定向与环境变量"><a href="#管道符-重定向与环境变量" class="headerlink" title="管道符,重定向与环境变量"></a>管道符,重定向与环境变量</h1><p>目前为止，我们已经学习了数十个常用的Linux系统命令，如果不能把这些命令进行<strong>组合使用</strong>，则无法提升工作效率。本章首先讲解与文件读写操作有关的重定向技术的<strong>5种模式</strong>:</p>
<ol>
<li>标准覆盖输出重定向</li>
<li>标准追加输出重定向</li>
<li>错误覆盖输出重定向</li>
<li>错误追加输出重定向</li>
<li>输入重定向，</li>
</ol>
<p>让读者通过实验切实理解每个重定向模式的作用，解决输出信息的保存问题。<strong>然后深入讲解管道命令符</strong>，帮助读者掌握命令之间的搭配使用方法，进一步提高命令输出值的处理效率。<br>随后通过讲解Linux系统命令行中的<strong>通配符和常见转义符</strong>，让您输入的Linux命令具有更准确的意义，为下一章学习编写Shell脚本打好功底。<br>最后，本章深度剖析了Bash解释器执行Linux命令的内部原理，为读者掌握<strong>PATH变量及Linux系统中的重要环境变量</strong>打下了基础。</p>
<h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><p>既然我们已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的<strong>输入重定向和输出重定向的原理。</strong></p>
<p>简而言之，<strong>输入重定向</strong>是指把文件导入到命令中，而<strong>输出重定向</strong>则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用<strong>输出重定向的频率更高</strong>，所以又将输出重定向分为了<strong>标准输出重定向和错误输出重定向</strong>两种不同的技术，以及<strong>清空写入与追加</strong>写入两种模式。</p>
<blockquote>
<p>标准输入重定向（STDIN，文件描述符为0）：默认从键盘输入，也可从其他文件或命令中输入。</p>
<p>标准输出重定向（STDOUT，文件描述符为1）：默认输出到屏幕。</p>
<p>错误输出重定向（STDERR，文件描述符为2）：默认输出到屏幕。</p>
</blockquote>
<p>比如我们<strong>分别查看两个文件的属性信息</strong>，其中第二个文件是不存在的，虽然针对这两个文件的操作都分别会在屏幕上输出一些数据信息，但这两个操作的差异其实很大：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ touch linuxprobe</span><br><span class="line">$ ls -l linuxprobe </span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">0</span> Aug <span class="number">5</span> <span class="number">05</span>:<span class="number">35</span> linuxprobe</span><br><span class="line">$ ls -l xxxxxx</span><br><span class="line">ls: cannot access xxxxxx: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure>
<p>在上述命令中，名为linuxprobe的文件是存在的，输出信息是该文件的一些相关权限、所有者、所属组、文件大小及修改时间等信息，这也是该命令的标准输出信息。而名为xxxxxx的第二个文件是不存在的，因此在执行完ls命令之后显示的报错提示信息也是该命令的错误输出信息。那么，要想把原本输出到屏幕上的数据转而写入到文件当中，就要区别对待这两种输出信息。</p>
<p>对于输入重定向来讲，用到的符号及其作用如表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令 &lt; 文件</td>
<td>将文件作为命令的标准输入</td>
</tr>
<tr>
<td>命令 &lt;&lt; 分界符</td>
<td>从标准输入中读入，直到遇见分界符才停止</td>
</tr>
<tr>
<td>命令 &lt; 文件1 &gt; 文件2</td>
<td>将文件1作为命令的标准输入并将标准输出到文件2</td>
</tr>
</tbody>
</table>
</div>
<p>对于输出重定向来讲，用到的符号及其作用如表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令 &gt; 文件</td>
<td>将标准输出重定向到一个文件中（<strong>清空</strong>原有文件的数据）</td>
</tr>
<tr>
<td>命令 2&gt; 文件</td>
<td>将错误输出重定向到一个文件中（清空原有文件的数据）</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件</td>
<td>将标准输出重定向到一个文件中（<strong>追加</strong>到原有内容的后面）</td>
</tr>
<tr>
<td>命令 2&gt;&gt; 文件</td>
<td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td>
<td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td>
</tr>
</tbody>
</table>
</div>
<p>对于重定向中的<strong>标准输出</strong>模式，可以省略文件描述符1不写，而<strong>错误输出</strong>模式的文件描述符2是必须要写的。我们先来小试牛刀。通过标准输出重定向将man bash命令原本要输出到屏幕的信息写入到文件readme.txt中，然后显示readme.txt文件中的内容。具体命令如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ man bash &gt; readme.txt</span><br><span class="line">$ cat readme.txt</span><br></pre></td></tr></table></figure>
<p>我们接下来尝试输出重定向技术中的<strong>覆盖写入与追加写入</strong>这两种不同模式带来的变化。首先通过覆盖写入模式向readme.txt文件写入一行数据（该文件中包含上一个实验的man命令信息），然后再通过追加写入模式向文件再写入一次数据，其命令如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="string">"Welcome to LinuxProbe.Com"</span> &gt; readme.txt</span><br><span class="line">$ echo <span class="string">"Quality linux learning materials"</span> &gt;&gt; readme.txt</span><br></pre></td></tr></table></figure>
<p>虽然都是输出重定向技术，但是不同命令的标准输出和错误输出还是有区别的。例如查看当前目录中某个文件的信息，这里以linuxprobe文件为例。因为这个文件是真实存在的，<strong>因此使用标准输出即可将原本要输出到屏幕的信息写入到文件中，而错误的输出重定向则依然把信息输出到了屏幕上。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l linuxprobe </span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">0</span> Mar  <span class="number">1</span> <span class="number">13</span>:<span class="number">30</span> linuxprobe</span><br><span class="line">$ ls -l linuxprobe &gt; /root/<span class="built_in">stderr</span>.txt </span><br><span class="line">$ ls -l linuxprobe <span class="number">2</span>&gt; /root/<span class="built_in">stderr</span>.txt </span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">0</span> Mar  <span class="number">1</span> <span class="number">13</span>:<span class="number">30</span> linuxprobe  <span class="comment">//输出到屏幕</span></span><br></pre></td></tr></table></figure>
<p><strong>如果想把命令的报错信息写入到文件</strong>，该怎么操作呢？当用户在执行一个自动化的Shell脚本时，这个操作会特别有用，而且特别实用，因为它可以把整个脚本执行过程中的报错信息都记录到文件中，便于安装后的排错工作。接下来我们以一个不存在的文件进行实验演示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l xxxxxx </span><br><span class="line">cannot access xxxxxx: No such file <span class="keyword">or</span> directory</span><br><span class="line">$ ls -l xxxxxx &gt; /root/<span class="built_in">stderr</span>.txt</span><br><span class="line">cannot access xxxxxx: No such file <span class="keyword">or</span> directory</span><br><span class="line">$ ls -l xxxxxx <span class="number">2</span>&gt; /root/<span class="built_in">stderr</span>.txt  <span class="comment">//与上面区别,这个如果不报错的情况下,当然输出到屏幕,相当于不执行.但是如果报错,那么用2&gt; 将错误信息写入文件.本来错误信息是输出到屏幕的.</span></span><br><span class="line">$ cat /root/<span class="built_in">stderr</span>.txt </span><br><span class="line">ls: cannot access xxxxxx: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure>
<p>输入重定向相对来说有些冷门，在工作中遇到的概率会小一点。输入重定向的作用是把文件直接导入到命令中。接下来使用输入重定向把readme.txt文件导入给wc -l命令，统计一下文件中的内容行数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wc -l &lt; readme.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述命令实际上等同于接下来要学习的cat readme.txt | wc -l的管道符命令组合。</p>
</blockquote>
<h2 id="管道命令符"><a href="#管道命令符" class="headerlink" title="管道命令符"></a>管道命令符</h2><p>细心的读者肯定还记得在2.6节学习tr命令时曾经见到过一个名为管道符的东西。同时按下键盘上的Shift+\键即可输入管道符<code>|</code>，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话来概括“<strong>把前一个命令原本要输出到屏幕的标准正常数据当作是后一个命令的标准输入</strong>”。在2.8节讲解grep文本搜索命令时，我们通过匹配关键词/sbin/nologin找出了所有被限制登录系统的用户。在学完本节内容后，完全可以把下面这两条命令合并为一条：</p>
<blockquote>
<p>找出被限制登录用户的命令是grep “/sbin/nologin” /etc/passwd；</p>
<p>统计文本行数的命令则是wc -l。</p>
</blockquote>
<p>现在要做的就是把搜索命令的输出值传递给统计命令，即把原本要输出到屏幕的用户信息列表再交给wc命令作进一步的加工，因此只需要把管道符放到两条命令之间即可，具体如下。这简直是太方便了！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep <span class="string">"/sbin/nologin"</span> /etc/passwd | wc -l</span><br></pre></td></tr></table></figure>
<p>这个管道符就像一个法宝，我们可以将它套用到其他不同的命令上，比如<strong>用翻页的形式查看/etc目录中的文件列表及属性信息</strong>（这些内容默认会一股脑儿地显示到屏幕上，根本看不清楚）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /etc/ | more</span><br><span class="line">total <span class="number">1400</span></span><br><span class="line">drwxr-xr-x. <span class="number">3</span> root root <span class="number">97</span> Jul <span class="number">10</span> <span class="number">17</span>:<span class="number">26</span> abrt</span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">16</span> Jul <span class="number">10</span> <span class="number">17</span>:<span class="number">36</span> adjtime</span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">1518</span> Jun <span class="number">7</span> <span class="number">2013</span> aliases</span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">12288</span> Jul <span class="number">10</span> <span class="number">09</span>:<span class="number">38</span> aliases.db</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<p>在修改用户密码时，通常都需要<strong>输入两次密码以进行确认</strong>，这在编写自动化脚本时将成为一个非常致命的缺陷。通过把管道符和passwd命令的—stdin参数相结合，我们可以用一条命令来完成密码重置操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="string">"linuxprobe"</span> | passwd --<span class="built_in">stdin</span> root</span><br><span class="line">Changing password <span class="keyword">for</span> user root.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>
<p>大家是不是觉得管道符命令有些相见恨晚？管道符的玩法还有很多，比如，在发送电子邮件时，默认采用交互式的方式来进行，我们完全可以利用一条结合了管道符的命令语句，<strong>把编辑好的内容与标题一起“打包”</strong>，最终用这一条命令实现邮件的发送。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="string">"Content"</span> | mail -s <span class="string">"Subject"</span> linuxprobe</span><br><span class="line">$ su - linuxprobe</span><br><span class="line">Last login: Fri Jul <span class="number">10</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">07</span> CST <span class="number">2017</span> on :<span class="number">0</span></span><br><span class="line">$ mail</span><br><span class="line">Heirloom Mail version <span class="number">12.5</span> <span class="number">7</span>/<span class="number">5</span>/<span class="number">10.</span> Type ? <span class="keyword">for</span> help.</span><br><span class="line"><span class="string">"/var/spool/mail/linuxprobe"</span>: <span class="number">1</span> message <span class="number">1</span> <span class="keyword">new</span></span><br><span class="line">&gt;N <span class="number">1</span> root Sun Aug <span class="number">30</span> <span class="number">17</span>:<span class="number">33</span> <span class="number">18</span>/<span class="number">578</span> <span class="string">"Subject"</span></span><br></pre></td></tr></table></figure>
<p>如果读者是一名Linux新手，可能会觉得上面的命令组合已经十分复杂了，但是有过运维经验的读者又会感觉如隔靴挠痒般不过瘾，他们希望能将这样方便的命令写得更高级一些，功能更强大一些。比如通过重定向技术能够一次性地把多行信息打包输入或输出，让日常工作更有效率。</p>
<p>下面这条自造的命令就结合使用了<strong>mail邮件命令与输入重定向的分界符</strong>，其目的是让用户一直输入内容，直到用户输入了其自定义的分界符时，才结束输入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mail -s <span class="string">"Readme"</span> root@linuxprobe.com &lt;&lt; over</span><br><span class="line">&gt; I think linux is very practical</span><br><span class="line">&gt; I hope to learn more</span><br><span class="line">&gt; can you teach me ?</span><br><span class="line">&gt; over</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>当然，大家千万不要误以为管道命令符只能在一个命令组合中使用一次，我们完全可以这样使用：“命令A | 命令B | 命令C”。</p>
<h2 id="命令行的通配符"><a href="#命令行的通配符" class="headerlink" title="命令行的通配符"></a>命令行的通配符</h2><p>大家可能都遇到过提笔忘字的尴尬，作为Linux运维人员，我们有时候也会遇到明明一个文件的名称就在嘴边但就是想不起来的情况。如果就记得一个文件的开头几个字母，想遍历查找出所有以这个关键词开头的文件，该怎么操作呢？又比如，假设想要批量查看所有硬盘文件的相关权限属性，一种方式是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /dev/sda</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk <span class="number">8</span>, <span class="number">0</span> May <span class="number">4</span> <span class="number">15</span>:<span class="number">55</span> /dev/sda</span><br><span class="line">$ ls -l /dev/sda1</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk <span class="number">8</span>, <span class="number">1</span> May <span class="number">4</span> <span class="number">15</span>:<span class="number">55</span> /dev/sda1</span><br><span class="line">$ ls -l /dev/sda2</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk <span class="number">8</span>, <span class="number">2</span> May <span class="number">4</span> <span class="number">15</span>:<span class="number">55</span> /dev/sda2</span><br><span class="line">$ ls -l /dev/sda3</span><br><span class="line">ls: cannot access /dev/sda3: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure>
<p>幸亏我的硬盘文件和分区只有3个，要是有几百个，估计需要花费一天的时间来忙这个事情了。由此可见，这种方式的效率确实很低。虽然我们在第6章才会讲解Linux系统的存储结构和FHS，但现在我们应该能看出一些简单规律了。比如，这些硬盘设备文件<strong>都是以sda开头并且存放到了/dev目录中</strong>，这样一来，即使我们不知道硬盘的分区编号和具体分区的个数，也可以使用通配符来搞定。<br>顾名思义，通配符就是通用的匹配信息的符号，比如星号（<code>*</code>）代表匹配零个或多个字符，问号（<code>?</code>）代表匹配单个字符，中括号内加上数字<code>[0-9]</code>代表匹配0～9之间的单个数字的字符，而中括号内加上字母<code>[abc]</code>则是代表匹配a、b、c三个字符中的任意一个字符。俗话讲“百闻不如一见，看书不如实验”，下面我们就来匹配所有在/dev目录中且以sda开头的文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /dev/sda*</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk <span class="number">8</span>, <span class="number">0</span> May <span class="number">4</span> <span class="number">15</span>:<span class="number">55</span> /dev/sda</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk <span class="number">8</span>, <span class="number">1</span> May <span class="number">4</span> <span class="number">15</span>:<span class="number">55</span> /dev/sda1</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk <span class="number">8</span>, <span class="number">2</span> May <span class="number">4</span> <span class="number">15</span>:<span class="number">55</span> /dev/sda2</span><br></pre></td></tr></table></figure>
<p>如果只想查看文件名为sda开头，但是后面还紧跟其他某一个字符的文件的相关信息，该怎么操作呢？这时就需要用到问号来进行通配了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /dev/sda?</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk <span class="number">8</span>, <span class="number">1</span> May <span class="number">4</span> <span class="number">15</span>:<span class="number">55</span> /dev/sda1</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk <span class="number">8</span>, <span class="number">2</span> May <span class="number">4</span> <span class="number">15</span>:<span class="number">55</span> /dev/sda2</span><br></pre></td></tr></table></figure>
<p>除了使用[0-9]来匹配0~9之间的单个数字，也可以用[135]这样的方式仅匹配这三个指定数字中的一个，若没有匹配到，则不会显示出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /dev/sda[<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk <span class="number">8</span>, <span class="number">1</span> May <span class="number">4</span> <span class="number">15</span>:<span class="number">55</span> /dev/sda1</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk <span class="number">8</span>, <span class="number">2</span> May <span class="number">4</span> <span class="number">15</span>:<span class="number">55</span> /dev/sda2</span><br><span class="line">$ ls -l /dev/sda[<span class="number">135</span>]</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk <span class="number">8</span>, <span class="number">1</span> May <span class="number">4</span> <span class="number">15</span>:<span class="number">55</span> /dev/sda1</span><br></pre></td></tr></table></figure>
<h2 id="常用的转义字符"><a href="#常用的转义字符" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h2><p>为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。从数十个转义字符中提炼出了<strong>4个</strong>最常用的转义字符！</p>
<p>4个最常用的转义字符如下所示。</p>
<blockquote>
<p>反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。</p>
<p>单引号（’’）：转义其中所有的变量为单纯的字符串。</p>
<p>双引号（””）：保留其中的变量属性，不进行转义处理。</p>
<p>反引号（``）：把其中的命令执行后返回结果。</p>
</blockquote>
<p>我们先定义一个名为PRICE的变量并赋值为5，然后输出以双引号括起来的字符串与变量信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ PRICE=<span class="number">5</span></span><br><span class="line">$ echo <span class="string">"Price is $PRICE"</span></span><br><span class="line">Price is <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们希望能够输出“Price is $5”，即价格是5美元的字符串内容，但碰巧美元符号与变量提取符号合并后的<strong>$$作用是显示当前程序的进程ID号</strong>码，于是命令执行后输出的内容并不是我们所预期的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="string">"Price is $$PRICE"</span> </span><br><span class="line">Price is <span class="number">3767</span>PRICE</span><br></pre></td></tr></table></figure>
<p>要想让<strong>第一个“$”</strong>乖乖地作为美元符号，那么就需要使用反斜杠（<code>\</code>）来进行转义，将这个命令提取符转义成单纯的文本，去除其特殊功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="string">"Price is \$$PRICE"</span></span><br><span class="line">Price is $<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>而如果只需要某个命令的输出值时，可以像<code>命令</code>这样，将命令用<strong>反引号</strong>括起来，达到预期的效果。例如，将反引号与uname -a命令结合，然后使用echo命令来查看本机的Linux版本和内核信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo `uname -a`  <span class="comment">//很像es6,毕竟es6就是这么发展过来的</span></span><br><span class="line">Linux linuxprobe.com <span class="number">3.10</span><span class="number">.0</span><span class="number">-123.</span>el7.x86_64 #<span class="number">1</span> SMP Mon May <span class="number">5</span> <span class="number">11</span>:<span class="number">16</span>:<span class="number">57</span> EDT <span class="number">2017</span> x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>
<h2 id="重要的环境变量"><a href="#重要的环境变量" class="headerlink" title="重要的环境变量"></a>重要的环境变量</h2><p>变量是计算机系统用于保存可变值的数据类型。在Linux系统中，<strong>变量名称一般都是大写的</strong>，这是一种约定俗成的规范。我们可以直接通过变量名称来提取到对应的变量值。Linux系统中的环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。</p>
<p>前文中曾经讲到，在Linux系统中一切都是文件，Linux命令也不例外。那么，在用户<strong>执行了一条命令之后</strong>，Linux系统中到底发生了什么事情呢？简单来说，命令在Linux中的执行分为<strong>4个</strong>步骤。</p>
<p><strong>第1步：</strong>判断用户是否以<strong>绝对路径或相对路径</strong>的方式输入命令（如/bin/ls），如果是的话则直接执行。</p>
<p><strong>第2步：</strong>Linux系统检查用户输入的命令是否为“<strong>别名命令</strong>”，即用一个自定义的命令名称来替换原本的命令名称。可以用<code>alias</code>命令来创建一个属于自己的命令别名，格式为“alias 别名=命令”。若要取消一个命令别名，则是用unalias命令，格式为“unalias 别名”。我们之前在使用rm命令删除文件时，Linux系统都会要求我们再确认是否执行删除操作，其实这就是Linux系统为了防止用户误删除文件而特意设置的rm别名命令，接下来我们把它取消掉：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">anaconda-ks.cfg Documents initial-setup-ks.cfg Pictures Templates</span><br><span class="line">Desktop Downloads Music Public Videos</span><br><span class="line">$ rm anaconda-ks.cfg </span><br><span class="line">rm: remove regular file ‘anaconda-ks.cfg’? y</span><br><span class="line">[root@linuxprobe~]<span class="meta"># alias rm</span></span><br><span class="line">alias rm='rm -i'</span><br><span class="line">$ unalias rm</span><br><span class="line">$ rm initial-setup-ks.cfg </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p><strong>第3步：</strong>Bash解释器判断用户输入的是<strong>内部命令还是外部命令</strong>。内部命令是解释器内部的指令，会被直接执行；而用户在绝大部分时间输入的是外部命令，这些命令交由步骤4继续处理。可以使用“<code>type命令名称</code>”来判断用户输入的命令是内部命令还是外部命令。</p>
<p><strong>第4步：</strong>系统在多个路径中查找用户输入的命令文件，而<strong>定义这些路径的变量叫作PATH</strong>，可以简单地把它理解成是“解释器的小助手”，作用是告诉Bash解释器待执行的命令可能存放的位置，然后Bash解释器就会乖乖地在这些位置中逐个查找。PATH是由多个路径值组成的变量，每个路径值之间用<strong>冒号间隔</strong>，对这些路径的增加和删除操作将影响到Bash解释器对Linux命令的查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin</span><br><span class="line">$ PATH=$PATH:/root/bin</span><br><span class="line">$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/root/bin</span><br></pre></td></tr></table></figure>
<p>这里有比较经典的问题：“<strong>为什么不能将当前目录（.）添加到PATH中呢?</strong> ” 原因是，尽管可以将当前目录（.）添加到PATH变量中，从而在某些情况下可以让用户免去输入命令所在路径的麻烦。但是，如果黑客在比较常用的公共目录/tmp中存放了一个与ls或cd命令同名的木马文件，而用户又恰巧在公共目录中执行了这些命令，那么就极有可能中招了。</p>
<p>所以，作为一名态度谨慎、有经验的运维人员，在接手了一台Linux系统后一定会在执行命令前先检查PATH变量中是否有可疑的目录，另外读者从前面的PATH变量示例中是否也感觉到环境变量特别有用呢。我们可以使用env命令来查看到Linux系统中所有的环境变量，而刘遄老师为您精挑细选出了最重要的10个环境变量，</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HOME</td>
<td>用户的主目录（即家目录）</td>
</tr>
<tr>
<td>SHELL</td>
<td>用户在使用的Shell解释器名称</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>输出的历史命令记录条数</td>
</tr>
<tr>
<td>HISTFILESIZE</td>
<td>保存的历史命令记录条数</td>
</tr>
<tr>
<td>MAIL</td>
<td>邮件保存路径</td>
</tr>
<tr>
<td>LANG</td>
<td>系统语言、语系名称</td>
</tr>
<tr>
<td>RANDOM</td>
<td>生成一个随机数字</td>
</tr>
<tr>
<td>PS1</td>
<td>Bash解释器的提示符</td>
</tr>
<tr>
<td>PATH</td>
<td>定义解释器搜索用户执行命令的路径</td>
</tr>
<tr>
<td>EDITOR</td>
<td>用户默认的文本编辑器</td>
</tr>
</tbody>
</table>
</div>
<p>Linux作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，<strong>一个相同的变量会因为用户身份的不同而具有不同的值</strong>。例如，我们使用下述命令来查看HOME变量在不同用户身份下都有哪些值（su是用于切换用户身份的命令，将在第5章跟大家见面）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo $HOME</span><br><span class="line">/root</span><br><span class="line">$ su - linuxprobe</span><br><span class="line">Last login: Fri Feb <span class="number">27</span> <span class="number">19</span>:<span class="number">49</span>:<span class="number">57</span> CST <span class="number">2017</span> on pts/<span class="number">0</span></span><br><span class="line">$ echo $HOME</span><br><span class="line">/home/linuxprobe</span><br></pre></td></tr></table></figure>
<p>其实<strong>变量是由固定的变量名与用户或系统设置的变量值两部分组成</strong>的，我们完全可以自行创建变量，来满足工作需求。例如设置一个名称为WORKDIR的变量，方便用户更轻松地进入一个层次较深的目录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /home/workdir</span><br><span class="line">$ WORKDIR=/home/workdir</span><br><span class="line">$ cd $WORKDIR </span><br><span class="line">$ pwd</span><br><span class="line">/home/workdir</span><br></pre></td></tr></table></figure>
<p>但是，这样的变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，可以使用<code>export命令将其提升为全局变量</code>，这样其他用户也就可以使用它了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe workdir]<span class="meta"># su linuxprobe</span></span><br><span class="line">Last login: Fri Mar <span class="number">20</span> <span class="number">20</span>:<span class="number">52</span>:<span class="number">10</span> CST <span class="number">2017</span> on pts/<span class="number">0</span></span><br><span class="line">[linuxprobe@linuxprobe ~]$ cd $WORKDIR</span><br><span class="line">[linuxprobe@linuxprobe ~]$ echo $WORKDIR</span><br><span class="line">[linuxprobe@linuxprobe ~]$ <span class="built_in">exit</span></span><br><span class="line">[root@linuxprobe ~]<span class="meta"># export WORKDIR</span></span><br><span class="line">[root@linuxprobe ~]<span class="meta"># su linuxprobe</span></span><br><span class="line">Last login: Fri Mar <span class="number">20</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">10</span> CST <span class="number">2017</span> on pts/<span class="number">0</span></span><br><span class="line">[linuxprobe@linuxprobe ~]$ cd $WORKDIR</span><br><span class="line">[linuxprobe@linuxprobe workdir]$ pwd</span><br><span class="line">/home/workdir</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/19/linux基本命令使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/19/linux基本命令使用/" itemprop="url">linux基本命令使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-19T20:09:53+08:00">2018-04-19</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="linux基本命令使用"><a href="#linux基本命令使用" class="headerlink" title="linux基本命令使用"></a>linux基本命令使用</h1><h2 id="打开终端"><a href="#打开终端" class="headerlink" title="打开终端"></a>打开终端</h2><ol>
<li><code>guake</code> 按F12</li>
</ol>
<p>各种配置见preferences</p>
<ol>
<li><code>terminal</code>  按ctrl+alt+t</li>
</ol>
<ul>
<li>常用系统工作命令<ol>
<li>echo</li>
<li>date</li>
<li>reboot,poweroff,shutdown</li>
<li>wget</li>
<li>ps</li>
<li>top(htop)</li>
<li>pidof</li>
<li>kill</li>
<li>killall</li>
</ol>
</li>
<li>系统状态检测命令<ol>
<li>ifconfig</li>
<li>uname</li>
<li>uptime(top)</li>
<li>free(top)</li>
<li>who</li>
<li>last</li>
<li>history</li>
<li>sosreport</li>
</ol>
</li>
<li>工作目录切换命令<ol>
<li>pwd</li>
<li>cd </li>
<li>ls</li>
</ol>
</li>
<li>文本文件编辑命令<ol>
<li>cat</li>
<li>more</li>
<li>head</li>
<li>tail</li>
<li>tr</li>
<li>wc word count</li>
<li>stat</li>
<li>cut</li>
<li>diff</li>
</ol>
</li>
<li>文件目录管理命令<ol>
<li>touch -a -m -d</li>
<li>mkdir</li>
<li>cp -p</li>
<li>mv</li>
<li>dd if= of= count= bs=</li>
<li>file</li>
</ol>
</li>
<li>打包压缩与搜索命令<ol>
<li>tar -cx/zj/vf</li>
<li>grep -n -v</li>
<li>find</li>
</ol>
</li>
</ul>
<p><strong>man命令中常用按键以及用途</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>按键</th>
<th style="text-align:left">用处</th>
</tr>
</thead>
<tbody>
<tr>
<td>空格键</td>
<td style="text-align:left">向下翻一页</td>
</tr>
<tr>
<td>PaGe down</td>
<td style="text-align:left">向下翻一页</td>
</tr>
<tr>
<td>PaGe up</td>
<td style="text-align:left">向上翻一页</td>
</tr>
<tr>
<td>home</td>
<td style="text-align:left">直接前往首页</td>
</tr>
<tr>
<td>end</td>
<td style="text-align:left">直接前往尾页</td>
</tr>
<tr>
<td>/</td>
<td style="text-align:left">从<strong>上至下</strong>搜索某个关键词，如“/linux”</td>
</tr>
<tr>
<td>?</td>
<td style="text-align:left">从<strong>下至上</strong>搜索某个关键词，如“?linux”</td>
</tr>
<tr>
<td>n</td>
<td style="text-align:left">定位到<strong>下一个</strong>搜索到的关键词</td>
</tr>
<tr>
<td>N</td>
<td style="text-align:left">定位到<strong>上一个</strong>搜索到的关键词</td>
</tr>
<tr>
<td>q</td>
<td style="text-align:left">退出帮助文档</td>
</tr>
</tbody>
</table>
</div>
<p>一般来讲，使用man命令查看到的帮助内容信息都会很长,然而并没有什么用.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>结构名称</th>
<th>代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME</td>
<td>命令的名称</td>
</tr>
<tr>
<td>SYNOPSIS</td>
<td>参数的大致使用方法</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>介绍说明</td>
</tr>
<tr>
<td>EXAMPLES</td>
<td>演示（附带简单说明）</td>
</tr>
<tr>
<td>OVERVIEW</td>
<td>概述</td>
</tr>
<tr>
<td>DEFAULTS</td>
<td>默认的功能</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>具体的可用选项（带介绍）</td>
</tr>
<tr>
<td>ENVIRONMENT</td>
<td>环境变量</td>
</tr>
<tr>
<td>FILES</td>
<td>用到的文件</td>
</tr>
<tr>
<td>SEE ALSO</td>
<td>相关的资料</td>
</tr>
<tr>
<td>HISTORY</td>
<td>维护历史与联系方式</td>
</tr>
</tbody>
</table>
</div>
<h2 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h2><ol>
<li>echo命令<br>echo命令用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量]”。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo hello </span><br><span class="line">eche $SHELL</span><br></pre></td></tr></table></figure>
<ol>
<li>date命令<br>date命令用于显示及设置系统的时间或日期，格式为“date [选项] [+指定的格式]”。<br>只需在强大的date命令中输入以<strong>“+”号开头的参数</strong>，即可按照指定格式来输出系统的时间或日期，这样在日常工作时便可以把备份数据的命令与指定格式输出的时间信息结合到一起。例如，把打包后的文件自动按照“年-月-日”的格式打包成“backup-2017-9-1.tar.gz”，用户只需要看一眼文件名称就能大概了解到每个文件的备份时间了</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>%t</td>
<td>跳格[Tab键]</td>
</tr>
<tr>
<td>%Y</td>
<td>年   %y是2位</td>
</tr>
<tr>
<td>%m</td>
<td>月   %M是分钟了</td>
</tr>
<tr>
<td>%d</td>
<td>日</td>
</tr>
<tr>
<td>%D</td>
<td>04/19/18  %d/%m/%y</td>
</tr>
<tr>
<td>%H / %I</td>
<td>小时（00～23）/小时（00～12）</td>
</tr>
<tr>
<td>%M</td>
<td>分钟（00～59）</td>
</tr>
<tr>
<td>%S</td>
<td>秒（00～59）</td>
</tr>
<tr>
<td>%j</td>
<td>今年中的第几天</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date +%Y-%m-%d</span><br><span class="line">date <span class="string">"+%Y-%m-%d %H:%M:%S"</span> <span class="comment">//有空格的一定要加引号</span></span><br></pre></td></tr></table></figure>
<ol>
<li>reboot poweroff halt </li>
</ol>
<p>一般我用shutdown诶</p>
<ol>
<li><p>wget<br>wget命令用于在终端中下载网络文件，格式为“wget [参数] 下载地址”。</p>
</li>
<li><p>ps命令<br>ps命令用于查看系统中的进程状态，格式为“ps [参数]”。</p>
</li>
</ol>
<p>执行这个命令时通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。ps命令的常见参数以及作用如表。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>显示所有进程（包括其他用户的进程）</td>
</tr>
<tr>
<td>-u</td>
<td>用户以及其他详细信息</td>
</tr>
<tr>
<td>-x</td>
<td>显示没有控制终端的进程</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux</span><br><span class="line">ps aux</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如前面所提到的，在Linux系统中的命令参数有<strong>长短格式</strong>之分，长格式和长格式之间不能合并，长格式和短格式之间也不能合并，<strong>只有短格式和短格式之间是可以合并的</strong>，合并后仅保留一个-（减号）即可。另外ps命令可允许参数不加减号（-），因此可直接写成ps aux的样子。</p>
</blockquote>
<p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中，有<strong>5种</strong>常见的进程状态，分别为<strong>运行、中断、不可中断、僵死与停止</strong>，其各自含义如下所示。</p>
<blockquote>
<p>R（运行running）：进程正在运行或在运行队列中等待。</p>
<p>S（中断interruptible sleep）：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该   状态。</p>
<p>D（不可中断uninterruptible sleep）：进程不响应系统异步信号，即便用kill命令也不能将其中断。</p>
<p>T（停止stopped by job control signal）：进程收到停止信号后停止运行。</p>
<p>Z（僵死zombie）：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。</p>
</blockquote>
<p>还有一些加在后面的</p>
<blockquote>
<p>&lt;    高优先级 (not nice to other users)<br>N    低优先级 (nice to other users)<br>L    内存中有pages locked(for real-time and custom IO)<br>s    是一个session leader<br>l    是多线程的multi-threaded (using CLONE_THREAD, like NPTL pthreads do)<br>+   在前台进程组中</p>
</blockquote>
<ol>
<li>top命令(还有htop)</li>
</ol>
<blockquote>
<p>top命令用于动态地监视进程活动与系统负载等信息，其格式为top。</p>
<p>top命令相当强大，能够动态地查看系统运维状态，完全将它看作Linux中的“强化版的Windows任务管理器”</p>
<p>第1行top：系统时间、up运行时间、user登录终端数、load average系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。</p>
<p>第2行Tasks：total进程总数、running运行中的进程数、sleeping睡眠中的进程数、stopped停止的进程数、zombie僵死的进程数。</p>
<p>第3行Cpu：%user用户占用资源百分比、%system系统内核占用资源百分比、%ni改变过优先级的进程资源百分比、%idle空闲的资源百分比等。其中数据均为CPU数据并以百分&gt; 比格式显示，例如“97.1 id”意味着有97.1%的CPU处理器资源处于空闲。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">us: is meaning of <span class="string">"user CPU time"</span></span><br><span class="line">sy: is meaning of <span class="string">"system CPU time"</span></span><br><span class="line">ni: is meaning of<span class="string">" nice CPU time"</span></span><br><span class="line">id: is meaning of <span class="string">"idle"</span></span><br><span class="line">wa: is meaning of <span class="string">"iowait"</span> </span><br><span class="line">hi：is meaning of <span class="string">"hardware irq"</span> 硬中断</span><br><span class="line">si : is meaning of <span class="string">"software irq"</span> 软中断</span><br><span class="line">st : is meaning of <span class="string">"steal time"</span></span><br></pre></td></tr></table></figure>
<p>第4行Mem：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。</p>
<p>第5行Swap：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。</p>
</blockquote>
<ol>
<li>pidof命令<br>pidof命令用于查询某个指定服务进程的PID值，格式为“pidof [参数] [服务名称]”。</li>
</ol>
<p>每个进程的进程号码值（PID）是唯一的，因此可以通过PID来区分不同的进程。例如，可以使用如下命令来查询本机上sshd服务程序的PID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pidof zsh</span><br><span class="line"><span class="number">90436</span> <span class="number">90108</span> <span class="number">89864</span> <span class="number">89585</span> <span class="number">80262</span> <span class="number">79890</span> <span class="number">75011</span> <span class="number">2211</span></span><br></pre></td></tr></table></figure>
<ol>
<li>kill命令</li>
</ol>
<p>kill命令用于终止某个指定PID的服务进程，格式为“kill [参数] [进程PID]”。</p>
<p>接下来，我们使用kill命令把上面用pidof命令查询到的PID所代表的进程终止掉.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill <span class="number">90436</span></span><br></pre></td></tr></table></figure>
<ol>
<li>killall命令</li>
</ol>
<p>killall命令用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数] [进程名称]”。</p>
<p>通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果逐个去结束这些进程会比较麻烦，此时可以使用killall命令来批量结束某个服务程序带有的全部进程。下面以httpd服务程序为例，来结束其全部进程。由于RHEL7系统默认没有安装httpd服务程序，因此大家此时只需看操作过程和输出结果即可，等学习了相关内容之后再来实践。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ pidof httpd</span><br><span class="line"><span class="number">13581</span> <span class="number">13580</span> <span class="number">13579</span> <span class="number">13578</span> <span class="number">13577</span> <span class="number">13576</span></span><br><span class="line">$ killall httpd</span><br><span class="line">$ pidof httpd</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>如果我们在系统终端中执行一个命令后想立即停止它，可以同时按下<code>Ctrl + C</code>组合键（生产环境中比较常用的一个快捷键），这样将立即终止该命令的进程。或者，如果有些命令在执行时不断地在屏幕上输出信息，影响到后续命令的输入，则可以在执行命令时在<strong>末尾添加</strong>上一个<code>&amp;</code>符号，这样命令将<strong>进入系统后台</strong>来执行。</p>
<h2 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h2><p>网卡网络、系统内核、系统负载、内存使用情况、当前启用终端数量、历史登录记录、命令执行记录以及救援诊断等相关命令的使用方法.</p>
<ol>
<li>ifconfig命令</li>
</ol>
<p>ifconfig命令用于获取网卡配置与网络状态等信息，格式为“ifconfig [网络设备] [参数]”。</p>
<p>使用ifconfig命令来查看本机当前的网卡配置与网络状态等信息时，其实主要查看的就是网卡名称、inet参数后面的IP地址、ether参数后面的网卡物理地址（又称为MAC地址），以及RX、TX的接收数据包与发送数据包的个数及累计流量（即下面加粗的信息内容）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># abc123 @ ubuntu in ~ [<span class="number">8</span>:<span class="number">48</span>:<span class="number">15</span>] </span><br><span class="line">$ ifconfig</span><br><span class="line">ens33     Link encap:Ethernet  HWaddr <span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:<span class="number">99</span>:ee:<span class="number">76</span>  </span><br><span class="line">          inet addr:<span class="number">192.168</span><span class="number">.138</span><span class="number">.142</span>  Bcast:<span class="number">192.168</span><span class="number">.138</span><span class="number">.255</span>  Mask:<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">          inet6 addr: fe80::<span class="number">9016</span>:a587:cb6c:<span class="number">8e22</span>/<span class="number">64</span> Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:<span class="number">1500</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">358492</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">194286</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span> </span><br><span class="line">          RX bytes:<span class="number">411586597</span> (<span class="number">411.5</span> MB)  TX bytes:<span class="number">19353703</span> (<span class="number">19.3</span> MB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  Mask:<span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">          inet6 addr: ::<span class="number">1</span>/<span class="number">128</span> Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:<span class="number">65536</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">16667</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">16667</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span> </span><br><span class="line">          RX bytes:<span class="number">1591176</span> (<span class="number">1.5</span> MB)  TX bytes:<span class="number">1591176</span> (<span class="number">1.5</span> MB)</span><br></pre></td></tr></table></figure>
<ol>
<li>uname命令</li>
</ol>
<p>uname命令用于<strong>查看系统内核与系统版本等信息</strong>，格式为“uname [-a]”。</p>
<p>在使用uname命令时，一般会固定搭配上<code>-a</code>参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># abc123 @ ubuntu in ~ [<span class="number">8</span>:<span class="number">48</span>:<span class="number">18</span>] </span><br><span class="line">$ uname -a</span><br><span class="line">Linux ubuntu <span class="number">4.13</span><span class="number">.0</span><span class="number">-38</span>-generic #<span class="number">43</span>~<span class="number">16.04</span><span class="number">.1</span>-Ubuntu SMP Wed Mar <span class="number">14</span> <span class="number">17</span>:<span class="number">48</span>:<span class="number">43</span> UTC <span class="number">2018</span> x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>
<p>顺带一提，如果要查看当前系统版本的详细信息，则需要查看redhat-release文件，其命令以及相应的结果如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/lsb-release </span><br><span class="line">DISTRIB_ID=Ubuntu</span><br><span class="line">DISTRIB_RELEASE=<span class="number">16.04</span></span><br><span class="line">DISTRIB_CODENAME=xenial</span><br><span class="line">DISTRIB_DESCRIPTION=<span class="string">"Ubuntu 16.04.3 LTS"</span></span><br></pre></td></tr></table></figure>
<ol>
<li>uptime命令(这不就是top命令的第一行么)</li>
</ol>
<p>uptime用于查看系统的负载信息，格式为uptime。</p>
<p>uptime命令真的很棒，它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况（下面加粗的信息部分）；负载值越低越好，尽量不要长期超过1，在生产环境中不要超过5。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime </span><br><span class="line"> <span class="number">08</span>:<span class="number">53</span>:<span class="number">54</span> up  <span class="number">9</span>:<span class="number">13</span>, <span class="number">10</span> users,  load average: <span class="number">1.64</span>, <span class="number">0.96</span>, <span class="number">0.70</span></span><br></pre></td></tr></table></figure>
<ol>
<li>free命令(top中)</li>
</ol>
<p>free用于显示当前系统中内存的使用量信息，格式为“free [-h]”。</p>
<p>为了保证Linux系统不会因资源耗尽而突然宕机，运维人员需要时刻关注内存的使用量。在使用free命令时，可以结合使用-h参数以更人性化的方式输出当前内存的实时使用量信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">free</span> -h</span><br><span class="line">              total        used        <span class="built_in">free</span>      shared  buff/cache   available</span><br><span class="line">Mem:           <span class="number">1.9</span>G        <span class="number">1.5</span>G         <span class="number">74</span>M         <span class="number">66</span>M        <span class="number">366</span>M        <span class="number">139</span>M</span><br><span class="line">Swap:          <span class="number">1.0</span>G        <span class="number">1.0</span>G          <span class="number">0B</span></span><br></pre></td></tr></table></figure>
<ol>
<li>who命令</li>
</ol>
<p>who用于查看当前登入主机的用户终端信息，格式为“who [参数]”。</p>
<p>这三个简单的字母可以快速显示出所有正在登录本机的用户的名称以及他们正在开启的终端信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ who</span><br><span class="line">abc123   tty7         <span class="number">2018</span><span class="number">-04</span><span class="number">-18</span> <span class="number">17</span>:<span class="number">59</span> (:<span class="number">0</span>)</span><br><span class="line">abc123   pts/<span class="number">18</span>       <span class="number">2018</span><span class="number">-04</span><span class="number">-18</span> <span class="number">17</span>:<span class="number">59</span> (ubuntu)</span><br><span class="line">abc123   pts/<span class="number">23</span>       <span class="number">2018</span><span class="number">-04</span><span class="number">-19</span> <span class="number">20</span>:<span class="number">22</span> (ubuntu)</span><br><span class="line">abc123   pts/<span class="number">24</span>       <span class="number">2018</span><span class="number">-04</span><span class="number">-19</span> <span class="number">20</span>:<span class="number">22</span> (ubuntu)</span><br><span class="line">abc123   pts/<span class="number">25</span>       <span class="number">2018</span><span class="number">-04</span><span class="number">-19</span> <span class="number">20</span>:<span class="number">22</span> (ubuntu)</span><br><span class="line">abc123   pts/<span class="number">26</span>       <span class="number">2018</span><span class="number">-04</span><span class="number">-19</span> <span class="number">20</span>:<span class="number">22</span> (ubuntu)</span><br><span class="line">abc123   pts/<span class="number">27</span>       <span class="number">2018</span><span class="number">-04</span><span class="number">-19</span> <span class="number">20</span>:<span class="number">22</span> (ubuntu)</span><br><span class="line">abc123   pts/<span class="number">28</span>       <span class="number">2018</span><span class="number">-04</span><span class="number">-19</span> <span class="number">20</span>:<span class="number">22</span> (ubuntu)</span><br><span class="line">abc123   pts/<span class="number">25</span>       <span class="number">2018</span><span class="number">-04</span><span class="number">-19</span> <span class="number">20</span>:<span class="number">25</span> (:<span class="number">0</span>)</span><br><span class="line">abc123   pts/<span class="number">19</span>       <span class="number">2018</span><span class="number">-04</span><span class="number">-19</span> <span class="number">21</span>:<span class="number">30</span> (ubuntu)</span><br></pre></td></tr></table></figure>
<ol>
<li>last命令</li>
</ol>
<p>last命令用于查看所有系统的登录记录，格式为“last [参数]”。</p>
<p>使用last命令可以查看本机的登录记录。但是，由于这些信息都是以日志文件的形式保存在系统中，<strong>因此黑客可以很容易地对内容进行篡改。千万不要单纯以该命令的输出信息而判断系统有无被恶意入侵！</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ last</span><br><span class="line">abc123   pts/<span class="number">19</span>       ubuntu           Thu Apr <span class="number">19</span> <span class="number">21</span>:<span class="number">30</span>    gone - no logout</span><br><span class="line">abc123   pts/<span class="number">26</span>       :<span class="number">0</span>               Thu Apr <span class="number">19</span> <span class="number">20</span>:<span class="number">26</span> - <span class="number">20</span>:<span class="number">26</span>  (<span class="number">00</span>:<span class="number">00</span>)</span><br><span class="line">abc123   pts/<span class="number">25</span>       :<span class="number">0</span>               Thu Apr <span class="number">19</span> <span class="number">20</span>:<span class="number">25</span>    gone - no logout</span><br><span class="line">abc123   pts/<span class="number">24</span>       ubuntu           Thu Apr <span class="number">19</span> <span class="number">20</span>:<span class="number">22</span>    gone - no logout</span><br><span class="line">abc123   pts/<span class="number">23</span>       ubuntu           Thu Apr <span class="number">19</span> <span class="number">20</span>:<span class="number">22</span>    gone - no logout</span><br><span class="line">abc123   pts/<span class="number">28</span>       ubuntu           Thu Apr <span class="number">19</span> <span class="number">20</span>:<span class="number">22</span>    gone - no logout</span><br><span class="line">abc123   pts/<span class="number">27</span>       ubuntu           Thu Apr <span class="number">19</span> <span class="number">20</span>:<span class="number">22</span>    gone - no logout</span><br><span class="line">abc123   pts/<span class="number">26</span>       ubuntu           Thu Apr <span class="number">19</span> <span class="number">20</span>:<span class="number">22</span> - <span class="number">20</span>:<span class="number">26</span>  (<span class="number">00</span>:<span class="number">03</span>)</span><br><span class="line">abc123   pts/<span class="number">25</span>       ubuntu           Thu Apr <span class="number">19</span> <span class="number">20</span>:<span class="number">22</span> - <span class="number">20</span>:<span class="number">25</span>  (<span class="number">00</span>:<span class="number">03</span>)</span><br><span class="line">abc123   pts/<span class="number">24</span>       ubuntu           Thu Apr <span class="number">19</span> <span class="number">20</span>:<span class="number">22</span> - <span class="number">20</span>:<span class="number">22</span>  (<span class="number">00</span>:<span class="number">00</span>)</span><br><span class="line">abc123   pts/<span class="number">23</span>       ubuntu           Thu Apr <span class="number">19</span> <span class="number">20</span>:<span class="number">22</span> - <span class="number">20</span>:<span class="number">22</span>  (<span class="number">00</span>:<span class="number">00</span>)</span><br><span class="line">abc123   pts/<span class="number">18</span>       ubuntu           Wed Apr <span class="number">18</span> <span class="number">17</span>:<span class="number">59</span>    gone - no logout</span><br><span class="line">abc123   tty7         :<span class="number">0</span>               Wed Apr <span class="number">18</span> <span class="number">17</span>:<span class="number">59</span>    gone - no logout</span><br><span class="line">reboot   system boot  <span class="number">4.13</span><span class="number">.0</span><span class="number">-38</span>-generi Wed Apr <span class="number">18</span> <span class="number">17</span>:<span class="number">57</span>   still running</span><br><span class="line">abc123   pts/<span class="number">18</span>       ubuntu           Wed Apr <span class="number">18</span> <span class="number">16</span>:<span class="number">03</span> - crash  (<span class="number">01</span>:<span class="number">54</span>)</span><br><span class="line">abc123   tty7         :<span class="number">0</span>               Wed Apr <span class="number">18</span> <span class="number">16</span>:<span class="number">03</span> - crash  (<span class="number">01</span>:<span class="number">54</span>)</span><br><span class="line">reboot   system boot  <span class="number">4.13</span><span class="number">.0</span><span class="number">-38</span>-generi Wed Apr <span class="number">18</span> <span class="number">16</span>:<span class="number">03</span>   still running</span><br><span class="line">abc123   pts/<span class="number">18</span>       ubuntu           Sat Apr <span class="number">14</span> <span class="number">21</span>:<span class="number">21</span> - crash (<span class="number">3</span>+<span class="number">18</span>:<span class="number">41</span>)</span><br><span class="line">abc123   tty7         :<span class="number">0</span>               Sat Apr <span class="number">14</span> <span class="number">21</span>:<span class="number">21</span> - crash (<span class="number">3</span>+<span class="number">18</span>:<span class="number">41</span>)</span><br><span class="line">reboot   system boot  <span class="number">4.13</span><span class="number">.0</span><span class="number">-38</span>-generi Sat Apr <span class="number">14</span> <span class="number">21</span>:<span class="number">21</span>   still running</span><br><span class="line">abc123   pts/<span class="number">1</span>        :<span class="number">0</span>               Fri Apr <span class="number">13</span> <span class="number">17</span>:<span class="number">51</span> - <span class="number">17</span>:<span class="number">51</span>  (<span class="number">00</span>:<span class="number">00</span>)</span><br><span class="line">abc123   pts/<span class="number">18</span>       ubuntu           Fri Apr <span class="number">13</span> <span class="number">17</span>:<span class="number">20</span> - down   (<span class="number">02</span>:<span class="number">24</span>)</span><br><span class="line">abc123   tty7         :<span class="number">0</span>               Fri Apr <span class="number">13</span> <span class="number">17</span>:<span class="number">20</span> - down   (<span class="number">02</span>:<span class="number">24</span>)</span><br><span class="line">reboot   system boot  <span class="number">4.13</span><span class="number">.0</span><span class="number">-38</span>-generi Fri Apr <span class="number">13</span> <span class="number">17</span>:<span class="number">20</span> - <span class="number">19</span>:<span class="number">44</span>  (<span class="number">02</span>:<span class="number">24</span>)</span><br><span class="line">abc123   pts/<span class="number">18</span>       ubuntu           Fri Apr <span class="number">13</span> <span class="number">10</span>:<span class="number">17</span> - crash  (<span class="number">07</span>:<span class="number">02</span>)</span><br><span class="line">abc123   tty7         :<span class="number">0</span>               Fri Apr <span class="number">13</span> <span class="number">10</span>:<span class="number">17</span> - crash  (<span class="number">07</span>:<span class="number">02</span>)</span><br><span class="line">reboot   system boot  <span class="number">4.13</span><span class="number">.0</span><span class="number">-38</span>-generi Fri Apr <span class="number">13</span> <span class="number">10</span>:<span class="number">17</span> - <span class="number">19</span>:<span class="number">44</span>  (<span class="number">09</span>:<span class="number">27</span>)</span><br><span class="line"></span><br><span class="line">wtmp begins Thu Apr <span class="number">12</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">41</span> <span class="number">2018</span></span><br></pre></td></tr></table></figure>
<ol>
<li>history命令</li>
</ol>
<p>history命令用于显示历史执行过的命令，格式为“history [-c]”。</p>
<p>history命令应该是作者最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，还可以自定义/etc/profile文件中的HISTSIZE变量值。在使用history命令时，如果使用-c参数则会清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">586</span>  ifconfig</span><br><span class="line"><span class="number">587</span>  top</span><br><span class="line"><span class="number">588</span>  ifconfig</span><br><span class="line"><span class="number">589</span>  uname -a</span><br><span class="line"><span class="number">590</span>  cat /etc/lsb-release</span><br><span class="line"><span class="number">591</span>  cat /etc/debian_version</span><br><span class="line"><span class="number">592</span>  uptime</span><br><span class="line"><span class="number">593</span>  <span class="built_in">free</span> -h</span><br><span class="line"><span class="number">594</span>  <span class="built_in">free</span></span><br><span class="line"><span class="number">595</span>  top</span><br><span class="line"><span class="number">596</span>  top -h</span><br><span class="line"><span class="number">597</span>  top -hv</span><br><span class="line"><span class="number">598</span>  <span class="built_in">free</span> -h</span><br><span class="line"><span class="number">599</span>  who</span><br><span class="line"><span class="number">600</span>  last</span><br></pre></td></tr></table></figure>
<p>历史命令会被保存到用户家目录中的.bash_history文件中。Linux系统中以点（.）开头的文件均代表隐藏文件，这些文件大多数为系统服务文件，可以用cat命令查看其文件内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.bash_history</span><br></pre></td></tr></table></figure>
<p>要清空当前用户在本机上执行的Linux命令历史记录信息，可执行如下命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history -c</span><br></pre></td></tr></table></figure>
<ol>
<li>sosreport命令(ubuntu上要先安装)</li>
</ol>
<p>sosreport命令用于收集系统配置及架构信息并输出诊断文档，格式为sosreport。</p>
<p>当Linux系统出现故障需要联系技术支持人员时，大多数时候都要先使用这个命令来简单收集系统的运行状态和服务配置信息，以便让技术支持人员能够远程解决一些小问题，亦或让他们能提前了解某些复杂问题。在下面的输出信息中，<strong>加粗的部分是收集好的资料压缩文件以及校验码</strong>，将其发送给技术支持人员即可：</p>
<h2 id="工作目录切换命令"><a href="#工作目录切换命令" class="headerlink" title="工作目录切换命令"></a>工作目录切换命令</h2><ol>
<li>pwd命令</li>
</ol>
<p>pwd命令用于显示用户当前所处的工作目录，格式为“pwd [选项]”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/home/abc123/Downloads</span><br></pre></td></tr></table></figure>
<ol>
<li>cd命令</li>
</ol>
<p>cd命令用于切换工作路径，格式为“cd [目录名称]”。</p>
<p>这个命令应该是最常用的一个Linux命令了。可以通过cd命令迅速、灵活地切换到不同的工作目录。除了常见的切换目录方式，还可以使用<code>“cd -”</code>命令返回到<strong>上一次</strong>所处的目录，使用<code>“cd..”</code>命令进入上级目录，以及使用<code>“cd ~”</code>命令切换到当前用户的家目录，亦或使用“cd ~username”切换到其他用户的家目录。例如，可以使用“cd 路径”的方式切换进/etc目录中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /etc</span><br><span class="line">cd -</span><br><span class="line">cd ..</span><br><span class="line">cd ~</span><br></pre></td></tr></table></figure>
<ol>
<li>ls命令</li>
</ol>
<p>ls命令用于显示目录中的文件信息，格式为“ls [选项] [文件] ”。</p>
<p>所处的工作目录不同，当前工作目录下的文件肯定也不同。使用ls命令的“-a”参数看到全部文件（包括隐藏文件），使用“-l”参数可以查看文件的属性、大小等详细信息。将这两个参数整合之后，再执行ls命令即可查看当前目录中的所有文件并输出这些文件的属性信息</p>
<p>如果想要查看目录属性信息，则需要额外添加一个-d参数。例如，可使用如下命令查看/etc目录的权限与属性信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -ld /usr</span><br><span class="line">drwxr-xr-x <span class="number">11</span> root root <span class="number">4096</span> Aug  <span class="number">1</span>  <span class="number">2017</span> /usr</span><br></pre></td></tr></table></figure>
<h2 id="文本文件编辑命令"><a href="#文本文件编辑命令" class="headerlink" title="文本文件编辑命令"></a>文本文件编辑命令</h2><ol>
<li>cat命令</li>
</ol>
<p>cat命令用于<strong>查看纯文本文件</strong>（内容较少的），格式为“cat [选项] [文件]”。</p>
<p>Linux系统中有多个用于查看文本内容的命令，每个命令都有自己的特点，比如这个cat命令就是用于查看内容较少的纯文本文件的。cat这个命令也很好记，因为cat在英语中是“猫”的意思，小猫咪是不是给您一种娇小、可爱的感觉呢？</p>
<p>如果在查看文本内容时<strong>还想顺便显示行号</strong>的话，不妨在cat命令后面追加一个-n参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n <span class="number">1.</span>txt</span><br></pre></td></tr></table></figure>
<ol>
<li>more命令</li>
</ol>
<p>more命令用于查看纯文本文件（内容较多的），格式为“more [选项]文件”。</p>
<p>如果需要阅读长篇小说或者非常长的配置文件，那么“小猫咪”可就真的不适合了。因为一旦使用cat命令阅读长篇的文本内容，信息就会在屏幕上快速翻滚，导致自己还没有来得及看到，内容就已经翻篇了。因此对于长篇的文本内容，推荐使用more命令来查看。more命令会在最下面使用百分比的形式来提示您已经阅读了多少内容。您还可以使用空格键或回车键向下翻页：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more <span class="number">1.</span>txt</span><br></pre></td></tr></table></figure>
<ol>
<li>head命令</li>
</ol>
<p>head命令用于查看纯文本文档的<strong>前N行</strong>，格式为“head [选项] [文件]”。</p>
<p>在阅读文本内容时，谁也难以保证会按照从头到尾的顺序往下看完整个文件。如果只想查看文本中前20行的内容，该怎么办呢？head命令可以派上用场了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n <span class="number">20</span> <span class="number">1.</span>txt</span><br></pre></td></tr></table></figure>
<ol>
<li>tail命令</li>
</ol>
<p>tail命令用于查看纯文本文档的<strong>后N行或持续刷新内容</strong>，格式为“tail [选项] [文件]”。</p>
<p>我们可能还会遇到另外一种情况，比如需要查看文本内容的最后20行，这时就需要用到tail命令了。tail命令的操作方法与head命令非常相似，只需要执行<code>“tail -n 20 文件名”</code>命令就可以达到这样的效果。tail命令最强悍的功能是可以<strong>持续刷新一个文件的内容</strong>，当想要实时查看最新日志文件时，这特别有用，此时的命令格式为“<strong>tail -f</strong> 文件名”：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure>
<ol>
<li>tr命令</li>
</ol>
<p>tr命令用于<strong>替换</strong>文本文件中的字符，格式为“tr [原始字符] [目标字符]”。</p>
<p>在很多时候，我们想要快速地替换文本中的一些词汇，又或者把整个文本内容都进行替换，如果进行手工替换，难免工作量太大，尤其是需要处理大批量的内容时，进行手工替换更是不现实。这时，就可以先使用<code>cat</code>命令读取待处理的文本，然后通过<strong>管道符</strong>（详见第3章）把这些文本内容<strong>传递给tr</strong>命令进行替换操作即可。例如，把某个文本内容中的英文全部替换为大写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat anaconda-ks.cfg | tr [a-z] [A-Z]</span><br></pre></td></tr></table></figure>
<ol>
<li>wc命令(word count)</li>
</ol>
<p>wc命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。</p>
<p>每次我在课堂上讲到这个命令时，总有同学会联想到一种公共设施，其实这两者毫无关联。Linux系统中的wc命令用于统计文本的行数、字数、字节数等。如果为了方便自己记住这个命令的作用，也可以联想到上厕所时好无聊，无聊到数完了手中的如厕读物上有多少行字。wc的参数以及相应的作用如表2-10所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc zoobar\ setup.txt </span><br><span class="line">  <span class="number">88</span>  <span class="number">206</span> <span class="number">2562</span> zoobar setup.txt</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>只显示行数</td>
</tr>
<tr>
<td>-w</td>
<td>只显示单词数</td>
</tr>
<tr>
<td>-c</td>
<td>只显示字节数</td>
</tr>
</tbody>
</table>
</div>
<p>在Linux系统中，passwd是用于保存系统账户信息的文件，要统计当前系统中有多少个用户，可以使用下面的命令来进行查询，是不是很神奇：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc -l /etc/passwd</span><br><span class="line"><span class="number">38</span> /etc/passwd</span><br></pre></td></tr></table></figure>
<ol>
<li>stat命令</li>
</ol>
<p>stat命令用于查看文件的具体存储信息和时间等信息，格式为“stat 文件名称”。</p>
<p>stat命令可以用于查看文件的存储信息和时间等信息，命令stat anaconda-ks.cfg会显示出文件的<strong>三种时间状态</strong>（已加粗）：Access、Modify、Change。这三种时间的区别将在下面的touch命令中详细详解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ stat zoobar\ setup.txt </span><br><span class="line">  File: 'zoobar setup.txt'</span><br><span class="line">  Size: <span class="number">2562</span>      	Blocks: <span class="number">8</span>          IO Block: <span class="number">4096</span>   regular file</span><br><span class="line">Device: <span class="number">801</span>h/<span class="number">2049</span>d	Inode: <span class="number">941078</span>      Links: <span class="number">1</span></span><br><span class="line">Access: (<span class="number">0766</span>/-rwxrw-rw-)  Uid: ( <span class="number">1000</span>/  abc123)   Gid: ( <span class="number">1000</span>/  abc123)</span><br><span class="line">Access: <span class="number">2018</span><span class="number">-04</span><span class="number">-20</span> <span class="number">13</span>:<span class="number">56</span>:<span class="number">20.364043512</span> +<span class="number">0800</span></span><br><span class="line">Modify: <span class="number">2017</span><span class="number">-11</span><span class="number">-22</span> <span class="number">21</span>:<span class="number">38</span>:<span class="number">13.280060000</span> +<span class="number">0800</span></span><br><span class="line">Change: <span class="number">2017</span><span class="number">-11</span><span class="number">-23</span> <span class="number">13</span>:<span class="number">56</span>:<span class="number">28.538010046</span> +<span class="number">0800</span></span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>
<ol>
<li>cut命令</li>
</ol>
<p>cut命令用于按“列”提取文本字符，格式为“cut [参数] 文本”。</p>
<p>在Linux系统中，如何准确地提取出最想要的数据，这也是我们应该重点学习的内容。一般而言，按基于“行”的方式来提取数据是比较简单的，只需要设置好要搜索的关键词即可。但是如果按列搜索，不仅要使用<strong>-f</strong>参数来设置需要看的<strong>列数</strong>，还需要使用<strong>-d</strong>参数来设置<strong>间隔符号</strong>。passwd在保存用户数据信息时，用户信息的每一项值之间是采用冒号来间隔的，接下来我们使用下述命令尝试提取出passwd文件中的用户名信息，即提取以冒号（：）为间隔符号的第一列内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ head -n <span class="number">2</span> /etc/passwd</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">$ cut -d: -f1 /etc/passwd  <span class="comment">//f1第一列</span></span><br></pre></td></tr></table></figure>
<ol>
<li>diff命令</li>
</ol>
<p>diff命令用于比较多个文本文件的差异，格式为“diff [参数] 文件”。</p>
<p>在使用diff命令时，不仅可以使用<strong>—brief</strong>参数来确认两个文件是否不同，还可以使用<strong>-c</strong>参数来详细比较出多个文件的差异之处，这绝对是判断文件是否被篡改的有力神器。例如，先使用cat命令分别查看diff_A.txt和diff_B.txt文件的内容，然后进行比较：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat diff_A.txt</span><br><span class="line"></span><br><span class="line">$ cat diff_A.txt</span><br></pre></td></tr></table></figure>
<p>接下来使用diff —brief命令显示比较后的结果，判断文件是否相同：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ diff --brief diff_A.txt diff_B.txt</span><br><span class="line">Files diff_A.txt <span class="keyword">and</span> diff_B.txt differ</span><br></pre></td></tr></table></figure></p>
<p>最后使用带有-c参数的diff命令来描述文件内容具体的不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -c diff_A.txt diff_B.txt</span><br></pre></td></tr></table></figure>
<h2 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h2><ol>
<li>touch命令</li>
</ol>
<p>touch命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]”。</p>
<p>在创建空白的文本文件方面，这个touch命令相当简捷，简捷到没有必要铺开去讲。比如，touch linuxprobe命令可以创建出一个名为linuxprobe的空白文本文件。对touch命令来讲，<strong>有难度的操作</strong>主要是体现在设置文件内容的修改时间（mtime）、文件权限或属性的更改时间（ctime）与文件的读取时间（atime）上面。touch命令的参数及其作用如表.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>仅修改“读取时间”（atime）</td>
</tr>
<tr>
<td>-m</td>
<td>仅修改“修改时间”（mtime）</td>
</tr>
<tr>
<td>-d</td>
<td>同时修改atime与mtime</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l anaconda-ks.cfg </span><br><span class="line">-rw-------. <span class="number">1</span> root root <span class="number">1213</span> May  <span class="number">4</span> <span class="number">15</span>:<span class="number">44</span> anaconda-ks.cfg</span><br><span class="line">$ echo <span class="string">"hello nihao"</span> &gt;&gt; anaconda-ks.cfg</span><br><span class="line">$ ls -l anaconda-ks.cfg</span><br><span class="line">-rw-------. <span class="number">1</span> root root <span class="number">1260</span> Aug  <span class="number">2</span> <span class="number">01</span>:<span class="number">26</span> anaconda-ks.cfg</span><br><span class="line">$ touch -d <span class="string">"2017-05-04 15:44"</span> anaconda-ks.cfg </span><br><span class="line">$ ls -l anaconda-ks.cfg </span><br><span class="line">-rw-------. <span class="number">1</span> root root <span class="number">1260</span> May  <span class="number">4</span> <span class="number">15</span>:<span class="number">44</span> anaconda-ks.cfg</span><br></pre></td></tr></table></figure>
<ol>
<li>mkdir命令</li>
</ol>
<p>mkdir命令用于创建空白的目录，格式为“mkdir [选项] 目录”。</p>
<p>在Linux系统中，文件夹是最常见的文件类型之一。除了能创建单个空白目录外，mkdir命令还可以结合<strong>-p参数来递归</strong>创建出具有嵌套叠层关系的文件目录。</p>
<ol>
<li>cp命令</li>
</ol>
<p>cp命令用于复制文件或目录，格式为“cp [选项] 源文件 目标文件”。大家对文件复制操作应该不陌生，在Linux系统中，复制操作具体分为3种情况：</p>
<blockquote>
<p>如果目标文件是目录，则会把源文件复制到该目录中；</p>
<p>如果目标文件也是普通文件，则会询问是否要覆盖它；</p>
<p>如果目标文件不存在，则执行正常的复制操作。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>保留原始文件的属性</td>
</tr>
<tr>
<td>-d</td>
<td>若对象为“链接文件”，则保留该“链接文件”的属性</td>
</tr>
<tr>
<td>-r</td>
<td>递归持续复制（用于目录）</td>
</tr>
<tr>
<td>-i</td>
<td>若目标文件存在则询问是否覆盖</td>
</tr>
<tr>
<td>-a</td>
<td>相当于-pdr（p、d、r为上述参数）</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>mv命令</li>
</ol>
<p>mv命令用于<strong>剪切文件或将文件重命名</strong>，格式为“mv [选项] 源文件 [目标路径|目标文件名]”。</p>
<p>剪切操作不同于复制操作，因为它会默认把源文件删除掉，只保留剪切后的文件。如果在同一个目录中对一个文件进行剪切操作，其实也就是对其进行重命名：</p>
<ol>
<li>rm命令</li>
</ol>
<p>rm命令用于删除文件或目录，格式为“rm [选项] 文件”。</p>
<p>在Linux系统中删除文件时，系统会默认向您询问是否要执行删除操作，如果不想总是看到这种反复的确认信息，可在rm命令后跟上<strong>-f参数来强制删除</strong>。另外，想要删除一个<strong>目录</strong>，需要在rm命令后面一个<strong>-r参数</strong>才可以，否则删除不掉。</p>
<ol>
<li>dd命令</li>
</ol>
<p>dd命令用于按照指定大小和个数的数据块来复制文件或转换文件，格式为“dd [参数]”。</p>
<p>dd命令是一个比较重要而且比较有特色的一个命令，它能够让用户按照指定大小和个数的数据块来复制文件的内容。当然如果愿意的话，还可以在复制过程中转换其中的数据。Linux系统中有一个名为<code>/dev/zero</code>的设备文件，每次在课堂上解释它时都充满哲学理论的色彩。因为这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此可以使用它<strong>作为dd命令的输入文件</strong>，来生成一个指定大小的文件</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>if</td>
<td>输入的文件名称   input file</td>
</tr>
<tr>
<td>of</td>
<td>输出的文件名称   output file</td>
</tr>
<tr>
<td>bs</td>
<td>设置每个“块”的大小  block size</td>
</tr>
<tr>
<td>count</td>
<td>设置要复制“块”的个数</td>
</tr>
</tbody>
</table>
</div>
<p>例如我们可以用dd命令从/dev/zero设备文件中取出一个大小为560MB的数据块，然后保存成名为560_file的文件。在理解了这个命令后，以后就能随意创建任意大小的文件了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=<span class="number">560</span>_file count=<span class="number">1</span> bs=<span class="number">560</span>M</span><br></pre></td></tr></table></figure>
<p>dd命令的功能也绝不仅限于复制文件这么简单。如果您想把光驱设备中的光盘<strong>制作成iso格式</strong>的镜像文件，在Windows系统中需要借助于第三方软件才能做到，但在Linux系统中可以直接使用dd命令来压制出光盘镜像文件，将它变成一个可立即使用的iso镜像</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/cdrom of=RHEL-server<span class="number">-7.0</span>-x86_64-LinuxProbe.Com.iso</span><br></pre></td></tr></table></figure>
<p>考虑到有些读者会纠结bs块大小与count块个数的关系,只要能满足需求，可随意组合搭配方式</p>
<ol>
<li>file命令</li>
</ol>
<p>file命令用于查看文件的类型，格式为“file 文件名”。</p>
<p>在Linux系统中，由于文本、目录、设备等所有这些一切都统称为文件，而我们又不能单凭后缀就知道具体的文件类型，这时就需要使用file命令来查看文件类型了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ file anaconda-ks.cfg </span><br><span class="line">anaconda-ks.cfg: ASCII text</span><br><span class="line">$ file /dev/sda</span><br><span class="line">/dev/sda: block special</span><br></pre></td></tr></table></figure>
<h2 id="打包压缩与搜索命令"><a href="#打包压缩与搜索命令" class="headerlink" title="打包压缩与搜索命令"></a>打包压缩与搜索命令</h2><ol>
<li>tar命令</li>
</ol>
<p>tar命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。</p>
<p>在Linux系统中，常见的文件格式比较多，其中主要使用的是<code>.tar或.tar.gz或.tar.bz2</code>格式，我们不用担心格式太多而记不住，其实这些格式大部分都是由tar命令来生成的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>创建压缩文件</td>
</tr>
<tr>
<td>-x</td>
<td>解开压缩文件</td>
</tr>
<tr>
<td>-t</td>
<td>查看压缩包内有哪些文件</td>
</tr>
<tr>
<td>-z</td>
<td>用Gzip压缩或解压</td>
</tr>
<tr>
<td>-j</td>
<td>用bzip2压缩或解压</td>
</tr>
<tr>
<td>-v</td>
<td>显示压缩或解压的过程</td>
</tr>
<tr>
<td>-f</td>
<td>目标文件名</td>
</tr>
<tr>
<td>-p</td>
<td>保留原始的权限与属性</td>
</tr>
<tr>
<td>-P</td>
<td>使用绝对路径来压缩</td>
</tr>
<tr>
<td>-C</td>
<td>指定解压到的目录</td>
</tr>
</tbody>
</table>
</div>
<p>首先，<code>-c</code>参数用于创建压缩文件，<code>-x</code>参数用于解压文件，因此这两个参数不能同时使用。<br>其次，<code>-z</code>参数指定使用Gzip格式来压缩或解压文件，<code>-j</code>参数指定使用bzip2格式来压缩或解压文件。用户使用时则是根据文件的后缀来决定应使用何种格式参数进行解压。<br>在执行某些压缩或解压操作时，可能需要花费数个小时，如果屏幕一直没有输出，您一方面不好判断打包的进度情况，另一方面也会怀疑电脑死机了，因此非常推荐使用<code>-v</code>参数向用户不断显示压缩或解压的过程。<br><code>-C</code>参数用于指定要解压到哪个指定的目录。<br><code>-f</code>参数特别重要，它必须放到参数的最后一位，代表要压缩或解压的软件包名称。刘遄老师一般使用“<code>tar -czvf</code> 压缩包名称<code>.tar.gz</code> 要打包的目录”命令把指定的文件进行打包压缩；相应的解压命令为“<code>tar -xzvf</code> 压缩包名称<code>.tar.gz</code>”。</p>
<ol>
<li>grep命令</li>
</ol>
<p>grep命令用于在文本中执行关键词搜索，并显示匹配的结果，格式为“grep [选项] [文件]”。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b</td>
<td>将可执行文件(binary)当作文本文件（text）来搜索</td>
</tr>
<tr>
<td>-c</td>
<td>仅显示找到的行数</td>
</tr>
<tr>
<td>-i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td><strong>-n</strong></td>
<td>显示行号</td>
</tr>
<tr>
<td><strong>-v</strong></td>
<td>反向选择——仅列出没有“关键词”的行。</td>
</tr>
</tbody>
</table>
</div>
<p>grep命令是用途最广泛的文本搜索匹配工具，虽然有很多参数，但是大多数基本上都用不到。我们在这里只讲两个最最常用的参数：<code>-n</code>参数用来显示搜索到信息的行号；<code>-v</code>参数用于反选信息（即没有包含关键词的所有信息行）。这两个参数几乎能完成您日后80%的工作需要，至于其他上百个参数，即使以后在工作期间遇到了，再使用man grep命令查询也来得及。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ grep /sbin/nologin /etc/passwd</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:<span class="number">3</span>:<span class="number">4</span>:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:<span class="number">4</span>:<span class="number">7</span>:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">mail:x:<span class="number">8</span>:<span class="number">12</span>:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line"><span class="keyword">operator</span>:x:<span class="number">11</span>:<span class="number">0</span>:<span class="keyword">operator</span>:/root:/sbin/nologin</span><br></pre></td></tr></table></figure>
<ol>
<li>find命令</li>
</ol>
<p>find命令用于按照指定条件来查找文件，格式为“find [查找路径] 寻找条件 操作”。</p>
<p>本书中曾经多次提到“Linux系统中的一切都是文件”，接下来就要见证这句话的分量了。在Linux系统中，搜索工作一般都是通过find命令来完成的，它可以使用不同的文件特性作为寻找条件（如文件名、大小、修改时间、权限等信息），一旦匹配成功则默认将信息显示到屏幕上。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-name</td>
<td>匹配名称</td>
</tr>
<tr>
<td>-perm</td>
<td>匹配权限（mode为完全匹配，-mode为包含即可）</td>
</tr>
<tr>
<td>-user</td>
<td>匹配所有者</td>
</tr>
<tr>
<td>-group</td>
<td>匹配所有组</td>
</tr>
<tr>
<td>-mtime -n +n</td>
<td>匹配修改内容的时间（-n指n天以内，+n指n天以前）</td>
</tr>
<tr>
<td>-atime -n +n</td>
<td>匹配访问文件的时间（-n指n天以内，+n指n天以前）</td>
</tr>
<tr>
<td>-ctime -n +n</td>
<td>匹配修改文件权限的时间（-n指n天以内，+n指n天以前）</td>
</tr>
<tr>
<td>-nouser</td>
<td>匹配无所有者的文件</td>
</tr>
<tr>
<td>-nogroup</td>
<td>匹配无所有组的文件</td>
</tr>
<tr>
<td>-newer f1 !f2</td>
<td>匹配比文件f1新但比f2旧的文件</td>
</tr>
<tr>
<td>—type b/d/c/p/l/f</td>
<td>匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件）</td>
</tr>
<tr>
<td>-size</td>
<td>匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件）</td>
</tr>
<tr>
<td>-prune</td>
<td>忽略某个目录</td>
</tr>
<tr>
<td>-exec …… {}\;</td>
<td>后面可跟用于进一步处理搜索结果的命令（下文会有演示）</td>
</tr>
</tbody>
</table>
</div>
<p>这里需要重点讲解一下-exec参数重要的作用。这个参数用于把find命令搜索到的结果交由紧随其后的命令作进一步处理，它十分类似于第3章将要讲解的管道符技术，并且由于find命令对参数的特殊要求，因此虽然exec是长格式形式，但依然只需要一个减号（-）。</p>
<p>根据文件系统层次标准（Filesystem Hierarchy Standard）协议，<strong>Linux系统中的配置文件会保存到/etc目录中（详见第6章）。</strong>如果要想获取到该目录中所有以host开头的文件列表，可以执行如下命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find /etc -name <span class="string">"host*"</span> -print</span><br></pre></td></tr></table></figure>
<p>如果要在整个系统中搜索权限中包括SUID权限的所有文件（详见第5章），只需使用-4000即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find / -perm <span class="number">-4000</span> -print</span><br></pre></td></tr></table></figure>
<p>进阶实验：在整个文件系统中找出所有归属于linuxprobe用户的文件并复制到/root/findresults目录。</p>
<p>该实验的重点是“-exec {}   \;”参数，其中的{}表示find命令搜索出的每一个文件，并且命令的结尾必须是“\;”。完成该实验的具体命令如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find / -user linuxprobe -exec cp -a &#123;&#125; /root/findresults/ \;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/19/ubuntu上安装软件方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/19/ubuntu上安装软件方法/" itemprop="url">ubuntu上安装软件方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-19T09:43:55+08:00">2018-04-19</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ubuntu上安装软件方法"><a href="#ubuntu上安装软件方法" class="headerlink" title="ubuntu上安装软件方法"></a>ubuntu上安装软件方法</h1><h2 id="总结下来就是有3种"><a href="#总结下来就是有3种" class="headerlink" title="总结下来就是有3种"></a>总结下来就是有3种</h2><ol>
<li>使用<code>sudo apt-get</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search package 搜索包</span><br><span class="line">apt-cache show package 获取包的相关信息，如说明、大小、版本等</span><br><span class="line"></span><br><span class="line">sudo apt-get install package 安装包</span><br><span class="line">sudo apt-get remove package 删除包</span><br></pre></td></tr></table></figure>
<ol>
<li>使用<code>dpkg</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> dpkg -i &lt;package.deb&gt;</span><br><span class="line">安装一个 Debian 软件包，如你手动下载的文件，（其中-i等价于--install）</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> dpkg -c &lt;package.deb&gt;</span><br><span class="line">列出&lt;package.deb&gt; 的内容中包含的文件结构（其中-c等价于--contents）</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> dpkg - I&lt;package.deb&gt;</span><br><span class="line">从&lt;package.deb&gt; 中提取包裹信息的详细信息，包括软件名称. 版本以及大小等（其中-I等价于--info）</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> dpkg -r &lt;package&gt;</span><br><span class="line">移除一个已安装的包裹（软件名称可通过dpkg -I命令查看，其中-r等价于--remove）</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> dpkg -P &lt;package&gt;</span><br><span class="line">完全清除一个已安装的包裹。和 remove 不同的是，remove 只是删掉数据和可执行文件，purge 另外还删除所有的配制文件。</span><br></pre></td></tr></table></figure>
<ol>
<li>解压缩<code>.tar.gz</code>的直接运行</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">解压：$ tar -xzvf &lt;FileName.tar.gz&gt;</span><br><span class="line">压缩：$ tar -czvf &lt;FileName.tar.gz DirName&gt;</span><br><span class="line">-c: 建立压缩档案</span><br><span class="line">-x：解压</span><br><span class="line"></span><br><span class="line">-z：有gzip属性的</span><br><span class="line">-v：显示所有过程</span><br><span class="line">-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</span><br></pre></td></tr></table></figure>
<h2 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h2><p>常用的APT命令参数<br>　　apt-cache search package 搜索包<br>　　apt-cache show package 获取包的相关信息，如说明、大小、版本等</p>
<p>　　sudo apt-get install package 安装包<br>　　sudo apt-get install package — reinstall 重新安装包<br>　　sudo apt-get -f install 修复安装”-f = —fix-missing”<br>　　sudo apt-get remove package 删除包<br>　　sudo apt-get remove package — purge 删除包，包括删除配置文件等<br>　　sudo apt-get update 更新源<br>　　sudo apt-get upgrade 更新已安装的包<br>　　sudo apt-get dist-upgrade 升级系统<br>　　sudo apt-get dselect-upgrade 使用 dselect 升级</p>
<p>　　apt-cache depends package 了解使用依赖<br>　　apt-cache rdepends package 是查看该包被哪些包依赖</p>
<p>　　sudo apt-get build-dep package 安装相关的编译环境<br>　　apt-get source package 下载该包的源代码<br>　　sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包<br>　　sudo apt-get check 检查是否有损坏的依赖<br>　　其中：<br>　　1 有sudo的表示需要管理员特权！<br>　　2 在UBUNTU中命令后面参数为短参数是用“-”引出，长参数用“—”引出<br>　　3 命令帮助信息可用man 命令的方式查看或者<br>　　命令 -H（—help）方式查看<br>　　4 在man命令中需要退出命令帮助请按“q”键！！<br>　　选项 含义 作用<br>　　sudo -h Help 列出使用方法，退出。<br>　　sudo -V Version 显示版本信息，并退出。<br>　　sudo -l List 列出当前用户可以执行的命令。只有在sudoers里的用户才能使用该选项。<br>　　sudo -u username|#uid User 以指定用户的身份执行命令。后面的用户是除root以外的，可以是用户名，也可以是#uid。<br>　　sudo -k Kill 清除“入场卷”上的时间，下次再使用sudo时要再输入密码。<br>　　sudo -K Sure kill 与-k类似，但是它还要撕毁“入场卷”，也就是删除时间戳文件。<br>　　sudo -b command Background 在后台执行指定的命令。<br>　　sudo -p prompt command Prompt 可以更改询问密码的提示语，其中%u会代换为使用者帐号名称，%h会显示主机名称。非常人性化的设计<br>　　sudo -e file Edit 不是执行命令，而是修改文件，相当于命令sudoedit。</p>
<h2 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h2><pre><code>1. dpkg -i &lt;package.deb&gt;
安装一个 Debian 软件包，如你手动下载的文件，（其中-i等价于--install）

2. dpkg -c &lt;package.deb&gt;
列出&lt;package.deb&gt; 的内容中包含的文件结构（其中-c等价于--contents）

3. dpkg - I&lt;package.deb&gt;
从&lt;package.deb&gt; 中提取包裹信息的详细信息，包括软件名称. 版本以及大小等（其中-I等价于--info）

4. dpkg -r &lt;package&gt;
移除一个已安装的包裹（软件名称可通过dpkg -I命令查看，其中-r等价于--remove）

5. dpkg -P &lt;package&gt;
完全清除一个已安装的包裹。和 remove 不同的是，remove 只是删掉数据和可执行文件，purge 另外还删除所有的配制文件。

6. dpkg -L &lt;package&gt;
列出 &lt;package&gt; 安装的软件包安装的所有文件（软件名称可通过dpkg -I命令查看，其中-L等价于--listfiles）

7. dpkg -l &lt;package&gt;
查看&lt;package&gt;软件包的信息（软件名称可通过dpkg -I命令查看，其中-l等价于--list）

8. dpkg -s &lt;package&gt;
显示已安装包裹的详细信息。同时请看 apt-cache 显示 Debian 存档中的包裹信息，以及 dpkg -I 来显示从一个 .deb 文件中提取的包裹信息。（软件名称可通过dpkg -I命令查看，其中-s等价于--status）

9. dpkg-reconfigure &lt;package&gt;
重新配制一个已经安装的包裹，如果它使用的是 debconf (debconf 为包裹安装提供了一个统一的配制界面)。
</code></pre><h2 id="tar-gz"><a href="#tar-gz" class="headerlink" title=".tar.gz"></a>.tar.gz</h2><ol>
<li>.tar.gz的先tar -x</li>
</ol>
<p>tar<br>-c: 建立压缩档案<br>-x：解压<br>-t：查看内容<br>-r：向压缩归档文件末尾追加文件<br>-u：更新原压缩包中的文件<br>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p>
<p>-z：有gzip属性的<br>-j：有bz2属性的<br>-Z：有compress属性的<br>-v：显示所有过程<br>-O：将文件解开到标准输出</p>
<p>下面的参数-f是必须的</p>
<p>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p>
<p>$ tar -cf all.tar *.jpg<br>这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。 </p>
<p>$ tar -rf all.tar *.gif<br>这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 </p>
<p>$ tar -uf all.tar logo.gif<br>这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 </p>
<p>$ tar -tf all.tar<br>这条命令是列出all.tar包中所有文件，-t是列出文件的意思 </p>
<p>$ tar -xf all.tar<br>这条命令是解出all.tar包中所有文件，-x是解开的意思 </p>
<p>压缩<br>tar –cvf jpg.tar <em>.jpg //将目录里所有jpg文件打包成tar.jpg<br>tar –czf jpg.tar.gz </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz<br>tar –cjf jpg.tar.bz2 <em>.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2<br>tar –cZf jpg.tar.Z </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z<br>rar a jpg.rar <em>.jpg //rar格式的压缩，需要先下载rar for Linux<br>zip jpg.zip </em>.jpg //zip格式的压缩，需要先下载zip for linux</p>
<p>解压<br>tar –xvf file.tar //解压 tar包<br>tar -xzvf file.tar.gz //解压tar.gz<br>tar -xjvf file.tar.bz2   //解压 tar.bz2<br>tar –xZvf file.tar.Z   //解压tar.Z<br>unrar e file.rar //解压rar<br>unzip file.zip //解压zip</p>
<p>总结</p>
<ol>
<li>*.tar 用 tar –xvf 解压</li>
<li>*.gz 用 gzip -d或者gunzip 解压</li>
<li><strong>*.tar.gz和*.tgz 用 tar –xzvf 解压</strong></li>
<li>*.bz2 用 bzip2 -d或者用bunzip2 解压</li>
<li>*.tar.bz2用tar –xjf 解压</li>
<li>*.Z 用 uncompress 解压</li>
<li>*.tar.Z 用tar –xZf 解压</li>
<li>*.rar 用 unrar e解压</li>
<li>*.zip 用 unzip 解压</li>
</ol>
<p>一般使用tar -xzvf  tar -czvf</p>
<p>01-.tar格式<br>解包：[＊＊＊＊＊＊＊]$ tar xvf FileName.tar<br>打包：[＊＊＊＊＊＊＊]$ tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）<br>02-.gz格式<br>解压1：[＊＊＊＊＊＊＊]$ gunzip FileName.gz<br>解压2：[＊＊＊＊＊＊＊]$ gzip -d FileName.gz<br>压 缩：[＊＊＊＊＊＊＊]$ gzip FileName</p>
<p><strong>03-.tar.gz格式</strong><br><strong>解压：[＊＊＊＊＊＊＊]$ tar -zxvf FileName.tar.gz</strong><br><strong>压缩：[＊＊＊＊＊＊＊]$ tar -zcvf FileName.tar.gz DirName</strong></p>
<p>04-.bz2格式<br>解压1：[＊＊＊＊＊＊＊]$ bzip2 -d FileName.bz2<br>解压2：[＊＊＊＊＊＊＊]$ bunzip2 FileName.bz2<br>压 缩： [＊＊＊＊＊＊＊]$ bzip2 -z FileName</p>
<p>05-.tar.bz2格式<br>解压：[＊＊＊＊＊＊＊]$ tar jxvf FileName.tar.bz2<br>压缩：[＊＊＊＊＊＊＊]$ tar jcvf FileName.tar.bz2 DirName</p>
<p>06-.bz格式<br>解压1：[＊＊＊＊＊＊＊]$ bzip2 -d FileName.bz<br>解压2：[＊＊＊＊＊＊＊]$ bunzip2 FileName.bz</p>
<p>07-.tar.bz格式<br>解压：[＊＊＊＊＊＊＊]$ tar jxvf FileName.tar.bz</p>
<p>08-.Z格式<br>解压：[＊＊＊＊＊＊＊]$ uncompress FileName.Z<br>压缩：[＊＊＊＊＊＊＊]$ compress FileName</p>
<p>09-.tar.Z格式<br>解压：[＊＊＊＊＊＊＊]$ tar Zxvf FileName.tar.Z<br>压缩：[＊＊＊＊＊＊＊]$ tar Zcvf FileName.tar.Z DirName</p>
<p>10-.tgz格式<br>解压：[＊＊＊＊＊＊＊]$ tar zxvf FileName.tgz</p>
<p>11-.tar.tgz格式<br>解压：[＊＊＊＊＊＊＊]$ tar zxvf FileName.tar.tgz<br>压缩：[＊＊＊＊＊＊＊]$ tar zcvf FileName.tar.tgz FileName</p>
<p>12-.zip格式<br>解压：[＊＊＊＊＊＊＊]$ unzip FileName.zip<br>压缩：[＊＊＊＊＊＊＊]$ zip FileName.zip DirName</p>
<p>13-.lha格式<br>解压：[＊＊＊＊＊＊＊]$ lha -e FileName.lha<br>压缩：[＊＊＊＊＊＊＊]$ lha -a FileName.lha FileName</p>
<p>14-.rar格式<br>解压：[＊＊＊＊＊＊＊]$ rar a FileName.rar<br>压缩：[＊＊＊＊＊＊＊]$ rar e FileName.rar<br>rar请到：下载！<br>解压后请将rar_static拷贝到/usr/bin目录（其他由$PATH环境变量<br>指定的目录也行）：[＊＊＊＊＊＊＊]$ cp rar_static /usr/bin/rar</p>
<h2 id="这样的要在把东西解压到-usr-local中-然后"><a href="#这样的要在把东西解压到-usr-local中-然后" class="headerlink" title="这样的要在把东西解压到/usr/local中 然后"></a>这样的要在把东西解压到/usr/local中 然后</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar  -xzvf node-v5.10.1-linux-x64.tar.gz  /usr/local/</span><br><span class="line">cd /usr/local/</span><br><span class="line">sudo mv node-v5.10.1-linux-x64/ nodejs</span><br><span class="line">sudo ln -s /usr/local/nodejs/bin/node /usr/local/bin</span><br><span class="line">sudo ln -s /usr/local/nodejs/bin/npm /usr/local/bin</span><br></pre></td></tr></table></figure>
<p>还有一种</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">下载完安装包，并解压 tgz（以下演示的是 <span class="number">64</span> 位 Linux上的安装） 。</span><br><span class="line"></span><br><span class="line">curl -O https:<span class="comment">//fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz    # 下载</span></span><br><span class="line">tar -zxvf mongodb-linux-x86_64<span class="number">-3.0</span><span class="number">.6</span>.tgz                                   # 解压</span><br><span class="line"></span><br><span class="line">mv  mongodb-linux-x86_64<span class="number">-3.0</span><span class="number">.6</span>/ /usr/local/mongodb                         # 将解压包拷贝到指定目录</span><br><span class="line"></span><br><span class="line">MongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 PATH 路径中：就是全局环境变量.window上那种</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> PATH=&lt;mongodb-install-directory&gt;/bin:$PATH</span><br><span class="line"><span class="keyword">export</span> PATH=/usr/local/mongodb/bin:$PATH</span><br><span class="line">&lt;mongodb-install-directory&gt; 为你 MongoDB 的安装路径。如本文的 /usr/local/mongodb 。</span><br></pre></td></tr></table></figure>
<p>上面的重启就没了 怎么永久<br><a href="https://www.cnblogs.com/lihao-blog/p/6945040.html" target="_blank" rel="noopener">https://www.cnblogs.com/lihao-blog/p/6945040.html</a><br>source /etc/profile后只在一个终端中有效<br><a href="https://www.cnblogs.com/tomato0906/articles/6048383.html" target="_blank" rel="noopener">https://www.cnblogs.com/tomato0906/articles/6048383.html</a><br><a href="https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=143895" target="_blank" rel="noopener">https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=143895</a></p>
<p><a href="http://liuzhijun.iteye.com/blog/1744465" target="_blank" rel="noopener">http://liuzhijun.iteye.com/blog/1744465</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/18/vscode上插件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/vscode上插件/" itemprop="url">vscode上插件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T18:45:50+08:00">2018-04-18</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vscode-上插件"><a href="#vscode-上插件" class="headerlink" title="vscode 上插件"></a>vscode 上插件</h1><h2 id="setting-sync"><a href="#setting-sync" class="headerlink" title="setting sync"></a>setting sync</h2><p>Settings Sync 这个插件可以通过 github 上面的 gist 来同步你的 vscode 的配置包括插件,自定义按键设置。还能够分享给别人使用。主要用在换电脑.</p>
<ol>
<li>首先当然是下载 vscode 然后安装 Setting Sync</li>
</ol>
<p><img src="1.jpg" alt="1"></p>
<ol>
<li>按 ctrl+shift+p 填入 sync 可以看到所有命令</li>
</ol>
<p><img src="2.jpg" alt="2"></p>
<ol>
<li><p>然后选择 update 的 快捷键是 alt+shift+u</p>
</li>
<li><p>会弹出一个 github 的登录页,登录有进入 Developer settings =&gt; personal access token.这里设置好 gist, 然后会生成一个 token</p>
</li>
</ol>
<p><img src="3.jpg" alt="3"></p>
<ol>
<li><p>再按下 alt+shift+u 就输入好了,最后会上传上去,然后就是得到一个 token 和 gist ID .</p>
</li>
<li><p>使用备份就是下载好 vscode 之后, 安装 Setting Sync, 然后按 ctrl+shif+p 搜 sync 选 download.(快捷键 alt+shift+d 当然同上),然后输入 token 在 gist ID . 插件下载要等一会</p>
</li>
<li><p>不行的话 reset 下 有个 Reset Extension Setting</p>
</li>
</ol>
<p>总结下:</p>
<ol>
<li>先去自己的 github 中的 personal access token 中获取 token</li>
<li>在使用 alt+shift+u 上传,这里使用 token,得到 gist ID</li>
<li>使用这个备份,alt+shift+d,一次输入 token 和 gist ID, 然后就是等待下载咯.</li>
</ol>
<p>比如<br>GitHub Token: 293f9e53416c8ae5xx2c6a6e69604125fe80f3e8 自己生成一个， 上传更新才用到<br>GitHub Gist: b7e3625d05f1b3b31cb33180254a1e7d 这里才是下载更新用到的<br>GitHub Gist Type: Secret</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/数据结构中的常用算法总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/数据结构中的常用算法总结/" itemprop="url">数据结构中的常用算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-15T23:18:18+08:00">2018-04-15</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据结构中的常用算法总结"><a href="#数据结构中的常用算法总结" class="headerlink" title="数据结构中的常用算法总结"></a>数据结构中的常用算法总结</h1><p>首先介绍4个可视化数据结构的网址,推荐度从前往后</p>
<ol>
<li><a href="https://visualgo.net/" target="_blank" rel="noopener">visualgo</a></li>
<li><a href="http://sorting.at/" target="_blank" rel="noopener">sorting</a></li>
<li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">Data Structure Visualizations</a></li>
<li><a href="http://algo-visualizer.jasonpark.me/#path=sorting/insertion/basic" target="_blank" rel="noopener">algo-visualizer</a></li>
</ol>
<p>书籍</p>
<ol>
<li><a href="https://algs4.cs.princeton.edu/home/" target="_blank" rel="noopener">Algorithms, 4th Edition</a><ul>
<li><a href="https://github.com/aistrate/AlgorithmsSedgewick" target="_blank" rel="noopener">algorithmsSedgewick</a></li>
<li><a href="https://introcs.cs.princeton.edu/java/assignments/" target="_blank" rel="noopener">assignment</a></li>
</ul>
</li>
<li><a href="https://www.toptal.com/developers/sorting-algorithms/" target="_blank" rel="noopener">topal</a></li>
</ol>
<h1 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序 sort"></a>排序 sort</h1><ol>
<li>insert</li>
<li>折半</li>
<li>shell</li>
<li>bubble</li>
<li>quick</li>
<li>select</li>
<li>heap</li>
<li>merge</li>
<li>基数</li>
</ol>
<h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h2><h3 id="ALGORITHM"><a href="#ALGORITHM" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>:n<span class="number">-1</span>,</span><br><span class="line">    <span class="keyword">for</span> (j = i; <span class="number">1</span> &lt;= j <span class="keyword">and</span> a[j<span class="number">-1</span>] &gt; a[j]; j--)</span><br><span class="line">        swap a[j<span class="number">-1</span>, j]</span><br><span class="line">    → invariant: a[<span class="number">1.</span>.i] is sorted</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>注解:</strong> 默认数组a下标就是1开始. k从i开始,例如一开始就是从第2个元素起步a[2]和第一个元素a[1]比较, 一趟比较完后k随着i++进行下一趟比较, i是用来确定一趟的最后一个元素位置. k&gt;1是说最后比较只会是a[1] a[2] 不会a[0] a[1]因为不存在a[0], 下标从1开始, 最后一趟是从a[n-1] a[n]开始比较.</p>
<p>注意这个不需要一个数组 用来特别往后移动.</p>
<blockquote>
<p>外层循环记录着每趟起始和终止位置,代表趟数;内层是比较方式. 要根据可视化的过程来决定外层怎么写. 比如select的 是小的放最前还是大的放最外层不一样.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">插入排序 </span></span><br><span class="line"><span class="comment">基本思想：将元素逐个添加到已经排好序的数组中去。 </span></span><br><span class="line"><span class="comment">平均时间复杂度O(n^2) </span></span><br><span class="line"><span class="comment">最好时间复杂度O(n) </span></span><br><span class="line"><span class="comment">最坏时间复杂度O(n^2) </span></span><br><span class="line"><span class="comment">空间复杂度O(1) </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span> <span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++)&#123;<span class="comment">//假设第0个已在正确位置，从第一个开始插入</span></span><br><span class="line">        <span class="comment">//第i趟插入需要在[0，i-1]中从后往前找到i的合适位置</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = i; <span class="number">1</span> &lt;= j &amp;&amp; a[j<span class="number">-1</span>] &gt; a[j]; j--)&#123;</span><br><span class="line">            swap(a[j<span class="number">-1</span>],a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span> <span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要进行n-1趟插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; <span class="number">0</span> &lt; j &amp;&amp; a[j<span class="number">-1</span>] &gt; a[j]; j--) &#123;  <span class="comment">// 0&lt;=j 不对哦 j是从1开始</span></span><br><span class="line">            swap(a[j<span class="number">-1</span>], a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span> <span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; <span class="number">1</span> &lt;= j &amp;&amp; a[j<span class="number">-1</span>] &lt; a[j]; j--) &#123;</span><br><span class="line">            swap(a[j<span class="number">-1</span>], a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内循环中将较大的元素一次性向右移动而不是交换两个元素，这样访问数组的次数将减半 。其代码如下：</span></span><br><span class="line">真的么?</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = data.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = data[i];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">//要插入的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; data[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                data[j] = data[j<span class="number">-1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                index = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION"><a href="#DISCUSSION" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>尽管存在最坏情况(worst-case)是O(n2), 也就是逆序(reversed)的情况下, insertion sort 在data几乎有序(这个叫adaptive)和问题size很小(这个叫low overhead 低开销)的情况下还是一个很好的选择.</p>
<p>还有他是<strong>stable</strong>的, insertion sort is often used as the <strong>recursive base case</strong> (when the problem size is <strong>small</strong>) for higher overhead 分治divide-and-conquer sorting algorithms, such as merge sort or quick sort.</p>
<h3 id="PROPERTIES"><a href="#PROPERTIES" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Stable</li>
<li>O(1) extra space</li>
<li>O(n2) comparisons and swaps</li>
<li>Adaptive: O(n) time when nearly sorted</li>
<li>Very low overhead</li>
</ul>
<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">将直接插入排序中寻找a[i]插入位置的方法改为二分查找，然后再一次性向右移动元素。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = binaryFind(a, a[i], <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        <span class="comment">//num后的元素向后移动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; num &lt; j; j--) &#123;</span><br><span class="line">           a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a[num] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出元素应在数组中插入的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binaryFind</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> temp, <span class="keyword">int</span> down, <span class="keyword">int</span> up)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(up&lt;down || up&gt;data.length || down&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"下标错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp &lt; data[down]) <span class="keyword">return</span> down;</span><br><span class="line">    <span class="keyword">if</span>(temp &gt; data[up]) <span class="keyword">return</span> up+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (up-down)/<span class="number">2</span> + down;</span><br><span class="line">    <span class="keyword">if</span>(temp == data[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp &lt; data[mid]) &#123;</span><br><span class="line">        up = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; data[mid]) &#123;</span><br><span class="line">        down = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binaryFind(data,temp, down, up);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell Sort"></a>Shell Sort</h2><h3 id="ALGORITHM-1"><a href="#ALGORITHM-1" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> h &lt; n, h = <span class="number">3</span>*h + <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> h &gt; <span class="number">0</span>,</span><br><span class="line">    h = h / <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span>:h, insertion sort a[k:h:n]</span><br><span class="line">    → invariant: each h-sub-<span class="built_in">array</span> is sorted</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>注解:</strong> 首先按n大小计算递增序列,这里是按1 4 13 40 来, 然后从最大的h开始. 注意有一步<code>h = h / 3</code> 这就是比n小的最大的h, 因为前一个while跳出就是h&gt;n的情况,还得返回去. 然后a[1,4] a[2, 5] 这样按insertion sort比较 a[k:h:n]  是从k到n以k为间隔</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">5、希尔排序 </span></span><br><span class="line"><span class="comment">基本思想：将无序数组分成若干个子序列，子序列不是逐段分割的，而是相隔特定增量。对各个子序列进行插入排序。 </span></span><br><span class="line"><span class="comment">然后再选择一个更小的增量，再将数组分割成多个子序列进行排序。最后选择增量为1，即使用直接插入排序，使最终数组成为有序数组。 </span></span><br><span class="line"><span class="comment">平均时间复杂度O(n^1.3) </span></span><br><span class="line"><span class="comment">最好时间复杂度O(n) </span></span><br><span class="line"><span class="comment">最坏时间复杂度O(n^2) </span></span><br><span class="line"><span class="comment">空间复杂度O(1) </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap;</span><br><span class="line">    <span class="keyword">for</span>( gap = n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &lt; a[j + gap]; j-=gap)&#123;<span class="comment">//每个元素与自己组内的元素进行插入排序</span></span><br><span class="line">                swap(a[j], a[j + gap]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n) &#123;</span><br><span class="line">        h = <span class="number">3</span>*h +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        h = h/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= h<span class="number">-1</span>; k++) &#123; <span class="comment">//根据增量分成若干组  每个h对应趟数</span></span><br><span class="line">            <span class="comment">// insert_sort的理解</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = k+h; i &lt;= n<span class="number">-1</span>; i=i+h)&#123;<span class="comment">//假设第0个已在正确位置，从第一个开始插入  </span></span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">int</span> j = i; k+h &lt;= j &amp;&amp; a[j-h] &gt; a[j]; j=j-h)&#123;  <span class="comment">//不能加 k&lt;= j 用k+h &lt;= j也对</span></span><br><span class="line">                    swap(a[j-h],a[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for ( int k = 0; k &lt;= h-1; k++) &#123; //根据增量分成若干组  </span></span><br><span class="line">            <span class="comment">// insert_sort()</span></span><br><span class="line">            <span class="comment">// for(int i = k+h; i &lt;= n-1; i=i+h)&#123;//假设第0个已在正确位置，从第一个开始插入  </span></span><br><span class="line">            <span class="comment">//     for ( int j = i; k &lt;= j &amp;&amp; a[j-h] &gt; a[j]; j=j-h)&#123;</span></span><br><span class="line">            <span class="comment">//         swap(a[j-h],a[j]);</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//核心算法，增量序列 1 4 13 ....（3*h+1）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h &lt; n/<span class="number">3</span>) <span class="comment">// 注意这里变了 </span></span><br><span class="line">        h = <span class="number">3</span>*h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt;= n<span class="number">-1</span>; i++) &#123; <span class="comment">//这种事按4的比完,再按5比完.而不是048这样. 8的这种后面会比到的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; h &lt;= j &amp;&amp; a[j-h] &gt; a[j]; j = j-h) &#123;</span><br><span class="line">                swap(a[j-h], a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION-1"><a href="#DISCUSSION-1" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>shell sort最坏情况时间复杂度(The worse-case time complexity)依赖于递增序列(the increment sequence). 这里所使用的the increments 1 4 13 40 121…, 时间复杂度是 O(n3/2). For other increments, time complexity is known to be O(n4/3) and even O(n·lg2(n)). 既不存在时间复杂度的紧上界，也不知道最佳增量序列。</p>
<p>Because shell sort is based on insertion sort, shell sort inherits insertion sort’s <strong>adaptive properties</strong>. The adapation is not as dramatic because shell sort requires one pass through the data for each increment, but it is significant. For the increment sequence shown above, there are log3(n) increments, so the time complexity for nearly sorted data is O(n·log3(n)).</p>
<p>Because of its <strong>low overhead, relatively simple implementation, adaptive properties, and sub-quadratic time complexity</strong>, shell sort may be a viable alternative to the O(n·lg(n)) sorting algorithms for some applications when the data to be sorted is not very large.</p>
<h3 id="PROPERTIES-1"><a href="#PROPERTIES-1" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Not stable</li>
<li>O(1) extra space</li>
<li>O(n3/2) time as shown (see below)</li>
<li>Adaptive: O(n·lg(n)) time when nearly sorted</li>
</ul>
<h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h2><h3 id="ALGORITHM-2"><a href="#ALGORITHM-2" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = n<span class="number">-1</span>:<span class="number">0</span>,</span><br><span class="line">    swapped = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span>:i; n--</span><br><span class="line">        <span class="keyword">if</span> a[j<span class="number">-1</span>] &gt; a[j],</span><br><span class="line">            swap a[j<span class="number">-1</span>,j]</span><br><span class="line">            swapped = <span class="literal">true</span></span><br><span class="line">    → invariant: a[i..n<span class="number">-1</span>] in final position</span><br><span class="line">    <span class="keyword">break</span> <span class="keyword">if</span> <span class="keyword">not</span> swapped</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> Bubble sort每趟排序完后最后一个元素到位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">冒泡排序 </span></span><br><span class="line"><span class="comment">基本思想： 不断比较相邻的两个数，让较大的数不断地往后移。经过一番比较，就选出了最大的数。经过第二轮比较，就选出了次大的数。以此类推。 </span></span><br><span class="line"><span class="comment">那么对于大小为N的数组，需要N-1轮比较。 </span></span><br><span class="line"><span class="comment">平均时间复杂度O（N^2） </span></span><br><span class="line"><span class="comment">最好情况O（N） </span></span><br><span class="line"><span class="comment">最坏情况O（N^2） </span></span><br><span class="line"><span class="comment">空间复杂度O（1） </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//要进行N-1轮比较, 这里记录趟数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n<span class="number">-2</span>; i++ )<span class="comment">//[0,n-2]恰好n-1轮比较</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> is_sorted = <span class="literal">true</span>;  <span class="comment">// 是否交换的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n<span class="number">-1</span>-i; j++)<span class="comment">//已经排好序的最后i个不用比较，要比较的数的个数为n-i个，那么需要比较的次数为n-i-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j<span class="number">-1</span>] &gt; a[j])&#123;</span><br><span class="line">                is_sorted = <span class="literal">false</span>;</span><br><span class="line">                swap(a[j<span class="number">-1</span>],a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_sorted)<span class="comment">//如果没有发生交换，说明已经排好序了，提前退出循环,所以最好情况下时间复杂度为O（N）</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; <span class="number">1</span> &lt;= i; i-- ) <span class="comment">// 这个好理解</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> is_sorted = <span class="literal">true</span>;  <span class="comment">// 是否交换的标志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j<span class="number">-1</span>] &gt; a[j])&#123;</span><br><span class="line">                is_sorted = <span class="literal">false</span>;</span><br><span class="line">                swap(a[j<span class="number">-1</span>],a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_sorted) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION-2"><a href="#DISCUSSION-2" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>Bubble sort has many of the same properties as insertion sort, but has <strong>slightly higher overhead</strong>. In the case of nearly sorted data, bubble sort takes O(n) time, but requires at least 2 passes through the data (whereas insertion sort requires something more like 1 pass).</p>
<h3 id="PROPERTIES-2"><a href="#PROPERTIES-2" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Stable</li>
<li>O(1) extra space</li>
<li>O(n2) comparisons and swaps</li>
<li>Adaptive: O(n) when nearly sorted</li>
</ul>
<h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><h3 id="ALGORITHM-3"><a href="#ALGORITHM-3" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_<span class="meta"># choose pivot_</span></span><br><span class="line">swap a[<span class="number">1</span>,rand(<span class="number">1</span>,n)]</span><br><span class="line"></span><br><span class="line">_# <span class="number">2</span>-way partition_</span><br><span class="line">k = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">2</span>:n, <span class="keyword">if</span> a[i] &lt; a[<span class="number">1</span>], swap a[++k,i]</span><br><span class="line">swap a[<span class="number">1</span>,k]</span><br><span class="line">_→ invariant: a[<span class="number">1.</span>.k<span class="number">-1</span>] &lt; a[k] &lt;= a[k+<span class="number">1.</span>.n]_</span><br><span class="line"></span><br><span class="line">_# recursive sorts_</span><br><span class="line">sort a[<span class="number">1.</span>.k<span class="number">-1</span>]</span><br><span class="line">sort a[k+<span class="number">1</span>,n]</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> Quick sort有好几种</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">3、快速排序 </span></span><br><span class="line"><span class="comment">基本思想：采用分而治之的思想，将要排序的数分成左右两部分，其中一部分的数据比key小，另一部分数据比key大。然后将所分得的两部分数据进行同样的划分。重复执行以上的划分操作。</span></span><br><span class="line"><span class="comment">平均时间复杂度O（Nlog2(N)）</span></span><br><span class="line"><span class="comment">最好情况O（Nlog2(N)）</span></span><br><span class="line"><span class="comment">最坏情况O（N^2）</span></span><br><span class="line"><span class="comment">空间复杂度O（Nlog2(N)）</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><span class="comment">//返回划分的中间值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    key = arr[low];<span class="comment">//相当于在索引low处挖坑，下一个就要找合适的据来填坑</span></span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; key &lt;= arr[high])&#123;</span><br><span class="line">            high --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">            arr[low ++] = arr[high];<span class="comment">//找到合适的数据填到了lo坑，但是形成了high坑，继续找合适的数据</span></span><br><span class="line">        <span class="keyword">while</span>( low &lt; high &amp;&amp; arr[low] &lt;= key)</span><br><span class="line">            low ++;</span><br><span class="line">        <span class="keyword">if</span>( low &lt; high)</span><br><span class="line">            arr[high --] =  arr[low];<span class="comment">//low又成了坑</span></span><br><span class="line"></span><br><span class="line">    arr[low] = key;<span class="comment">//将key填到这个坑</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        pos = partition(num, low, high);</span><br><span class="line">        quick_sort(num, low, pos<span class="number">-1</span>);</span><br><span class="line">        quick_sort(num, pos+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*快速排序非递归版*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort2</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = num[low];</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = partition(num, low, high);</span><br><span class="line">        <span class="keyword">if</span>(pos<span class="number">-1</span> &gt; low)&#123;</span><br><span class="line">            s.push(pos - <span class="number">1</span>);</span><br><span class="line">            s.push(low);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos+<span class="number">1</span> &lt; high)&#123;</span><br><span class="line">            s.push(high);</span><br><span class="line">            s.push(pos + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> l = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">int</span> r = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            pos = partition(num, l, r);</span><br><span class="line">            <span class="keyword">if</span>(pos - <span class="number">1</span> &gt; l)&#123;</span><br><span class="line">                s.push(pos - <span class="number">1</span>);</span><br><span class="line">                s.push(l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">                s.push(r);</span><br><span class="line">                s.push(pos + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=low,j=high,key=arr[low];<span class="comment">//i j 是需要的 low high用来递归 不能动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &gt; j)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &lt;= arr[j])&#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">            arr[i ++] = arr[j];<span class="comment">//找到合适的数据填到了low坑，但是形成了high坑，继续找合适的数据</span></span><br><span class="line">        <span class="keyword">while</span>( i &lt; j &amp;&amp; arr[i] &lt;= key)</span><br><span class="line">            i ++;</span><br><span class="line">        <span class="keyword">if</span>( i &lt; j)</span><br><span class="line">            arr[j --] =  arr[i];<span class="comment">//low又成了坑</span></span><br><span class="line">    &#125;</span><br><span class="line">	arr[i] = key;<span class="comment">//将key填到这个坑 一趟后</span></span><br><span class="line"></span><br><span class="line">    quick_sort(arr,low,i<span class="number">-1</span>);</span><br><span class="line">    quick_sort(arr,i+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION-3"><a href="#DISCUSSION-3" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>When carefully implemented, quick sort is <strong>robust and has low overhead</strong>. When a stable sort is not needed, quick sort is an excellent general-purpose sort – although the <strong>3-way</strong> partitioning version should always be used instead.</p>
<p>The 2-way partitioning code shown above is written for clarity rather than optimal performance; it exhibits poor locality, and, critically, exhibits O(n2) time when there are few unique keys. A more efficient and robust 2-way partitioning method is given in Quicksort is Optimal by Robert Sedgewick and Jon Bentley. The robust partitioning produces balanced recursion when there are many values equal to the pivot, yielding probabilistic guarantees of O(n·lg(n)) time and O(lg(n)) space for all inputs.</p>
<p>With both sub-sorts performed recursively, quick sort requires O(n) extra space for the recursion stack in the worst case when recursion is not balanced. This is exceedingly unlikely to occur, but it can be avoided by sorting the smaller sub-array recursively first; the second sub-array sort is a tail recursive call, which may be done with iteration instead. With this optimization, the algorithm uses O(lg(n)) extra space in the worst case.</p>
<h3 id="PROPERTIES-3"><a href="#PROPERTIES-3" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Not stable</li>
<li>O(lg(n)) extra space (see discussion)</li>
<li>O(n2) time, but typically O(n·lg(n)) time</li>
<li>Not adaptive</li>
</ul>
<h2 id="Quick-Sort-3-Way"><a href="#Quick-Sort-3-Way" class="headerlink" title="Quick Sort 3 Way"></a>Quick Sort 3 Way</h2><h3 id="ALGORITHM-4"><a href="#ALGORITHM-4" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">_<span class="meta"># choose pivot_</span></span><br><span class="line">swap a[n,rand(<span class="number">1</span>,n)]</span><br><span class="line"></span><br><span class="line">_# <span class="number">3</span>-way partition_</span><br><span class="line">i = <span class="number">1</span>, k = <span class="number">1</span>, p = n</span><br><span class="line"><span class="keyword">while</span> i &lt; p,</span><br><span class="line">  <span class="keyword">if</span> a[i] &lt; a[n], swap a[i++,k++]</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> a[i] == a[n], swap a[i,--p]</span><br><span class="line">  <span class="keyword">else</span> i++</span><br><span class="line">end</span><br><span class="line">_→ invariant: a[p..n] all equal_</span><br><span class="line">_→ invariant: a[<span class="number">1.</span>.k<span class="number">-1</span>] &lt; a[p..n] &lt; a[k..p<span class="number">-1</span>]_</span><br><span class="line"></span><br><span class="line">_# move pivots to center_</span><br><span class="line">m = min(p-k,n-p+<span class="number">1</span>)</span><br><span class="line">swap a[k..k+m<span class="number">-1</span>,n-m+<span class="number">1.</span>.n]</span><br><span class="line"></span><br><span class="line">_# recursive sorts_</span><br><span class="line">sort a[<span class="number">1.</span>.k<span class="number">-1</span>]</span><br><span class="line">sort a[n-p+k+<span class="number">1</span>,n]</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION-4"><a href="#DISCUSSION-4" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>The 3-way partition variation of quick sort has slightly higher overhead compared to the standard 2-way partition version. Both have the same best, typical, and worst case time bounds, but this version is highly adaptive in the very common case of sorting with few unique keys.</p>
<p>The 3-way partitioning code shown above is written for clarity rather than optimal performance; it exhibits poor locality, and performs more swaps than necessary. A more efficient but more elaborate 3-way partitioning method is given in Quicksort is Optimal by Robert Sedgewick and Jon Bentley.</p>
<p>When stability is not required, quick sort is the general purpose sorting algorithm of choice. Recently, a novel dual-pivot variant of 3-way partitioning has been discovered that beats the single-pivot 3-way partitioning method both in theory and in practice.</p>
<h3 id="PROPERTIES-4"><a href="#PROPERTIES-4" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Not stable</li>
<li>O(lg(n)) extra space</li>
<li>O(n2) time, but typically O(n·lg(n)) time</li>
<li>Adaptive: O(n) time when O(1) unique keys</li>
</ul>
<h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h2><h3 id="ALGORITHM-5"><a href="#ALGORITHM-5" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>:n<span class="number">-1</span>,</span><br><span class="line">    min = i</span><br><span class="line">    <span class="keyword">for</span> j = i+<span class="number">1</span>:n<span class="number">-1</span>, </span><br><span class="line">        <span class="keyword">if</span> a[min] &gt; a[j], min = j</span><br><span class="line">    → invariant: a[min] smallest of a[i..n<span class="number">-1</span>]</span><br><span class="line">    swap a[i,min]</span><br><span class="line">    → invariant: a[<span class="number">0.</span>.i] in final position</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 每一趟可以选择最小的放到最前面,也可以选最大的放最后面. k使用存放临时极小值(极大值). 最后一趟比完才最后确定.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">选择排序 </span></span><br><span class="line"><span class="comment">基本思想：首先，选出最小的数放在第一位，然后选择第二小的数，放在第二位；以此类推，直到所有的数从小到大排列. </span></span><br><span class="line"><span class="comment">那么，对于大小为N的数组需要N-1轮选择过程。第i轮选取第i小的数，请将其放在第i个位置上。</span></span><br><span class="line"><span class="comment">不稳定 </span></span><br><span class="line"><span class="comment">平均时间复杂度O（N^2）</span></span><br><span class="line"><span class="comment">最好情况O（N^2）</span></span><br><span class="line"><span class="comment">最坏情况O（N^2）</span></span><br><span class="line"><span class="comment">空间复杂度O（1）</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n<span class="number">-1</span><span class="number">-1</span>; i++)&#123;<span class="comment">//进行n-1轮选择,也就是i的取值为[0，n-2] </span></span><br><span class="line">        <span class="keyword">int</span> min_index = i;</span><br><span class="line">        <span class="comment">//记录第i小的数所在的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[min_index] &gt; a[j]) <span class="comment">//有点谐</span></span><br><span class="line">                min_index = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != min_index)&#123;<span class="comment">//根据记录的第i小的数的索引，找到了第i小的数。然后将该数放到其正确位置。也就是第i个位置。</span></span><br><span class="line">            swap(a[i] , a[min_index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[min])</span><br><span class="line">                min=j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[i], a[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION-5"><a href="#DISCUSSION-5" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>从比较结果来看, 最好不要用selection sort <strong>should never be used</strong>. It does not adapt to the data in any way (notice that the four animations above run in lock step), 运行时间一直是平方项(quadratic).</p>
<p>但是有一个优点 selection sort 可以减少交换项数目. 可以应用于交换项cost很大的的情况.</p>
<h3 id="PROPERTIES-5"><a href="#PROPERTIES-5" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Not stable</li>
<li>O(1) extra space</li>
<li>Θ(n2) comparisons</li>
<li>Θ(n) swaps</li>
<li>Not adaptive</li>
</ul>
<h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><h3 id="ALGORITHM-6"><a href="#ALGORITHM-6" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># heapify</span></span><br><span class="line"><span class="keyword">for</span> i = n/<span class="number">2</span>:<span class="number">1</span>, sink(a,i,n)</span><br><span class="line">→ invariant: a[<span class="number">1</span>,n] in heap order</span><br><span class="line"></span><br><span class="line"># sortdown</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>:n,</span><br><span class="line">    swap a[<span class="number">1</span>,n-i+<span class="number">1</span>]</span><br><span class="line">    sink(a,<span class="number">1</span>,n-i)</span><br><span class="line">    → invariant: a[n-i+<span class="number">1</span>,n] in final position</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># sink from i in a[<span class="number">1.</span>.n]</span><br><span class="line">function sink(a,i,n):</span><br><span class="line">    # &#123;lc,rc,mc&#125; = &#123;left,right,max&#125; child index</span><br><span class="line">    lc = <span class="number">2</span>*i</span><br><span class="line">    <span class="keyword">if</span> lc &gt; n, <span class="keyword">return</span> # no children</span><br><span class="line">    rc = lc + <span class="number">1</span></span><br><span class="line">    mc = (rc &gt; n) ? lc : (a[lc] &gt; a[rc]) ? lc : rc</span><br><span class="line">    <span class="keyword">if</span> a[i] &gt;= a[mc], <span class="keyword">return</span> # heap ordered</span><br><span class="line">    swap a[i,mc]</span><br><span class="line">    sink(a,mc,n)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>完全二叉, 用的是数组,首先是建堆,然后再排序.<br>建堆(heapify)中确定大顶堆还是小顶堆. 从最后一个非叶子节点(n/2)开始比较,往上比较.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序:树形选择排序，将带排序记录看成完整的二叉树，第一步：建立初堆，第二步：调整堆</span></span><br><span class="line"><span class="comment">//第二步：调整堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span>  <span class="comment">//但习惯上用大顶堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调整为小根堆，从小到大</span></span><br><span class="line">    <span class="keyword">int</span> rc=a[s];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*s;j&lt;=n;j*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;n &amp;&amp; a[j]&gt;a[j+<span class="number">1</span>])<span class="comment">//判断左右子数大小,找小的</span></span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span>(rc&lt;=a[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        a[s]=a[j]; <span class="comment">//小的放上去</span></span><br><span class="line">        s=j;</span><br><span class="line">    &#125;</span><br><span class="line">    a[s]=rc;    <span class="comment">//大的放下来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一步：建初堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatHeap</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//小根堆,从最后一个非叶子节点开始,根是1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        HeapAdjust(a,i,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CreatHeap(a,n);<span class="comment">//第一步，建立初堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=a[<span class="number">1</span>];<span class="comment">//堆顶与最后一个元素互换</span></span><br><span class="line">        a[<span class="number">1</span>]=a[i];</span><br><span class="line">        a[i]=x;</span><br><span class="line">        HeapAdjust(a,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> *a=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)<span class="comment">//注意：这里是从1开始的</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[j];</span><br><span class="line">    HeapSort(a,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i];</span><br><span class="line">    <span class="keyword">delete</span> []a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//　　创建大堆顶，i为当节点，n为堆的大小</span></span><br><span class="line"><span class="comment">//    从第一个非叶子结点i从下至上，从右至左调整结构</span></span><br><span class="line"><span class="comment">//    从两个儿子节点中选出较大的来与父亲节点进行比较</span></span><br><span class="line"><span class="comment">//    如果儿子节点比父亲节点大，则进行交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatHeap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span>  n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    注意数组是从0开始计数，所以左节点为2*i+1，右节点为2*i+2</span></span><br><span class="line">    <span class="comment">// 这里改了吧 应该从1开始好</span></span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left = i * <span class="number">2</span> + <span class="number">1</span>;    <span class="comment">//左子树节点</span></span><br><span class="line">        <span class="keyword">int</span> right = i * <span class="number">2</span> + <span class="number">2</span>;    <span class="comment">//右子树节点</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//选出左右子节点中最大的</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n) &#123;</span><br><span class="line">            a[left] &gt; a[right] ? j= left : j = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = left;</span><br><span class="line">        <span class="comment">//交换子节点与父节点</span></span><br><span class="line">        <span class="keyword">if</span> (a[j] &gt; a[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    进行堆排序，依次选出最大值放到最后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//初始化构造堆</span></span><br><span class="line">    CreatHeap(a, n/<span class="number">2</span><span class="number">-1</span>, n);</span><br><span class="line">　　<span class="comment">//交换第一个元素和最后一个元素后，堆的大小减1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后一个元素和第一个元素进行交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = j / <span class="number">2</span> - <span class="number">1</span>;  <span class="comment">//有必要-1么</span></span><br><span class="line">        CreatHeap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">10</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">14</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    HeapSort(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"排序好的数组为："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[l]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span>  <span class="comment">//但习惯上用大顶堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调整为大根堆，</span></span><br><span class="line">    <span class="keyword">int</span> rc = a[s];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>*s; j &lt;= n; j*=<span class="number">2</span>) <span class="comment">// 有左子树,</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span> (j+<span class="number">1</span> &lt;= n ) &#123;	<span class="comment">//如果右子树存在</span></span><br><span class="line">			<span class="keyword">if</span>(a[j] &lt; a[j+<span class="number">1</span>])<span class="comment">//判断左右子数大小</span></span><br><span class="line">				j++;			</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(rc &gt;= a[j]) &#123;  <span class="comment">//根和左子树比</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;    </span><br><span class="line">        a[s] = a[j]; <span class="comment">//大的放上去</span></span><br><span class="line">        s = j;		<span class="comment">// 继续往大的子树的子树找,保证当前堆是大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    a[s] = rc;    <span class="comment">//小的放下来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一步：建初堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatHeap</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//小根堆,从最后一个非叶子节点开始,根是1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        HeapAdjust(a,i,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CreatHeap(a,n);<span class="comment">//第一步，建立初堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">2</span>; i--)  <span class="comment">//这里从n-1到2就可以了</span></span><br><span class="line">    &#123;</span><br><span class="line">		swap(a[<span class="number">1</span>], a[i]);</span><br><span class="line">        HeapAdjust(a,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION-6"><a href="#DISCUSSION-6" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>Heap sort is simple to implement, performs an O(n·lg(n)) in-place sort, but is not stable.</p>
<p>The first loop, the Θ(n) “heapify” phase, puts the array into heap order. The second loop, the O(n·lg(n)) “sortdown” phase, repeatedly extracts the maximum and restores heap order.</p>
<p>The sink function is written recursively for clarity. Thus, as shown, the code requires Θ(lg(n)) space for the recursive call stack. However, the tail recursion in sink() is easily converted to iteration, which yields the O(1) space bound.</p>
<p>Both phases are slightly adaptive, though not in any particularly useful manner. In the nearly sorted case, the heapify phase destroys the original order. In the reversed case, the heapify phase is as fast as possible since the array starts in heap order, but then the sortdown phase is typical. In the few unique keys case, there is some speedup but not as much as in shell sort or 3-way quicksort.</p>
<h3 id="PROPERTIES-6"><a href="#PROPERTIES-6" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Not stable</li>
<li>O(1) extra space (see discussion)</li>
<li>O(n·lg(n)) time</li>
<li>Not really adaptive</li>
</ul>
<h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><h3 id="ALGORITHM-7"><a href="#ALGORITHM-7" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># split in half</span></span><br><span class="line">m = n / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"># recursive sorts</span><br><span class="line">sort a[<span class="number">1.</span>.m]</span><br><span class="line">sort a[m+<span class="number">1.</span>.n]</span><br><span class="line"></span><br><span class="line"># merge sorted sub-arrays <span class="keyword">using</span> temp <span class="built_in">array</span></span><br><span class="line">b = copy of a[<span class="number">1.</span>.m]</span><br><span class="line">i = <span class="number">1</span>, j = m+<span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= m <span class="keyword">and</span> j &lt;= n,</span><br><span class="line">    a[k++] = (a[j] &lt; b[i]) ? a[j++] : b[i++]</span><br><span class="line">    → invariant: a[<span class="number">1.</span>.k] in final position</span><br><span class="line"><span class="keyword">while</span> i &lt;= m,</span><br><span class="line">    a[k++] = b[i++]</span><br><span class="line">    → invariant: a[<span class="number">1.</span>.k] in final position</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">6、归并排序： </span></span><br><span class="line"><span class="comment">基本思想：将待排序序列【0，n-1】看成是n个长度为1的有序序列，将相邻的有序表成对归并，得到n/2个长度为2的有序表。再次归并，得到n/4个长度为4的有序表。 </span></span><br><span class="line"><span class="comment">依次类推，最后得到长度为n的1个有序表。 </span></span><br><span class="line"><span class="comment">所以归并排序其实要做两件事： </span></span><br><span class="line"><span class="comment">1、先递归的分解数列， </span></span><br><span class="line"><span class="comment">2、再合并数列就完成了归并排序。 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">先来考虑如何合并？ </span></span><br><span class="line"><span class="comment">每次合并过程中都要对两个有序的序列段进行合并，然后排序 </span></span><br><span class="line"><span class="comment">待合并的两个有序序列段分别为 R[low, mid] 和 R[mid+1, high] </span></span><br><span class="line"><span class="comment">先将它们合并到一个暂存数组R2，合并完再将R2复制回R1中。 </span></span><br><span class="line"><span class="comment">这样一次合并排序就完成了。 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">最好、最坏和平均时间复杂度都是O(nlogn)， </span></span><br><span class="line"><span class="comment">空间复杂度是O(n) </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low ,<span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> tmp[];</span><br><span class="line">    <span class="keyword">int</span> i,j,k;  </span><br><span class="line">    i = low;  <span class="comment">//i 和 j是临时会动的 所以新定义一个变量</span></span><br><span class="line">    j = mid + <span class="number">1</span>;</span><br><span class="line">    k = <span class="number">0</span>;<span class="comment">//k是存放临时合并数组的下表</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>( i &lt;= mid &amp;&amp; j &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">if</span>( a[i] &lt; a[j])  <span class="comment">// 小的元素放tmp</span></span><br><span class="line">            tmp[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( i &lt;= mid)</span><br><span class="line">        tmp[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>( j &lt;= high)</span><br><span class="line">        tmp[k++] = a[i++];</span><br><span class="line">    <span class="comment">//最后再复制回a</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i++ )</span><br><span class="line">        a[low+i] = tmp[i];<span class="comment">//!!!!此处a是从low开始，tmp是从0开始。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上完整程序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span> <span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    sort (a, <span class="number">0</span>, a.length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span> <span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right) / <span class="number">2</span>;  <span class="comment">// (right - left)/2 + left</span></span><br><span class="line">    sort (a, left, mid);</span><br><span class="line">    sort (a, mid+<span class="number">1</span>, right);</span><br><span class="line">    merge (a, left, mid, right);</span><br><span class="line">    print(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//改进 还有换一种自底向上的</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。</span><br><span class="line">首先考虑下如何将<span class="number">2</span>个有序数列合并。这个非常简单，只要从比较<span class="number">2</span>个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。</span><br><span class="line"></span><br><span class="line"><span class="comment">//将有序数组a[]和b[]合并到c[]中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemeryArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> b[], <span class="keyword">int</span> m, <span class="keyword">int</span> c[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line"> i = j = k = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (a[i] &lt; b[j])</span><br><span class="line">         c[k++] = a[i++];</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         c[k++] = b[j++]; </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (i &lt; n)</span><br><span class="line">     c[k++] = a[i++];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (j &lt; m)</span><br><span class="line">     c[k++] = b[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION-7"><a href="#DISCUSSION-7" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>Merge sort is very <strong>predictable</strong>. It makes between 0.5lg(n) and lg(n) comparisons per element, and between lg(n) and 1.5lg(n) swaps per element. The minima are achieved for already sorted data; the maxima are achieved, on average, for random data. If using Θ(n) extra space is of no concern, then merge sort is <strong>an excellent choice</strong>: It is simple to implement, and it is the only stable O(n·lg(n)) sorting algorithm. Note that when sorting linked lists, merge sort requires only Θ(lg(n)) extra space (for recursion).</p>
<p>Merge sort is the algorithm of choice for a variety of situations: <strong>when stability is required, when sorting linked lists, and when random access is much more expensive than sequential access</strong> (for example, external sorting on tape).</p>
<p>There do exist linear time in-place merge algorithms for the last step of the algorithm, but they are both expensive and complex. The complexity is justified for applications such as external sorting when Θ(n) extra space is not available.</p>
<h3 id="PROPERTIES-7"><a href="#PROPERTIES-7" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Stable</li>
<li>Θ(n) extra space for arrays (as shown)</li>
<li>Θ(lg(n)) extra space for linked lists</li>
<li>Θ(n·lg(n)) time</li>
<li>Not adaptive</li>
<li>Does not require random access to data</li>
</ul>
<hr>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h1 id="树中"><a href="#树中" class="headerlink" title="树中"></a>树中</h1><h2 id="堆说过了"><a href="#堆说过了" class="headerlink" title="堆说过了"></a>堆说过了</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/17/HaiKu-OS/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/17/HaiKu-OS/" itemprop="url">HaiKu_OS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-17T23:17:00+08:00">2018-03-17</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/多媒体/" itemprop="url" rel="index"><span itemprop="name">多媒体</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatarMogu.jpg" alt="Henry x">
            
              <p class="site-author-name" itemprop="name">Henry x</p>
              <p class="site-description motion-element" itemprop="description">this is description</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">133</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">135</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="weibo" target="_blank">weibo</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Henry x</span>

  

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.1"></script>



  



	





  





  










  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  

</body>
</html>
