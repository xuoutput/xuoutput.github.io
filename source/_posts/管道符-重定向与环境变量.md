---
title: '管道符,重定向与环境变量'
date: 2018-04-22 09:53:42
tags:
- ubuntu
- linux
categories:
- linux
comments: false
permalink:
---

* 输入输出重定向
    1. < << Delimiter
    2. \> \>\>追加 
    3. 2> 2>> 
    4. $>>
* 管道命令符
    1. |
* 命令行的通配符
    1. \*
    2. ?
    3. [0-9]
* 常用哦转义字符
    1. \
    2. ''
    3. ""
    4. ``
* 重要的环境变量
    1. 判断用户是否以**绝对路径或相对路径**的方式输入命令
    2. Linux系统检查用户输入的命令是否为“**别名命令**”
    3. Bash解释器判断用户输入的是**内部命令还是外部命令**
    4. 系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫作**PATH**



# 管道符,重定向与环境变量

目前为止，我们已经学习了数十个常用的Linux系统命令，如果不能把这些命令进行**组合使用**，则无法提升工作效率。本章首先讲解与文件读写操作有关的重定向技术的**5种模式**:
1. 标准覆盖输出重定向
2. 标准追加输出重定向
3. 错误覆盖输出重定向
4. 错误追加输出重定向
5. 输入重定向，

让读者通过实验切实理解每个重定向模式的作用，解决输出信息的保存问题。**然后深入讲解管道命令符**，帮助读者掌握命令之间的搭配使用方法，进一步提高命令输出值的处理效率。
随后通过讲解Linux系统命令行中的**通配符和常见转义符**，让您输入的Linux命令具有更准确的意义，为下一章学习编写Shell脚本打好功底。
最后，本章深度剖析了Bash解释器执行Linux命令的内部原理，为读者掌握**PATH变量及Linux系统中的重要环境变量**打下了基础。

##  输入输出重定向

既然我们已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的**输入重定向和输出重定向的原理。**

简而言之，**输入重定向**是指把文件导入到命令中，而**输出重定向**则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用**输出重定向的频率更高**，所以又将输出重定向分为了**标准输出重定向和错误输出重定向**两种不同的技术，以及**清空写入与追加**写入两种模式。

> 标准输入重定向（STDIN，文件描述符为0）：默认从键盘输入，也可从其他文件或命令中输入。

> 标准输出重定向（STDOUT，文件描述符为1）：默认输出到屏幕。

> 错误输出重定向（STDERR，文件描述符为2）：默认输出到屏幕。

比如我们**分别查看两个文件的属性信息**，其中第二个文件是不存在的，虽然针对这两个文件的操作都分别会在屏幕上输出一些数据信息，但这两个操作的差异其实很大：

```c
$ touch linuxprobe
$ ls -l linuxprobe 
-rw-r--r--. 1 root root 0 Aug 5 05:35 linuxprobe
$ ls -l xxxxxx
ls: cannot access xxxxxx: No such file or directory
```

在上述命令中，名为linuxprobe的文件是存在的，输出信息是该文件的一些相关权限、所有者、所属组、文件大小及修改时间等信息，这也是该命令的标准输出信息。而名为xxxxxx的第二个文件是不存在的，因此在执行完ls命令之后显示的报错提示信息也是该命令的错误输出信息。那么，要想把原本输出到屏幕上的数据转而写入到文件当中，就要区别对待这两种输出信息。

对于输入重定向来讲，用到的符号及其作用如表

| 符号                 | 作用                                         |
| -------------------- | -------------------------------------------- |
| 命令 < 文件          | 将文件作为命令的标准输入                     |
| 命令 << 分界符       | 从标准输入中读入，直到遇见分界符才停止       |
| 命令 < 文件1 > 文件2 | 将文件1作为命令的标准输入并将标准输出到文件2 |

对于输出重定向来讲，用到的符号及其作用如表

| 符号                               | 作用                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| 命令 > 文件                        | 将标准输出重定向到一个文件中（**清空**原有文件的数据）       |
| 命令 2> 文件                       | 将错误输出重定向到一个文件中（清空原有文件的数据）           |
| 命令 >> 文件                       | 将标准输出重定向到一个文件中（**追加**到原有内容的后面）     |
| 命令 2>> 文件                      | 将错误输出重定向到一个文件中（追加到原有内容的后面）         |
| 命令 >> 文件 2>&1 或 命令 &>> 文件 | 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面） |

对于重定向中的**标准输出**模式，可以省略文件描述符1不写，而**错误输出**模式的文件描述符2是必须要写的。我们先来小试牛刀。通过标准输出重定向将man bash命令原本要输出到屏幕的信息写入到文件readme.txt中，然后显示readme.txt文件中的内容。具体命令如下：

```c
$ man bash > readme.txt
$ cat readme.txt
```

我们接下来尝试输出重定向技术中的**覆盖写入与追加写入**这两种不同模式带来的变化。首先通过覆盖写入模式向readme.txt文件写入一行数据（该文件中包含上一个实验的man命令信息），然后再通过追加写入模式向文件再写入一次数据，其命令如下：

```c
$ echo "Welcome to LinuxProbe.Com" > readme.txt
$ echo "Quality linux learning materials" >> readme.txt
```

虽然都是输出重定向技术，但是不同命令的标准输出和错误输出还是有区别的。例如查看当前目录中某个文件的信息，这里以linuxprobe文件为例。因为这个文件是真实存在的，**因此使用标准输出即可将原本要输出到屏幕的信息写入到文件中，而错误的输出重定向则依然把信息输出到了屏幕上。**

```c
$ ls -l linuxprobe 
-rw-r--r--. 1 root root 0 Mar  1 13:30 linuxprobe
$ ls -l linuxprobe > /root/stderr.txt 
$ ls -l linuxprobe 2> /root/stderr.txt 
-rw-r--r--. 1 root root 0 Mar  1 13:30 linuxprobe  //输出到屏幕
```

**如果想把命令的报错信息写入到文件**，该怎么操作呢？当用户在执行一个自动化的Shell脚本时，这个操作会特别有用，而且特别实用，因为它可以把整个脚本执行过程中的报错信息都记录到文件中，便于安装后的排错工作。接下来我们以一个不存在的文件进行实验演示：

```c
$ ls -l xxxxxx 
cannot access xxxxxx: No such file or directory
$ ls -l xxxxxx > /root/stderr.txt
cannot access xxxxxx: No such file or directory
$ ls -l xxxxxx 2> /root/stderr.txt  //与上面区别,这个如果不报错的情况下,当然输出到屏幕,相当于不执行.但是如果报错,那么用2> 将错误信息写入文件.本来错误信息是输出到屏幕的.
$ cat /root/stderr.txt 
ls: cannot access xxxxxx: No such file or directory
```


输入重定向相对来说有些冷门，在工作中遇到的概率会小一点。输入重定向的作用是把文件直接导入到命令中。接下来使用输入重定向把readme.txt文件导入给wc -l命令，统计一下文件中的内容行数。

```c
$ wc -l < readme.txt
```

> 上述命令实际上等同于接下来要学习的cat readme.txt | wc -l的管道符命令组合。

## 管道命令符

细心的读者肯定还记得在2.6节学习tr命令时曾经见到过一个名为管道符的东西。同时按下键盘上的Shift+\键即可输入管道符`|`，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话来概括“**把前一个命令原本要输出到屏幕的标准正常数据当作是后一个命令的标准输入**”。在2.8节讲解grep文本搜索命令时，我们通过匹配关键词/sbin/nologin找出了所有被限制登录系统的用户。在学完本节内容后，完全可以把下面这两条命令合并为一条：

> 找出被限制登录用户的命令是grep "/sbin/nologin" /etc/passwd；

> 统计文本行数的命令则是wc -l。

现在要做的就是把搜索命令的输出值传递给统计命令，即把原本要输出到屏幕的用户信息列表再交给wc命令作进一步的加工，因此只需要把管道符放到两条命令之间即可，具体如下。这简直是太方便了！

```c
$ grep "/sbin/nologin" /etc/passwd | wc -l
```

这个管道符就像一个法宝，我们可以将它套用到其他不同的命令上，比如**用翻页的形式查看/etc目录中的文件列表及属性信息**（这些内容默认会一股脑儿地显示到屏幕上，根本看不清楚）：

```c
$ ls -l /etc/ | more
total 1400
drwxr-xr-x. 3 root root 97 Jul 10 17:26 abrt
-rw-r--r--. 1 root root 16 Jul 10 17:36 adjtime
-rw-r--r--. 1 root root 1518 Jun 7 2013 aliases
-rw-r--r--. 1 root root 12288 Jul 10 09:38 aliases.db
--More--
```

在修改用户密码时，通常都需要**输入两次密码以进行确认**，这在编写自动化脚本时将成为一个非常致命的缺陷。通过把管道符和passwd命令的--stdin参数相结合，我们可以用一条命令来完成密码重置操作：

```c
$ echo "linuxprobe" | passwd --stdin root
Changing password for user root.
passwd: all authentication tokens updated successfully.
```

大家是不是觉得管道符命令有些相见恨晚？管道符的玩法还有很多，比如，在发送电子邮件时，默认采用交互式的方式来进行，我们完全可以利用一条结合了管道符的命令语句，**把编辑好的内容与标题一起“打包”**，最终用这一条命令实现邮件的发送。


```c
$ echo "Content" | mail -s "Subject" linuxprobe
$ su - linuxprobe
Last login: Fri Jul 10 09:44:07 CST 2017 on :0
$ mail
Heirloom Mail version 12.5 7/5/10. Type ? for help.
"/var/spool/mail/linuxprobe": 1 message 1 new
>N 1 root Sun Aug 30 17:33 18/578 "Subject"
```

如果读者是一名Linux新手，可能会觉得上面的命令组合已经十分复杂了，但是有过运维经验的读者又会感觉如隔靴挠痒般不过瘾，他们希望能将这样方便的命令写得更高级一些，功能更强大一些。比如通过重定向技术能够一次性地把多行信息打包输入或输出，让日常工作更有效率。


下面这条自造的命令就结合使用了**mail邮件命令与输入重定向的分界符**，其目的是让用户一直输入内容，直到用户输入了其自定义的分界符时，才结束输入。

```c
$ mail -s "Readme" root@linuxprobe.com << over
> I think linux is very practical
> I hope to learn more
> can you teach me ?
> over
$
```

当然，大家千万不要误以为管道命令符只能在一个命令组合中使用一次，我们完全可以这样使用：“命令A | 命令B | 命令C”。

## 命令行的通配符

大家可能都遇到过提笔忘字的尴尬，作为Linux运维人员，我们有时候也会遇到明明一个文件的名称就在嘴边但就是想不起来的情况。如果就记得一个文件的开头几个字母，想遍历查找出所有以这个关键词开头的文件，该怎么操作呢？又比如，假设想要批量查看所有硬盘文件的相关权限属性，一种方式是这样的：

```c
$ ls -l /dev/sda
brw-rw----. 1 root disk 8, 0 May 4 15:55 /dev/sda
$ ls -l /dev/sda1
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1
$ ls -l /dev/sda2
brw-rw----. 1 root disk 8, 2 May 4 15:55 /dev/sda2
$ ls -l /dev/sda3
ls: cannot access /dev/sda3: No such file or directory
```

幸亏我的硬盘文件和分区只有3个，要是有几百个，估计需要花费一天的时间来忙这个事情了。由此可见，这种方式的效率确实很低。虽然我们在第6章才会讲解Linux系统的存储结构和FHS，但现在我们应该能看出一些简单规律了。比如，这些硬盘设备文件**都是以sda开头并且存放到了/dev目录中**，这样一来，即使我们不知道硬盘的分区编号和具体分区的个数，也可以使用通配符来搞定。
顾名思义，通配符就是通用的匹配信息的符号，比如星号（`*`）代表匹配零个或多个字符，问号（`?`）代表匹配单个字符，中括号内加上数字`[0-9]`代表匹配0～9之间的单个数字的字符，而中括号内加上字母`[abc]`则是代表匹配a、b、c三个字符中的任意一个字符。俗话讲“百闻不如一见，看书不如实验”，下面我们就来匹配所有在/dev目录中且以sda开头的文件：


```c
$ ls -l /dev/sda*
brw-rw----. 1 root disk 8, 0 May 4 15:55 /dev/sda
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1
brw-rw----. 1 root disk 8, 2 May 4 15:55 /dev/sda2
```

如果只想查看文件名为sda开头，但是后面还紧跟其他某一个字符的文件的相关信息，该怎么操作呢？这时就需要用到问号来进行通配了。

```c
$ ls -l /dev/sda?
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1
brw-rw----. 1 root disk 8, 2 May 4 15:55 /dev/sda2

```

除了使用[0-9]来匹配0~9之间的单个数字，也可以用[135]这样的方式仅匹配这三个指定数字中的一个，若没有匹配到，则不会显示出来：

```c
$ ls -l /dev/sda[0-9]
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1
brw-rw----. 1 root disk 8, 2 May 4 15:55 /dev/sda2
$ ls -l /dev/sda[135]
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1
```

## 常用的转义字符

为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。从数十个转义字符中提炼出了**4个**最常用的转义字符！

4个最常用的转义字符如下所示。

> 反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。
> 
> 单引号（''）：转义其中所有的变量为单纯的字符串。
> 
> 双引号（""）：保留其中的变量属性，不进行转义处理。
> 
> 反引号（``）：把其中的命令执行后返回结果。

我们先定义一个名为PRICE的变量并赋值为5，然后输出以双引号括起来的字符串与变量信息：

```c
$ PRICE=5
$ echo "Price is $PRICE"
Price is 5
```

接下来，我们希望能够输出“Price is $5”，即价格是5美元的字符串内容，但碰巧美元符号与变量提取符号合并后的**$$作用是显示当前程序的进程ID号**码，于是命令执行后输出的内容并不是我们所预期的：

```c
$ echo "Price is $$PRICE" 
Price is 3767PRICE
```

要想让**第一个“$”**乖乖地作为美元符号，那么就需要使用反斜杠（`\`）来进行转义，将这个命令提取符转义成单纯的文本，去除其特殊功能。

```c
$ echo "Price is \$$PRICE"
Price is $5
```

而如果只需要某个命令的输出值时，可以像`命令`这样，将命令用**反引号**括起来，达到预期的效果。例如，将反引号与uname -a命令结合，然后使用echo命令来查看本机的Linux版本和内核信息：

```c
$ echo `uname -a`  //很像es6,毕竟es6就是这么发展过来的
Linux linuxprobe.com 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2017 x86_64 x86_64 x86_64 GNU/Linux
```

## 重要的环境变量

变量是计算机系统用于保存可变值的数据类型。在Linux系统中，**变量名称一般都是大写的**，这是一种约定俗成的规范。我们可以直接通过变量名称来提取到对应的变量值。Linux系统中的环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。

前文中曾经讲到，在Linux系统中一切都是文件，Linux命令也不例外。那么，在用户**执行了一条命令之后**，Linux系统中到底发生了什么事情呢？简单来说，命令在Linux中的执行分为**4个**步骤。

**第1步：**判断用户是否以**绝对路径或相对路径**的方式输入命令（如/bin/ls），如果是的话则直接执行。

**第2步：**Linux系统检查用户输入的命令是否为“**别名命令**”，即用一个自定义的命令名称来替换原本的命令名称。可以用`alias`命令来创建一个属于自己的命令别名，格式为“alias 别名=命令”。若要取消一个命令别名，则是用unalias命令，格式为“unalias 别名”。我们之前在使用rm命令删除文件时，Linux系统都会要求我们再确认是否执行删除操作，其实这就是Linux系统为了防止用户误删除文件而特意设置的rm别名命令，接下来我们把它取消掉：

```c
$ ls
anaconda-ks.cfg Documents initial-setup-ks.cfg Pictures Templates
Desktop Downloads Music Public Videos
$ rm anaconda-ks.cfg 
rm: remove regular file ‘anaconda-ks.cfg’? y
[root@linuxprobe~]# alias rm
alias rm='rm -i'
$ unalias rm
$ rm initial-setup-ks.cfg 
$
```

**第3步：**Bash解释器判断用户输入的是**内部命令还是外部命令**。内部命令是解释器内部的指令，会被直接执行；而用户在绝大部分时间输入的是外部命令，这些命令交由步骤4继续处理。可以使用“`type命令名称`”来判断用户输入的命令是内部命令还是外部命令。

**第4步：**系统在多个路径中查找用户输入的命令文件，而**定义这些路径的变量叫作PATH**，可以简单地把它理解成是“解释器的小助手”，作用是告诉Bash解释器待执行的命令可能存放的位置，然后Bash解释器就会乖乖地在这些位置中逐个查找。PATH是由多个路径值组成的变量，每个路径值之间用**冒号间隔**，对这些路径的增加和删除操作将影响到Bash解释器对Linux命令的查找。

```c
$ echo $PATH
/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin
$ PATH=$PATH:/root/bin
$ echo $PATH
/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/root/bin
```

这里有比较经典的问题：“**为什么不能将当前目录（.）添加到PATH中呢?** ” 原因是，尽管可以将当前目录（.）添加到PATH变量中，从而在某些情况下可以让用户免去输入命令所在路径的麻烦。但是，如果黑客在比较常用的公共目录/tmp中存放了一个与ls或cd命令同名的木马文件，而用户又恰巧在公共目录中执行了这些命令，那么就极有可能中招了。

所以，作为一名态度谨慎、有经验的运维人员，在接手了一台Linux系统后一定会在执行命令前先检查PATH变量中是否有可疑的目录，另外读者从前面的PATH变量示例中是否也感觉到环境变量特别有用呢。我们可以使用env命令来查看到Linux系统中所有的环境变量，而刘遄老师为您精挑细选出了最重要的10个环境变量，

| 变量名称     | 作用                             |
| ------------ | -------------------------------- |
| HOME         | 用户的主目录（即家目录）         |
| SHELL        | 用户在使用的Shell解释器名称      |
| HISTSIZE     | 输出的历史命令记录条数           |
| HISTFILESIZE | 保存的历史命令记录条数           |
| MAIL         | 邮件保存路径                     |
| LANG         | 系统语言、语系名称               |
| RANDOM       | 生成一个随机数字                 |
| PS1          | Bash解释器的提示符               |
| PATH         | 定义解释器搜索用户执行命令的路径 |
| EDITOR       | 用户默认的文本编辑器             |

Linux作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，**一个相同的变量会因为用户身份的不同而具有不同的值**。例如，我们使用下述命令来查看HOME变量在不同用户身份下都有哪些值（su是用于切换用户身份的命令，将在第5章跟大家见面）：

```c
$ echo $HOME
/root
$ su - linuxprobe
Last login: Fri Feb 27 19:49:57 CST 2017 on pts/0
$ echo $HOME
/home/linuxprobe
```

其实**变量是由固定的变量名与用户或系统设置的变量值两部分组成**的，我们完全可以自行创建变量，来满足工作需求。例如设置一个名称为WORKDIR的变量，方便用户更轻松地进入一个层次较深的目录：

```c
$ mkdir /home/workdir
$ WORKDIR=/home/workdir
$ cd $WORKDIR 
$ pwd
/home/workdir
```

但是，这样的变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，可以使用`export命令将其提升为全局变量`，这样其他用户也就可以使用它了：

```c
[root@linuxprobe workdir]# su linuxprobe
Last login: Fri Mar 20 20:52:10 CST 2017 on pts/0
[linuxprobe@linuxprobe ~]$ cd $WORKDIR
[linuxprobe@linuxprobe ~]$ echo $WORKDIR
[linuxprobe@linuxprobe ~]$ exit
[root@linuxprobe ~]# export WORKDIR
[root@linuxprobe ~]# su linuxprobe
Last login: Fri Mar 20 21:52:10 CST 2017 on pts/0
[linuxprobe@linuxprobe ~]$ cd $WORKDIR
[linuxprobe@linuxprobe workdir]$ pwd
/home/workdir
```