---
title: js事件处理
date: 2018-12-28 17:35:51
tags:
- javascript
- 事件处理
categories:
- javascript教程
comments: false
permalink:
---

# js事件处理

客户端js程序采用了异步事件驱动编程模型(有介绍, 搞个链接). 在这种程序设计风格下, 当文档, 浏览器, 元素或**与之相关的对象**发生某些有趣的事情时, web浏览器就会产生事件(`event`).

例如: 当web浏览器加载完文档, 用户把鼠标指针移到超链接上或敲击键盘时, web浏览器都会产生事件. 如果js应用程序关注特定类型的事件, 那么他可以注册当这类事件发生时要调用的一个或多个函数.

> 注意: 这种风格并不止应用于web编程, 所有使用图形用户界面的应用程序都采用了它, 他们静待某些事情发生(即, 它们等待事件发生), 然后它们响应.

事件就是web浏览器通知应用程序发生了什么事情. 事件不是js对象, 不会出现在程序源代码中. 当然, **会有一些事件相关的对象出现在源代码中**, 他们需要技术说明.

**事件类型(`event type`)**是一个用来说明发生什么类型事件的字符串.
例如: `mousemove`表示用户鼠标移动, `keydown`表示键盘上某个键被按下, 而`load`表示文档(或某个其他资源)从网络上加载完毕.
由于事件类型只是一个字符串, 因此实际上**有时会称之为事件名字**(`event name`), 我们用这个名字来标识所谈论的特定类型的事件.

**事件目标(`event target`)**是发生的**事件**或与之相关的**对象**.当将事件时, 我们必须同时指明类型(`type, name`)和目标(`target`).

例如: `window`上的`load`事件或`<button>`元素的`click`事件. 在客户端的js应用程序中, `Window`, `Document`和`Element`对象是最常见的事件目标, 但某些事件是由其他类型的对象触发.比如`XMLHttpRequest`对象触发的`readystatechange`事件.

**事件处理程序**`event handle`或**事件监听程序**(`event listener`)是处理或响应事件的函数. 应用程序通过指明事件类型`type`和事件目标`target`, 在web浏览器中注册他们的事件处理程序`handle, listener`. 当在特定的目标上发生特定类型的事件时, 浏览器会调用对应的处理程序. 当对象上注册的事件处理程序被调用时, 我们有时会说浏览器"触发"(`fire, trigger`)和"派发"(`dispatch`)了事件. 有很多注册事件处理程序的方法.

**事件对象(`event object`)**是与特定事件相关且包含有关该**事件详细信息的对象**. 事件对象`object`**作为参数**传递给事件处理程序函数`handle`. 所有的事件对象`object`都有用来指定事件类型的`type`属性和指定事件目标的`target`属性. 每个事件类型都为其相关事件对象`object`定义一组属性.
例如: 鼠标事件的相关对象会包含鼠标指针的坐标, 而键盘事件的相关对象会包含按下的键和辅助键的详细信息. 许多事件类型仅定义了像`type`和`target`这样少量的标准属性, 就无法获取许多其他有用的信息.

**事件传播(`event propagation`)**是**浏览器决定哪个对象触**发其事件处理程序的过程. 对于单个对象的特定事件(比如`Window`对象的`load`事件), 必须是不能传播的. 当文档元素上发生某个类型的事件时, 然而, 他们会在文档树上向上传播或"冒泡(`bubble`)", 如果用户移动鼠标指针到超链接上, 在定义这个链接的`<a>`元素上首先会触发`mousemove`事件, 然后是在这个容器元素上触发这个时间, 也许是`<p>`元素,`<div>`元素或`Document`对象本身. 有时, 在`Document`或其他容器元素上注册单个事件处理程序比在每个独立的目标元素上都注册程序要更方便. 事件处理程序能通过调用方法或设置事件对象属性来阻止事件传播, 这样它就能停止冒泡且将无法在容器元素上触发处理程序.

事件传播的另外一种形式称之为**事件捕获(`event capturing`)**, 在容器元素上注册的特定处理程序有机会在事件传播倒真实目标之前拦截(或"捕获")它., 但是,当处理鼠标拖放事件时, 捕获或"夺取"鼠标时间的能力是必须的.

一些事件有与之相关的默认操作. 例如: 当超链接上发生`click`事件时, 浏览器的默认操作是按照链接加载新页面. 事件处理程序可以通过返回一个适当的值, 调用时间对象的某个方法或设置事件对象的某个属性来阻止默认操作的发生. 这有时称为"取消"事件.

## 17.1事件类型

web初期,客户端程序员只能使用很少部分事件,`load`, `click`, `mouseover`, 现在有新事件,3个来源:

* 3级DOM事件(`DOM Level Events`)规范,经过长期的停滞之后, 在W3Cde主持下又开始焕发生机.
* HTML5规范及相关衍生规范的大量新API定义了新事件, 比如历史管理, 拖放, 跨文档通信,以及视频和音频的播放.
* 基于触摸和支持JavaScript的移动设备的出现, 他们需要定义新的触摸和手势事件类型.

**注意**:许多新事件类型尚未广泛实现, 定义它们的标准也依旧处于草案阶段.

事件分类: 大致先分6类吧

**1依赖与设备的输入事件**:
有些事件和特定输入设备直接相关, 比如鼠标和键盘. 包括诸如`mousedown`, `mousemove`,`mouseup`,`keypress`,`keyup`这样传统事件类型, 也包括像`touchmove`,`getsturcchange`这样新的触摸事件类型

**2独立于设备的输入事件**:
有些输入事件没有直接相关的特定输入设备. 比如`click`事件表示激活了链接, 按钮或其他文档元素, 这通常是通过鼠标单击实现, 但也能通过键盘或触控感知设备上的手势来实现. 尚未广泛实现的`textinput`事件就是一个独立与设备的输入事件, 他既能取代按键事件并支持键盘输入, 也可以取代剪切和粘贴与手写识别的事件.

**3用户界面事件**:
用户界面事件是比较高级的事件, 通常出现在定义web应用用户界面的HTML表单元素上. 包括文本输入域获取键盘焦点的`focus`事件, 用户改变表单元素显示值的`change`事件和用户单击表单中的提交按钮的`submit`事件

**4状态变化事件**:
有些事件不是由用户活动而是由网络或浏览器活动触发, 用来表示某种生命周期或相关状态的变化. 当文档完全加载时, 在Window对象上会发生`load`事件, 这可能是这类事件中最常用的, `DOMContentLoaded`事件与此类似, HTML5历史管理机制会触发`popstate`事件来响应浏览器的后退按钮. HTML5离线web应用API包括`online`和`offline`事件. 当向服务器请求的数据准备就绪事, 如何利用`readystatechange`事件得到通知, 类似的, 用于读取用户选择本地文件中的新API使用像`loadstate`, `progress`和`loadend`事件来实现I/O过程的异步通知.

**5特定API事件**:
HTML5及相关规范定义的大量web API都有自己的事件类型. 拖放API定义了诸如`dragstart`, `dragenter`, `dragover`和`drop`事件, 应用程序想自定义拖放源(drag source)或拖放目标(drop target)就必须处理这些相关事件. HTML5的`<video>`和`<audio>`元素定义一长串像`waiting`, `playibg`, `seeking`和`volumechange`等相关事件, 这些事件通常仅用于web应用, 这些web应用希望为视频和音频的播放定义自定义控件.

**6计数器和错误处理程序**:
在第14章中介绍过计时器(`timer`)和错误处理程序(`error handler`)属于客户端JavaScript异步编程模型的部分, 并有相似的事件.

### 17.1.1传统事件类型

处理鼠标, 键盘, HTML表单和window对象的事件都是web应用中最常用的, 他们已经存在很长的时间并得到了广泛的支持.

#### 1.表单事件

回到web和JavaScript的早期, 表单和超链接都是网页中**最早支持脚本的元素**. 这就意味着表单事件是所有事件类型中**最稳定且得到良好支持**的那部分.

* 当提交表单和重置表单时, `<form>`元素会分别触发`submit`和`reset`事件.
* 当用户和类按钮表单元素(包括单选按钮和复选框)交互时, 他们会发生`click`事件.
* 当用户通过输入文字, 选择选项或选择复选框来改变相应表单元素的状态时, 这些通常维护某种状态的表单元素会触发`change`事件.
* 对于文本输入域, 只有用户和表单元素完成交互并通过`Tab`键或单击的方式移动焦点到其他元素上时才会触发`change`事件.响应通过键盘改变焦点的表单元素在得到和失去焦点时会分别触发`focus`和`blur`事件

**15.9.3**节涵盖了所有表单相关事件的详细信息, 不过还有一些进一步说明. 通过事件处理程序能取消`submit`和`reset`事件的默认操作, 某些`click`事件也是如此. `focus`和`blur`事件不会冒泡, 但其他所有表单事件都可以. IE定义了`focusin`和`focusout`事件可以冒泡, 他们可以用于替代`focus`和`blur`事件. jQuery库为不持之`focusin`和`focusout`事件的浏览器模拟了这两个事件, 同时3级DOM事件规范也正在标准化他们.

最后注意, 无论用户何时输入文字(通过键盘或剪切和粘贴)到`<textarea>`和其他文本输入表单元素, 除IE外的浏览器都会触发`input`事件. 不像`change`事件, 每次文字插入都会触发`input`事件. 遗憾的是, `input`事件的事件对象没有指定输入文本的内容 (稍后介绍的`textinput`事件将会成为这个事件的有用替代方案)

#### 2.Window事件

window事件是指事件的发生于**浏览器窗口本身**而非窗口中显示的任何特定文档内容相关. 但是, 这些事件中有一些会和文档元素发生的事件同名.

`load`事件是这些事件中最重要的一个, 当文档和其所有外部资源(比如图片)完全加载并显示给用户时就会触发它. 有关`load`事件的讨论贯穿整个**第13章**. `DOMContentLoaded`和`readystatechange`是`load`事件的替代方案, 当文档和其他元素为操作准备就绪, 但外部资源完全加载完毕之前, 浏览器就会尽在触发他们. 17.4有这些与文档加载相关事件的示例.

`unload`事件和`load`相对, 当用户离开当前文档转向其他文档时会触发它. `unload`事件处理程序可有用于保护用户的状态, 但他不能用于取消用户转向其他地方. `beforeunload`事件和`unload`事件类似, 但他能提供询问用户是否正确离开当前页面的机会. 如果`beforeunload`的处理程序返回字符串, 那么在新页面加载之前, 字符串会出现在展示给用户确认的对话框上, 这样用户就有机会取消其跳转而留在当前页上.

`window`对象的`onerror`属性有点像事件处理程序, 当JavaScript出错时会触发它. 但是, 他不是真正的事件处理程序, 因为他能用不同的参数来调用. 更多详细信息看14.6节

像`<img>`元素这样的单个文档元素也能为`load`和`error`事件注册处理程序. 当外部资源(例如图片)完全家在或发生阻止加载的错误时就会触发它们. 某些浏览器也支持`abort`事件(HTML5将其标准化), 当图片(或其他网络资源)因为用户停止加载进程而导致失败就会触发它.

前面介绍的表单元素的`focus`和`blur`事件也能用做`Window`事件, 当浏览器窗口从操作系统中得到或失去键盘焦点时会触发它们.

最后, 当用户调整浏览器窗口大小或滚动它时会触发`resize`和`scroll`事件.`scroll`事件也能在任何可以滚动的文档元素上触发, 比如那些设置`CSS`的`overflow`属性的元素. 传递给`resize`和`scroll`事件处理程序的事件对象是一个非常普遍的`Event`对象, 他没有制定调整大小或发生滚动的详细信息属性, 但可以通过15.8节介绍的技术来确定新窗口的尺寸和滚动条的位置.

#### 3.鼠标事件

当




