---
title: vim和shell命令脚本
date: 2018-04-23 13:42:14
tags:
- ubuntu
- linux
categories:
- linux
comments: false
permalink:
---

# vim 和 shell 命令脚本

本章首先讲解如何使用`Vim编辑器`来编写、修改文档，然后通过逐个配置主机名称、系统网卡以及 Yum 软件仓库参数文件等实验，帮助读者加深 Vim 编辑器中诸多命令、快捷键、模式切换方法的理解。**然后把前面章节中讲解的 Linux 命令、命令语法与 Shell 脚本中的各种流程控制语句通过 Vim 编辑器写到 Shell 脚本中结合到一起**，实现最终能够自动化工作的脚本文件。本章最后演示了怎样通过 at 命令与 crond 计划任务服务来分别实现一次性的系统任务设置和长期性的系统任务设置，从而让日常的工作更加高效，更自动化。

## Vim 文本编辑器

“在 Linux 系统中一切都是文件，而配置一个服务就是在修改其配置文件的参数”。而且在日常工作中大家也肯定免不了要编写文档，这些工作都是通过文本编辑器来完成的。
Vim 之所以能得到广大厂商与用户的认可，原因在于 Vim 编辑器中设置了**三种模式**—命令模式、末行模式和编辑模式，每种模式分别又支持多种不同的命令快捷键，这大大提高了工作效率，而且用户在习惯之后也会觉得相当顺手。要想高效率地操作文本，就必须先搞清这三种模式的操作区别以及模式之间的切换方法

> 命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。

> 输入模式：正常的文本录入。

> 末行模式：保存或退出文档，以及设置编辑环境。

![vim不同模式间的切换.png](vim不同模式间的切换.png)

在每次运行 Vim 编辑器时，**默认进入命令模式**，此时需要先切换到输入模式后再进行文档编写工作，而每次在编写完文档后需要先返回命令模式，然后再进入末行模式，执行文档的保存或退出操作。在 Vim 中，无法直接从输入模式切换到末行模式。Vim 编辑器中内置的命令有成百上千种用法，为了能够帮助读者更快地掌握 Vim 编辑器，

| 命令 | 作用                                                   |
| ---- | ------------------------------------------------------ |
| dd   | 删除（剪切）光标所在整行                               |
| 5dd  | 删除（剪切）从光标处开始的 5 行 往下删除 5 行          |
| yy   | 复制光标所在整行                                       |
| 5yy  | 复制从光标处开始的 5 行                                |
| n    | 显示搜索命令定位到的下一个字符串                       |
| N    | 显示搜索命令定位到的上一个字符串                       |
| u    | 撤销上一步的操作 那么回去呢?                           |
| p    | 将之前**删除**（dd）或复制（yy）过的数据粘贴到光标后面 |

**末行模式主要用于保存或退出文件**，以及设置 Vim 编辑器的工作环境，还可以让用户执行外部的 Linux 命令或跳转到所编写文档的特定行数。要想切换到末行模式，在命令模式中输入一个冒号就可以了。

| 命令          | 作用                                    |
| ------------- | --------------------------------------- |
| :w            | 保存                                    |
| :q            | 退出                                    |
| :q!           | 强制退出（放弃对文档的修改内容）        |
| :wq!          | 强制保存退出                            |
| :set nu       | 显示行号                                |
| :set nonu     | 不显示行号                              |
| :命令         | 执行该命令                              |
| :整数         | 跳转到该行                              |
| :s/one/two    | 将当前光标所在行的第一个 one 替换成 two |
| :s/one/two/g  | 将当前光标所在行的所有 one 替换成 two   |
| :%s/one/two/g | 将全文中的所有 one 替换成 two           |
| ?字符串       | 在文本中从下至上搜索该字符串            |
| /字符串       | 在文本中从上至下搜索该字符串            |

## 编写简单文档

编写脚本文档的第 1 步就是给文档取个名字，这里将其命名为 practice.txt。如果存在该文档，则是打开它。如果不存在，则是创建一个临时的输入文件，如图所示。

![第1步：创建文档.png](第1步：创建文档.png)

打开 practice.txt 文档后，默认进入的是 Vim 编辑器的**命令模式**。此时只能执行该模式下的命令，而不能随意输入文本内容，我们需要**切换到输入模式**才可以编写文档。

在图 4-1 中提到，可以分别使用`a、i、o`三个键从命令模式切换到输入模式。其中，a 键与 i 键分别是在**光标后面一位**和**光标当前位置**切换到输入模式，而 o 键则是在**光标的下面再创建一个空行**，此时可敲击 a 键进入到编辑器的输入模式.
进入输入模式后，可以随意输入文本内容，Vim 编辑器不会把您输入的文本内容当作命令而执行
在编写完之后，想要保存并退出，必须先敲击键盘 Esc 键从输入模式返回命令模式，如图所示。然后再输入:wq!切换到末行模式才能完成保存退出操作

![第5步：敲击“：wq”，保存并退出.png](第5步：敲击“：wq”，保存并退出.png)

当在末行模式中输入:wq!命令时，就意味着强制保存并退出文档。然后便可以用 cat 命令查看保存后的文档内容了.

是不是很简单？！继续编辑这个文档。因为要在原有文本内容的下面追加内容，所以在命令模式中敲击 o 键进入输入模式更会高效.

因为此时已经修改了文本内容，所以 Vim 编辑器在我们尝试直接退出文档而不保存的时候就会拒绝我们的操作了。此时只能强制退出才可以结束本次输入操作，

大家在学完了理论知识之后又自己动手编写了一个文本，现在是否感觉成就满满呢？接下来将会由浅入深为读者安排三个小任务。为了彻底掌握 Vim 编辑器的使用，大家一定要逐个完成不许偷懒，如果在完成这三个任务期间忘记了相关命令，可返回前文进一步复习掌握。

## 配置主机名称

为了便于在局域网中查找某台特定的主机，或者对主机进行区分，除了要有 IP 地址外，还要为主机配置一个主机名，主机之间可以通过这个类似于域名的名称来相互访问。在 Linux 系统中，主机名大多保存在/etc/hostname 文件中，接下来将/etc/hostname 文件的内容修改为“linuxprobe.com”

> 第 1 步：使用 Vim 编辑器修改“`/etc/hostname`”主机名称文件。

> 第 2 步：把原始主机名称删除后**追加**“linuxprobe.com”。注意，使用 Vim 编辑器修改主机名称文件后，要在末行模式下执行:wq!命令才能保存并退出文档。

> 第 3 步：保存并退出文档，然后使用**hostname**命令检查是否修改成功。

## 配置网卡信息

网卡 IP 地址配置的是否正确是两台服务器是否可以**相互通信的前提**。在 Linux 系统中，一切都是文件，因此配置网络服务的工作其实就是在编辑网卡配置文件，因此这个小任务不仅可以帮助您练习使用 Vim 编辑器，而且也为您后面学习 Linux 中的各种服务配置打下了坚实的基础。当您认真学习完本书后，一定会特别有成就感，因为本书前面的基础部分非常扎实，而后面内容则具有几乎一致的网卡 IP 地址和运行环境，从而确保您全身心地投入到各类服务程序的学习上，而不用操心系统环境的问题。

现在有一个名称为 ifcfg-eno16777736 的网卡设备，我们将其配置为开机自启动，并且 IP 地址、子网、网关等信息由人工指定，其步骤应该如下所示。

**第 1 步：**首先切换到`/etc/sysconfig/network-scripts`目录中（存放着网卡的配置文件）。

**第 2 步：**使用 Vim 编辑器修改网卡文件 ifcfg-eno16777736，逐项写入下面的配置参数并保存退出。由于每台设备的硬件及架构是不一样的，因此请读者使用 ifconfig 命令自行确认各自网卡的默认名称。

> 设备类型：TYPE=Ethernet
>
> 地址分配模式：BOOTPROTO=static
>
> 网卡名称：NAME=eno16777736
>
> 是否启动：ONBOOT=yes
>
> IP 地址：IPADDR=192.168.10.10
>
> 子网掩码：NETMASK=255.255.255.0
>
> 网关地址：GATEWAY=192.168.10.1
>
> DNS 地址：DNS1=192.168.10.1

**第 3 步：**重启网络服务并测试网络是否联通。

进入到网卡配置文件所在的目录，然后编辑网卡配置文件，在其中填入下面的信息：

```c
[root@linuxprobe ~]# cd /etc/sysconfig/network-scripts/
[root@linuxprobe network-scripts]# vim ifcfg-eno16777736
TYPE=Ethernet
BOOTPROTO=static
NAME=eno16777736
ONBOOT=yes
IPADDR=192.168.10.10
NETMASK=255.255.255.0
GATEWAY=192.168.10.1
DNS1=192.168.10.1
```

执行重启网卡设备的命令（在正常情况下不会有提示信息），然后通过 ping 命令测试网络能否联通。由于在 Linux 系统中 ping 命令不会自动终止，因此需要手动按下 Ctrl-c 键来强行结束进程。

```c
[root@linuxprobe network-scripts]# systemctl restart network
[root@linuxprobe network-scripts]# ping 192.168.10.10
PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.
64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.081 ms
64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.083 ms
64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.059 ms
64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.097 ms
^C
--- 192.168.10.10 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 2999ms
rtt min/avg/max/mdev = 0.059/0.080/0.097/0.013 ms
```

## 配置 Yum 仓库

本书前面讲到，Yum 软件仓库的作用是为了进一步简化 RPM 管理软件的难度以及自动分析所需软件包及其依赖关系的技术。可以把 Yum 想象成是一个硕大的软件仓库，里面保存有几乎所有常用的工具，而且只需要说出所需的软件包名称，系统就会自动为您搞定一切。

既然要使用 Yum 软件仓库，就要先把它搭建起来，然后将其配置规则确定好才行。鉴于第 6 章才会讲解 Linux 的存储结构和设备挂载操作，所以我们当前还是将重心放到 Vim 编辑器的学习上。如果遇到看不懂的参数也不要紧，后面章节会单独讲解。搭建并配置 Yum 软件仓库的大致步骤如下所示

## 编写 Shell 脚本

[Linux shell 编程基础，一看就能入门](https://zhuanlan.zhihu.com/p/35465182)

可以将 Shell 终端解释器当作**人与计算机硬件之间**的“翻译官”，它作为用户与 Linux 系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如**循环、分支**等高级编程语言才有的控制结构特性。要想正确使用 Shell 中的这些功能特性，准确下达命令尤为重要。Shell 脚本命令的工作方式有两种：交互式和批处理。

> 交互式（Interactive）：用户每输入一条命令就立即执行。

> 批处理（Batch）：由用户事先编写好一个完整的 Shell 脚本，Shell 会一次性执行脚本中诸多的命令。

在 Shell 脚本中不仅会用到前面学习过的很多 Linux 命令以及**正则表达式、管道符、数据流重定向等语法规则**，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的 Shell 脚本。

查看 SHELL 变量可以发现当前系统已经默认使用 Bash 作为命令行终端解释器了：

```c
$ echo $SHELL
/bin/bash
```

## 编写简单的脚本

估计读者在看完上文中有关 Shell 脚本的复杂描述后，会累觉不爱吧。但是，上文指的是一个高级 Shell 脚本的编写原则，其实使用 Vim 编辑器把 Linux 命令按照顺序依次写入到一个文件中，这就是一个简单的脚本了。

例如，如果想查看当前所在工作路径并列出当前目录下所有的文件及属性信息，实现这个功能的脚本应该类似于下面这样

```c
$ vim example.sh
#!/bin/bash
#For Example BY linuxprobe.com
pwd
ls -al
```

Shell 脚本文件的名称可以任意，**但为了避免被误以为是普通文件**，建议将`.sh`后缀加上，以表示是一个脚本文件。在上面的这个 example.sh 脚本中实际上出现了**三种**不同的元素：
第一行的脚本声明（`#!`）用来告诉系统使用哪种 Shell 解释器来执行该脚本；
第二行的注释信息（`#`）是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的作用或一些警告信息；
第三、四行的可执行语句也就是我们平时执行的 Linux 命令了。什么？！你们不相信这么简单就编写出来了一个脚本程序，那我们来执行一下看看结果：

```c
$ bash example.sh
/root/Desktop
total 8
drwxr-xr-x. 2 root root 23 Jul 23 17:31 .
dr-xr-x---. 14 root root 4096 Jul 23 17:31 ..
-rwxr--r--. 1 root root 55 Jul 23 17:31 example.sh
```

除了上面**用 bash 解释器命令直接运行 Shell 脚本文件外**，第二种运行脚本程序的方法是通过**输入完整路径**的方式来执行。但默认会因为权限不足而提示报错信息，此时只需要为脚本文件**增加执行权限即可**（详见第 5 章）。初次学习 Linux 系统的读者不用心急，等下一章学完用户身份和权限后再来做这个实验也不迟：

```c
[root@linuxprobe ~]# ./example.sh
bash: ./Example.sh: Permission denied
[root@linuxprobe ~]# chmod u+x example.sh
[root@linuxprobe ~]# ./example.sh
/root/Desktop
total 8
drwxr-xr-x. 2 root root 23 Jul 23 17:31 .
dr-xr-x---. 14 root root 4096 Jul 23 17:31 ..
-rwxr--r--. 1 root root 55 Jul 23 17:31 example.sh
```

## 接收用户的参数

但是，像上面这样的脚本程序只能执行一些预先定义好的功能，未免太过死板了。为了让 Shell 脚本程序更好地满足用户的一些实时需求，以便**灵活**完成工作，必须要让脚本程序能够像之前执行命令时那样，接收用户输入的参数。
其实，Linux 系统中的 Shell 脚本语言早就考虑到了这些，已经内设了**用于接收参数的变量**，变量之间可以使用**空格间隔**。例如\$0 对应的是当前 Shell 脚本程序的名称，`$#`对应的是总共有几个参数，`$*`对应的是所有位置的参数值，`$?`对应的是显示上一次命令的执行返回值，而$1、$2、\$3……则分别对应着第 N 个位置的参数值，如图 4-15 所示。

![Shell脚本程序中的参数位置变量.png](Shell脚本程序中的参数位置变量.png)

```c
[root@linuxprobe ~]# vim example.sh
#!/bin/bash
echo "当前脚本名称为$0"
echo "总共有$#个参数，分别是$*。"
echo "第1个参数为$1，第5个为$5。"
[root@linuxprobe ~]# sh example.sh one two three four five six
当前脚本名称为example.sh
总共有6个参数，分别是one two three four five six。
第1个参数为one，第5个为five。
```

## 判断用户的参数

学习是一个登堂入室、由浅入深的过程。在学习完 Linux 命令、掌握 Shell 脚本语法变量和接收用户输入的信息之后，就要踏上新的高度—能够进一步处理接收到的用户参数。

在本书前面章节中讲到，系统在执行 mkdir 命令时会判断用户输入的信息，即判断用户指定的文件夹名称是否已经存在，如果存在则提示报错；反之则自动创建。Shell 脚本中的**条件测试语法**可以判断表达式是否成立，**若条件成立则返回数字 0，否则便返回其他随机数值**。条件测试语法的执行格式如图 4-16 所示。切记，条件表达式两边均应有一个空格。

![测试语句格式.png](测试语句格式.png)

按照测试对象来划分，条件测试语句可以分为 4 种：

> 文件测试语句；
>
> 逻辑测试语句；
>
> 整数值比较语句；
>
> 字符串比较语句。

文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符，具体的参数如表

| 操作符 | 作用                       |
| ------ | -------------------------- |
| -e     | 测试文件是否存在           |
| -f     | 判断是否为一般文件         |
| -d     | 测试文件是否为目录类型     |
| -r     | 测试当前用户是否有权限读取 |
| -w     | 测试当前用户是否有权限写入 |
| -x     | 测试当前用户是否有权限执行 |

下面使用文件测试语句来判断/etc/fstab 是否为一个**目录类型**的文件，然后通过 Shell 解释器的内设\$?变量显示上一条命令执行后的返回值。如果返回值为 0，则目录存在；如果返回值为非零的值，则意味着目录不存在：(2 步)

```c
[root@linuxprobe ~]# [ -d /etc/fstab ]
[root@linuxprobe ~]# echo $?
1
```

再使用文件测试语句来判断/etc/fstab 是否为一般文件，如果返回值为 0，则代表文件存在，且为一般文件：

```c
[root@linuxprobe ~]# [ -f /etc/fstab ]
[root@linuxprobe ~]# echo $?
0
```

**逻辑语句**用于对测试结果进行逻辑分析，根据测试结果可实现不同的效果。例如在 Shell 终端中逻辑“与”的运算符号是`&&`，**它表示当前面的命令执行成功后才会执行它后面的命令**，因此可以用来判断/dev/cdrom 文件是否存在，若存在则输出 Exist 字样。

```c
[root@linuxprobe ~]# [ -e /dev/cdrom ] && echo "Exist"
Exist
```

除了逻辑“与”外，还有逻辑“或”，它在 Linux 系统中的运算符号为`||`，**表示当前面的命令执行失败后才会执行它后面的命令**，因此可以用来结合系统环境变量 USER 来判断当前登录的用户是否为非管理员身份

```c
[root@linuxprobe ~]# echo $USER
root
[root@linuxprobe ~]# [ $USER = root ] || echo "user"
[root@linuxprobe ~]# su - linuxprobe
[linuxprobe@linuxprobe ~]$ [ $USER = root ] || echo "user"
user
```

第三种逻辑语句是“非”，在 Linux 系统中的运算符号是一个叹号（`！`），它表示把条件测试中的判断结果取相反值。也就是说，如果原本测试的结果是正确的，则将其变成错误的；原本测试错误的结果则将其变成正确的。

我们现在切换回到 root 管理员身份，再判断当前用户是否为一个非管理员的用户。由于判断结果因为两次否定而变成正确，因此会正常地输出预设信息：

```c
[linuxprobe@linuxprobe ~]$ exit
logout
[root@linuxprobe root]# [ $USER != root ] || echo "administrator"
administrator
```

当前我们正在登录的即为管理员用户—root。下面这个示例的执行顺序是，先判断当前登录用户的 USER 变量名称是否等于 root，然后用逻辑运算符“非”进行取反操作，效果就变成了判断当前登录的用户是否为非管理员用户了。最后若条件成立则会根据逻辑“与”运算符输出 user 字样；或条件不满足则会通过逻辑“或”运算符输出 root 字样，而如果前面的&&不成立才会执行后面的||符号。

```c
[root@linuxprobe ~]# [ $USER != root ] && echo "user" || echo "root"
root
```

整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且不能想当然地使用日常生活中的**等号、大于号、小于号**等来判断。**因为等号与赋值命令符冲突，大于号和小于号分别与输出重定向命令符和输入重定向命令符冲突**。因此一定要使用规范的整数比较运算符来进行操作。可用的整数比较运算符如表

| 操作符 | 作用           |
| ------ | -------------- |
| -eq    | 是否等于       |
| -ne    | 是否不等于     |
| -gt    | 是否大于       |
| -lt    | 是否小于       |
| -le    | 是否等于或小于 |
| -ge    | 是否大于或等于 |

接下来小试牛刀。我们先测试一下 10 是否大于 10 以及 10 是否等于 10（通过输出的返回值内容来判断）：

```c
[root@linuxprobe ~]# [ 10 -gt 10 ]
[root@linuxprobe ~]# echo $?
1
[root@linuxprobe ~]# [ 10 -eq 10 ]
[root@linuxprobe ~]# echo $?
0
```

在 2.4 节曾经讲过`free`命令，它可以用来获取当前系统正在使用及可用的内存量信息。接下来先使用`free -m`命令查看内存使用量情况（单位为 MB），然后通过`grep Mem`:命令过滤出剩余内存量的行，再用`awk '{print $4}'`命令只保留第四列，最后用`FreeMem=\`语句\``的方式把语句内执行的结果赋值给变量。

这个演示确实有些难度，但看懂后会觉得很有意思，没准在运维工作中也会用得上。

```c
[root@linuxprobe ~]# free -m
            total     used     free     shared     buffers     cached
Mem:        1826      1244     582      9          1           413
-/+ buffers/cache:    830 996
Swap:       2047      0        2047
[root@linuxprobe ~]# free -m | grep Mem:
Mem:        1826      1244     582      9
[root@linuxprobe ~]# free -m | grep Mem: | awk '{print $4}'
582
[root@linuxprobe ~]# FreeMem=`free -m | grep Mem: | awk '{print $4}'`
[root@linuxprobe ~]# echo $FreeMem
582
```

上面用于获取内存可用量的命令以及步骤可能有些“超纲”了，如果不能理解领会也不用担心，接下来才是重点。我们使用整数运算符来判断内存可用量的值是否小于 1024，若小于则会提示“Insufficient Memory”（内存不足）的字样：

```c
[root@linuxprobe ~]# [ $FreeMem -lt 1024 ] && echo "Insufficient Memory"
Insufficient Memory
```

**字符串比较语句用于判断测试字符串是否为空值**，或两个字符串是否相同。它经常用来判断某个变量是否未被定义（即内容为空值），理解起来也比较简单。字符串比较中常见的运算符如表

| 操作符 | 作用                   |
| ------ | ---------------------- |
| =      | 比较字符串内容是否相同 |
| !=     | 比较字符串内容是否不同 |
| -z     | 判断字符串内容是否为空 |

接下来通过判断 String 变量是否为空值，进而判断是否定义了这个变量：

```c
[root@linuxprobe ~]# [ -z $String ]
[root@linuxprobe ~]# echo $?
0
```

再尝试引入逻辑运算符来试一下。当用于保存当前语系的环境变量值 LANG 不是英语（en.US）时，则会满足逻辑测试条件并输出“Not en.US”（非英语）的字样

```c
[root@linuxprobe ~]# echo $LANG
en_US.UTF-8
[root@linuxprobe ~]# [ $LANG != "en.US" ] && echo "Not en.US"
Not en.US
```

## 流程控制语句

尽管此时可以通过使用 Linux 命令、管道符、重定向以及条件测试语句来编写最基本的 Shell 脚本，但是这种脚本并不适用于生产环境。原因是它不能根据真实的工作需求来调整具体的执行命令，也不能根据某些条件实现自动循环执行。例如，我们需要批量创建 1000 位用户，首先要判断这些用户是否已经存在；若不存在，则通过循环语句让脚本自动且依次创建他们。

接下来我们通过`if、for、while、case`这 4 种流程控制语句来学习编写难度更大、功能更强的 Shell 脚本。为了保证下文的实用性和趣味性，做到寓教于乐，我会尽可能多地讲解各种不同功能的 Shell 脚本示例，而不是逮住一个脚本不放，在它原有内容的基础上修修补补。尽管这种修补式的示例教学也可以让读者明白理论知识，但是却无法开放思路，不利于日后的工作

### if 条件测试语句

if 条件测试语句可以让脚本根据实际情况自动执行相应的命令。从技术角度来讲，if 语句分为**单分支结构、双分支结构、多分支结构**；其复杂度随着灵活度一起逐级上升。

if 条件语句的单分支结构由`if、then、fi`关键词组成，而且只在条件成立后才执行预设的命令，相当于口语的“如果……那么……”。单分支的 if 语句属于最简单的一种条件判断结构，语法格式如图

![单分支结构-2.png](单分支结构-2.png)

下面使用单分支的 if 条件语句来判断/media/cdrom 文件是否存在，若存在就结束条件判断和整个 Shell 脚本，反之则去创建这个目录：

```c
[root@linuxprobe ~]# vim mkcdrom.sh
#!/bin/bash
DIR="/media/cdrom"
if [ ! -e $DIR ]
then
mkdir -p $DIR
fi
```

由于第 5 章才讲解用户身份与权限，因此这里继续用“bash 脚本名称”的方式来执行脚本。在正常情况下，顺利执行完脚本文件后没有任何输出信息，但是可以使用`ls命令验证/media/cdrom`目录是否已经成功创建：

```c
[root@linuxprobe ~]# bash mkcdrom.sh
[root@linuxprobe ~]# ls -d /media/cdrom
/media/cdrom
```

if 条件语句的双分支结构由`if、then、else、fi`关键词组成，它进行一次条件匹配判断，如果与条件匹配，则去执行相应的预设命令；反之则去执行不匹配时的预设命令，相当于口语的“如果……那么……或者……那么……”。if 条件语句的双分支结构也是一种很简单的判断结构，语法格式如图

![双分支结构-1.png](双分支结构-1.png)

下面使用**双分支的 if 条件语句来验证某台主机是否在线**，然后根据返回值的结果，要么显示主机在线信息，要么显示主机不在线信息。这里的脚本主要使用`ping`命令来测试与对方主机的网络联通性，而 Linux 系统中的 ping 命令不像 Windows 一样尝试 4 次就结束，因此为了避免用户等待时间过长，需要通过`-c`参数来规定尝试的次数，并使用`-i`参数定义每个数据包的发送间隔，以及使用`-W`参数定义等待超时时间。

```c
[root@linuxprobe ~]# vim chkhost.sh
#!/bin/bash
ping -c 3 -i 0.2 -W 3 $1 &> /dev/null
if [ $? -eq 0 ]
then
echo "Host $1 is On-line."
else
echo "Host $1 is Off-line."
fi
```

我们在 4.2.3 小节中用过`$?`变量，作用是**显示上一次命令的执行返回值**。若前面的那条语句成功执行，则$?变量会显示数字0，反之则显示一个非零的数字（可能为1，也可能为2，取决于系统版本）。因此可以使用整数比较运算符来判断$?变量是否为 0，从而获知那条语句的最终判断情况。这里的服务器 IP 地址为 192.168.10.10，我们来验证一下脚本的效果：

```c
[root@linuxprobe ~]# bash chkhost.sh 192.168.10.10
Host 192.168.10.10 is On-line.
[root@linuxprobe ~]# bash chkhost.sh 192.168.10.20
Host 192.168.10.20 is Off-line.
```

if 条件语句的`多分支结构由if、then、else、elif、fi`关键词组成，它进行多次条件匹配判断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令，相当于口语的“如果……那么……如果……那么……”。if 条件语句的多分支结构是工作中最常使用的一种条件判断结构，尽管相对复杂但是更加灵活，语法格式如图

![多分支结构-2.png](多分支结构-2.png)

下面使用多分支的 if 条件语句来判断用户输入的分数在哪个成绩区间内，然后输出如 Excellent、Pass、Fail 等提示信息。在 Linux 系统中，`read`是用来读取用户输入信息的命令，能够把接收到的用户输入信息赋值给后面的指定变量，`-p`参数用于向用户显示一定的提示信息。在下面的脚本示例中，只有当用户输入的分数大于等于 85 分且小于等于 100 分，才输出 Excellent 字样；若分数不满足该条件（即匹配不成功），则继续判断分数是否大于等于 70 分且小于等于 84 分，如果是，则输出 Pass 字样；若两次都落空（即两次的匹配操作都失败了），则输出 Fail 字样：

```c
[root@linuxprobe ~]# vim chkscore.sh
#!/bin/bash
read -p "Enter your score（0-100）：" GRADE
if [ $GRADE -ge 85 ] && [ $GRADE -le 100 ] ; then
echo "$GRADE is Excellent"
elif [ $GRADE -ge 70 ] && [ $GRADE -le 84 ] ; then
echo "$GRADE is Pass"
else
echo "$GRADE is Fail"
fi
[root@linuxprobe ~]# bash chkscore.sh
Enter your score（0-100）：88
88 is Excellent
[root@linuxprobe ~]# bash chkscore.sh
Enter your score（0-100）：80
80 is Pass
```

下面执行该脚本。当用户输入的分数分别为 30 和 200 时，其结果如下：

```c
[root@linuxprobe ~]# bash chkscore.sh
Enter your score（0-100）：30
30 is Fail
[root@linuxprobe ~]# bash chkscore.sh
Enter your score（0-100）：200
200 is Fail
```

为什么输入的分数为 200 时，依然显示 Fail 呢？原因很简单—没有成功匹配脚本中的两个条件判断语句，因此自动执行了**最终的兜底策略**。可见，这个脚本还不是很完美，建议读者自行完善这个脚本，使得用户在输入大于 100 或小于 0 的分数时，给予 Error 报错字样的提示。

### for 条件循环语句

for 循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理，当要处理的数据有范围时，使用 for 循环语句再适合不过了。for 循环语句的语法格式如图

![for条件语句-1.png](for条件语句-1.png)

下面使用 for 循环语句从列表文件中**读取多个用户名**，然后为其逐一创建用户账户并设置密码。首先创建用户名称的列表文件 users.txt，每个用户名称单独一行。读者可以自行决定具体的用户名称和个数

```c
[root@linuxprobe ~]# vim users.txt
andy
barry
carl
duke
eric
george
```

接下来编写 Shell 脚本**Example.sh**。在脚本中使用`read`命令读取用户输入的密码值，然后赋值给 PASSWD 变量，并通过`-p`参数向用户显示一段提示信息，告诉用户正在输入的内容即将作为账户密码。在执行该脚本后，会自动使用从列表文件 users.txt 中获取到所有的用户名称，然后逐一使用“id 用户名”命令查看用户的信息，并使用`$?`判断这条命令是否执行成功，也就是判断该用户是否已经存在。

需要多说一句，**/dev/null 是一个被称作 Linux 黑洞的文件**，把输出信息重定向到这个文件**等同于删除数据**（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。

```c
[root@linuxprobe ~]# vim Example.sh
#!/bin/bash
read -p "Enter The Users Password : " PASSWD
for UNAME in `cat users.txt`
do
id $UNAME &> /dev/null
if [ $? -eq 0 ]
then
echo "Already exists"
else
useradd $UNAME &> /dev/null
echo "$PASSWD" | passwd --stdin $UNAME &> /dev/null
if [ $? -eq 0 ]
then
echo "$UNAME , Create success"
else
echo "$UNAME , Create failure"
fi
fi
done
```

执行批量创建用户的 Shell 脚本 Example.sh，在输入为账户设定的密码后将由脚本自动检查并创建这些账户。由于已经将多余的信息通过输出重定向符转移到了/dev/null 黑洞文件中，因此在正常情况下屏幕窗口除了“用户账户创建成功”（Create success）的提示后不会有其他内容。

在 Linux 系统中，**/etc/passwd 是用来保存用户账户信息的文件**。如果想确认这个脚本是否成功创建了用户账户，可以打开这个文件，看其中是否有这些新创建的用户信息。

```c
[root@linuxprobe ~]# bash Example.sh
Enter The Users Password : linuxprobe
andy , Create success
barry , Create success
carl , Create success
duke , Create success
eric , Create success
george , Create success
[root@linuxprobe ~]# tail -6 /etc/passwd
andy:x:1001:1001::/home/andy:/bin/bash
barry:x:1002:1002::/home/barry:/bin/bash
carl:x:1003:1003::/home/carl:/bin/bash
duke:x:1004:1004::/home/duke:/bin/bash
eric:x:1005:1005::/home/eric:/bin/bash
george:x:1006:1006::/home/george:/bin/bash
```

您还记得在学习双分支 if 条件语句时，用到的那个**测试主机是否在线的脚本么**？既然我们现在已经掌握了 for 循环语句，不妨做些更酷的事情，比如尝试让脚本从文本中自动读取主机列表，然后自动逐个测试这些主机是否在线。

首先创建一个主机列表文件 ipadds.txt：

```c
[root@linuxprobe ~]# vim ipadds.txt
192.168.10.10
192.168.10.11
192.168.10.12
```

然后前面的双分支 if 条件语句与 for 循环语句相结合，让脚本从主机列表文件 ipadds.txt 中自动读取 IP 地址（用来表示主机）并将其赋值给 HLIST 变量，从而通过判断 ping 命令执行后的返回值来逐个测试主机是否在线。脚本中出现的\$（命令）是一种完全类似于第 3 章的转义字符中反引号`命令`的 Shell 操作符，效果同样是执行括号或双引号括起来的字符串中的命令。大家在编写脚本时，多学习几种类似的新方法，可在工作中大显身手：

```c
[root@linuxprobe ~]# vim CheckHosts.sh
#!/bin/bash
HLIST=$(cat ~/ipadds.txt)
for IP in $HLIST
do
ping -c 3 -i 0.2 -W 3 $IP &> /dev/null
if [ $? -eq 0 ] ; then
echo "Host $IP is On-line."
else
echo "Host $IP is Off-line."
fi
done
[root@linuxprobe ~]# ./CheckHosts.sh
Host 192.168.10.10 is On-line.
Host 192.168.10.11 is Off-line.
Host 192.168.10.12 is Off-line.
```

### while 条件循环语句

while 条件循环语句是一种让脚本根据某些条件来重复执行命令的语句，它的循环结构往往在执行前并**不确定最终执行的次数**，完全不同于 for 循环语句中有目标、有范围的使用场景。while 循环语句通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执行，为假就结束循环。while 语句的语法格式如图 4-21 所示。

![while条件语句-1.png](while条件语句-1.png)

接下来结合使用多分支的 if 条件测试语句与 while 条件循环语句，编写一个用来猜测数值大小的脚本 Guess.sh。该脚本使用\$RANDOM 变量来调取出一个随机的数值（范围为 0 ～ 32767），将这个随机数对 1000 进行取余操作，并使用 expr 命令取得其结果，再用这个数值与用户通过 read 命令输入的数值进行比较判断。这个判断语句分为三种情况，分别是判断用户输入的数值是等于、大于还是小于使用 expr 命令取得的数值。当前，现在这些内容不是重点，我们当前要关注的是 while 条件循环语句中的条件测试始终为 true，因此判断语句会无限执行下去，直到用户输入的数值等于 expr 命令取得的数值后，这两者相等之后才运行 exit 0 命令，终止脚本的执行。

```c
[root@linuxprobe ~]# vim Guess.sh
#!/bin/bash
PRICE=$(expr $RANDOM % 1000)
TIMES=0
echo "商品实际价格为0-999之间，猜猜看是多少？"
while true
do
read -p "请输入您猜测的价格数目：" INT
let TIMES++
if [ $INT -eq $PRICE ] ; then
echo "恭喜您答对了，实际价格是 $PRICE"
echo "您总共猜测了 $TIMES 次"
exit 0
elif [ $INT -gt $PRICE ] ; then
echo "太高了！"
else
echo "太低了！"
fi
done
```

在这个 Guess.sh 脚本中，我们添加了一些交互式的信息，从而使得用户与系统的互动性得以增强。而且每当循环到 let TIMES++命令时都会让 TIMES 变量内的数值加 1，用来统计循环总计执行了多少次。**这可以让用户得知总共猜测了多少次之后，才猜对价格**。

```c
[root@linuxprobe ~]# bash Guess.sh
商品实际价格为0-999之间，猜猜看是多少？
请输入您猜测的价格数目：500
太低了！
请输入您猜测的价格数目：800
太高了！
请输入您猜测的价格数目：650
太低了！
请输入您猜测的价格数目：720
太高了！
请输入您猜测的价格数目：690
太低了！
请输入您猜测的价格数目：700
太高了！
请输入您猜测的价格数目：695
太高了！
请输入您猜测的价格数目：692
太高了！
请输入您猜测的价格数目：691
恭喜您答对了，实际价格是 691
您总共猜测了 9 次
```

### case 条件测试语句

如果您之前学习过 C 语言，看到这一小节的标题肯定会会心一笑“这不就是 switch 语句嘛！”是的，case 条件测试语句和 switch 语句的功能非常相似！case 语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；而如果数据不在所列出的范围内，则会去执行星号（\*）中所定义的默认命令。case 语句的语法结构如图

![case条件语句-1.png](case条件语句-1.png)

在前文介绍的**Guess.sh 脚本中有一个致命的弱点—只能接受数字！**您可以尝试输入一个字母，会发现脚本立即就崩溃了。原因是字母无法与数字进行大小比较，例如，“a 是否大于等于 3”这样的命题是完全错误的。我们必须有一定的措施来判断用户的输入内容，当用户输入的内容不是数字时，脚本能予以提示，从而免于崩溃。

通过在脚本中组合使用 case 条件测试语句和**通配符**（详见第 3 章），完全可以满足这里的需求。接下来我们编写脚本 Checkkeys.sh，提示用户输入一个字符并将其赋值给变量 KEY，然后根据变量 KEY 的值向用户显示其值是字母、数字还是其他字符。

```c
[root@linuxprobe ~]# vim Checkkeys.sh
#!/bin/bash
read -p "请输入一个字符，并按Enter键确认：" KEY
case "$KEY" in
[a-z]|[A-Z])
echo "您输入的是 字母。"
;;
[0-9])
echo "您输入的是 数字。"
;;
*)
echo "您输入的是 空格、功能键或其他控制字符。"
esac
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：6
您输入的是 数字。
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：p
您输入的是 字母。
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：^[[15~
您输入的是 空格、功能键或其他控制字符。
```

## 计划任务服务程序

经验丰富的系统运维工程师可以使得 Linux 在**无需人为介入**的情况下，在指定的时间段自动启用或停止某些服务或命令，从而实现运维的自动化。尽管我们现在已经有了功能彪悍的脚本程序来执行一些批处理工作，但是，如果仍然需要在每天凌晨两点敲击键盘回车键来执行这个脚本程序，这简直太痛苦了（当然，也可以训练您的小猫在半夜按下回车键）。接下来，刘遄老师将向大家讲解如何设置服务器的计划任务服务，把**周期性、规律性**的工作交给系统自动完成。

**计划任务分为一次性计划任务与长期性计划任务，大家可以按照如下方式理解。**

> 一次性计划任务：今晚 11 点 30 分开启网站服务。

> 长期性计划任务：每周一的凌晨 3 点 25 分把/home/wwwroot 目录打包备份为 backup.tar.gz。

顾名思义，**一次性计划任务只执行一次**，一般用于满足临时的工作需求。我们可以用`at`命令实现这种功能，只需要写成“`at 时间`”的形式就可以。如果想要查看已设置好但还未执行的一次性计划任务，可以使用“`at -l`”命令；要想将其删除，可以用“`atrm 任务序号`”。在使用 at 命令来设置一次性计划任务时，**默认采用的是交互式方法**。例如，使用下述命令将系统设置为在今晚 23:30 分自动重启网站服务

```c
[root@linuxprobe ~]# at 23:30
at > systemctl restart httpd
at > 此处请同时按下Ctrl+d来结束编写计划任务
job 3 at Mon Apr 27 23:30:00 2015
[root@linuxprobe ~]# at -l
3 Mon Apr 27 23:30:00 2016 a root
```

如果读者想挑战一下难度更大但简捷性更高的方式，可以把前面学习的管道符（任意门）放到两条命令之间，让 at 命令接收前面 echo 命令的输出信息，以达到通过非交互式的方式创建计划一次性任务的目的。

```c
[root@linuxprobe ~]# echo "systemctl restart httpd" | at 23:30
job 4 at Mon Apr 27 23:30:00 2015
[root@linuxprobe ~]# at -l
3 Mon Apr 27 23:30:00 2016 a root
4 Mon Apr 27 23:30:00 2016 a root
```

如果我们不小心设置了两个一次性计划任务，可以使用下面的命令轻松删除其中一个：

```c
[root@linuxprobe ~]# atrm 3
[root@linuxprobe ~]# at -l
4 Mon Apr 27 23:30:00 2016 a root
```

如果我们希望 Linux 系统能够周期性地、有规律地执行某些具体的任务，那么 Linux 系统中默认启用的`crond`服务简直再适合不过了。创建、编辑计划任务的命令为“`crontab -e`”，查看当前计划任务的命令为“`crontab -l`”，删除某条计划任务的命令为“`crontab -r`”。另外，如果您是以管理员的身份登录的系统，还可以在 crontab 命令中加上`-u`参数来编辑他人的计划任务。

在正式部署计划任务前，请先跟刘遄老师念一下口诀“**分、时、日、月、星期 命令**”。这是使用 crond 服务设置任务的参数格式（其格式见表 4-6）。需要注意的是，如果有些字段没有设置，则需要使用星号（\*）占位，如图

![cron计划任务的参数.png](cron计划任务的参数.png)

| 字段 | 说明                                             |
| ---- | ------------------------------------------------ |
| 分钟 | 取值为 0 ～ 59 的整数                            |
| 小时 | 取值为 0 ～ 23 的任意整数                        |
| 日期 | 取值为 1 ～ 31 的任意整数                        |
| 月份 | 取值为 1 ～ 12 的任意整数                        |
| 星期 | 取值为 0 ～ 7 的任意整数，其中 0 与 7 均为星期日 |
| 命令 | 要执行的命令或程序脚本                           |

假设在每周一、三、五的凌晨 3 点 25 分，都需要使用 tar 命令把某个网站的数据目录进行打包处理，使其作为一个备份文件。我们可以使用 crontab -e 命令来创建计划任务。为自己创建计划任务无需使用-u 参数，具体的实现效果的参数如 crontab -l 命令结果所示：

```c
[root@linuxprobe ~]# crontab -e
no crontab for root - using an empty one
crontab: installing new crontab
[root@linuxprobe ~]# crontab -l
25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot
```

需要说明的是，除了用**逗号（,）**来分别表示多个时间段，例如“8,9,12”表示 8 月、9 月和 12 月。还可以用**减号（-）**来表示一段连续的时间周期（例如字段“日”的取值为“12-15”，则表示每月的 12 ～ 15 日）。以及用**除号（/）**表示执行任务的间隔时间（例如“\*/2”表示每隔 2 分钟执行一次任务）。

如果在 crond 服务中需要同时包含多条计划任务的命令语句，应每行仅写一条。例如我们再添加一条计划任务，它的功能是每周一至周五的凌晨 1 点钟自动清空/tmp 目录内的所有文件。尤其需要注意的是，在 crond 服务的计划任务参数中，所有命令一定要用绝对路径的方式来写，如果不知道绝对路径，请用 whereis 命令进行查询，rm 命令路径为下面输出信息中加粗部分。

```c
[root@linuxprobe ~]# whereis rm
rm: /usr/bin/rm /usr/share/man/man1/rm.1.gz /usr/share/man/man1p/rm.1p.gz
[root@linuxprobe ~]# crontab -e
crontab: installing new crontab
[root@linuxprobe ~]# crontab -l
25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot
0 1 * * 1-5 /usr/bin/rm -rf /tmp/*
```

> 在 crond 服务的配置参数中，可以像 Shell 脚本那样以**#号开头写上注释信息**，这样在日后回顾这段命令代码时可以快速了解其功能、需求以及编写人员等重要信息。

> 计划任务中的**“分”字段必须有数值，绝对不能为空或是\*号，而“日”和“星期”字段不能同时使用**，否则就会发生冲突。

最后再啰嗦一句，想必读者也已经发现了，**诸如 crond 在内的很多服务默认调用的是 Vim 编辑器**，相信大家现在能进一步体会到在 Linux 系统中掌握 Vim 文本编辑器的好处了吧。所以请大家一定要在彻底掌握 Vim 编码器之后再学习下一章

## 参考

[Linux shell 编程基础，一看就能入门](https://zhuanlan.zhihu.com/p/35465182)
