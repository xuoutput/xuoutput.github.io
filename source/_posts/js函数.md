---
title: js函数
date: 2018-12-14 20:05:04
tags:
- javascript
- 函数
categories:
- javascript教程
comments: false
permalink:
---

# js函数

1. 只定义一次, 但可能被执行或调用任意次. js的函数是参数化的, 就是函数的定义会包括一个称为形参的标识符列表, 这些参数像**局部参数一样**工作. 函数调用时为形参提供实参的值. 函数用实参值来计算返回值, 成为**函数调用表达式的值**

2. 每次调用除了拥有一个值外, 还有本地调用的上下文, **就是this关键字的值**  `this`用法可以看**只在运行时确定** {% post_link javascript中this指向由函数调用方式决定 javascript中this指向由函数调用方式决定 %}

3. 如果函数挂载在一个对象上, 作为对象的一个属性, 就成为他是**对象的方法**. 用于初始化一个新创建的对象的函数成为**构造函数**.

4. js中, **函数就是对象**.所以可以给他们设置属性, 甚至调用他们的方法.

5. js函数还能**嵌套**在其他函数中定义, 这样他们就能访问他们被定义时所处的作用域中的任何变量. 构成**闭包**

## 函数定义

`function`关键字, 在函数定义表达式和函数声明语句中用.

3部分组成

1. 函数名称标识符: 这个是**函数声明语句**必需的. 用途就像变量的名字, **新定义的函数对象会赋值给这个变量**`name`. 对**函数表达式**来说这个名字是可选的, 如果存在, 该名字只存在于函数体中并指代该函数对象本身, 和函数声明有点区别. **一个不在函数体中, 一个在函数体`{}`中**.
2. 一对圆括号(): 用包含0个或多个用逗号隔开的标识符组成的列表. 都是函数参数名称, **就像函数体中的局部变量一样**(就当成局部变量好了).
3. 一对花括号{}: 包含0到多条js语句, 这些语句构成**函数体**.

一条函数声明语句实际上声明了一个变量, 并把一个函数对象赋值给它.函数定义表达式并没有声明一个变量.

所以函数声明中的函数名是一个指代自己的名称. **函数表达式中如果包含名称, 函数的局部作用域将会包含一个绑定到函数对象的名称**.实际上函数的名称将会成为函数内部的一个局部变量. 通常而言, 函数表达式是不需要名称的. 特别适合来定义那些只会用到一次的函数.

还有就是提升问题, 声明会, 表达式不会.

函数大多有一条`return`语句, 用来导致函数停止执行,并返回表达式的值. 如果只有`return`就返回`undefined`, 如果函数不包含`return`就只是执行完函数后返回`undefined`, 有些需要返回值, 有些不需要. 不需要个也叫过程.

函数声明语句并不是真正的语句, ECMA只是允许它作为顶级语句, 不能出现在循环, 条件判断, 或try/catch/finally和with中. 函数表达式可以出现在任何地方.

## 8.2 函数调用

作为函数主体的js代码在定义之时并不会执行, 只有调用该函数时他们才会执行. 有4种方式来调用js函数.

* 作为函数
* 作为方法(保存在对象那个属性里的js函数)
* 作为构造函数
* 通过他们的call()和apply()方法简介调用

### 8.2.1 函数调用

使用**调用表达式**(由多个**函数表达式**组成)可以进行普通的函数调用也可以进行方法调用.

函数表达式还可以是一个**属性访问表达式`[]`**(是对象的一个属性`o.m()`或数组的一个元素)

```javascript
var total = distance(0, 0, 2, 1) + distance(2, 1, 3, 5)
```

注意`this`, 以函数形式调用的函数通常不使用`this`关键字. 不过`this`可以用来判断当前是否是严格模式

```javascript
var strict = (function() { return !this }())
```

### 8.2.2 方法调用

一个方法就是保存在一个对象属性里的js函数. 比如一个对象`o`和一个函数`f`

```javascript
// 这里说的就是给对象o定义一个名为m()的方法
o.m = f

//调用的时候就
o.m()
```

对方法调用的参数和返回值的处理和普通函数调用完全一致. 只有一个区别而已, 就是**调用上下文** `this`的区别

> 方法和`this`关键字是面向对象编程的核心. 任何函数只要作为方法调用实际上都会传入一个隐式的实参-实参是个对象(**就是那个`o`**), **方法调用的母体就是这个对象**. 函数基于一个对象进行操作.

例如:

```javascript
rect.setSize(width, height)
```

第一行的方法调用语法非常清晰地表明这个函数执行的载体就是`rect`对象, 函数中的所有操作都讲基于这个对象.

> 方法链: 当方法的返回值是一个对象, 这个对象还可以再调用它的方法. 当方法不需要返回值时, 最好直接返回`this`. 
> **不要将方法的链式调用和构造函数的链式调用混为一谈**

在说下`this`: 是一个关键字, 不是变量,也不是属性名. 不允许赋值诶.

所以`this`和变量不同, `this`没有作用域的限制, 嵌套的函数不会从调用它的函数中继承`this`:(很多人误以为调用嵌套函数时`this`会指向调用外层函数的上下文)

1. 如果嵌套函数作为方法调用, 其`this`的值指向调用它的对象.
2. 如果嵌套函数作为函数调用, 其`this`的值不是全局对象(非严格)就是`undefined`(严格)

如果你想访问外部函数的`this`值, 需要将`this`保存在一个变量中, 这个变量和内部函数都在同一个作用域内.

{% post_link javascript中this指向由函数调用方式决定 javascript中this指向由函数调用方式决定 %}

### 8.2.3 构造函数调用

如果函数或方法调用之前带有关键字`new`, 它就构成构造函数调用.
> 构造函数调用和普通的函数调用以及方法调用在实参处理, 调用上下文和返回值方面都有不同

如果构造函数调用圆括号内包含一组实参列表, 先计算这些实参表达式, 然后传入函数内, 这和函数调用和方法调用时一致的.
但如果构造函数没有形参, js构造函数的语法允许省略实参列表和圆括号, 就留一个名字.

```javascript
// 两者等价
var o = new Object()
var o = new Object
```

构造函数调用创建一个新的空对象, 这个对象继承自构造函数的`prototype`属性, 构造函数试图初始化这个新创建的对象, 并将这个对象用作其调用上下文, 因此构造函数可以使用`this`关键字来引用这个新创建的对象.
> 注意, 尽管构造函数看起来像一个方法调用, 他依然会使用这个新对象作为调用上下文, 也就是说,在表达式`new o.m()`中,调用上下文并不是`o`, 而是新建好的那个对象.

构造函数通常不使用`return`关键字, 他们通常初始化新对象, 当构造函数的函数体执行完毕事, 它会显示返回.
当然使用`return`返回这个对象,就是这个对象咯.(返回别的对象就是别的对象)
如果只给了`return`但没有指定返回值, 或者返回一个原始值, 那么这时将**忽略返回值**, 同时**使用这个新对象作为调用结果**.

### 8.2.4 间接调用

js的函数也是对象, 函数对象也有方法啊. 其中两个方法就是`call()`和`apply()`可用来间接地调用函数.
两个方法都允许显示指定调用所需的`this`值, 也就是说,任何函数可以作为任何对象的方法来调用, 哪怕这个函数不是那个对象的方法.

## 8.3 函数的实参和形参

js函数定义没有指定函数形参的类型啊, 对传入的实参也没有做类型检查, 甚至数量也没有检查.

### 8.3.1 可选形参

当传入的实参比函数声明指定的形参个数**少**时, 剩下的形参将设为`undefined`. 所以可以给省略的参数赋一个合理的默认值.

当然可以用一个`undefined`或者`null`来作为一个占位符.a

### 8.3.2 可变长的实参列表: 实参对象

当传入的实参比函数声明指定的形参个数**多**时, 没办法直接获取未命名值的引用. **参数对象**解决这个问题.
**标识符**`arguments`指向是实参对象的引用, 实参对象是一个类数组对象, 可以用下标,不必非要用名字来得到实参.

```javascript
arguments[0]
arguments.length
```

一般js是省略的实参将都是`undefined`, 多余的实参自动省略.

**实参对象**有一个重要用处,就是让函数可以操作任意数量的实参. 类似这种可以接受任意个数的是实参, 这种函数也称为 **不定实参函数**
> 注意:不定实参函数的实参个数不能为0. `arguments[]`对象最适合的场景就是一类函数: 这类函数包括固定个数的命名和必须参数, 以及随后个数不定的可选实参.

类数组对象, `arguments`并不是真正的数组, 是一个实参对象. 每个实参对象都包含以数字为索引的一组元素以及`length`属性, 但他毕竟不是真正的数组. **可以理解为他是一个对象, 只是碰巧具有以数字为索引的属性**.

数组对象包含一个非同寻常的特性.非严格模式下, 当一个函数包含若干形参, **实参对象的数组元素是函数形参对应实参的别名**, 实参对象中以数字索引, 并且形参名称可以认为是**相同变量的不同命名**.

```javascript
function f(x) {
    console.log(x);         // 输出实参初始值
    arguments[0] = null;    // 修改实参数组对象元素, 对应形参别名x也修改了
    console.log(x);         // 输出null
}

f(1)
```

如果实参对象是一个真正的数组的话, 那么修改`arguments[0] = null`是不会影响到`console.log(x)`的值的.
这里`arguments[0]`和`x`指代同一个值, 修改其中一个的值会影响到另一个.

**es5**中移除了这个特殊特性. 不过浏览器上还是能跑的
非严格模式下`arguments`是个标识符, 可以用, 但在严格模式下, `arguments`是一个保留字

#### callee和caller属性

`arguments`实参对象除了数组元素, 还定义了`callee`和`caller`属性. 严格模式下对这两个属性读写都会长生一个类型错误. 非严格模式下, ECMA宝追规范规定`callee`属性指代当前正在运行的函数, `caller`是非标准的, 指代当前正在执行的函数**的函数**.
`callee`属性在某些时候非常有用, 比如匿名函数中通过`callee`来递归地调用自身.

### 8.3.3 将对象属性用作实参

当一个函数包含超过3个形参时, 对于程序员来说, 记住调用函数中实参的正确顺序实在让人头疼. 最好用**键值对**的形式来传入参数, 这样参数的顺序就无关紧要了. 所以在定义函数的时候, 传入的实参都写入一个单独的对象中, 对象中的k/v就是真正需要的实参数据.

### 8.3.4 实参类型

js中形参并没有声明类型, 在形参传入函数体之前也没有做任何类型检查.

## 8.4 作为值的函数

函数可以定义, 也可以调用, 这是函数最重要的特性. js中函数不经是一种语法, 也是值, 也就是说**可以将函数赋值给变量**, 存储在对象的属性或数组的元素中, 作为参数传入另外一个函数等

看一个函数定义:

```javascript
function square(x) { return x*x}
```

这个定义创建一个新的函数对象, 并将其赋值给变量`square`. 函数的名字实际上是看不见的,`square`仅仅是变量的名字, 这个变量指点函数对象. 函数还能赋值给其他的变量, 并且仍可以正常工作.

```javascript
var s = square
square(4)
s(4)
```

除了可以将函数赋值给变量, 同样可以将函数赋值给对象的属性. **当函数作为对象属性调用时, 函数就成为方法**.

```javascript
var o = {square: function(x) {return x*x}}
var y = o.square(16)
```

函数甚至不需要带名字, 当把它们赋值给数组元素时:

```javascript
var a = [function(x) { return x*x }, 20]
a[0](a[1])      // 合法的函数调用表达式
```

看一下函数用作值的, 就是要给给定操作符, 操作数的函数

```javascript
function add(x, y) { return x + y}

function operate(operate, operand1, operand2) {
    return operate(operand1, operand2)
}
```

又比如`Array.sort()`来对数组元素进行排序, 但排序的规则有很多(比如基于数值大小, 字母表排序, 日期大小, 从小到大, 从大到小等等), `sort()`可以接受一个函数作为参数, 用来处理具体的排序操作.

### 自定义函数属性

js中的函数并不是原始值, 而是一种特殊的对象. 是对象就可以有属性, 所以函数可以有属性. 当函数需要一个`静态`变量在调用时保持某个值不变, **最方便的就是给函数定义属性, 而不是定义全局变量**, 显然定义全局量会让命名空间变得更加杂乱无章.

比如你想返回一个唯一整数的函数, 不管在哪调用都会返回这个整数.

```javascript
// 初始化函数对象的计数器属性
// 由于函数声明被提前了, 因此这里是可以在函数声明之前给他的成员赋值的
uniqueInteger.count = 0

// 每次调用这个函数都会返回一个不同的整数
// 它使用一个属性来记住下一次要返回的值
function uniqueInteger() {
    return uniqueInteger.count++
}

```

计算阶乘

```javascript
function factorial(n) {
    if (isFinite(n) && n > 0 && n === Math.round(n)) {
        if (!(n in factorial))
            factorial[n] = n* factorial(n-1)
        return factorial[n]
    }
    else return NaN
}
factorial[1] = 1
```

## 8.5 作为命名空间的函数

js的函数作用域概念: 在函数中声明的变量在整个函数体内都是可见的(包括在嵌套的函数中), 在函数外部是不可见的. 不在任何函数内声明的变量是全局变量, 在整个js程序中都是可见的.

js无法声明只在一个代码块内可见的变量, es6中可以了. 这里的话可以简单地定义一个函数用作临时的命名空间, 不会污染全局命名空间.

```javascript
function mymodule() {
    // 局部变量
}

mymodule() // 调用
```

上面定义了一个单独的全局变量, 叫`mymodule`的函数, 可以直接定义一个匿名函数, 并在单个表达式中调用它.

```javascript
(function() {   // 匿名函数

}())  // 结束函数定义并立即调用它
```

定义匿名函数并立即在单个表达式中调用它的写法非常常见. 使用`(`才会正确得把他解析为函数定义表达式.

## 8.6 闭包

js也使用词法作用域, 也就是说,函数的执行依赖于变量作用域, 这个**作用域是在函数定义时**决定的, 而不是函数调用时决定的, 为了实现词法作用域, js函数对象的内部状态不仅包含函数的代码逻辑, 还必须引用当前的作用域链. **函数对象可以通过作用域链相互关联起来**, 函数体内部的变量都可以保存在函数作用域内, 称为**闭包**

从技术角度讲, 所有的js函数都是闭包: 他们都是对象, 他们都关联到作用域链. **`定义大多数函数时的作用域链在调用函数时依旧有效`**, 但这并不影响闭包.
**当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域时, 事情就变得非常微妙**. 当一个函数嵌套了另外一个函数, 外部函数讲嵌套的函数对象作为返回值返回的时候往往会发生这种事情.

理解闭包首先要了解嵌套函数的词法作用域规则.

```javascript
var scope = "global scope"          // 全局变量
function checkscope() {
    var scope = "local scope"       // 局部变量
    function f() { return scope}
    return f()  // 注意这里有() 直接返回结果
}
checkscope()    // => "local scope"
```

```javascript
var scope = "global scope"          // 全局变量
function checkscope() {
    var scope = "local scope"       // 局部变量
    function f() { return scope}
    return f    // 注意这里没() 返回的是函数内嵌套的一个函数对象.
}
checkscope()()    // => "local scope"
```

词法作用域的基本规则: js函数的执行用到了作用域链, 这个作用域链是**函数定义**的时候创建的. 嵌套的函数`f()`定义在这个作用域里, 其中的变量`scope`一定是局部变量, 不管在何时何地执行函数`f()`, 这种绑定在执行`f()`时依旧有效, 因此最后一样代码返回`local scope`而不是`global scope`.
简言之, 闭包的这个特性强大到让人吃惊: 他们可以捕捉到局部变量(和参数), 并一直保存下来, 看起来像这些变量绑定到了其中定义他们的外部函数.

> 更底层, 了解基于栈的CPU架构: 如果一个函数的局部变量定会在CPU的栈中, 那么当函数返回时他们的确就不存在了.

```javascript
var uniqueInteger = (function() {
    var counter = 0;
    return function() { return counter++}
})
```

也可以嵌套多个, 多个嵌套函数都共享一个作用域链.

```javascript
function counter() {
    var n = 0;
    return {
        count: function() { return n++},
        reset: function() { n = 0}
    }
}
```

一个对象下的共享, 不同对象下的不影响.

从技术角度看, 其实可以将这个闭包合并为属性存取器方法`getter`和`setter`

```javascript
function counter(n) {   //  函数参数n是一个私有变量, count函数并没有声明局部变量
    return {
        // 属性getter方法返回并给私有计数器var递增1
        get count() { return n++; },
        set count(m) {
            if (m >= n) n = m;
            else throw Error("count can only be set to a large value")
        }
    }
}

var c = counter(1000)
c.count
c.count = 2000
```

```javascript
function addPrivateProperty(o, name, preficate) {
    var value
    // getter
    o["get" + name] = function() { return value }

    // setter
    o["set" + name] = function(v) {
        if (predicate && !predicate(v))
            throw Error("set" + name + ": invalid value " + v)
        else
            value = v
    }
}
```

> 注意咯, 这个函数的`getter`和`setter`函数, 所操作的属性值并没有存储在对象o中, 这个值仅仅保存在函数中的局部变量中.
> 也就是说, 对于两个存取器方法来说这个变量是私有的, 没有办法绕过存取器方法来设置或修改这个值.

要注意如果用循环创建很多个闭包, 会犯一个错误. 所有的闭包都共享一个值. 关联到闭包的作用域链都是"活动的", 嵌套的函数不会将作用域内的私有成员复制一份, 也不会对所绑定的变量生成静态快照.

书写闭包的时候还需要注意, `this`是js的关键字, 而不是变量. 每个函数调用都包含一个this值, 如果闭包在外部函数里是无法访问this的, 除非外部函数讲this转存为一个变量.
arguments类似, 他并不是一个关键字, 但在调用每个函数时都会自动声明它, 由于闭包具有自己所绑定的arguments, 因此闭包内无法直接访问外部函数的参数数组, 除非外部函数将参数数组保存到另一个变量中.

## 8.7 函数属性, 方法和构造函数

js中函数是值, 用`typeof`运算符返回字符串`'function'`, 但函数又是js中特殊的对象. 所有有属性和方法, 甚至可以用`Function()`构造函数来创建新的函数对象.

### 8.7.1 length属性

函数体里的`arguments.length`表示传入函数的实参的个数. 而在函数本身的`length`属性则有不同的含义. 函数的`length`属性是只读属性, 它代表函数是参数的数量, 这里的参数指的是'形参'而非'实参', 也就是函数定义时给出的形参个数, 通常也是在函数调用时期望传入函数的参数个数.

例子是一个`check()`的函数, 从另外一个 函数给他传入`arguments`数组, 它比较`arguments.length`(实际传入的实参个数)和`arguments.callee.length`(期望传入的实参个数)来判断所传入的实参个数是否正确.

```javascript
function check(args) {
    var actual = args.length;           // 实参的真实个数
    var expected = args.callee.length;  // 期望的是从哪个数
    if (actual !== expected)
        throw Error("Expected " + expected + "args; got" + actual)
}

function f(x, y, z) {
    check(arguments);
    return x + y + z;
}
```

### 8.7.2 prototye属性



## 参考


