---
title: WebAssembly
date: 2019-05-31 09:55:12
tags:
- WebAssembly
categories:
- javascript教程
comments: false
permalink:
---

# WebAssembly

## 需要了解计算机组成原理, 操作系统

从 OS 的原来 0101 写对应某一种 CPU, 然后写汇编, 用编译器来装换, 到高级语言在"编译", "汇编", "链接". 这里会出现不同的 CPU 架构, 指令集不同, 然后 是编译器来识别到最后编译成 对应什么架构 CPU 的机器码么. 高级语言会用 LLVM 来编译成对应底层不同 CPU 架构能识别的机器码.

WebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行， 但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。

每个高级语言都去实现源码到不同平台的机器码的转换工作是重复的，高级语言只需要生成底层虚拟机(LLVM)认识的中间语言(LLVM IR)，LLVM 能实现：

通常负责把高级语言翻译到 LLVM IR 的部分叫做编译器前端，把 LLVM IR 编译成各架构 CPU 对应机器码的部分叫做编译器后端； 现在越来越多的高级编程语言选择 LLVM 作为后端，高级语言只需专注于如何提供开发效率更高的语法同时保持翻译到 LLVM IR 的程序执行性能。

ARM 的手机上还有很多不同的处理器, 高通 小米 华为 联发科 三星 苹果.

## 指令

举个例子，假设有以下 5 盏灯。灯由开关控制着，只有开关两种状态。我们约定 1 表示开灯，0 表示关灯。那么，当电灯管理员得到“01000”这样一组数字时，**他就知道了应该开第二盏灯，其他的关掉**。

机器码编程是不方便的，程序员想要完成某种计算功能，往往需要从非常庞大的**指令表**查找到相应的数字功能码。因此，后来人们设计了很多助记符，用有意义的单词来表示机器指令，这就形成了汇编语言。

[CPU 的指令集存放在什么地方？Ricky Li 回答 6](https://www.zhihu.com/question/20793038)

CPU 的指令集是软件与 CPU 这两个层级之间的接口, 而 CPU 自己, 就是对于这一套 CPU 指令集的**实例化**.

软件意义上, "指令集"实际上是一个规范, 规范汇编的文件格式.一条汇编指令与一段机器码是一一对应的. 可以看出来, 指令集的作用, 就是告诉程序员/编译器, 汇编一定要有格式. 支持什么指令, 指令带什么限制条件, 用什么操作数, 用什么地址, 都是指令集规范的内容, 要是写错了, 就无法翻译成机器码.**指令集规范汇编**, 汇编可以翻译成机器码, 机器码告诉 CPU 每个周期去做什么. 因此, **CPU 指令集是描述 CPU 能实现什么功能的一个集合, 就是描述"CPU 能使用哪些机器码"的集合"**.

[汇编指令集与 cpu 指令集是什么关系？bombless 的回答](https://www.zhihu.com/question/22193700)
更多的讲了标准与实现哦, CPU 指令集是标准, CPU 这个硬件是实现. 同理还有编译器上, 这个编译器也是个实现, 按不同的 CPU 指令集标准来.

## 从 0101 到汇编 6

[汇编语言入门教程](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)
先看下阮一峰的第二段,阮一峰的很好的讲了从开关到打孔纸带, 到使用人能识别的符号即汇编语言的这个过程.

到汇编语言后就多出一个步骤，要把这些文字指令重新翻译回二进制, 这样 CPU 才能识别，这个步骤就称为 assembling，用来处理这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言.

注: 每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。

> 例如常见的处理器还有 intel AMD ARM 这些, 手机上 ARM 的还有高通, 华为麒麟, 小米松果, 三星, 联发科, 苹果 A 这些. 都不同的.
> 现在的话你不需要关心不同的汇编语言问题 LLVM 会把一份汇编语言都转换成对应 CPU 能运行的机器指令.

然后看下周荷琴的 **微机原理及接口第三版** 第 65 页开始的 **3-2 指令的机器码表示方式**, 讲了对于 8 位的微处理器可以从汇编到机器码通过查表. 对于 8086 这种 32 位的直接查表不行, 要先按指令类型给出编码格式, 再查表得到机器码. 就举了个 `MOV SP, BX` 指令的例子. 所以你就知道了编译器 assembler 干什么的了. **其实也是按某种方式查表**

更进一步是看下[intel 指令集](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf#page=29&zoom=100,0,818)
知乎上张盼锋的解释, 讲的十分不错哦. 第 1 个视频，正是汇编语言到机器语言的步骤，在编译器处理此阶段，是直接将 mov 这些汇编翻译为机器码；在计算机执行层面，是 CU 控制单元根据不同的 opcode 产生不同的控制信号(见视频 3)。
[汇编语言转换成机器语言，具体在机器这个层面是如何实现的？ 知乎](https://www.zhihu.com/question/65385471)

> 前面我只讲了从编译器处理程序的角度, 没有说计算机执行层面的, 知乎上张盼锋还讲了从执行层面的.

对于我们现在在用的高级语言, 当然也是从汇编语言发展过来, 为了进一步提高开发效率咯. 那高级语言怎么运行呢?

你可能在编写完 C 文件后用 gcc 的时候听过预处理, 编译, 链接 这个. 那编译完后不是成汇编语言了么, 为什么有个链接, 直接从汇编语言到机器指令有这个步骤么?

[编译器的工作过程](http://www.ruanyifeng.com/blog/2014/11/compiler.html)
除了将你知道的用 gcc 进行 -E -S -c 生成 .i .s .o 文件后, 还有其他步骤准备. [建议看英文原文更加详细](http://nethack4.org/blog/building-c.html).

## 参考

[WebAssembly 现状与实战](https://www.ibm.com/developerworks/cn/web/wa-lo-webassembly-status-and-reality/index.html)
