<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.1',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  
  <meta name="keywords" content="Hexo, NexT">


<meta name="description" content="this is description">
<meta property="og:type" content="website">
<meta property="og:title" content="Little H title">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Little H title">
<meta property="og:description" content="this is description">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Little H title">
<meta name="twitter:description" content="this is description">






  <link rel="canonical" href="http://yoursite.com/">


  <title>Little H title</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Little H title</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">this is subtitle</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益404</a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/k8s集群的简单安装和使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/k8s集群的简单安装和使用/" itemprop="url">k8s集群的简单安装和使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T17:55:09+08:00">2019-03-06</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/后端教程/" itemprop="url" rel="index"><span itemprop="name">后端教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="k8s集群的简单安装和使用"><a href="#k8s集群的简单安装和使用" class="headerlink" title="k8s集群的简单安装和使用"></a>k8s集群的简单安装和使用</h1><h2 id="什么是kubernetes"><a href="#什么是kubernetes" class="headerlink" title="什么是kubernetes"></a>什么是kubernetes</h2><p><a href="https://kubernetes.feisky.xyz/ji-chu-ru-men/index" target="_blank" rel="noopener">Kubernetes 是一个平台</a></p>
<p>Kubernetes 提供了很多的功能，它可以<strong>简化应用程序的工作流</strong>，加快开发速度。通常，一个成功的<strong>应用编排系统</strong>需要有较强的自动化能力，这也是为什么 Kubernetes 被设计作为构建组件和工具的生态系统平台，以便更轻松地部署、扩展和管理应用程序(Kubernetes 是一个容器编排平台)。</p>
<p><a href="https://caicloud.io/blog/5a90db21ea51874faccead25" target="_blank" rel="noopener">编排的艺术| K8S 中的容器编排和应用编排 6666</a></p>
<p>在传统的单体式架构的应用中，我们开发、测试、交付、部署等都是针对单个组件，我们很少听到编排这个概念。而在云的时代，微服务和容器大行其道，除了为我们显示出了它们在敏捷性，可移植性等方面的巨大优势以外，也为我们的交付和运维带来了新的挑战：我们将单体式的架构拆分成越来越多细小的服务，运行在各自的容器中，那么该如何解决它们之间的依赖管理，服务发现，资源管理，高可用等问题呢？</p>
<p>在容器环境中，编排通常涉及到三个方面:</p>
<ul>
<li>资源编排 - 负责资源的分配，如限制 <code>namespace</code> 的可用资源，<code>scheduler</code> 针对资源的不同调度策略；</li>
<li>工作负载编排 - 负责在资源之间共享工作负载，如 Kubernetes 通过不同的 <code>controller</code> 将 <code>Pod</code> 调度到合适的 <code>node</code> 上，并且负责管理它们的生命周期；</li>
<li>服务编排 - 负责服务发现和高可用等，如 Kubernetes 中可用通过 <code>Service</code> 来对内暴露服务，通过 <code>Ingress</code> 来对外暴露服务。</li>
</ul>
<p>在 Kubernetes 中有 5 种我们经常会用到的控制器来帮助我们进行容器编排，它们分别是 <code>Deployment</code>, <code>StatefulSet</code>, <code>DaemonSet</code>, <code>CronJob</code>, <code>Job</code>。</p>
<p>在这 5 种常见资源中</p>
<ul>
<li><code>Deployment</code> 经常被作为无状态实例控制器使用;</li>
<li><code>StatefulSet</code> 是一个有状态实例控制器;</li>
<li><code>DaemonSet</code> 可以指定在选定的 <code>Node</code> 上跑，每个 <code>Node</code> 上会跑一个副本，它有一个特点是它的 <code>Pod</code> 的调度不经过调度器，在 <code>Pod</code> 创建的时候就直接绑定 <code>NodeName</code>；</li>
<li>最后一个是<code>CronJob</code>定时任务，它是一个上级控制器，和 <code>Deployment</code> 有些类似，当一个定时任务触发的时候，它会去创建一个 <code>Job</code> ，具体的任务实际上是由 <code>Job</code> 来负责执行的。</li>
</ul>
<p>他们之间的关系如下图：</p>
<p><img src="controllers.jpeg" alt="controllers.jpeg"></p>
<p>一个简单的例子</p>
<p>我们来考虑这么一个简单的例子，一<strong>个需要使用到数据库</strong>的 <code>API</code> 服务在 Kubernetes 中应该如何表示: </p>
<p>客户端程序通过 <code>Ingress</code> 来访问到内部的 <code>API Service</code>, <code>API Service</code> 将流量导流到 <code>API Server Deployment</code> 管理的其中一个 <code>Pod</code> 中，这个 <code>Server</code> 还需要访问数据库服务，它通过 <code>DB Service</code> 来访问 <code>DataBase StatefulSet</code> 的有状态副本。由定时任务 <code>CronJob</code> 来定期备份数据库，通过 <code>DaemonSet</code> 的 <code>Logging</code> 来采集日志，<code>Monitoring</code> 来负责收集监控指标。</p>
<p><img src="example1.jpeg" alt="example1.jpeg"></p>
<h3 id="容器编排的困境"><a href="#容器编排的困境" class="headerlink" title="容器编排的困境"></a>容器编排的困境</h3><h4 id="Kubernetes-为我们带来了什么？"><a href="#Kubernetes-为我们带来了什么？" class="headerlink" title="Kubernetes 为我们带来了什么？"></a>Kubernetes 为我们带来了什么？</h4><p>通过上面的例子，我们发现 Kubernetes 已经为我们对大量常用的基础资源进行了<strong>抽象和封装</strong>，我们可以非常灵活地组合、使用这些资源来解决问题，同时它还提供了一系列自动化运维的机制:如 HPA, VPA, Rollback, Rolling Update 等帮助我们进行弹性伸缩和滚动更新，而且上述所有的功能都可以用 <code>YAML</code> 声明式进行部署。</p>
<h4 id="困境"><a href="#困境" class="headerlink" title="困境"></a>困境</h4><p>但是这些抽象<strong>还是在容器层面</strong>的，对于一个大型的应用而言，需要组合大量的 Kubernetes 原生资源，需要非常多的 Services, Deployments, StatefulSets 等，这里面用起来就会比较繁琐，而且其中服务之间的依赖关系需要用户自己解决，<strong>缺乏统一的依赖管理机制</strong>。</p>
<h3 id="应用编排"><a href="#应用编排" class="headerlink" title="应用编排"></a>应用编排</h3><h4 id="什么是应用？"><a href="#什么是应用？" class="headerlink" title="什么是应用？"></a>什么是应用？</h4><p>一个对外提供服务的应用，</p>
<ul>
<li>首先它需要一个能够与外部通讯的网络，</li>
<li>其次还需要能运行这个服务的载体 (Pods)，</li>
<li>如果这个应用需要存储数据，这还需要配套的存储，</li>
</ul>
<p>所以我们可以认为:</p>
<p>应用单元 = 网络 + 服务载体 +存储 </p>
<p><img src="service1.jpeg" alt="service1.jpeg"></p>
<p>那么我们很容易地可以将 Kubernetes 的资源联系起来，然后将他们划分为 4 种类型的应用：</p>
<ul>
<li>无状态应用 = Services + Volumes + <code>Deployment</code></li>
<li>有状态应用 = Services + Volumes + <code>StatefulSet</code></li>
<li>守护型应用 = Services + Volumes + <code>DaemonSet</code></li>
<li>批处理应用 = Services + Volumes + <code>CronJob/Job</code></li>
</ul>
<p>我们来重新审视一下之前的例子：</p>
<p><img src="example2.jpeg" alt="example2.jpeg"></p>
<h4 id="应用层面的四个问题"><a href="#应用层面的四个问题" class="headerlink" title="应用层面的四个问题"></a>应用层面的四个问题</h4><p>通过前面的探索，我们可以引出应用层面的<strong>四个问题</strong>：</p>
<ol>
<li>应用包的定义</li>
<li>应用依赖管理</li>
<li>包存储</li>
<li>运行时管理</li>
</ol>
<p>在社区中，这四个方面的问题分别由<strong>三个组件</strong>或者项目来解决:</p>
<ol>
<li><code>Helm Charts</code>: 定义了应用包的结构以及依赖关系；</li>
<li><code>Helm Registry</code>: 解决了包存储；</li>
<li><code>HelmTiller</code>: 负责将包运行在 Kubernetes 集群中。</li>
</ol>
<p>Helm是一个kubernetes应用的包管理工具. 但有很多问题, 也有很多年代替的东西.</p>
<h2 id="k8s核心架构介绍"><a href="#k8s核心架构介绍" class="headerlink" title="k8s核心架构介绍"></a>k8s核心架构介绍</h2><p><a href="https://clsn.io/clsn/lx8.html" target="_blank" rel="noopener">Kubernetes 编排系统 666</a></p>
<p>下面是kubernetes的架构图, 核心组件, 可以看个大概, 记住的话很有用.</p>
<p><img src="framework2.png" alt="framework2.png"><br><img src="framework1.png" alt="framework1.png"></p>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Kubernetes的<strong>基本调度单元</strong>称为“pod”。它可以把更高级别的抽象内容增加到容器化组件。<strong>一个pod一般包含一个或多个容器</strong>，这样可以保证它们一直位于主机上，并且可以共享资源。Kubernetes中的每个pod都被分配一个唯一的（在集群内的）IP地址这样就可以允许应用程序使用端口，而不会有冲突的风险。</p>
<p>Pod可以定义一个卷，例如本地磁盘目录或网络磁盘，并将其暴露在pod中的一个容器之中。pod可以通过Kubernetes API手动管理，也可以委托给控制器来管理。</p>
<h3 id="标签和选择器"><a href="#标签和选择器" class="headerlink" title="标签和选择器"></a>标签和选择器</h3><p>标签和选择器是Kubernetes中的主要分组机制，用于确定操作适用的组件。</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>控制器是将实际集群状态转移到所需集群状态的对帐循环。它通过<strong>管理一组pod来实现</strong>。</p>
<p>其它控制器，是核心Kubernetes系统的一部分包括一个“DaemonSet控制器”为每一台机器（或机器的一些子集）上运行的恰好一个pod，和一个“作业控制器”用于运行pod运行到完成，例如作为批处理作业的一部分。控制器管理的一组pod由作为控制器定义的一部分的标签选择器确定。</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>Kubernetes<strong>服务是一组协同工作的pod</strong>，就像多层架构应用中的一层。构成服务的pod组通过标签选择器来定义。</p>
<h2 id="Kubernetes核心组件"><a href="#Kubernetes核心组件" class="headerlink" title="Kubernetes核心组件"></a>Kubernetes核心组件</h2><p>再重复一遍核心组件架构图.</p>
<p><img src="framework2.png" alt="framework2.png"><br><img src="framework1.png" alt="framework1.png"></p>
<p>Kubernetes遵循<code>master-slave architecture</code>。Kubernetes的组件可以分为管理单个的 node 组件和控制平面的一部分的组件。</p>
<p>Kubernetes <code>Master</code>是集群的<strong>主要控制单元</strong>，用于管理其工作负载并指导整个系统的通信。<br>Kubernetes控制平面由各自的进程组成，每个组件都可以在<strong>单个主节点node</strong>上运行，也可以在支持high-availability clusters的多个主节点上运行。</p>
<p>Kubernetes主要由以下几个核心组件组成：如上图</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组件名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>etcd</td>
<td>保存了整个集群的状态；</td>
</tr>
<tr>
<td>apiserver</td>
<td>提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</td>
</tr>
<tr>
<td>controller manager</td>
<td>负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</td>
</tr>
<tr>
<td>scheduler</td>
<td>负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</td>
</tr>
<tr>
<td>kubelet</td>
<td>负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；</td>
</tr>
<tr>
<td>Container runtime</td>
<td>负责镜像管理以及Pod和容器的真正运行（CRI）；</td>
</tr>
<tr>
<td>kube-proxy</td>
<td>负责为Service提供cluster内部的服务发现和负载均衡；</td>
</tr>
</tbody>
</table>
</div>
<p>除了核心组件，还有一些推荐的<code>Add-ons</code>：addons</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组件名称</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>kube-dns</td>
<td>负责为整个集群提供DNS服务</td>
</tr>
<tr>
<td>Ingress Controller</td>
<td>为服务提供外网入口</td>
<td>有看过</td>
</tr>
<tr>
<td>Heapster</td>
<td>提供资源监控</td>
</tr>
<tr>
<td>Dashboard</td>
<td>提供GUI</td>
<td>有用到</td>
</tr>
<tr>
<td>Federation</td>
<td>提供跨可用区的集群</td>
</tr>
<tr>
<td>Fluentd-elasticsearch</td>
<td>提供集群日志采集、存储与查询</td>
</tr>
</tbody>
</table>
</div>
<h2 id="使用docker来安装单节点k8s集群"><a href="#使用docker来安装单节点k8s集群" class="headerlink" title="使用docker来安装单节点k8s集群"></a>使用docker来安装单节点k8s集群</h2><p>直接下载最新版的docker, 然后找到kubernetes选项, 勾上<code>enable kubernetes</code>等待安装上就好.</p>
<p><img src="enablek8s.png" alt="enablek8s.png"></p>
<p>安装完会顺便自动安装上<code>kubectl</code>控制命令</p>
<p>运行<code>kubectl version</code>查看安装成功否.</p>
<h3 id="部署kubernetes-dashboard服务-方便查看k8s的配置"><a href="#部署kubernetes-dashboard服务-方便查看k8s的配置" class="headerlink" title="部署kubernetes-dashboard服务, 方便查看k8s的配置"></a>部署kubernetes-dashboard服务, 方便查看k8s的配置</h3><p>要想启动 Kubernetes Dashboard，还得在集群中<strong>部署</strong>一下 <code>kubernetes-dashboard.yaml</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure>
<p>部署成功后，我们进行启动 <code>proxy</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl proxy</span><br><span class="line"></span><br><span class="line">Starting to serve on 127.0.0.1:8001</span><br></pre></td></tr></table></figure>
<p>这时候，打开浏览器，访问 Kubernetes Dashboard</p>
<p><img src="dashboard1.webp" alt="dashboard1.webp"></p>
<p>通过以下脚本，填写 <code>kubeconfig</code> 的 <code>Token</code> 信息（如果不操作这一步，就会提示 config 信息不全）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">TOKEN=$(kubectl -n kube-system describe secret default| awk <span class="string">'$1=="token:"&#123;print $2&#125;'</span>)</span><br><span class="line">kubectl config <span class="built_in">set</span>-credentials docker-for-desktop --token=<span class="string">"<span class="variable">$&#123;TOKEN&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>选择 <code>kubeconfig</code> 文件，使用“<code>shift + command + .</code>”打开 <code>$HOME</code> 下隐藏目录文件 <code>./kube/config</code>，点击“登录”，就可以认证成功，进入首页了。</p>
<p><img src="home1.webp" alt="home1.webp"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>第一部分: dockerhe k8s, 如何设置k8s集群,以及运行一个小程序</li>
<li>第二部分: 在k8s中运行应用必须理解的关键技术</li>
<li>第三部分: 深入研究k8s内部, 介绍一些额外的概念</li>
</ul>
<p>本来应用是开发给运维, 运维部署在监控.<br>微服务, 大型单体应用, 到微服务.大应用分解成小的, </p>
<p>k8s使开发者可以自主部署应用, 并控制部署的频率<br>抽象数据中心的硬件基础设施.</p>
<p>开发和运维在一起的一个团队中DevOps<br>kubernetes 使用linux容器技术来提供应用的隔离.</p>
<p>Docker: </p>
<ul>
<li>镜像</li>
<li>镜像仓库</li>
<li>容器</li>
</ul>
<p>流程是:</p>
<ol>
<li>先开发者操作docker构建和推送镜像,</li>
<li>开发机器上docker构建镜像</li>
<li>然后推送到镜像仓库中,开发者可以在生产机器中拉取</li>
<li>生产机器上拉取镜像中心的docker, 然后基于容器运行.</li>
</ol>
<p>kubernetes是一个软件系统, 允许你在其上很容易部署和管理容器化的应用.</p>
<p>开发者开发开发了一个应用, 然后交给kubernetes master, 他会控制成为一个个工作节点.  架构</p>
<p>kubernetes分2种节点,</p>
<ul>
<li>主节点master: 控制和管理</li>
<li>工作节点node: 运行用户实际部署的应用.</li>
</ul>
<p>主节点中: </p>
<ul>
<li>kubernetes API: 控制和其他控制面板组件都要和他通信.</li>
<li>scheduler: 调度应用</li>
<li>controller manager: 执行集群级别的功能, 如复制组件, 持续跟踪node, 处理节点失败</li>
<li>etcd开考的分布式数据存储, 持久化存储集群配置.</li>
</ul>
<p>工作节点中node:</p>
<ul>
<li>docker: 或其他容器</li>
<li>kubelet: 和API通信, 并管理它所在节点的容器.</li>
<li>kubernetes service proxy: 负责组件之间的负载均衡网络流量</li>
</ul>
<p>跑应用的话要先把应用大包进一个或多个容器镜像, 再把这些镜像推动到镜像仓库中, 然后把应用的<strong>描述</strong>发布到kubernetes API中.<br>图1.10很不错: </p>
<p>APP descriptor描述了4个容器, 并分为3组(叫3个pod), 前2个pod中一个容器, 后一个2个容器.表示这两个容器要协同工作, 不要隔离.旁边的数字表示要运行每个pod的副本数量.</p>
<blockquote>
<p>pod在node中</p>
</blockquote>
<p>例子: 如何创建一个简单的应用, 并把它打包成容器镜像并在远端的kubernetes集群中或本地的单节点集群中运行</p>
<ol>
<li>安装docker并运行一个hello容器</li>
<li>创建一个简单的node.js应用并部署在kubernetes中</li>
<li>把应用打包成可以独立运行的容器镜像</li>
<li>基于镜像运行容器</li>
<li>把镜像推送到docker hub中.</li>
</ol>
<p>docker build看图2.2<br>镜像的构建不是在docker客户端而是在docker的守护进程daemon. 两者可以不要求在同一台机器上.<br>没有的镜像会从docker hub中下.<br>镜像是分层的, 只有本地没有的镜像才会去hub上下.<br>Dockerfile是每一条语句创建一个层.<br>最后一层也就是最上面一层标记为<code>kubia:latest</code><br>构建完成后, 新的镜像存储在本地.</p>
<p>访问下<br>一些列docker操作后, 就可以push到docker hub了</p>
<p>然后是一些kubernetes的操作. 设置一个完整的多节点的kubernetes集群是很麻烦的额, 暂时就用docker的自带enable kubernetes. 最简单的 比用<code>minikube</code>还方便.</p>
<p>安装完后用<code>kubectl cluster-info</code>看集群状况. 下面还没有装<code>dashboard</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https:<span class="comment">//localhost:6443</span></span><br><span class="line">KubeDNS is running at https:<span class="comment">//localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span></span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use <span class="string">'kubectl cluster-info dump'</span>.</span><br></pre></td></tr></table></figure>
<p>使用GKE托管 kubernetes 集群</p>
<p>暂时不用了, 自己看下好了</p>
<p><code>kubectl get nodes</code>看节点的状况, <code>kubectl get</code>用来看kubernetes中对象情况</p>
<p>更详细的是用<code>kubectl describe node docker-for-desktop</code> 看节点的详情.</p>
<p>设置别名<code>kubectl</code>为<code>k</code></p>
<p>超实用的不全, 在<code>bash</code>或<code>zsh shell</code>中</p>
<p>在kubernetes上运行第一个应用.</p>
<p><code>kubectl run</code>来部署<br>运行一个前面推到 docker hub 的上那个. 本地的那个kubia</p>
<p><code>kubectl run kubia --image=ximage/kubia --port=8080 --generator=run/v1</code></p>
<p>kubia是kubernetes中的名字,<br>—image= 指定要运行的image,<br>—port= 指定kubernete应用监听哪个端口<br>—generator= 创建一个<code>ReplicationController</code>而不是Deployment. 以后不会用到这个命令.</p>
<p>pod的信息. 这里你会想是不是有一个kubectl的命令来看pod, 但是没有, kubernetes不是干这个活. 他不直接处理单个容器. 使用的是多容器共存的概念, 就是pod.</p>
<p>每个pod类似一个独立逻辑机器, 有自己的ip, 主机名这种, 运行一个独立的应用程序.<br>应用程序可以是单进程, 运行在单容器中, 也可以是一个主应用进程或其他支持进程.</p>
<p>容器, pod, node的关系看图2.5<br><code>kubectl get pods</code> 然后等status为running才行.</p>
<p>ImagePullBackOff的情况会等一会才成功的. 具体就用describe看</p>
<p>那么如何访问正在运行的pod的呢</p>
<p>前面说过每个pod都有自己的IP地址, 但这个地址是集群内部的, 不能从外部访问, 所以为了能从外部访问, 需要用服务对象公开他. 需要创建一个特殊的<code>LoadBalancer</code>类型的服务. 如果是一个常规服务的话(一个<code>ClusterIP</code>服务)还是只能在内部访问.<br><code>LoadBalancer</code>将创建一个外部的负载均衡, 通过负载均衡的公共IP来访问pod</p>
<h3 id="开始创建一个服务对象"><a href="#开始创建一个服务对象" class="headerlink" title="开始创建一个服务对象."></a>开始创建一个服务对象.</h3><p>告知kubernetes对外暴露之前创建的<code>ReplicationController</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl expose rc kubia --type=LoadBalancer --name kubia-http</span><br><span class="line">service &quot;kubia-http&quot; exposed</span><br></pre></td></tr></table></figure>
<ul>
<li>rc是名字<code>ReplicationController</code>的缩写, 不用写全称. pods是po, service是svc</li>
<li>kubia是前面<code>kubectl run</code>的名字,</li>
<li>—type=LoadBalancer是服务类型</li>
<li>—name kubia-http一个新的名字</li>
</ul>
<h3 id="列出服务"><a href="#列出服务" class="headerlink" title="列出服务"></a>列出服务</h3><p>用<code>kubectl get</code> 到目前为止有<code>nodes pods services</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get services</span><br><span class="line">NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          1d</span><br><span class="line">kubia-http   LoadBalancer   10.110.207.73   localhost     8080:32391/TCP   3m</span><br></pre></td></tr></table></figure>
<p>可以看到新创建的<code>kubia-http</code>并没有外部IP,是<code>localhost</code>, 如果是<code>&lt;none&gt;</code>的话,这是因为kubernetes创建负载均衡是要一段时间的, 过一会看.</p>
<p><code>kubectl get svc kubia-http</code> 看</p>
<p>还是用<code>curl localhost:8080</code>来看, 其实在用<code>docker ps</code>可以看到运行的容器哦.</p>
<p>仔细看应用将<code>pod</code>的名字当做主机名.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubia-m9zfv   1/1       Running   0          32m</span><br><span class="line"></span><br><span class="line">$ curl localhost:8080</span><br><span class="line">You&apos;ve hit kubia-m9zfv</span><br></pre></td></tr></table></figure>
<p>我们只需要记得, 我单点访问<code>master</code>节点就好了.</p>
<p><code>ReplicationController</code>和<code>pod</code>和服务是如何组合在一起的.</p>
<p>我们没有直接创建和使用容器, kubernetes的基本构建又是pod. 我们也没有真正直接创建pod, 是通过<code>kubectl run</code> 创建了一个<code>ReplicationController</code>, 这个是用来创建pod实例的. 为了能够外部访问, kubernetes将<code>ReplicationController</code>管理的所有pod有一个服务对外暴露.</p>
<p>图2.7看看</p>
<h3 id="最终要你的组件是pod和它的容器"><a href="#最终要你的组件是pod和它的容器" class="headerlink" title="最终要你的组件是pod和它的容器"></a>最终要你的组件是pod和它的容器</h3><p>第一个组件是: pod的的容器是node进程,</p>
<p>第二个组件是: <code>ReplicationController</code>是用来确保始终存在一个运行中的pod实例, 通常<code>ReplicationController</code>用于复制pod并让他们保持运行.</p>
<p>第三个组件是: <code>kubia-http</code>服务. 为什么要有服务, 因为pod是短暂存在的,  或故障, 或误操作. 虽然<code>ReplicationController</code>会复制一个新的, 但和原来的pod有个一区别就是<strong>IP地址不一样</strong>, 解决不断变化的IP问题, 这就是需要服务的地方. 还有就是搞定一个IP和端口对上对外暴露多个pod.<br>当一个服务创建时, 他会得到一个静态的IP, 服务生命周期内这个IP地址都不会发生改变. 客户端是通过固定IP地址来连接到服务. 而不是直接连接pod</p>
<h3 id="水平伸缩应用"><a href="#水平伸缩应用" class="headerlink" title="水平伸缩应用"></a>水平伸缩应用</h3><p>有前面3个组件基础后, 搞事情咯</p>
<p>用kubernetes一个主要好处就是可以简单扩展部署, 例子🌰</p>
<p>把运行实例增加到3个.</p>
<p>现在是一个</p>
<figure class="highlight k"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">get</span> replicationcontrollers</span><br><span class="line">NAME      DESIRED   CURRENT   READY     AGE</span><br><span class="line">kubia     <span class="number">1</span>         <span class="number">1</span>         <span class="number">1</span>         <span class="number">1</span>h</span><br></pre></td></tr></table></figure>
<p>名为kubia的单 <code>ReplicationControllers</code> . <code>DESIRED</code>表示希望保持的pod的副本数, <code>CURRENT</code>是当前的pod副本数.</p>
<h4 id="增加期望副本数DESIRED"><a href="#增加期望副本数DESIRED" class="headerlink" title="增加期望副本数DESIRED"></a>增加期望副本数DESIRED</h4><figure class="highlight k"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl scale rc kubia --replicas=<span class="number">3</span></span><br><span class="line">replicationcontroller <span class="string">"kubia"</span> scaled</span><br></pre></td></tr></table></figure>
<p>只是告诉kubernetes我期望的数量, kubernetes会自己去做.</p>
<figure class="highlight k"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">get</span> rc</span><br><span class="line">NAME      DESIRED   CURRENT   READY     AGE</span><br><span class="line">kubia     <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>         <span class="number">1</span>h</span><br></pre></td></tr></table></figure>
<p>同时看下pod</p>
<figure class="highlight k"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">get</span> po</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubia-m9zfv   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>h</span><br><span class="line">kubia-q89qr   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>m</span><br><span class="line">kubia-w22k7   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>m</span><br></pre></td></tr></table></figure>
<p>然后重新访问下哦,多试几次可以看到访问不同的主机, <code>pod</code></p>
<figure class="highlight k"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:<span class="number">8080</span></span><br><span class="line">You've hit kubia-m9zfv</span><br><span class="line"></span><br><span class="line">$ curl localhost:<span class="number">8080</span></span><br><span class="line">You've hit kubia-q89qr</span><br><span class="line"></span><br><span class="line">$ curl localhost:<span class="number">8080</span></span><br><span class="line">You've hit kubia-w22k7</span><br></pre></td></tr></table></figure>
<h3 id="查看应用运行在哪个节点上"><a href="#查看应用运行在哪个节点上" class="headerlink" title="查看应用运行在哪个节点上"></a>查看应用运行在哪个节点上</h3><p>kubernetes中不需要管这个.</p>
<p>想要看就用加参数<code>-o wide</code> 多了2列</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po -o wide</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE       IP          NODE</span><br><span class="line">kubia-m9zfv   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>h        <span class="number">10.1</span><span class="number">.0</span><span class="number">.8</span>    docker-<span class="keyword">for</span>-desktop</span><br><span class="line">kubia-q89qr   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">6</span>m        <span class="number">10.1</span><span class="number">.0</span><span class="number">.10</span>   docker-<span class="keyword">for</span>-desktop</span><br><span class="line">kubia-w22k7   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">6</span>m        <span class="number">10.1</span><span class="number">.0</span><span class="number">.9</span>    docker-<span class="keyword">for</span>-desktop</span><br></pre></td></tr></table></figure>
<h3 id="还有使用dashboard"><a href="#还有使用dashboard" class="headerlink" title="还有使用dashboard"></a>还有使用dashboard</h3><p>暂时不管了, 2步</p>
<h2 id="pod这个kubernetes的核心"><a href="#pod这个kubernetes的核心" class="headerlink" title="pod这个kubernetes的核心"></a>pod这个kubernetes的核心</h2><p>其他对象只是在管理, 暴露pod或被pod使用.</p>
<h3 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h3><p>pod是一组并置的容器, 代表kubernetes中基本构建模块. 实际应用中并不会单独部署容器, 而是针对一组pod中的容器进行部署和操作.<br>这并不意味这一个pod中总要包含多个容器.<br>pod也不会跨越多个工作节点.</p>
<p>由于不能将多个进程都聚集在一个单独的容器中, 所以产生pod, 对他们当做一个单元进行管理.</p>
<p><strong>在docker中 知道容器间是隔离的, 但在pod中我们要共享</strong>, 所以kubernetes是配置docker让一个pod中的容器都在一个namespace中. 而不是每一个容器都一个命名空间.<br>所以他们也共享相同的主机名和网络接口, 一个namespace的好处,<br>由于现在pod中容器都共享相同的IP和端口, 所以要注意容器中的进程不能绑定到相同的port中. 这个只涉及一个pod中. 不同的pod间不会冲突.<br>同时一个pod中的所有容器都具有相同的loopback网络接口, 因此容器可以通过localhost与同一个pod的其他容器进行通信.</p>
<p><strong>集群中的所有pod都在一个共享网络地址空间</strong>, 意味着每个pod可以和其他pod进行相互访问, 包括不同node间的pod, 不用NAT</p>
<p>通过pod合理管理容器, 就是前后端应用服务器, 数据库的都放不同的pod中.<br>还有 <strong>扩容是基于pod的</strong><br>何时在一个pod中用多个容器呢, 主要是主进程和辅进程.</p>
<h4 id="何时在pod中放多个容器"><a href="#何时在pod中放多个容器" class="headerlink" title="何时在pod中放多个容器"></a>何时在pod中放多个容器</h4><ul>
<li>他们需要一起运行还是可以在不同的主机上运行</li>
<li>他们代表一个整体还是相互独立的组件</li>
<li>他们必须一起进行扩容还是可以分别进行</li>
</ul>
<p>图3.4哈哈哈 </p>
<ul>
<li>前后端在一个容器,一个pod中</li>
<li>前后端在不同容器, 但在一个pod中</li>
<li>前后端不同容器, 不容pod中</li>
</ul>
<h4 id="以YAML或JSON格式描述文件来创建pod"><a href="#以YAML或JSON格式描述文件来创建pod" class="headerlink" title="以YAML或JSON格式描述文件来创建pod"></a>以YAML或JSON格式描述文件来创建pod</h4><p>前面的命令行只允许你配置一组有限的属性. 通过YAML可以利用版本控制系统哦.</p>
<p>使用<code>kuberctl get po kubia-xxx -o yaml</code>来查看这个pod的YAML格式</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>                                  <span class="comment"># kubernetes API版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                                       <span class="comment"># kubernetes对象/资源</span></span><br><span class="line"><span class="attr">metadata:</span>                                       <span class="comment"># pod元数据(名称, 标签, 注解)</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T08:39:21Z</span></span><br><span class="line"><span class="attr">  generateName:</span> <span class="string">kubia-</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    run:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-m9zfv</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  ownerReferences:</span></span><br><span class="line"><span class="attr">  - apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">    blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    controller:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    uid:</span> <span class="string">ab300f02-417d-11e9-ae46-025000000001</span></span><br><span class="line"><span class="attr">  resourceVersion:</span> <span class="string">"82915"</span></span><br><span class="line"><span class="attr">  selfLink:</span> <span class="string">/api/v1/namespaces/default/pods/kubia-m9zfv</span></span><br><span class="line"><span class="attr">  uid:</span> <span class="string">ab4e1d22-417d-11e9-ae46-025000000001</span></span><br><span class="line"><span class="attr">spec:</span>                                           <span class="comment"># pod规格 / 内容(pod的容器列表, volume等)</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">ximage/kubia</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">    terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line"><span class="attr">    terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - mountPath:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">default-token-xgtvp</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line"><span class="attr">  nodeName:</span> <span class="string">docker-for-desktop</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">  schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line"><span class="attr">  securityContext:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  serviceAccount:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  serviceAccountName:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">  tolerations:</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoExecute</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">node.kubernetes.io/not-ready</span></span><br><span class="line"><span class="attr">    operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="attr">    tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoExecute</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">node.kubernetes.io/unreachable</span></span><br><span class="line"><span class="attr">    operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="attr">    tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">default-token-xgtvp</span></span><br><span class="line"><span class="attr">    secret:</span></span><br><span class="line"><span class="attr">      defaultMode:</span> <span class="number">420</span></span><br><span class="line"><span class="attr">      secretName:</span> <span class="string">default-token-xgtvp</span></span><br><span class="line"><span class="attr">status:</span>                                             <span class="comment"># pod及其内部容器的详细状态</span></span><br><span class="line"><span class="attr">  conditions:</span></span><br><span class="line"><span class="attr">  - lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    lastTransitionTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T08:39:21Z</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Initialized</span></span><br><span class="line"><span class="attr">  - lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    lastTransitionTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T08:48:18Z</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Ready</span></span><br><span class="line"><span class="attr">  - lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    lastTransitionTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T08:39:21Z</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">PodScheduled</span></span><br><span class="line"><span class="attr">  containerStatuses:</span></span><br><span class="line"><span class="attr">  - containerID:</span> <span class="attr">docker://14a88ed822997fea0d94d0a19366082c6cdaf648510f56b6221bd9bd7fc38c2e</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">kubia:latest</span></span><br><span class="line"><span class="attr">    imageID:</span> <span class="attr">docker-pullable://ximage/kubia@sha256:11b82b25e898ed75b9436654a243198d1c4e1e133d930f1c9dffed7c22a80aa4</span></span><br><span class="line"><span class="attr">    lastState:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    ready:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    restartCount:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    state:</span></span><br><span class="line"><span class="attr">      running:</span></span><br><span class="line"><span class="attr">        startedAt:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T08:48:18Z</span></span><br><span class="line"><span class="attr">  hostIP:</span> <span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br><span class="line"><span class="attr">  phase:</span> <span class="string">Running</span></span><br><span class="line"><span class="attr">  podIP:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.8</span></span><br><span class="line"><span class="attr">  qosClass:</span> <span class="string">BestEffort</span></span><br><span class="line"><span class="attr">  startTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T08:39:21Z)</span></span><br></pre></td></tr></table></figure>
<h5 id="介绍pod定义的主要部分"><a href="#介绍pod定义的主要部分" class="headerlink" title="介绍pod定义的主要部分"></a>介绍pod定义的主要部分</h5><ul>
<li>首先是YAML中使用的kubernetes API 版本和 YAML中用来描述的资源类型</li>
<li>其次是几乎在所有kubernetes资源中都可以找到的3大重要部分<ul>
<li>metadata 包括名称, 命名空间, 标签和关于该容器的其他信息</li>
<li>spec 包含pod内容的实际说明, 例如pod的容器, 卷和其他数据</li>
<li>status 包含<strong>运行中</strong>的pod的当前信息(新建时不需要的), 例如pod所处的条件, 每个容器的描述状态, 以及内部IP和其他基本信息</li>
</ul>
</li>
</ul>
<h5 id="创建一个简答的pod的YAML描述文件"><a href="#创建一个简答的pod的YAML描述文件" class="headerlink" title="创建一个简答的pod的YAML描述文件"></a>创建一个简答的pod的YAML描述文件</h5><p>kubia-manual.yaml 可以在任意目录下哦</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>              <span class="comment"># kubernetes API v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                   <span class="comment"># 是一个pod</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment"># </span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-manual</span>        <span class="comment"># pod名称</span></span><br><span class="line"><span class="attr">spec:</span>                       <span class="comment"># pod规格 / 内容(pod的容器列表, volume等)</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">ximage/kubia</span>     <span class="comment"># 容器所用镜像</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span>             <span class="comment"># 容器名</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span>   <span class="comment"># 监听端口</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<p>上面在pod中指定port是展示性的, 客户端能否通过端口链接到pod和这个并没有多大关系, 只不过这个明确指定很有用, 后面还可以用来允许你为每个端口指定一个名称.</p>
<p>可以用<code>kubectl explain pod</code>来查看怎么写. 对象含有那些属性. <code>kubectl explain pod.spec</code></p>
<p>使用<code>kuberctl create</code>命令从YAML文件中创建pod</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f kubia-manual.yaml </span><br><span class="line">pod <span class="string">"kubia-manual"</span> created</span><br></pre></td></tr></table></figure>
<p><code>kubectl create -f</code>用户从YAML或JSON中创建任何资源(不只是pod)</p>
<p>然后再看创建好的pod的yaml格式</p>
<p><code>kubectl get po kubia-manual -o yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T12:13:05Z</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-manual</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  resourceVersion:</span> <span class="string">"95408"</span></span><br><span class="line"><span class="attr">  selfLink:</span> <span class="string">/api/v1/namespaces/default/pods/kubia-manual</span></span><br><span class="line"><span class="attr">  uid:</span> <span class="number">8767870</span><span class="string">d-419b-11e9-ae46-025000000001</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">ximage/kubia</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">    terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line"><span class="attr">    terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - mountPath:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">default-token-xgtvp</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line"><span class="attr">  nodeName:</span> <span class="string">docker-for-desktop</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">  schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line"><span class="attr">  securityContext:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  serviceAccount:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  serviceAccountName:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">  tolerations:</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoExecute</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">node.kubernetes.io/not-ready</span></span><br><span class="line"><span class="attr">    operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="attr">    tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoExecute</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">node.kubernetes.io/unreachable</span></span><br><span class="line"><span class="attr">    operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="attr">    tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">default-token-xgtvp</span></span><br><span class="line"><span class="attr">    secret:</span></span><br><span class="line"><span class="attr">      defaultMode:</span> <span class="number">420</span></span><br><span class="line"><span class="attr">      secretName:</span> <span class="string">default-token-xgtvp</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line"><span class="attr">  conditions:</span></span><br><span class="line"><span class="attr">  - lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    lastTransitionTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T12:13:05Z</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Initialized</span></span><br><span class="line"><span class="attr">  - lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    lastTransitionTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T12:13:09Z</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Ready</span></span><br><span class="line"><span class="attr">  - lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    lastTransitionTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T12:13:05Z</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">PodScheduled</span></span><br><span class="line"><span class="attr">  containerStatuses:</span></span><br><span class="line"><span class="attr">  - containerID:</span> <span class="attr">docker://2c04c4f7551ac2e2e862722a780a4befe28d9037df0b74b8d0116c66ff4e1352</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">kubia:latest</span></span><br><span class="line"><span class="attr">    imageID:</span> <span class="attr">docker-pullable://ximage/kubia@sha256:11b82b25e898ed75b9436654a243198d1c4e1e133d930f1c9dffed7c22a80aa4</span></span><br><span class="line"><span class="attr">    lastState:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    ready:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    restartCount:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    state:</span></span><br><span class="line"><span class="attr">      running:</span></span><br><span class="line"><span class="attr">        startedAt:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T12:13:08Z</span></span><br><span class="line"><span class="attr">  hostIP:</span> <span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br><span class="line"><span class="attr">  phase:</span> <span class="string">Running</span></span><br><span class="line"><span class="attr">  podIP:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.11</span></span><br><span class="line"><span class="attr">  qosClass:</span> <span class="string">BestEffort</span></span><br><span class="line"><span class="attr">  startTime:</span> <span class="number">2019</span><span class="bullet">-03</span><span class="bullet">-08</span><span class="attr">T12:13:05Z</span></span><br></pre></td></tr></table></figure>
<p>虽然看<code>kubectl get po</code>可以知道pod运不运行, 但还有是需求, 通过与pod的时机通信来确定其正在运行. 后面讨论</p>
<p>现在看下应用的日志来检查错误.</p>
<h4 id="查看应用程序日志"><a href="#查看应用程序日志" class="headerlink" title="查看应用程序日志"></a>查看应用程序日志</h4><p>容器化的应用程序通常会把日志记录到标准输出和标准错误流, 而不是将其写入文件.</p>
<p><code>docker logs &lt;cid&gt;</code> 这种可以用</p>
<p>在kubernetes中可以用更方便的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs kubia-manual</span><br><span class="line">Kubia server starting ......</span><br><span class="line"></span><br><span class="line">$ kubectl logs kubia-m9zfv </span><br><span class="line">Kubia server starting ......</span><br><span class="line">Received request <span class="keyword">from</span>::ffff:<span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br><span class="line">Received request <span class="keyword">from</span>::ffff:<span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br><span class="line">Received request <span class="keyword">from</span>::ffff:<span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br><span class="line">Received request <span class="keyword">from</span>::ffff:<span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br><span class="line">Received request <span class="keyword">from</span>::ffff:<span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br><span class="line">Received request <span class="keyword">from</span>::ffff:<span class="number">192.168</span><span class="number">.65</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>
<p>在我们向nodejs中的程序发送web请求前, 日志只显示一条<code>Kubia server starting ......</code></p>
<p>获取多容器pod的日志时指定容器名称要加<code>-c &lt;容器名&gt;</code> 这个名称不能用<code>docker ps</code>看到, 而是你YAML文件中的<code>spec.containers.name</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs kubia-manual -c kubia       </span><br><span class="line">Kubia server starting ......</span><br></pre></td></tr></table></figure>
<p><strong>注意我们只能获取到仍然存在的pod的日志</strong>, 当一个pod被删除时, 他的日志也会被删除. 如果希望pod在删除之后也能获取到日志, 那么我们需要设置中心化吗集群范围的日志系统.</p>
<h4 id="向pod中发送请求"><a href="#向pod中发送请求" class="headerlink" title="向pod中发送请求"></a>向pod中发送请求</h4><p><code>kubectl get</code>和日志显示该pod正在运行, 但我们如何在实际操作用看到该状态呢.<br>前一章用<code>kubectl expose</code>创建一个service, 以便在外部访问pod.<br>还有其他链接到pod以进行测试和调试的方法. 其中之一就是<strong>端口转发</strong></p>
<h5 id="将本地网络端口转发到pod中的端口"><a href="#将本地网络端口转发到pod中的端口" class="headerlink" title="将本地网络端口转发到pod中的端口"></a>将本地网络端口转发到pod中的端口</h5><p>不通过service, 用端口 <code>kubectl port-forward</code>来</p>
<p><strong>如将本地端口8888转发到我们的kubia-manual pod中的8080端口</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl port-forward kubia-manual <span class="number">8888</span>:<span class="number">8080</span></span><br><span class="line">Forwarding <span class="keyword">from</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8888</span> -&gt; <span class="number">8080</span></span><br><span class="line">Forwarding <span class="keyword">from</span> [::<span class="number">1</span>]:<span class="number">8888</span> -&gt; <span class="number">8080</span></span><br><span class="line"></span><br><span class="line">$ curl localhost:<span class="number">8888</span></span><br><span class="line">You<span class="string">'ve hit kubia-manual</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ kubectl port-forward kubia-manual 8888:8080</span></span><br><span class="line"><span class="string">Forwarding from 127.0.0.1:8888 -&gt; 8080</span></span><br><span class="line"><span class="string">Forwarding from [::1]:8888 -&gt; 8080</span></span><br><span class="line"><span class="string">Handling connection for 8888</span></span><br></pre></td></tr></table></figure>
<p>图3.5</p>
<p>是一种测试特定pod有效的方法.</p>
<h4 id="用标签组织pod"><a href="#用标签组织pod" class="headerlink" title="用标签组织pod"></a>用标签组织pod</h4><p>在node中有很多pod的时候, 打标签分类就很有用了.</p>
<p>标签不仅可以用来组织pod, 也可以组织kubernetes的其他资源,</p>
<p>只要标签的key在资源内是唯一的, 一个资源就可以拥有多个标签. <strong>通常在我们创建资源的时候就会将标签附加到资源上</strong>, 后面也可以再打标签上去.</p>
<p>比如每个pod有2个标签</p>
<ul>
<li>app: 指定pod属于哪个应用, 组件或微服务</li>
<li>rel: 显示在pod中运行的应用程序版本是stable, beta还是canary</li>
</ul>
<p>这样就可以对原来的pod组织成2个维度, 从app角度和从版本角度.<br>图3.7</p>
<p>例子 在创建yaml文件时给pod带上标签.</p>
<p>一个<code>kubia-manual-with-labels.yaml</code></p>
<p>只是多了label</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>              <span class="comment"># kubernetes API v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                   <span class="comment"># 是一个pod</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment"># </span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-manual-v2</span>     <span class="comment"># pod名称</span></span><br><span class="line"><span class="attr">  labels:</span>                     <span class="comment"># 这里是新增的labels</span></span><br><span class="line"><span class="attr">    creation_method:</span> <span class="string">manual</span></span><br><span class="line"><span class="attr">    env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">spec:</span>                       <span class="comment"># pod规格 / 内容(pod的容器列表, volume等)</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">ximage/kubia</span>     <span class="comment"># 容器所用镜像</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span>             <span class="comment"># 容器名</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span>   <span class="comment"># 监听端口</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<p>使用命令创建后</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f kubia-manual-<span class="keyword">with</span>-labels.yaml</span><br><span class="line">pod <span class="string">"kubia-manual-v2"</span> created</span><br></pre></td></tr></table></figure>
<p>使用带上标签的可以看pod各自标签</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po --show-labels</span><br><span class="line">NAME              READY     STATUS    RESTARTS   AGE       LABELS</span><br><span class="line">kubia-m9zfv       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">17</span>h       run=kubia</span><br><span class="line">kubia-manual      <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>h       &lt;none&gt;</span><br><span class="line">kubia-manual-v2   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>m        creation_method=manual,env=prod</span><br><span class="line">kubia-q89qr       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h       run=kubia</span><br><span class="line">kubia-w22k7       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h       run=kubia</span><br></pre></td></tr></table></figure>
<p>用 -L 来显示指定标签列.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po -L creation_method,env</span><br><span class="line">NAME              READY     STATUS    RESTARTS   AGE       CREATION_METHOD   ENV</span><br><span class="line">kubia-m9zfv       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">17</span>h</span><br><span class="line">kubia-manual      <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>h</span><br><span class="line">kubia-manual-v2   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">3</span>m        manual            prod</span><br><span class="line">kubia-q89qr       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h</span><br><span class="line">kubia-w22k7       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h</span><br></pre></td></tr></table></figure>
<h4 id="修改现有pod的标签"><a href="#修改现有pod的标签" class="headerlink" title="修改现有pod的标签"></a>修改现有pod的标签</h4><p>给原来的 kubia-manual 添加上一个标签.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl label po kubia-manual creation_method=manual</span><br><span class="line">pod <span class="string">"kubia-manual"</span> labeled</span><br></pre></td></tr></table></figure>
<p>给 kubia-manual-v2 修改 env 的标签为 debug</p>
<p>就是比前面加标签多一个 <code>--overwrite</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl label po kubia-manual-v2 end=debug --overwrite</span><br><span class="line">pod <span class="string">"kubia-manual-v2"</span> labeled</span><br><span class="line"></span><br><span class="line">$ kubectl get po -L creation_method,env</span><br><span class="line">NAME              READY     STATUS    RESTARTS   AGE       CREATION_METHOD   ENV</span><br><span class="line">kubia-m9zfv       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">17</span>h</span><br><span class="line">kubia-manual      <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>h       manual</span><br><span class="line">kubia-manual-v2   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">7</span>m        manual            prod</span><br><span class="line">kubia-q89qr       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h</span><br><span class="line">kubia-w22k7       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h</span><br></pre></td></tr></table></figure>
<h3 id="前面只是看pod有啥标签-刷选具体标签的值-这里用标签选择器来过滤pod子集"><a href="#前面只是看pod有啥标签-刷选具体标签的值-这里用标签选择器来过滤pod子集" class="headerlink" title="前面只是看pod有啥标签, 刷选具体标签的值, 这里用标签选择器来过滤pod子集"></a>前面只是看pod有啥标签, 刷选具体标签的值, 这里用标签选择器来过滤pod子集</h3><p><strong>标签要和标签选择器一起用哦</strong>, 刷选的条件如下(就是key 和 value)</p>
<ul>
<li>包含或不包含使用特定键的标签  (in notin)</li>
<li>包含具有特定键和值的标签  =</li>
<li>包含有特定key的, 但value和我们指定的不同 !=</li>
</ul>
<h4 id="使用下-列出pod"><a href="#使用下-列出pod" class="headerlink" title="使用下 ,列出pod"></a>使用下 ,列出pod</h4><p>这里用<code>get</code> 的命令</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po -l creation_method=manual</span><br><span class="line">NAME              READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubia-manual      <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>h</span><br><span class="line">kubia-manual-v2   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">12</span>m</span><br><span class="line"></span><br><span class="line">$ kubectl get po -l env</span><br><span class="line">NAME              READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubia-manual-v2   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">13</span>m</span><br><span class="line"></span><br><span class="line">$ kubectl get po -l <span class="string">'!env'</span></span><br><span class="line">NAME           READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubia-m9zfv    <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">17</span>h</span><br><span class="line">kubia-manual   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>h</span><br><span class="line">kubia-q89qr    <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h</span><br><span class="line">kubia-w22k7    <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">16</span>h</span><br></pre></td></tr></table></figure>
<p>就是 -l 后面的值</p>
<ul>
<li>creatin_method!=manual</li>
<li>env in (prod, devel)</li>
<li>env notin (prod, devel)</li>
</ul>
<h4 id="在标签中使用多个条件"><a href="#在标签中使用多个条件" class="headerlink" title="在标签中使用多个条件"></a>在标签中使用多个条件</h4><p>使用逗号, 来分隔多个条件. 这个标签还能用来一次性删除多个pod</p>
<h3 id="使用标签来约束调度pod"><a href="#使用标签来约束调度pod" class="headerlink" title="使用标签来约束调度pod"></a>使用标签来约束调度pod</h3><p>不约束正是kubernetes的正确方式. 但某些情况下你想要约束下, 比如垃圾的机器上跑小应用, 高级的机器上跑大应用.<br>GPU, CPU机器区别对待. 但还是不会特别说明这个pod去哪个node上.</p>
<h4 id="使用标签分类工作节点node"><a href="#使用标签分类工作节点node" class="headerlink" title="使用标签分类工作节点node"></a>使用标签分类工作节点node</h4><p>比如新建一个node, 这个node是一个计算节点. 所以我们可以打label</p>
<p>用法还是同pod上打标签的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node &lt;node name&gt; gpu=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>              <span class="comment"># kubernetes API v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                   <span class="comment"># 是一个pod</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment">#</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-gpu</span>           <span class="comment"># pod名称</span></span><br><span class="line"><span class="attr">spec:</span>                       <span class="comment"># pod规格 / 内容(pod的容器列表, volume等)</span></span><br><span class="line"><span class="attr">  nodeSelector:</span>   <span class="comment"># 添加节点选择器,</span></span><br><span class="line"><span class="attr">    gpu:</span> <span class="string">"true"</span>   <span class="comment"># 要求pod部署到包含标签gpu=true的节点上</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">ximage/kubia</span>     <span class="comment"># 容器所用镜像</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span>             <span class="comment"># 容器名</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span>   <span class="comment"># 监听端口</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<p>创建pod的时候, 调度器会只在包含标签gpu=true的节点node上找, 然后在里面部署pod</p>
<h4 id="调度pod到某一个node"><a href="#调度pod到某一个node" class="headerlink" title="调度pod到某一个node"></a>调度pod到某一个node</h4><p>每一个node有一个唯一的标签, key是<code>kubernetes.io/hostname</code> value是节点的实际主机名</p>
<p>但我们不考虑单节点, 而是考虑一个逻辑上的节点组, 保证能够pod调度成功</p>
<h3 id="注解pod"><a href="#注解pod" class="headerlink" title="注解pod"></a>注解pod</h3><p>除了标签, 其他都可以注解. 也没有注解选择器哦.<br>kubernetes也会自动添加一些注解的, 比如新特性.</p>
<h4 id="查看对象的注解"><a href="#查看对象的注解" class="headerlink" title="查看对象的注解"></a>查看对象的注解</h4><p>现在看不到了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get po kubia-manual -o yaml</span><br></pre></td></tr></table></figure>
<h4 id="添加和修改注解"><a href="#添加和修改注解" class="headerlink" title="添加和修改注解"></a>添加和修改注解</h4><p>和标签一样的操作, 创建时可以添加, 也可以在之后对现有的pod进行操作.</p>
<p>用<code>kubectl annotate</code> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl annotate pod kubia-manual mycompany.com.someannotation=<span class="string">'foo bar'</span></span><br><span class="line">pod <span class="string">"kubia-manual"</span> annotated</span><br></pre></td></tr></table></figure>
<p>mycompany.com.someannotation=’foo bar’ 是一个key: value</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">describe</span> <span class="string">pod</span> <span class="string">kubia-manual</span></span><br><span class="line"><span class="attr">Name:</span>         <span class="string">kubia-manual</span></span><br><span class="line"><span class="attr">Namespace:</span>    <span class="string">default</span></span><br><span class="line"><span class="attr">Node:</span>         <span class="string">docker-for-desktop/192.168.65.3</span></span><br><span class="line"><span class="string">Start</span> <span class="attr">Time:</span>   <span class="string">Fri,</span> <span class="number">08</span> <span class="string">Mar</span> <span class="number">2019</span> <span class="number">20</span><span class="string">:13:05</span> <span class="string">+0800</span></span><br><span class="line"><span class="attr">Labels:</span>       <span class="string">creation_method=manual</span></span><br><span class="line"><span class="attr">Annotations:</span>  <span class="string">mycompany.com.someannotation=foo</span> <span class="string">bar</span>      <span class="comment"># 这条</span></span><br><span class="line"><span class="attr">Status:</span>       <span class="string">Running</span></span><br><span class="line"><span class="attr">IP:</span>           <span class="number">10.1</span><span class="number">.0</span><span class="number">.11</span></span><br><span class="line"><span class="attr">Containers:</span></span><br><span class="line"><span class="attr">  kubia:</span></span><br><span class="line">    <span class="string">Container</span> <span class="attr">ID:</span>   <span class="attr">docker://2c04c4f7551ac2e2e862722a780a4befe28d9037df0b74b8d0116c66ff4e1352</span></span><br><span class="line"><span class="attr">    Image:</span>          <span class="string">ximage/kubia</span></span><br><span class="line">    <span class="string">Image</span> <span class="attr">ID:</span>       <span class="attr">docker-pullable://ximage/kubia@sha256:11b82b25e898ed75b9436654a243198d1c4e1e133d930f1c9dffed7c22a80aa4</span></span><br><span class="line"><span class="attr">    Port:</span>           <span class="number">8080</span><span class="string">/TCP</span></span><br><span class="line">    <span class="string">Host</span> <span class="attr">Port:</span>      <span class="number">0</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">    State:</span>          <span class="string">Running</span></span><br><span class="line"><span class="attr">      Started:</span>      <span class="string">Fri,</span> <span class="number">08</span> <span class="string">Mar</span> <span class="number">2019</span> <span class="number">20</span><span class="string">:13:08</span> <span class="string">+0800</span></span><br><span class="line"><span class="attr">    Ready:</span>          <span class="literal">True</span></span><br><span class="line">    <span class="string">Restart</span> <span class="attr">Count:</span>  <span class="number">0</span></span><br><span class="line"><span class="attr">    Environment:</span>    <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">    Mounts:</span></span><br><span class="line">      <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span> <span class="string">from</span> <span class="string">default-token-xgtvp</span> <span class="string">(ro)</span></span><br><span class="line"><span class="attr">Conditions:</span></span><br><span class="line">  <span class="string">Type</span>           <span class="string">Status</span></span><br><span class="line">  <span class="string">Initialized</span>    <span class="literal">True</span></span><br><span class="line">  <span class="string">Ready</span>          <span class="literal">True</span></span><br><span class="line">  <span class="string">PodScheduled</span>   <span class="literal">True</span></span><br><span class="line"><span class="attr">Volumes:</span></span><br><span class="line"><span class="attr">  default-token-xgtvp:</span></span><br><span class="line"><span class="attr">    Type:</span>        <span class="string">Secret</span> <span class="string">(a</span> <span class="string">volume</span> <span class="string">populated</span> <span class="string">by</span> <span class="string">a</span> <span class="string">Secret)</span></span><br><span class="line"><span class="attr">    SecretName:</span>  <span class="string">default-token-xgtvp</span></span><br><span class="line"><span class="attr">    Optional:</span>    <span class="literal">false</span></span><br><span class="line"><span class="string">QoS</span> <span class="attr">Class:</span>       <span class="string">BestEffort</span></span><br><span class="line"><span class="attr">Node-Selectors:</span>  <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Tolerations:</span>     <span class="string">node.kubernetes.io/not-ready:NoExecute</span> <span class="string">for</span> <span class="number">300</span><span class="string">s</span></span><br><span class="line">                 <span class="string">node.kubernetes.io/unreachable:NoExecute</span> <span class="string">for</span> <span class="number">300</span><span class="string">s</span></span><br><span class="line"><span class="attr">Events:</span>          <span class="string">&lt;none&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-7-使用命名空间对资源进行分组"><a href="#3-7-使用命名空间对资源进行分组" class="headerlink" title="3.7 使用命名空间对资源进行分组"></a>3.7 使用命名空间对资源进行分组</h3><p>回到标签. 看到标签是如何将pod和其他对象组织成组的, 每个对象可以有多个标签, 当然可以分成多个组. 在集群中, 如果我们没有明确指定标签选择器, 那么能够看到所有对象.</p>
<p>当你想将对象分隔成完全独立但有不重叠的组时, kubernetes提供一个命名空间, 但这个和linux的命名空间不一样, kubernetes中的命名空间只是简单地为对象名称提供了一个作用域.</p>
<p>所以我们不会讲所有的资源都放在一个命名空间中, 而是多个命名空间中, 这样可以允许我们多次使用相同的资源名称.跨不同的命名空间.</p>
<h4 id="可以将大组件大系统接着拆"><a href="#可以将大组件大系统接着拆" class="headerlink" title="可以将大组件大系统接着拆"></a>可以将大组件大系统接着拆</h4><h4 id="列出集群中所有命名空间及其pod"><a href="#列出集群中所有命名空间及其pod" class="headerlink" title="列出集群中所有命名空间及其pod"></a>列出集群中所有命名空间及其pod</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get ns</span><br><span class="line">NAME          STATUS    AGE</span><br><span class="line"><span class="keyword">default</span>       Active    <span class="number">2</span>d</span><br><span class="line">docker        Active    <span class="number">2</span>d</span><br><span class="line">kube-public   Active    <span class="number">2</span>d</span><br><span class="line">kube-system   Active    <span class="number">2</span>d</span><br></pre></td></tr></table></figure>
<p>目前为止只是在<code>default</code>命名空间中操作. 使用<code>kubectl get</code>的时候并没有明确指定命名空间, 所以默认是<code>default</code>命名空间</p>
<p>看下其他命令空间的pod   <code>--namespace/-n</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po --namespace kube-system</span><br><span class="line">NAME                                         READY     STATUS    RESTARTS   AGE</span><br><span class="line">etcd-docker-<span class="keyword">for</span>-desktop                      <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">2</span>d</span><br><span class="line">kube-apiserver-docker-<span class="keyword">for</span>-desktop            <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">2</span>d</span><br><span class="line">kube-controller-manager-docker-<span class="keyword">for</span>-desktop   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">2</span>d</span><br><span class="line">kube-dns<span class="number">-86</span>f4d74b45<span class="number">-46</span>hx7                    <span class="number">3</span>/<span class="number">3</span>       Running   <span class="number">0</span>          <span class="number">2</span>d</span><br><span class="line">kube-proxy-ffc8d                             <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">2</span>d</span><br><span class="line">kube-scheduler-docker-<span class="keyword">for</span>-desktop            <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">2</span>d</span><br></pre></td></tr></table></figure>
<p>保持区分不同的pod</p>
<h4 id="创建一个命名空间"><a href="#创建一个命名空间" class="headerlink" title="创建一个命名空间"></a>创建一个命名空间</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>              <span class="comment"># kubernetes API v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span>             <span class="comment"># 表示定义一个namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">custom-namespace</span>    <span class="comment">#  命名空间的名字</span></span><br></pre></td></tr></table></figure>
<p>还是用原来的命令</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f custom-namespace.yaml</span><br><span class="line">namespace <span class="string">"custom-namespace"</span> created</span><br></pre></td></tr></table></figure>
<p>更方便的是使用命令咯 <code>kubectl create namespace custom-namespace</code></p>
<blockquote>
<p>只是要注意命名规范</p>
</blockquote>
<h4 id="管理其他命名空间中的对象"><a href="#管理其他命名空间中的对象" class="headerlink" title="管理其他命名空间中的对象"></a>管理其他命名空间中的对象</h4><p>如果想在刚创建的命名空间中创建资源, 可以选择在<code>yaml</code>文件的<code>metadata</code>字段添加一个<code>namespace: custom-namespace</code>属性, 也可以使用<code>kubectl create -f kubia-manual.yaml -n custom-namespace</code> 指定</p>
<p>这事我们有两个pod, 一个在<code>default</code>命名空间, 一个在<code>custom-namespace</code>命名空间</p>
<p><code>kubectl config</code>可以配置</p>
<h4 id="命名空间的隔离"><a href="#命名空间的隔离" class="headerlink" title="命名空间的隔离"></a>命名空间的隔离</h4><p>不提供,至少不是开箱即用/ 尽管命名空间将对象分隔到不同的组, 只允许你对属于特定命名空间的对象进行操作, 但实际上命名空间之间并不提供对正在运行的对象的任何隔离.</p>
<p>比如不同对象在不同命名空间中部署pod, 你觉得他们是隔离的, 但这个取决于kubernetes所使用的网络解决方案.</p>
<h3 id="停止和移除pod"><a href="#停止和移除pod" class="headerlink" title="停止和移除pod"></a>停止和移除pod</h3><h4 id="按名称删除"><a href="#按名称删除" class="headerlink" title="按名称删除"></a>按名称删除</h4><p>实际上是告诉kubernetes终止该pod中的所有容器. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="keyword">delete</span> po kubia-w22k7 <span class="comment">// 还能通过空格删多个</span></span><br><span class="line">pod <span class="string">"kubia-w22k7"</span> deleted</span><br></pre></td></tr></table></figure>
<h4 id="使用标签选择器来删pod"><a href="#使用标签选择器来删pod" class="headerlink" title="使用标签选择器来删pod"></a>使用标签选择器来删pod</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po --show-labels</span><br><span class="line">NAME              READY     STATUS    RESTARTS   AGE       LABELS</span><br><span class="line">kubia-drw74       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>m        run=kubia</span><br><span class="line">kubia-m9zfv       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">19</span>h       run=kubia</span><br><span class="line">kubia-manual      <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">15</span>h       creation_method=manual</span><br><span class="line">kubia-manual-v2   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>h        creation_method=manual,end=debug,env=prod</span><br><span class="line">kubia-q89qr       <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">18</span>h       run=kubia</span><br><span class="line"></span><br><span class="line">$ kubectl <span class="keyword">delete</span> po -l creation_method</span><br><span class="line">pod <span class="string">"kubia-manual"</span> deleted</span><br><span class="line">pod <span class="string">"kubia-manual-v2"</span> deleted</span><br><span class="line"></span><br><span class="line">$ kubectl get po --show-labels      <span class="comment">// 状态变了, 正在停止</span></span><br><span class="line">NAME              READY     STATUS        RESTARTS   AGE       LABELS</span><br><span class="line">kubia-drw74       <span class="number">1</span>/<span class="number">1</span>       Running       <span class="number">0</span>          <span class="number">2</span>m        run=kubia</span><br><span class="line">kubia-m9zfv       <span class="number">1</span>/<span class="number">1</span>       Running       <span class="number">0</span>          <span class="number">19</span>h       run=kubia</span><br><span class="line">kubia-manual      <span class="number">1</span>/<span class="number">1</span>       Terminating   <span class="number">0</span>          <span class="number">15</span>h       creation_method=manual</span><br><span class="line">kubia-manual-v2   <span class="number">1</span>/<span class="number">1</span>       Terminating   <span class="number">0</span>          <span class="number">1</span>h        creation_method=manual,end=debug,env=prod</span><br><span class="line">kubia-q89qr       <span class="number">1</span>/<span class="number">1</span>       Running       <span class="number">0</span>          <span class="number">18</span>h       run=kubia</span><br></pre></td></tr></table></figure>
<h4 id="通过删除整个命名空间删pod"><a href="#通过删除整个命名空间删pod" class="headerlink" title="通过删除整个命名空间删pod"></a>通过删除整个命名空间删pod</h4><p><code>kubectl delete ns custom-namespace</code></p>
<h4 id="删除命名空间所有pod-但命名空间要留着"><a href="#删除命名空间所有pod-但命名空间要留着" class="headerlink" title="删除命名空间所有pod, 但命名空间要留着"></a>删除命名空间所有pod, 但命名空间要留着</h4><p>通过<code>--all</code>删除当前命名空间的素有pod</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubia-drw74   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">4</span>m</span><br><span class="line">kubia-m9zfv   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">19</span>h</span><br><span class="line">kubia-q89qr   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">18</span>h</span><br><span class="line"></span><br><span class="line">$ kubectl <span class="keyword">delete</span> po --all</span><br><span class="line">pod <span class="string">"kubia-drw74"</span> deleted</span><br><span class="line">pod <span class="string">"kubia-m9zfv"</span> deleted</span><br><span class="line">pod <span class="string">"kubia-q89qr"</span> deleted</span><br></pre></td></tr></table></figure>
<p>但是鸡儿还有3个, 但不是原来的名字的pod, 看AGE还是新建的. 问题是一开始我们用<code>ReplicationController</code>的问题, 她会保持3个配额的. 所以删除整个<code>ReplicationController</code>先</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubia<span class="number">-7</span>xgdg   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">46</span>s</span><br><span class="line">kubia-rh2vj   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">46</span>s</span><br><span class="line">kubia-xkm76   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">46</span>s</span><br></pre></td></tr></table></figure>
<h4 id="删除命名空间中几乎所有资源"><a href="#删除命名空间中几乎所有资源" class="headerlink" title="删除命名空间中几乎所有资源"></a>删除命名空间中几乎所有资源</h4><p>直接是<code>all -all</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="keyword">delete</span> all --all</span><br><span class="line">pod <span class="string">"kubia-7xgdg"</span> deleted</span><br><span class="line">pod <span class="string">"kubia-rh2vj"</span> deleted</span><br><span class="line">pod <span class="string">"kubia-xkm76"</span> deleted</span><br><span class="line">replicationcontroller <span class="string">"kubia"</span> deleted</span><br><span class="line">service <span class="string">"kubernetes"</span> deleted</span><br><span class="line">service <span class="string">"kubia-http"</span> deleted</span><br></pre></td></tr></table></figure>
<p>第一个all是所有资源类型<br>第二个all是所有资源实例(并不是完全删, 还有一些会剩下)</p>
<h3 id="4-章-副本机制和其他控制器"><a href="#4-章-副本机制和其他控制器" class="headerlink" title="4 章 副本机制和其他控制器"></a>4 章 副本机制和其他控制器</h3><p>kubernetes的主要好处就是可一个kubernetes一个容器列表来由其保持容器在集群中的运行.</p>
<p>只要将pod调度到某个节点, 该节点上的kubelet就会运行pod的容器, 从此只要该pod存在, 就会保持运行.</p>
<h4 id="4-1-存活探针"><a href="#4-1-存活探针" class="headerlink" title="4.1 存活探针"></a>4.1 存活探针</h4><p>kubernetes可以通过使用探针 liveness probe 检查容器是否还在运行. 可以为pod中的每个容器单独指定存活探针, 如果探测失败, kubernetes将定期执行探针并重新启动容器.</p>
<blockquote>
<p>还支持就绪探针 readiness probe 不要搞混.</p>
</blockquote>
<p>有3种探测容器的机制</p>
<ul>
<li>HTTP GET 探针对容器的IP地址(你指定的端口和路径)执行HTTP GET请求.</li>
<li>TCP 套接字探针尝试与容器指定端口建立TCP连接.</li>
<li>Exec 探针在容器内执行任意命令, 并检查命令的退出状态码.</li>
</ul>
<h5 id="创建HTTP的存活探针"><a href="#创建HTTP的存活探针" class="headerlink" title="创建HTTP的存活探针"></a>创建HTTP的存活探针</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>              <span class="comment"># kubernetes API v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                   <span class="comment"># 是一个pod</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment"># </span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-liveness</span>     <span class="comment"># pod名称</span></span><br><span class="line"><span class="attr">spec:</span>                       <span class="comment"># pod规格 / 内容(pod的容器列表, volume等)</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">luksa/kubia-unhealthy</span>     <span class="comment"># 容器所用镜像</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span>             <span class="comment"># 容器名</span></span><br><span class="line"><span class="attr">    livenessProbe:</span>          <span class="comment"># 一个存活探针</span></span><br><span class="line"><span class="attr">      httpGet:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/</span>             <span class="comment"># http请求路径</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p>然后就是创建, 接着查看pod</p>
<p>还有查看log, 加上—previous可以看前一个容器的日志.</p>
<p>在用describe中可以看到错误码 Exit code 137这种. 还有附加信息显示. 在yaml中也可以配置<br>137是128+x</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>              <span class="comment"># kubernetes API v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                   <span class="comment"># 是一个pod</span></span><br><span class="line"><span class="attr">metadata:</span>                   <span class="comment"># </span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-liveness</span>     <span class="comment"># pod名称</span></span><br><span class="line"><span class="attr">spec:</span>                       <span class="comment"># pod规格 / 内容(pod的容器列表, volume等)</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">luksa/kubia-unhealthy</span>     <span class="comment"># 容器所用镜像</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span>             <span class="comment"># 容器名</span></span><br><span class="line"><span class="attr">    livenessProbe:</span>          <span class="comment"># 一个存活探针</span></span><br><span class="line"><span class="attr">      httpGet:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/</span>             <span class="comment"># http请求路径</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      initialDelaySeconds:</span> <span class="number">15</span>   <span class="comment"># 会在第一次探测前等待15秒</span></span><br></pre></td></tr></table></figure>
<p>一般都会设置延迟, 保证应用程序已经启动了running的状态</p>
<h4 id="4-2-了解ReplicationController"><a href="#4-2-了解ReplicationController" class="headerlink" title="4.2 了解ReplicationController"></a>4.2 了解ReplicationController</h4><p>ReplicationController是一种 kubernetes 资源, 可确保它的pod始终保持运行.</p>
<p>图4.1</p>
<h5 id="ReplicationController的操作"><a href="#ReplicationController的操作" class="headerlink" title="ReplicationController的操作"></a>ReplicationController的操作</h5><p>ReplicationController不是根据pod类型来操作的, 而是根据pod是否匹配某个标签选择器<br>他的工作是确保pod的数量始终与其标签选择器匹配.</p>
<p>有3个部分:</p>
<ul>
<li>label selector: 用于确定 ReplicationController 作用域中有哪些pod</li>
<li>replica count: 指定运行的pod数量</li>
<li>pod template: 用于创建新的pod副本模板</li>
</ul>
<p>图4.3</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1120412" target="_blank" rel="noopener">基于Docker for macOS的Kubernetes本地环境搭建与应用部署</a><br><a href="https://cloud.tencent.com/developer/article/1077486" target="_blank" rel="noopener">Docker集群编排工具之Kubernetes（K8s）介绍、安装及使用</a><br><a href="https://blog.docker.com/2018/01/docker-mac-kubernetes/" target="_blank" rel="noopener">DOCKER FOR MAC WITH KUBERNETES</a><br><a href="http://docs.kubernetes.org.cn/" target="_blank" rel="noopener">Kubernetes中文社区 | 中文文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/yarn的使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/yarn的使用/" itemprop="url">yarn的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T19:32:25+08:00">2019-03-05</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端教程/" itemprop="url" rel="index"><span itemprop="name">前端教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="yarn的使用"><a href="#yarn的使用" class="headerlink" title="yarn的使用"></a>yarn的使用</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化新项目</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn init</span><br></pre></td></tr></table></figure>
<p>添加依赖包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add [package]</span><br><span class="line">yarn add [package]@[version]</span><br><span class="line">yarn add [package]@[tag]</span><br></pre></td></tr></table></figure>
<p>将依赖项添加到不同依赖项类别</p>
<p>分别添加到 <code>devDependencies</code>、<code>peerDependencies</code> 和 <code>optionalDependencies</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add [package] --dev/-D</span><br><span class="line">yarn add [package] --peer/-P</span><br><span class="line">yarn add [package] --optional/-O</span><br></pre></td></tr></table></figure>
<p>全局安装</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add &lt;package...&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>yarn add global &lt;package...&gt;</code>会变成本地安装，注意顺序。</p>
</blockquote>
<p>升级依赖包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn upgrade [package]</span><br><span class="line">yarn upgrade [package]@[version]</span><br><span class="line">yarn upgrade [package]@[tag]</span><br></pre></td></tr></table></figure>
<p>移除依赖包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn remove [package]</span><br></pre></td></tr></table></figure>
<p>安装项目的全部依赖</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">yarn install</span><br></pre></td></tr></table></figure>
<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><h4 id="yarn-cache"><a href="#yarn-cache" class="headerlink" title="yarn cache"></a>yarn cache</h4><p>运行 <code>yarn cache dir</code>会打印出当前的 yarn 全局缓存在哪里。</p>
<p><code>yarn cache list --pattern &lt;pattern&gt;</code> 将列出匹配指定模式的已缓存的包。</p>
<p>示例：<code>yarn cache list --pattern &quot;gulp-(match|newer)&quot;</code></p>
<p><code>yarn cache clean</code>运行此命令将清除全局缓存。</p>
<p>将在下次运行 <code>yarn</code> 或 <code>yarn install</code> 时重新填充。</p>
<h4 id="yarn-list"><a href="#yarn-list" class="headerlink" title="yarn list"></a>yarn list</h4><p><code>yarn list [--depth] [--pattern]</code></p>
<p>默认情况下，所有包和它们的依赖会被显示。 <strong>要限制依赖的深度</strong>，你可以给 <code>list</code> 命令添加一个标志 <code>--depth</code> 所需的深度。<br>示例: <code>yarn list --depth=0</code></p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><h4 id="yarn-run"><a href="#yarn-run" class="headerlink" title="yarn run"></a>yarn run</h4><p><code>yarn run [script] [&lt;args&gt;]</code></p>
<p>如果你已经在你的包里定义了 <code>scripts</code>，这个命令会运行指定的 <code>[script]</code>。例如：<br>运行这个命令会执行你的 <code>package.json</code> 里名为 <code>&quot;test&quot;</code> 的脚本。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yarnpkg.com/zh-Hans/docs/usage" target="_blank" rel="noopener">官网使用</a><br><a href="https://www.jianshu.com/p/f5d85e541a99" target="_blank" rel="noopener">yarn 常用命令</a><br><a href="https://www.kancloud.cn/shellway/yarn-notes/262504" target="_blank" rel="noopener">命令列表</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/travis配置文件的编写/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/travis配置文件的编写/" itemprop="url">travis配置文件的编写</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T14:08:21+08:00">2019-03-05</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端教程/" itemprop="url" rel="index"><span itemprop="name">前端教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="travis配置文件的编写"><a href="#travis配置文件的编写" class="headerlink" title="travis配置文件的编写"></a>travis配置文件的编写</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">dist:</span> <span class="string">trusty</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="string">required</span></span><br><span class="line"><span class="attr">matrix:</span></span><br><span class="line"><span class="attr">  include:</span></span><br><span class="line"><span class="attr">    - language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">      node_js:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">8.15</span><span class="number">.0</span></span><br><span class="line"><span class="attr">      env:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">TRAVIS_SECURE_ENV_VARS=false</span></span><br><span class="line"><span class="attr">      addons:</span></span><br><span class="line"><span class="attr">        apt:</span></span><br><span class="line"><span class="attr">          sources:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">ubuntu-toolchain-r-test</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">mysql-5.7-trusty</span></span><br><span class="line"><span class="attr">          packages:</span></span><br><span class="line"><span class="attr">      branches:</span></span><br><span class="line"><span class="attr">        only:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">master</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">      before_install:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">echo</span> <span class="bullet">-e</span> <span class="string">"machine github.com\n login $CI_USER_TOKEN\n password x-oauth-basic"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.netrc</span></span><br><span class="line">        <span class="comment"># Repo for Yarn</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">sudo</span> <span class="string">apt-key</span> <span class="string">adv</span> <span class="bullet">--fetch-keys</span> <span class="attr">http://dl.yarnpkg.com/debian/pubkey.gpg</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">echo</span> <span class="string">"deb http://dl.yarnpkg.com/debian/ stable main"</span> <span class="string">| sudo tee /etc/apt/sources.list.d/yarn.list</span></span><br><span class="line"><span class="string">        - sudo apt-get update -qq</span></span><br><span class="line"><span class="string">        - sudo apt-get install -y -qq yarn=1.12.3-1</span></span><br><span class="line"><span class="string"></span><span class="attr">      script:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">node</span> <span class="bullet">-v</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">yarn</span> <span class="bullet">-v</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">./travis-script.sh</span></span><br><span class="line"><span class="attr">      cache:</span></span><br><span class="line"><span class="attr">        yarn:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        directories:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">$TRAVIS_BUILD_DIR/project-template/client/node_modules</span></span><br></pre></td></tr></table></figure>
<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>需不需要<code>sudo</code>权限 一般是要的<code>require</code></p>
<h3 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h3><p>相当于就是一个几乘几的各种情况, 自动给你跑, 也可以<code>include</code>, 也可以<code>exclude</code>下.</p>
<p>exclude的要精确匹配 env 这种</p>
<h3 id="addons"><a href="#addons" class="headerlink" title="addons"></a>addons</h3><p>额外的软件包</p>
<h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><p>就是环境咯, <code>TRAVIS_SECURE_ENV_VARS=false</code>不加密</p>
<h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><p>要进行CI的分支, 可以写safelist<code>only</code>和blocklist<code>except</code></p>
<h3 id="在before-install下"><a href="#在before-install下" class="headerlink" title="在before_install下"></a>在<code>before_install</code>下</h3><p>第一条命令: <code>echo -e &quot;machine github.com\n  login $CI_USER_TOKEN&quot; &gt; ~/.netrc</code>, 用来将登陆配置信息追加写入<code>~/.netrc</code>中, 方便以后登录不用填用户名密码.<br><a href="https://docs.travis-ci.com/user/private-dependencies/#api-token" target="_blank" rel="noopener">travis API Token machine github.com\n</a></p>
<p>第二条命令: <code>apt-key adv --fetch-keys</code> will only fetch one key from the URL, and if the URL contains multiple keys, please use <code>wget | apt-key add instead</code>.</p>
<p>第三条命令: <code>tee</code>用来从标准输入中读, 然后便准输出. 就是一个复制粘贴的功能. 所以后面就是将 <code>deb http://dl.yarnpkg.com/debian/ stable main</code> 写入 <code>yarn.list</code> 中</p>
<p>第四第五条命令: 就是更新软件库表, 然后安装上 <code>yarn</code></p>
<blockquote>
<p>整个第2-5条命令就是在安装<code>yarn</code> <a href="https://yarnpkg.com/en/docs/install#debian-stable" target="_blank" rel="noopener">https://yarnpkg.com/en/docs/install#debian-stable</a></p>
</blockquote>
<h3 id="script"><a href="#script" class="headerlink" title="script"></a><code>script</code></h3><p>就是这个travis要跑的脚本.</p>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>就是cache, 看教程就是这么写的, <code>$TRAVIS_BUILD_DIR</code>就是当前<code>.travis.yml</code>所在的目录.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html" target="_blank" rel="noopener">持续集成服务 Travis CI 教程 阮一峰 666</a></p>
<p><a href="https://docs.travis-ci.com/user/languages/javascript-with-nodejs/" target="_blank" rel="noopener">Building a JavaScript and Node.js project</a></p>
<p><a href="https://docs.travis-ci.com/user/private-dependencies/#api-token" target="_blank" rel="noopener">travis API Token machine github.com\n</a><br><a href="https://blog.csdn.net/du_chao_qun/article/details/53464454" target="_blank" rel="noopener">.netrc文件简单使用</a><br><a href="http://lujun9972.github.io/blog/2017/05/25/%E4%BD%BF%E7%94%A8auth-source%E5%BA%93%E8%AF%BB%E5%8F%96netrc%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81/" target="_blank" rel="noopener">使用auth-source库读取Netrc文件中的用户名和密码</a><br><a href="https://blog.csdn.net/wenxuechaozhe/article/details/52564394" target="_blank" rel="noopener">linux &gt;和&gt;&gt;的区别</a></p>
<p><a href="http://blog.51yip.com/linux/1176.html" target="_blank" rel="noopener">apt-get 命令详解(中文),以及实例</a><br><a href="https://yarnpkg.com/en/docs/install#debian-stable" target="_blank" rel="noopener">https://yarnpkg.com/en/docs/install#debian-stable</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/20/preiiter代码格式美化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/20/preiiter代码格式美化/" itemprop="url">preiiter代码格式美化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-20T20:39:17+08:00">2019-02-20</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/vsc插件/" itemprop="url" rel="index"><span itemprop="name">vsc插件</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="preiiter代码格式美化"><a href="#preiiter代码格式美化" class="headerlink" title="preiiter代码格式美化"></a>preiiter代码格式美化</h1><p>从<code>EditorConfig</code>到各种<code>***Lint</code>, 再到 <code>prettier</code>。 其实就是一起用</p>
<p>为什么要用Prettier</p>
<p>用来替代<code>*lint</code>中的一些场景，比如说分号/tab缩进/空格/引号，这些在lint工具检查出问题之后<strong>还需要手动修改</strong>，而通常这样的错误都是空格或者符号之类的，这样相对来说不太优雅，利用格式化工具自动生成省时省力。</p>
<h2 id="搞起"><a href="#搞起" class="headerlink" title="搞起"></a>搞起</h2><h2 id="在项目中"><a href="#在项目中" class="headerlink" title="在项目中"></a>在项目中</h2><p><a href="https://juejin.im/post/59ddc2a751882578c17e9ccf" target="_blank" rel="noopener">为什么用Prettier 66</a></p>
<p>安装完依赖, <code>npm install --save-dev prettier</code>后, 执行常见的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prettier --single-quote --trailing-comma es5 --write <span class="string">"&#123;app,__&#123;tests,mocks&#125;__&#125;/**/*.js"</span></span><br><span class="line">或</span><br><span class="line">prettier -l --write <span class="string">'src/**/*.&#123;ts,tsx,less,css&#125;'</span> --no-semi --single-quote</span><br></pre></td></tr></table></figure>
<h3 id="在vscode中"><a href="#在vscode中" class="headerlink" title="在vscode中"></a>在vscode中</h3><p>首先安装<code>vscode</code>的插件<code>Prettier-Code formatter</code></p>
<p>安装成功后，编辑器默认的格式化处理就会被<code>prettier</code>代替， 默认快捷键是<code>alt + shift + f</code></p>
<p>插件安装成功后，按<code>cmd+,</code>调出编辑器的配置,会出现<code>prettier</code>插件的相关配置节点，同时也能看到一些默认的配置信息, 在<code>setting.json</code>中也可以自己定义。  </p>
<p>更多的配置方式<br><a href="https://prettier.io/docs/en/configuration.html" target="_blank" rel="noopener">Configuration File</a></p>
<h2 id="其他的prettier"><a href="#其他的prettier" class="headerlink" title="其他的prettier"></a>其他的prettier</h2><p>除了直接用<code>prettier</code>, 还有像<code>tslint-config-prettier</code>这种prettier</p>
<h2 id="typescript配置prettier"><a href="#typescript配置prettier" class="headerlink" title="typescript配置prettier"></a>typescript配置prettier</h2><ul>
<li>文件保存时执行一次格式化</li>
<li>迁移已有代码的格式</li>
<li>代码提交前进行一次格式化</li>
</ul>
<p>首先确认了 <code>Prettier</code> 对 <code>TypeScript</code> 有良好的支持.</p>
<h3 id="保存时格式化"><a href="#保存时格式化" class="headerlink" title="保存时格式化"></a>保存时格式化</h3><p>但我更喜欢保存时只是做一点比如去掉多余的空格, 按<code>alt + shift + f</code>才进行格式化.</p>
<p>在vsc中安装完插件后, 配置<code>prettierrc</code> 文件, 临时的配置比如:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tabWidth"</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">"useTabs"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多配置文件方式<br><a href="https://prettier.io/docs/en/configuration.html" target="_blank" rel="noopener">Configuration File</a></p>
<p>然后<code>cmd+,</code>调出编辑器的配置, 设置<code>editor.formatOnSave</code> 选项.把值设置为 <code>true</code>.</p>
<h3 id="代码提交前"><a href="#代码提交前" class="headerlink" title="代码提交前"></a>代码提交前</h3><p><a href="https://juejin.im/post/59ddc2a751882578c17e9ccf" target="_blank" rel="noopener">为什么用Prettier 66</a></p>
<h2 id="已经有了ESlint下"><a href="#已经有了ESlint下" class="headerlink" title="已经有了ESlint下"></a>已经有了ESlint下</h2><p><a href="https://juejin.im/post/5ae91143f265da0ba60f97ea" target="_blank" rel="noopener">Prettier 介绍与基本用法 6</a></p>
<h3 id="使用ESLint运行Prettier"><a href="#使用ESLint运行Prettier" class="headerlink" title="使用ESLint运行Prettier"></a>使用ESLint运行Prettier</h3><p>如果你已经在你的项目中使用<code>ESLint</code>并且想要只通过<strong>单独一条命令</strong>来执行你的所有的代码检查的话，你可以使用<code>ESLint</code>来为你运行<code>Prettier</code>。</p>
<p>只需要使用<code>eslint-plugin-prettier</code>来添加<code>Prettier</code>作为<code>ESLint</code>的<strong>规则配置</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev prettier eslint-plugin-prettier</span><br></pre></td></tr></table></figure>
<p><strong>.eslintrc.json</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"prettier"</span>],</span><br><span class="line">  <span class="string">"rules"</span>: &#123;</span><br><span class="line">    <span class="string">"prettier/prettier"</span>: <span class="string">"error"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关闭ESLint的格式规则"><a href="#关闭ESLint的格式规则" class="headerlink" title="关闭ESLint的格式规则"></a>关闭ESLint的格式规则</h3><p><strong>你是否通过<code>ESLint</code>来运行<code>Prettier</code>，又或者是单独运行两个工具</strong>，那你大概<strong>只想要每个格式问题只出现一次</strong>，而且你特别不想要<code>ESLint</code>仅仅是和<code>Prettier</code>有简单的不同和偏好而报出“问题”。</p>
<p>所以你大概想要<strong>禁用冲突的规则</strong>（当保留其他<code>Prettier</code>不关心的规则时）最简单的方式是使用<code>eslint-config-prettier</code>。它可以添加到任何<code>ESLint</code>配置上面。</p>
<h2 id="345345总"><a href="#345345总" class="headerlink" title="345345总"></a>345345总</h2><p>目标是有两个setting,<br>一个是user的setting, 设置好自己对常用的语言的一些代码规范<br>一个是workspace的setting, 是读取要工作的项目文件中的文件, 来保持项目的代码规范<br>(先设置自己的user, 在读取项目中的<code>setting</code>)</p>
<p>然后自己对于<code>cmd+s</code>的情况是只去掉空格, 而不格式化,用<code>alt+shift+f</code>是来手动格式化, 然后<code>pre-commit</code>前会最好自动格式化下</p>
<p>从EditorConfig到xxLint, 到prettier.  prettier只暴力格式化, xxlint是检查</p>
<p>安装prettier的话有2种, 一种是在vsc中安装插件<code>prettier code format</code><br>一种是在项目中用<code>npm</code>或<code>yarn</code>安装dev依赖, <strong>依赖项目, 不依赖编辑器</strong><br>2者略有不同.</p>
<h3 id="项目npm-yarn中后"><a href="#项目npm-yarn中后" class="headerlink" title="项目npm, yarn中后"></a>项目npm, yarn中后</h3><p>项目中的就是比如<code>npm</code>安装完后, 就可以在script中写个prettier的格式命令, 然后<code>yarn prettier</code>下</p>
<p>常见的命令是<code>prettier --write --config .prettierrc src/*.ts</code> 当然还要一些prettier的参数等会看 比如<code>{}</code>, <code>[]</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这个是对前端的, 后面不加分号</span><br><span class="line">prettier -l --write 'src/**/*.&#123;ts,tsx,less,css&#125;' --no-semi --single-quote</span><br><span class="line"># 这个是后端的js 加分号</span><br><span class="line">prettier -l --write 'app/**/*.js' --single-quote</span><br><span class="line"># 这个是按.prettierrc中的格式</span><br><span class="line">prettier --write --config .prettierrc src/*.ts</span><br></pre></td></tr></table></figure>
<p>当然可以在<code>package.json</code>中的<code>script</code>写<code>prettier</code>搞定.<br>而在<code>package.json</code>中的<code>prettier</code>写是自定义格式选项. 一般不会用这个</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"prettier": &#123;</span><br><span class="line">    "singleQuote": true,</span><br><span class="line">    "semi": false,</span><br><span class="line">    "printWidth": 120,</span><br><span class="line">    "proseWrap": "never"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>查看prettier中内置的一些<code>formatter</code></p>
<h3 id="vsc中"><a href="#vsc中" class="headerlink" title="vsc中"></a>vsc中</h3><p>在vsc中多说下, 首先vsc有自己的格式方式, 按<code>cmd+k m</code>可以查看到许多语言, 然后是你可以自己配置<code>Configure &#39;language_name&#39; language based settings.</code>, 跳转到<code>setting.json</code> 中写这种(和你用<code>cmd+shift+p</code>在输入<code>preferences: config</code>这种快多了)</p>
<p>这里的保存后格式化是对当前文件吧, 而不是本项目中所有的.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Set the default</span><br><span class="line">"editor.formatOnSave": false,</span><br><span class="line">// Enable per-language</span><br><span class="line">"[javascript]": &#123;</span><br><span class="line">    "editor.formatOnSave": true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在<code>cmd+,</code>中看<code>setting.json</code> 中可以自己直接改</p>
<p>vsc的配置, workspace setting在项目根目录<code>.vscode</code>中, 但我找不到. 一般我在里面写debug的文件, 比如egg的那个配置</p>
<h3 id="各种不同的prettier"><a href="#各种不同的prettier" class="headerlink" title="各种不同的prettier"></a>各种不同的prettier</h3><p>常见的<a href="https://prettier.io/docs/en/configuration.html" target="_blank" rel="noopener">prettier文件</a></p>
<ul>
<li>A <code>.prettierrc</code> file, written in YAML or JSON, with optional extensions: <code>.yaml/.yml/.json</code>.</li>
<li>A <code>.prettierrc.toml</code> file, written in TOML (the .toml extension is required).</li>
<li>A <code>prettier.config.js</code> or <code>.prettierrc.js</code> file that exports an object.</li>
<li>A <code>&quot;prettier&quot;</code> key in your <code>package.json</code> file.</li>
</ul>
<p>常见的4种吧, 首先是<code>.prettierrc</code>, 你可以在里面用<code>YAML or JSON</code>格式来写, 其次是<code>.prettierrc.toml</code>, 用<code>TOML</code>格式来写 算一类吧, 我们常见的事用<code>JSON</code>写<br>还有就是用<code>prettier.config.js</code> or <code>.prettierrc.js</code>这种导出一个对象来写<br>最后就是在<code>package.json</code>中的<code>&quot;prettier&quot;</code>, 一般就是在<code>script</code>中写呗, 不会单独搞一个属性</p>
<p>当然<code>.editorconfig, .babelrc, .eslintrc, .prettierrc</code> 都挺常见的</p>
<h3 id="对于我常用的配置"><a href="#对于我常用的配置" class="headerlink" title="对于我常用的配置"></a>对于我常用的配置</h3><p>ts, tsx, js, jsx, md这些文件, 在setting.json中可以单独配置user的, 还有css, less 都可以</p>
<p>但是不能配合<code>prettier</code>用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  // js</span><br><span class="line">"[javascript]": &#123;</span><br><span class="line">  "editor.formatOnSave": true,</span><br><span class="line">  "editor.formatOnPaste": false</span><br><span class="line">&#125;,</span><br><span class="line">// jsx</span><br><span class="line">"[javascriptreact]": &#123;</span><br><span class="line">  "editor.formatOnSave": true,</span><br><span class="line">  "editor.formatOnPaste": false</span><br><span class="line">&#125;,</span><br><span class="line">// ts</span><br><span class="line">"[typescript]": &#123;</span><br><span class="line">  "editor.formatOnSave": true,</span><br><span class="line">  "editor.formatOnPaste": false</span><br><span class="line">&#125;,</span><br><span class="line">// tsx</span><br><span class="line">"[typescriptreact]": &#123;</span><br><span class="line">  "editor.formatOnSave": true,</span><br><span class="line">  "editor.formatOnPaste": false</span><br><span class="line">&#125;</span><br><span class="line">// md</span><br><span class="line">"[markdown]": &#123;&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="下面链接中讲了详细使用prettier"><a href="#下面链接中讲了详细使用prettier" class="headerlink" title="下面链接中讲了详细使用prettier"></a>下面链接中讲了详细使用prettier</h3><p><a href="https://survivejs.com/maintenance/code-quality/code-formatting/" target="_blank" rel="noopener">Code Formatting 6666 各种配置</a></p>
<h3 id="读取顺序"><a href="#读取顺序" class="headerlink" title="读取顺序"></a>读取顺序</h3><p>先从vsc的市场中可以看到, setting会先从</p>
<ol>
<li>prettier 的配置文件读, 也就是前面说的4种</li>
<li>没有的话从<code>.editorconfig</code>这个小老鼠读</li>
<li>最后才是从默认的vsc的prettier setting</li>
</ol>
<p>再说下一下默认在vsc中插件prettier设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 一行最大80个字符</span><br><span class="line">prettier.printWidth (default: 80)</span><br><span class="line"></span><br><span class="line">// 使用tab代表几个空格</span><br><span class="line">prettier.tabWidth (default: 2)</span><br><span class="line"></span><br><span class="line">// 是否使用单引号代替双引号</span><br><span class="line">prettier.singleQuote (default: false)</span><br><span class="line"></span><br><span class="line">// 末尾的逗号, 3个选项, "none"就是无, "es5"会在例如对象和数组, "all"是包括函数参数</span><br><span class="line">prettier.trailingComma (default: 'none')</span><br><span class="line"></span><br><span class="line">// 控制对象字面量里面的空格</span><br><span class="line">prettier.bracketSpacing (default: true)</span><br><span class="line"></span><br><span class="line">// 如果为true, 在多行的jsx元素中, 最后的 &gt; 单独一行,而不是跟在最后一样的末尾</span><br><span class="line">prettier.jsxBracketSameLine (default: false)</span><br><span class="line"></span><br><span class="line">// 用什么 parser .只有 'flow' 和 'babylon'.</span><br><span class="line">prettier.parser (default: 'babylon') - JavaScript only</span><br><span class="line"></span><br><span class="line">// 在每行的末尾加上分号 true. false就是用ASI, 看链接参考</span><br><span class="line">prettier.semi (default: true)</span><br><span class="line"></span><br><span class="line">// 缩进用不用tab</span><br><span class="line">prettier.useTabs (default: false)</span><br><span class="line"></span><br><span class="line">// (Markdown) wrap prose over multiple lines.</span><br><span class="line">prettier.proseWrap (default: 'preserve')</span><br><span class="line"></span><br><span class="line">// 对只有一个参数的箭头函数的这个参数, 用不用圆括号包上</span><br><span class="line">prettier.arrowParens (default: 'avoid')</span><br><span class="line"></span><br><span class="line">// 在jsx中用单引号而不是双引号</span><br><span class="line">prettier.jsxSingleQuote (default: false)</span><br><span class="line"></span><br><span class="line">// 对html文件空格敏感, 有更多选项</span><br><span class="line">prettier.htmlWhitespaceSensitivity (default: 'css')</span><br><span class="line"></span><br><span class="line">// 对每行末尾通过prettier自己设定, 有更多选项</span><br><span class="line">prettier.endOfLine (default: 'auto')</span><br></pre></td></tr></table></figure>
<p>然后是vsc中特殊指定的, 通过<code>setting.json</code>可以改 <a href="https://code.visualstudio.com/docs/getstarted/settings" target="_blank" rel="noopener">User and Workspace Settings</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 使用 prettier-eslint 代替 prettier.</span><br><span class="line">prettier.eslintIntegration (default: false) - JavaScript and TypeScript only</span><br><span class="line"></span><br><span class="line">// 使用 prettier-tslint 代替 prettier.</span><br><span class="line">prettier.tslintIntegration (default: false) - JavaScript and TypeScript only</span><br><span class="line"></span><br><span class="line">// 使用 prettier-stylelint 代替 prettier.</span><br><span class="line">prettier.stylelintIntegration (default: false) - CSS, SCSS and LESS only</span><br><span class="line"></span><br><span class="line">// 需要一个 a 'prettierconfig' 文件来格式化</span><br><span class="line">prettier.requireConfig (default: false)</span><br><span class="line"></span><br><span class="line">// 支持写一个 .gitignore 或 .prettierignore 这样的文件来忽略项目中哪些路径下的不进行格式化. 需要重启下vsc</span><br><span class="line">prettier.ignorePath (default: .prettierignore)</span><br><span class="line"></span><br><span class="line">// 对一些特定语言不进行用prettier的格式化. 在父目录下设置也会组织所有子目录下的配置</span><br><span class="line">prettier.disableLanguages (default: ["vue"])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>vsc中的<code>prettier</code>插件也是会依赖项目中的本地依赖, 就是前面的优先级.</p>
</blockquote>
<h4 id="vsc中的setting"><a href="#vsc中的setting" class="headerlink" title="vsc中的setting"></a>vsc中的setting</h4><p>按<code>cmd+,</code>打开, 有两种不同的设定</p>
<ul>
<li>User Settings - 这是全局的设定</li>
<li>Workspace Settings - 指定的workspace打开才会应用, 这个优先级高. 常用在小组中分享项目设定. 在<code>.vscode</code>文件中de <code>.settings.json</code>,  <code>launch.json</code>是用来debug的</li>
</ul>
<p>改变会需要重启下vsc, 也有不需要重启的, 自己点着试试, 先看Commonly Userd =&gt; workbench  看下去</p>
<p>对于workspace setting在一个文件下当然可以加一个<code>.vacode</code>文件夹, 但当有一个根文件下有很多项目时呢. 比如ava<br>那就在根目录下写一个<code>Global Workspace settings</code> 叫<code>.code-workspace</code>文件</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"folders"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"vscode"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"vscode-docs"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"vscode-generator-code"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"window.zoomLevel"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"files.autoSave"</span>: <span class="string">"afterDelay"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如debugging的东西就写在<code>.vscode</code>文件夹下的<code>lounch.json</code>中</p>
<p>然后就是语言指定配置, 这个在前面讲过<code>cmd+k, m</code></p>
<h3 id="prettier的默认配置"><a href="#prettier的默认配置" class="headerlink" title="prettier的默认配置"></a>prettier的默认配置</h3><p><a href="https://prettier.io/docs/en/options.html" target="_blank" rel="noopener">options.</a></p>
<h3 id="prettierc常用命令参数"><a href="#prettierc常用命令参数" class="headerlink" title="prettierc常用命令参数"></a>prettierc常用命令参数</h3><p>基本命令就是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prettier [opts] [filename ...]</span><br></pre></td></tr></table></figure>
<p>实际中常用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prettier --single-quote --trailing-comma es5 --write <span class="string">"&#123;app,__&#123;tests,mocks&#125;__&#125;/**/*.js"</span></span><br></pre></td></tr></table></figure>
<p>默认是不会访问<code>node_modules</code>文件夹中的, 需要访问的话加参数<code>--with-node-modules</code></p>
<h4 id="CLI的一些其他参数"><a href="#CLI的一些其他参数" class="headerlink" title="CLI的一些其他参数"></a>CLI的一些其他参数</h4><p>讲的主要是比<code>option</code>多一点的东西.</p>
<h5 id="check或-c"><a href="#check或-c" class="headerlink" title="--check或-c"></a><code>--check</code>或<code>-c</code></h5><p>就是check下文件是否格式化了, 也经常配合在<code>pre-commit hook</code>前使用,<br>如果是想讲这些没格式化的文件输出给下一个命令, 就用<code>--list-different</code>. 两者还是有区别的</p>
<h5 id="debug-check"><a href="#debug-check" class="headerlink" title="--debug-check"></a><code>--debug-check</code></h5><p>如果你怕<code>prettier</code>改变你正确的代码, 那么用这个. 当然<code>--write</code>是不能配合这个用了.</p>
<h5 id="find-config-path-和-config"><a href="#find-config-path-和-config" class="headerlink" title="--find-config-path 和 --config"></a><code>--find-config-path</code> 和 <code>--config</code></h5><p>当你经常去格式化那些指定目录的文件时, <code>prettier</code>会先尝试读取配置文件的信息, <strong>造成性能有点缺失</strong>, 所以你可以用这个命令配置好, 先读第一次, 之后就重用第一次的配置.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prettier --find-config-path ./my/file.js</span><br><span class="line">./my/.prettierrc  <span class="comment">// 这是配置文件</span></span><br></pre></td></tr></table></figure>
<p>而这里是, 直接提供一个配置文件路径<code>--config</code>, 当然可以任意指定配置文件在哪了.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prettier --config ./my/.prettierrc --write ./my/file.js</span><br></pre></td></tr></table></figure>
<p>不想要配置文件用<code>--no-config</code>, 默认配置就是不查找.</p>
<h5 id="ignore-path"><a href="#ignore-path" class="headerlink" title="--ignore-path"></a><code>--ignore-path</code></h5><p>用来忽略一些不需要格式化的目录中的文件, 比如 <code>./.prettierignore</code></p>
<h5 id="require-pragma"><a href="#require-pragma" class="headerlink" title="--require-pragma"></a><code>--require-pragma</code></h5><p>pragma指需要一些特别的comment.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @prettier  // @prettier 或 @format</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h5 id="insert-pragma"><a href="#insert-pragma" class="headerlink" title="--insert-pragma"></a><code>--insert-pragma</code></h5><p>在没有pragma的时候会插入<code>@format</code>这种pragma到格式化文件最顶端, 配合<code>--require-pragma</code>一起用</p>
<h5 id="list-different或-l"><a href="#list-different或-l" class="headerlink" title="--list-different或-l"></a><code>--list-different</code>或<code>-l</code></h5><p>这是另一个常用的flag, 会打印出prettier格式化前后不同的文件名.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prettier --single-quote --list-different <span class="string">"src/**/*.js"</span></span><br></pre></td></tr></table></figure>
<p>也可以用<code>--check</code>, 这个打印出跟人性化的信息</p>
<h5 id="config-precedence"><a href="#config-precedence" class="headerlink" title="--config-precedence"></a><code>--config-precedence</code></h5><p>config file文件中的配置优先级高还是 CLI options中的高</p>
<ul>
<li>config file 指的是配置文件</li>
<li><p>CLI options 指的是输入的命令参数</p>
</li>
<li><p>cli-override (default)</p>
<ul>
<li>默认cli中高, 也就是默认的prettier的配置高</li>
</ul>
</li>
<li>file-override<ul>
<li>config file中的高</li>
</ul>
</li>
<li>prefer-file<ul>
<li>如果配置文件找到了, 就按配置文件, 没找到就用CLI的</li>
</ul>
</li>
</ul>
<p>常用来整合编辑器中的, 比如用户定义了自己的配置, 但还是尊重项目的定的配置.</p>
<h5 id="no-editorconfig"><a href="#no-editorconfig" class="headerlink" title="--no-editorconfig"></a><code>--no-editorconfig</code></h5><p>不考虑小老鼠了, 具体看<a href="https://prettier.io/docs/en/api.html" target="_blank" rel="noopener">API</a>中的信息</p>
<h5 id="with-node-modules"><a href="#with-node-modules" class="headerlink" title="--with-node-modules"></a><code>--with-node-modules</code></h5><p>默认不会访问, 加了后就去访问格式化咯.</p>
<h5 id="write"><a href="#write" class="headerlink" title="--write"></a><code>--write</code></h5><p>就地改正, 按prettier的格式</p>
<h5 id="loglevel"><a href="#loglevel" class="headerlink" title="--loglevel"></a><code>--loglevel</code></h5><p>改一下CLI的log等级</p>
<ul>
<li>error</li>
<li>warn</li>
<li>log (default)</li>
<li>debug</li>
<li>silent</li>
</ul>
<h5 id="stdin-filepath"><a href="#stdin-filepath" class="headerlink" title="--stdin-filepath"></a><code>--stdin-filepath</code></h5><p>prettier CLI当做<code>stdin</code>的文件路径, 比如</p>
<p>abc.css</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.name</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat abc.css | prettier --stdin-filepath abc.css</span></span><br><span class="line">.name &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="API-用来setting-json中的"><a href="#API-用来setting-json中的" class="headerlink" title="API 用来setting.json中的"></a>API 用来setting.json中的</h4><p>不推荐, 就是直接在js中写</p>
<h4 id="默认的option"><a href="#默认的option" class="headerlink" title="默认的option"></a>默认的option</h4><p><a href="https://segmentfault.com/a/1190000012909159" target="_blank" rel="noopener">prettier的配置选项（参数）官网直译</a></p>
<p>总结下就是</p>
<ul>
<li>一行超过多少个字符换行, markdown也需要强制换行么. 末尾加不加分号, 换行后<code>&gt;</code>在哪</li>
<li>对象字面量前后加空格么, 最后一个属性加逗号么, 单引号代替双引号么, 箭头寒素参数括号么.</li>
<li>缩进用tab还是空格, 一个tab几个空格</li>
<li>html默认, endOfLine默认, parser, filePath, pragma. range默认</li>
<li><strong>关注点还是末尾js加分号, tsx不加,多一个—no-semi, 然后都用单引号</strong> 比vsc的配置多一点点</li>
</ul>
<h5 id="Print-Width"><a href="#Print-Width" class="headerlink" title="Print Width"></a>Print Width</h5><p>指定一行不能超过多少长, 长了换行, 报错是xxlint的事</p>
<p>为了可读写, 建议不要超过80个字符的, 因为人阅读的时候一般不会超过100-120的, <code>prettier</code>的话倒是希望每行越长越好.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>80</td>
<td><code>--print-width &lt;int&gt;</code></td>
<td><code>printWidth: &lt;int&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>如果你不想在<code>markdown</code>中限定换行, 可以用<code>Prose Wrap</code>来关闭它, 默认<code>preserve</code>是保持<code>markdown</code>的<code>as-is</code></p>
</blockquote>
<h5 id="Tab-Width"><a href="#Tab-Width" class="headerlink" title="Tab Width"></a>Tab Width</h5><p>一个缩进等级代表几个空格</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td><code>--tab-width &lt;int&gt;</code></td>
<td><code>tabWidth: &lt;int&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h5><p>缩进的行用tab而不是用空格</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td><code>--use-tabs</code></td>
<td><code>useTabs: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<p>tab常用来缩进,但在prettier中tab是用来align的</p>
<h5 id="Semicolons"><a href="#Semicolons" class="headerlink" title="Semicolons"></a>Semicolons</h5><p>每行后面带不带分号</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>true</td>
<td><code>--no-semi</code></td>
<td><code>semi: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<p>true是在每行末尾加<br>false是在每行开头加,但会引入ASI问题.</p>
<h5 id="Quotes"><a href="#Quotes" class="headerlink" title="Quotes"></a>Quotes</h5><p>使用单引号而不是双引号:</p>
<p>注意:</p>
<ul>
<li>jsx的会忽略这个配置, 用的是<code>jsx-single-quote.</code></li>
<li>如果在一个用字符串包上字符串的情况下, <code>&quot;I&#39;m double quoted&quot;</code>变<code>&quot;I&#39;m double quoted&quot;</code>. <code>&quot;This \&quot;example\&quot; is single quoted&quot;</code>变<code>&#39;This &quot;example&quot; is single quoted&#39;</code></li>
<li>更多信息看<code>strings rationale</code></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td><code>--single-quote</code></td>
<td><code>singleQuote: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="JSX-Quotes"><a href="#JSX-Quotes" class="headerlink" title="JSX Quotes"></a>JSX Quotes</h5><p>在jsx中用单引号代替双引号</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td><code>--jsx-single-quote</code></td>
<td><code>jsxSingleQuote: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Trailing-Commas"><a href="#Trailing-Commas" class="headerlink" title="Trailing Commas"></a>Trailing Commas</h5><p>多行的时候在末尾打印逗号. 单行数组是不会有末尾逗号的.<br>尾逗号<code>[a,b,c,d,]</code> 数组项d后面的逗号就是尾逗号</p>
<p>可选项:</p>
<ul>
<li><code>none</code>, 不加</li>
<li><code>es5</code>: 在es5中某些加, 比如(objects, arrays, etc.)</li>
<li><code>all</code>: 甚至在函数参数中也加</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>“none”</td>
<td>`—trailing-comma &lt;none</td>
<td>es5</td>
<td>all&gt;`</td>
<td>`trailingComma: “&lt;none</td>
<td>es5</td>
<td>all&gt;”`</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Bracket-Spacing"><a href="#Bracket-Spacing" class="headerlink" title="Bracket Spacing"></a>Bracket Spacing</h5><p>在一个对象字面量中加空格</p>
<p><code>true</code> - Example: <code>{ foo: bar }</code>.<br><code>false</code> - Example: <code>{foo: bar}</code>.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>true</td>
<td><code>--no-bracket-spacing</code></td>
<td><code>bracketSpacing: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="JSX-Brackets"><a href="#JSX-Brackets" class="headerlink" title="JSX Brackets"></a>JSX Brackets</h5><p>对一个jsx元素而言,<code>&gt;</code>是加在最后一样还是换新行</p>
<p>Valid options:</p>
<p><code>true</code> - Example:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button</span><br><span class="line">  className=<span class="string">"prettier-class"</span></span><br><span class="line">  id=<span class="string">"prettier-id"</span></span><br><span class="line">  onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">  Click Here</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>false</code> - Example:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button</span><br><span class="line">  className=<span class="string">"prettier-class"</span></span><br><span class="line">  id=<span class="string">"prettier-id"</span></span><br><span class="line">  onClick=&#123;<span class="keyword">this</span>.handleClick&#125;</span><br><span class="line">&gt;</span><br><span class="line">  Click Here</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td><code>--jsx-bracket-same-line</code></td>
<td><code>jsxBracketSameLine: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Arrow-Function-Parentheses"><a href="#Arrow-Function-Parentheses" class="headerlink" title="Arrow Function Parentheses"></a>Arrow Function Parentheses</h5><p>箭头函数的参数, 在只有一个的情况下加不加圆括号<code>()</code></p>
<p>Valid options:</p>
<p><code>&quot;avoid&quot;</code> - 忽略. Example: <code>x =&gt; x</code><br><code>&quot;always&quot;</code> - 加上. Example: <code>(x) =&gt; x</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>“avoid”</td>
<td>`—arrow-parens &lt;avoid</td>
<td>always&gt;`</td>
<td>`arrowParens: “&lt;avoid</td>
<td>always&gt;”`</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h5><p>只format文件中的一段, <code>[)</code> 选一个偏移范围</p>
<p>不能和<code>cursorOffset</code>一起用</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>--range-start &lt;int&gt;</code></td>
<td><code>rangeStart: &lt;int&gt;</code></td>
</tr>
<tr>
<td>Infinity</td>
<td><code>--range-end &lt;int&gt;</code></td>
<td><code>rangeEnd: &lt;int&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h5><p>指定用什么parse, <code>prettier</code>会自动从输入的文件目录中读取, 你不需要配置这个.</p>
<p>但 <code>babel</code> 和 <code>flow</code>对一个js集来说是不同的两种, 所以可以选.</p>
<p>当然还要其他选项.</p>
<h5 id="File-Path"><a href="#File-Path" class="headerlink" title="File Path"></a>File Path</h5><p>指定前面parser的路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat foo | prettier --stdin-filepath foo.css</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>--stdin-filepath &lt;string&gt;</code></td>
<td><code>filepath: &quot;&lt;string&gt;&quot;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Require-pragma"><a href="#Require-pragma" class="headerlink" title="Require pragma"></a>Require pragma</h5><p><code>prettier</code>可以按照这个标志来严格指定format 文件, 只需要在每个文件前面加上<code>pramga</code></p>
<p>例如文件中带上下面的参数后, 使用<code>--require-pragma</code>就会format</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @prettier</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @format</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td><code>--require-pragma</code></td>
<td><code>requirePragma: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Insert-Pragma"><a href="#Insert-Pragma" class="headerlink" title="Insert Pragma"></a>Insert Pragma</h5><p>prettier可以在用prettier进行format的时候在文件的开头插入<code>@format</code>, 如果已经有其他的<code>docblock</code>的时候会加入一行的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td><code>--insert-pragma</code></td>
<td><code>insertPragma: &lt;bool&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Prose-Wrap"><a href="#Prose-Wrap" class="headerlink" title="Prose Wrap"></a>Prose Wrap</h5><p>换行问题, 最开始的是超过多少字符提示, 但不换行的.</p>
<p>Valid options:</p>
<ul>
<li><code>&quot;always&quot;</code> - Wrap prose if it exceeds the <code>print width</code>.</li>
<li><code>&quot;never&quot;</code> - Do not wrap prose.</li>
<li><code>&quot;preserve&quot;</code> - Wrap prose as-is. First available in v1.9.0</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;preserve&quot;</code></td>
<td>`—prose-wrap &lt;always</td>
<td>never</td>
<td>preserve&gt;</td>
<td>`</td>
<td>`proseWrap: “&lt;always</td>
<td>never</td>
<td>preserve&gt;”`</td>
</tr>
</tbody>
</table>
</div>
<h5 id="HTML-Whitespace-Sensitivity"><a href="#HTML-Whitespace-Sensitivity" class="headerlink" title="HTML Whitespace Sensitivity"></a>HTML Whitespace Sensitivity</h5><p>HTML文件全局空格敏感问题, 详细看<code>whitespace-sensitive formatting</code></p>
<p>就是空格会影响布局, 就按css的display来</p>
<p>Valid options:</p>
<ul>
<li><code>&quot;css&quot;</code> - Respect the default value of CSS <code>display</code> property.</li>
<li><code>&quot;strict&quot;</code> - Whitespaces are considered sensitive.</li>
<li><code>&quot;ignore&quot;</code> - Whitespaces are considered insensitive.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Default</th>
<th>CLI Override</th>
<th>API Override</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;css&quot;</code></td>
<td>`—html-whitespace-sensitivity &lt;css</td>
<td>strict</td>
<td>ignore&gt;`</td>
<td>`htmlWhitespaceSensitivity: “&lt;css</td>
<td>strict</td>
<td>ignore&gt;”`</td>
</tr>
</tbody>
</table>
</div>
<h5 id="End-of-Line"><a href="#End-of-Line" class="headerlink" title="End of Line"></a>End of Line</h5><p>历史原因, 有两种, That is <code>\n</code> (or <code>LF</code> for Line Feed) and <code>\r\n</code> (or <code>CRLF</code> for Carriage Return + Line Feed).</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/3dda4756eca5" target="_blank" rel="noopener">Visual Studio Code入门(译)</a><br><a href="https://blog.csdn.net/u013304372/article/details/78917536" target="_blank" rel="noopener">VS Code使用之基本设置与配置详解</a><br><a href="https://juejin.im/post/5b27a326e51d45588a7dac57" target="_blank" rel="noopener">使用ESLint+Prettier来统一前端代码风格</a><br><a href="https://www.jeffjade.com/2019/02/02/150-prettier-quickapp-plugin/" target="_blank" rel="noopener">Prettier 插件为更漂亮快应用代码</a><br><a href="http://www.valarvo.com/edwardvoon/587.html" target="_blank" rel="noopener">使用Prettier美化JavaScript代码，让编程更舒心</a><br><a href="https://juejin.im/post/5a791d566fb9a0634853400e" target="_blank" rel="noopener">vscode + prettier 专治代码洁癖（一）</a><br><a href="https://segmentfault.com/a/1190000011122443" target="_blank" rel="noopener">笔记, TypeScript 配置 Prettier 6</a><br><a href="https://juejin.im/post/5ae91143f265da0ba60f97ea" target="_blank" rel="noopener">Prettier 介绍与基本用法 6</a><br><a href="https://juejin.im/post/59ddc2a751882578c17e9ccf" target="_blank" rel="noopener">为什么用Prettier 66</a><br><a href="https://blog.fundebug.com/2017/10/23/format-code-use-Prettier/" target="_blank" rel="noopener">我为什么推荐Prettier来统一代码风格 6</a><br><a href="https://survivejs.com/maintenance/code-quality/code-formatting/" target="_blank" rel="noopener">Code Formatting 6666 各种配置</a><br><a href="https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi" target="_blank" rel="noopener">What are the rules for JavaScript’s automatic semicolon insertion (ASI)?</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/17/js立即执行函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/17/js立即执行函数/" itemprop="url">js立即执行函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T16:52:02+08:00">2019-02-17</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="js立即执行函数表达式"><a href="#js立即执行函数表达式" class="headerlink" title="js立即执行函数表达式"></a>js立即执行函数表达式</h1><p>IIFE（ 立即调用函数表达式）是一个<strong>在定义时就会立即执行的</strong>  <code>JavaScript</code> 函数。</p>
<p>这是一个被称为 <code>自执行匿名函数</code> 的<strong>设计模式</strong>，主要包含两部分。<br>第一部分是包围在 <code>圆括号运算符()</code> 里的<strong>一个匿名函数</strong>，这个匿名函数<strong>拥有独立的词法作用域</strong>。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</p>
<p>第二部分<strong>再一次使用</strong> <code>()</code> 创建了一个<strong>立即执行函数表达式</strong>，JavaScript 引擎到此<strong>将直接执行函数</strong>。</p>
<p><strong>当函数变成立即执行的函数表达式时</strong>，表达式中的变量不能从外部访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Barry"</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 外部不能访问变量 name</span></span><br><span class="line">name <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Barry"</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// IIFE 执行后返回的结果：</span></span><br><span class="line">result; <span class="comment">// "Barry"</span></span><br></pre></td></tr></table></figure>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>立即执行函数通常有下面两种写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">   ...</span><br><span class="line">&#125;)();</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>在Javascript中，一对圆括号“<code>()</code>”是一种运算符，跟在函数名之后，表示调用该函数。比如，<code>print()</code>就表示调用<code>print函数</code>。</p>
<p>这个写法和我们想象的写法不一样（知道的人当然已经习以为常）<br>很多人刚开始理解<strong>立即执行函数</strong>的时候，觉得应该是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; ... &#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fName</span>(<span class="params"></span>)</span>&#123; ... &#125;();</span><br></pre></td></tr></table></figure>
<p>然而事实却是这样：<code>SyntaxError: Unexpected token (</code>。这是为什么呢？</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>要理解立即执行函数，需要先理解一些<strong>函数的基本概念</strong>：<code>函数声明</code>、<code>函数表达式</code>,因为我们定义一个函数通常都是通过这两种方式</p>
<p><strong>函数声明 (function 语句)</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">[param[, param[, ... param]]]</span>) </span>&#123;</span><br><span class="line">   statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>name</code>：函数名；<br><code>param</code>：被传入函数的参数的名称,一个函数最多可以有255个参数；<br><code>statements</code>：这些语句组成了函数的函数体。</p>
<p><strong>函数表达式 (function expression)</strong>:</p>
<p>函数表达式和函数声明非常类似,它们甚至有相同的语法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function [name]([param] [, param] [..., param]) &#123;</span><br><span class="line">   statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>name</code>：函数名,可以省略,<strong>省略函数名的话,该函数就成为了匿名函数</strong>；<br><code>param</code>：被传入函数的参数的名称,一个函数最多可以有255个参数；<br><code>statements</code>：这些语句组成了函数的函数体。</p>
<p>下面我们给出一些栗子说明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明函数f1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"f1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过()来调用此函数</span></span><br><span class="line">f1();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个匿名函数的函数表达式，被赋值给变量f2:</span></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"f2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过()来调用此函数</span></span><br><span class="line">f2();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个命名为f3的函数的函数表达式(这里的函数名可以随意命名，可以不必和变量f3重名)，被赋值给变量f3:</span></span><br><span class="line"><span class="keyword">var</span> f3 = <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"f3"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过()来调用此函数</span></span><br><span class="line">f3();</span><br></pre></td></tr></table></figure>
<p>上面所起的作用都差不多，但还是有一些<strong>差别</strong></p>
<p>1、<strong>函数名和函数的变量存在着差别</strong>。函数名不能被改变，但函数的变量却能够被再分配。函数名只能在函数体内使用。倘若在函数体外使用函数名将会导致错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">alert(x); <span class="comment">// throws an erro</span></span><br></pre></td></tr></table></figure>
<p>2、函数声明定义的函数可以在它被声明之前使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// alerts FOO!</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   alert(<span class="string">'FOO!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>但函数声明非常容易（经常是意外地）转换为函数表达式</strong>。当它不再是一个函数声明：</p>
<ol>
<li><strong>成为<code>表达式</code>的一部分</strong>, 不单单是用()括号, 还有其他操作符和一些语句中.</li>
<li>不在是函数或者script自身的“源元素” （source element）。在script或者函数体内“源元素”并非是内嵌的语句（statement）<strong>有点难懂</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;               <span class="comment">// source element</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) &#123;            <span class="comment">// source element</span></span><br><span class="line">   x = <span class="number">10</span>;               <span class="comment">// 非source element</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params"></span>) </span>&#123;&#125;     <span class="comment">// 非 source element</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;         <span class="comment">// source element</span></span><br><span class="line">   <span class="keyword">var</span> y = <span class="number">20</span>;           <span class="comment">// source element</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;     <span class="comment">// source element</span></span><br><span class="line">   <span class="keyword">while</span> (y == <span class="number">10</span>) &#123;     <span class="comment">// source element</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">blah</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 非 source element</span></span><br><span class="line">      y++;               <span class="comment">//非source element</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>🌰栗子:</p>
<blockquote>
<p>简单点看就判断是不是<code>function</code>开头</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式, 在括号中</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式, 赋值语句</span></span><br><span class="line">x = <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在逻辑语句中</span></span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">   <span class="comment">// 函数表达式</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">world</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 函数声明</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//函数表达式</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们来解释上面的<code>SyntaxError: Unexpected token (</code>：</p>
<p><strong>产生这个错误的原因</strong>是，Javascript引擎看到<code>function</code>关键字之后，认为后面跟的是函数定义语句，不应该以圆括号结尾。<br><strong>解决方法</strong>就是让引擎知道，圆括号前面的部分不是函数定义语句，而是一个表达式，可以对此进行运算。所以应该这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;());   <span class="comment">// 这个是第二种吧</span></span><br></pre></td></tr></table></figure>
<p>这两种写法<strong>都是以圆括号开头</strong>，引擎就会认为后面跟的<strong>是一个表示式，而不是函数定义</strong>，所以就避免了错误。这就叫做“立即调用的函数表达式”（<code>Immediately-Invoked Function Expression</code>），简称IIFE。</p>
<blockquote>
<p>注意，上面的两种写法的结尾，都必须加上分号。</p>
</blockquote>
<p>推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;();</span><br><span class="line"></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>
<p>甚至像这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"></span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"></span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>
<p>new关键字也能达到这个效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;() <span class="comment">// 只有传递参数时，才需要最后那个圆括号。</span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>那我们通常为什么使用函数立即表达式呢，以及我如何使用呢？</p>
<p><strong>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”</strong>。<br>它的目的有两个：</p>
<ul>
<li>一是不必为函数命名，避免了污染全局变量；</li>
<li>二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> tmp = newData;</span><br><span class="line">processData(tmp);</span><br><span class="line">storeData(tmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = newData;</span><br><span class="line">  processData(tmp);</span><br><span class="line">  storeData(tmp);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong>写法二比写法一更好，因为完全避免了污染全局变量</strong>。</p>
<p>最后在举一个真实的栗子：在JavaScript的<code>OOP</code>中，我们可以通过IIFE来实现一个单例(关于单例的优化不再此处讨论)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个立即调用的匿名函数表达式</span></span><br><span class="line"><span class="comment">// return一个变量，其中这个变量里包含你要暴露的东西</span></span><br><span class="line"><span class="comment">// 返回的这个变量将赋值给counter，而不是外面声明的function自身</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">            i = val;</span><br><span class="line">        &#125;,</span><br><span class="line">        increment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; ());</span><br><span class="line"></span><br><span class="line"><span class="comment">// counter是一个带有多个属性的对象，上面的代码对于属性的体现其实是方法</span></span><br><span class="line"></span><br><span class="line">counter.get(); <span class="comment">// 0</span></span><br><span class="line">counter.set(<span class="number">3</span>);</span><br><span class="line">counter.increment(); <span class="comment">// 4</span></span><br><span class="line">counter.increment(); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">counter.i; <span class="comment">// undefined 因为i不是返回对象的属性</span></span><br><span class="line">i; <span class="comment">// 引用错误: i 没有定义（因为i只存在于闭包）</span></span><br></pre></td></tr></table></figure>
<h2 id="圆括号运算符"><a href="#圆括号运算符" class="headerlink" title="圆括号运算符"></a>圆括号运算符</h2><p><a href="https://segmentfault.com/a/1190000015644558" target="_blank" rel="noopener">进击的 JavaScript（五） 之 立即执行函数与闭包 666</a></p>
<p>圆括号运算符也叫<strong>分组运算符</strong>，它有两种用法：如果表达式放在圆括号中，作用是<strong>求值</strong>；如果跟在函数后面，作用是<strong>调用函数</strong></p>
<p>把表达式放在圆括号之中，将返回表达式的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>+<span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><strong>将函数放在圆括号中，会返回函数本身</strong>。如果圆括号紧跟在函数的后面，就表示调用函数，即对函数求值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span> <span class="title">testa</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">666</span>;&#125;));</span><br><span class="line"><span class="comment">// function testa()&#123;return 666;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> <span class="title">testa</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">666</span>;&#125;());</span><br><span class="line"><span class="comment">// 666</span></span><br></pre></td></tr></table></figure>
<p>注意:圆括号运算符<strong>不能为空</strong>，否则会报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">();<span class="comment">//SyntaxError: Unexpected token )</span></span><br></pre></td></tr></table></figure>
<p>由于圆括号的作用是求值，如果将语句放在圆括号之中，就会报错，因为语句没有返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">666</span>&#125;);</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token var</span></span><br></pre></td></tr></table></figure>
<h2 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h2><p>在 Javascript 中，圆括号<code>()</code>是一种<strong>运算符</strong>，跟在函数名之后，表示调用该函数。比如，<code>print()</code>就表示调用<code>print函数</code>。</p>
<p>有时，我们<strong>需要在定义函数之后，立即调用该函数</strong>。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token (</span></span><br></pre></td></tr></table></figure>
<p>产生这个<strong>错误的原因</strong>是，<code>function</code>这个关键字<strong>既可以当作语句，也可以当作表达式</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>为了<strong>避免解析上的歧义</strong>，JavaScript 引擎规定，如果<code>function关键字</code>出现在<strong>行首</strong>，<strong>一律解释成语句</strong>。因此，JavaScript引擎看到行首是<code>function关键字</code>之后，认为这一段都是函数的定义，不应该以圆括号结尾，<strong>所以就报错了</strong>。</p>
<p><strong>解决方法</strong>就是不要让<code>function</code>出现在行首，让引擎将其理解成一个表达式。<strong>最简单的处理</strong>，就是将其放在一个圆括号里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;());</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure>
<p>上面两种写法都是以<code>圆括号</code>开头，引擎就会认为后面跟的<strong>是一个表示式，而不是函数定义语句</strong>，所以就避免了错误。这就叫做“立即调用的函数表达式”（<code>Immediately-Invoked Function Expression</code>），简称 <code>IIFE</code>。</p>
<p>注意，上面两种写法最后的<strong>分号都是必须</strong>的。如果省略分号，遇到连着两个 IIFE，可能就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;())</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;())</span><br></pre></td></tr></table></figure>
<p>上面代码的两行之间没有分号，<code>JavaScript</code> 会将它们<strong>连在一起解释，将第二行解释为第一行的参数</strong>。</p>
<p><strong>推而广之</strong>，任何让解释器以<strong>表达式</strong>来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;();</span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>
<h2 id="自执行匿名函数和立即执行的函数表达式区别"><a href="#自执行匿名函数和立即执行的函数表达式区别" class="headerlink" title="自执行匿名函数和立即执行的函数表达式区别"></a>自执行匿名函数和立即执行的函数表达式区别</h2><p><a href="https://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html" target="_blank" rel="noopener">深入理解JavaScript系列（4）：立即调用的函数表达式 6666</a></p>
<p>在这篇帖子里，我们一直叫<strong>自执行函数</strong>，确切的说是<code>自执行匿名函数</code>（<code>Self-executing anonymous function</code>），但英文原文作者一直倡议使用立即调用的函数表达式（<code>Immediately-Invoked Function Expression</code>）这一名称，作者又举了一堆例子来解释，好吧，我们来看看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个自执行的函数，函数内部执行自身，递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; foo(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个自执行的匿名函数，因为没有标示名称</span></span><br><span class="line"><span class="comment">// 必须使用arguments.callee属性来执行自己</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">arguments</span>.callee(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这可能也是一个自执行的匿名函数，仅仅是foo标示名称引用它自身</span></span><br><span class="line"><span class="comment">// 如果你将foo改变成其它的，你将得到一个used-to-self-execute匿名函数</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; foo(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有些人叫这个是自执行的匿名函数（即便它不是），因为它没有调用自身，它只是立即执行而已。</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为函数表达式添加一个标示名称，可以方便Debug</span></span><br><span class="line"><span class="comment">// 但一定命名了，这个函数就不再是匿名的了</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即调用的函数表达式（IIFE）也可以自执行，不过可能不常用罢了</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">arguments</span>.callee(); &#125; ());</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; foo(); &#125; ());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，下面的代码在黑莓5里执行会出错，因为在一个命名的函数表达式里，他的名称是undefined</span></span><br><span class="line"><span class="comment">// 呵呵，奇怪</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; foo(); &#125; ());</span><br></pre></td></tr></table></figure>
<p>希望这里的一些例子，可以让大家明白，什么叫<strong>自执行</strong>，什么叫<strong>立即调用</strong>。</p>
<blockquote>
<p>注：<code>arguments.callee</code>在<code>ECMAScript 5 strict mode</code>里<strong>被废弃了</strong>，所以在这个模式下，其实是不能用的。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">IIFE</a><br><a href="https://segmentfault.com/a/1190000003902899" target="_blank" rel="noopener">JavaScript中的立即执行函数 666</a><br><a href="http://javascript.ruanyifeng.com/grammar/function.html#toc23" target="_blank" rel="noopener">阮一峰 IIFE 666666</a><br><a href="https://segmentfault.com/a/1190000003985390" target="_blank" rel="noopener">[译] JavaScript：立即执行函数表达式（IIFE）666</a><br><a href="https://segmentfault.com/a/1190000015644558" target="_blank" rel="noopener">进击的 JavaScript（五） 之 立即执行函数与闭包 666</a><br><a href="https://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html" target="_blank" rel="noopener">深入理解JavaScript系列（4）：立即调用的函数表达式 6666</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/再谈js作用域/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/再谈js作用域/" itemprop="url">再谈js作用域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T19:19:09+08:00">2019-02-12</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="再谈js作用域"><a href="#再谈js作用域" class="headerlink" title="再谈js作用域"></a>再谈js作用域</h1><p>在上一篇<a href="/2019/01/10/js作用域链和闭包/" title="js作用域链和闭包">js作用域链和闭包</a>中讲的有点没头绪, 重新梳理下</p>
<h2 id="scope-scope-chain-execution-context-context-的区别"><a href="#scope-scope-chain-execution-context-context-的区别" class="headerlink" title="scope, scope chain, execution context, context 的区别"></a>scope, scope chain, execution context, context 的区别</h2><h3 id="先解释下函数和作用域的关系"><a href="#先解释下函数和作用域的关系" class="headerlink" title="先解释下函数和作用域的关系"></a>先解释下函数和作用域的关系</h3><p>每一个<code>JavaScript</code>函数都被表示为<code>object</code>,进一步, as an instance of <code>Function</code>, 函数对象和其他对象一样, 拥有你可以编程访问的属性, 和一系列不能被访问, 但仅供<code>JavaScript</code>引擎使用的内部属性. 其中一个内部属性就是<code>[[scope]]</code>.</p>
<p>这个内部属性<code>[[scope]]</code>包含一个代表作用域<code>scope</code>的对象集合, 这个集合是在函数被创建时产生的. 这个集合叫函数的<code>作用域链</code>, 他决定了函数能访问哪些数据. 这个集合中的每个对象叫做可变对象<code>variable object</code>. 当一个函数被创建后, 他的作用域链就有这些对象.</p>
<blockquote>
<p>上面的创建指写好代码, 只是定义哦, 还没运行呢.</p>
</blockquote>
<h3 id="作用域scope"><a href="#作用域scope" class="headerlink" title="作用域scope"></a>作用域scope</h3><p>作用域是你的代码在<strong>运行时(不运行时的预处理阶段也是可以产生的静态作用域链, 是非自己部分的哦)</strong>，各个变量、函数和对象的可访问性。换句话说，作用域决定了你的代码里的变量和其他资源在各个区域中的可见性。</p>
<p>js有3种作用域, 全局作用域(<code>Global context： window/global</code>), 局部作用域(<code>Local Scope</code> , 又称为函数作用域 <code>Function context</code>), 块级作用域<code>{}</code>和<code>const let</code></p>
<h3 id="上下文-context"><a href="#上下文-context" class="headerlink" title="上下文 context"></a>上下文 context</h3><p>上下文指的是在<strong>相同的作用域</strong>中的<code>this</code>的值, 这里<code>this</code>是在调用时确定的(本函数的<code>this</code>值), 而作用域<code>scope</code>也是运行时才有的. 所以没错.</p>
<h2 id="例子add"><a href="#例子add" class="headerlink" title="例子add()"></a>例子add()</h2><p>主要是看这个链接<br><a href="https://www.css88.com/archives/7262" target="_blank" rel="noopener">JavaScript 核心概念之作用域和闭包 666</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Scope-Chain（作用域链）"><a href="#Scope-Chain（作用域链）" class="headerlink" title="Scope Chain（作用域链）"></a>Scope Chain（作用域链）</h3><blockquote>
<p>作用域链的<strong>非自己部分</strong>在函数对象被建立（<strong>函数声明、函数表达式</strong>）的时候建立，<strong>而不需要等到执行</strong>，这部分<strong>作用域链是静态</strong>的；当函数执行时，<strong>建立一个自己当次执行的作用域</strong>，然后把这个作用域与前面的作用域链关联起来</p>
</blockquote>
<p>所以, 当<strong>定义</strong> <code>add</code> 函数后，其<strong>作用域链就创建了</strong>。函数所在的全局作用域的全局对象被放置到 <code>add</code> 函数作用域链（<code>[[scope]</code>] 属性）中。我们可以从下图中看到作用域链的第一个对象保存的是全局对象，全局对象中保存了诸如 <code>this</code> , <code>window</code> , <code>document</code> 以及全局对象中的 <code>add</code> 函数，也就是他自己。这也就是我们可以在全局作用域下的函数中访问 <code>window(this)</code>，访问全局变量，访问函数自身的原因。<br>作用域链在稍后的执行函数时使用。当然还有函数作用域不是全局的情况，等会儿我们再讨论。</p>
<p><img src="scope1.jpg" alt="scope1.jpg"></p>
<p><a href="https://www.css88.com/archives/7300" target="_blank" rel="noopener">实例分析 JavaScript 作用域</a></p>
<p>上面这个链接讲了 <strong>JavaScript 的词法作用域</strong></p>
<h3 id="Execution-Context（执行期上下文）"><a href="#Execution-Context（执行期上下文）" class="headerlink" title="Execution Context（执行期上下文）"></a>Execution Context（执行期上下文）</h3><blockquote>
<p>也分<strong>全局执行期上下文</strong>和<strong>函数执行期上下文</strong></p>
</blockquote>
<p>假设我们<strong>运行</strong>以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = add(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>执行该函数创建一个<strong>内部对象</strong>，称为 <code>Execution Context</code>（执行期上下文）。执行期上下文<strong>定义了一个函数<code>正在执行时</code>的作用域环境</strong>。</p>
<blockquote>
<p>特别注意，执行期上下文和我们平常说的上下文不同，<code>执行期上下文</code>指的是作用域<code>scope</code>。平常说的上下文是<code>this</code>的取值指向。</p>
</blockquote>
<p>执行期上下文和函数创建时的作用域链对象<code>[[scope]]</code>区分，这是<strong>两个不同的作用域链对象</strong>。分开的原因很简单，函数定义时的作用域链对象 <code>[[scope]]</code> 是固定的，而 <code>执行期上下文</code> 会根据不同的运行时环境变化。而且该函数每执行一次，都会创建单独的 <code>执行期上下文</code>，因此对同一函数调用多次，会导致创建多个执行期上下文。一旦函数执行完成，执行期上下文将被销毁。</p>
<blockquote>
<p>函数定义时函数对象的属性是 <code>[[scope]]</code> ,而<code>Execution Context</code>（执行期上下文）的属性是<code>scope chain</code></p>
</blockquote>
<p><code>执行期上下文对象</code>有自己的作用域链，当创建执期行上下文时，其作用域链将<strong>使用</strong>执行函数<code>[[scope]]</code>属性所包含的对象（即，函数<strong>定义时</strong>的作用域链对象）进行<strong>初始化</strong>。这些值按照它们在函数中出现的顺序复制到执行期上下文作用域链中。</p>
<h3 id="Activation-Object（激活对象）"><a href="#Activation-Object（激活对象）" class="headerlink" title="Activation Object（激活对象）"></a>Activation Object（激活对象）</h3><p>随后，在执行其上下文<strong>中</strong>创建一个名为 <code>Activation Object</code>（激活对象）的<code>新对象</code>。 这个<code>激活对象AO</code>保存了函数中的<code>所有形参，实参，局部变量，this 指针等</code>函数执行时函数内部的数据情况。然后将这个激活对象推送到执行其上下文作用域链的<strong>顶部</strong>。</p>
<p><code>激活对象AO</code>是一个<strong>可变对象</strong>，里面的数据随着函数执行时的数据的变化而变化，当函数执行结束之后，执行期上下文将被销毁。也就会销毁<code>Execution Context</code>的作用域链，激活对象也同样被销毁。<strong>但如果存在闭包</strong>，激活对象就会以另外一种方式存在，这也是<strong>闭包产生的真正原因</strong>，具体的我们稍后讨论。下图显示了执行上下文及其作用域链：</p>
<p><img src="scope_execution.jpg" alt="scope_execution.jpg"></p>
<p>从左往右看，<strong>第一部分</strong>是函数<strong>执行时</strong>创建的<code>执行期上下文</code>，它有自己的作用域链，第二部分是作用域链中的对象，<code>索引为1</code>的对象是从<code>[[scope]]</code>作用域链中<strong>复制</strong>过来的，<code>索引为0</code>的对象是在<strong>函数执行时</strong>创建的<code>激活对象AO</code>，第三部分是作用域链中的对象的内容<code>Activation Object</code>(激活对象)和<code>Global Object</code>(全局对象)。</p>
<p>函数在执行时，每遇到一个变量，都会去执行期上下文的作用域链的顶部，执行函数的激活对象开始向下<strong>搜索</strong>，如果在第一个作用域链（即，<code>Activation Object</code> 激活对象）中找到了，那么就返回这个变量。如果没有找到，那么继续向下查找，直到找到为止。如果在整个执行期上下文中都没有找到这个变量，在这种情况下，该变量被认为是<strong>未定义</strong>的。这也就是为什么函数可以访问全局变量，当局部变量和全局变量同名时，会使用局部变量而不使用全局变量，以及 JavaScript 中各种看似怪异的、有趣的作用域问题的答案。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>尤其是注意闭包的定义哦, 要使用到父函数的变量</p>
</blockquote>
<p>这个看<a href="/2019/01/10/js作用域链和闭包/" title="js作用域链和闭包">js作用域链和闭包</a>中的闭包</p>
<p>再说下一道经典的题啊, <strong>涉及闭包, 作用域, 内核线程, 事件队列</strong>, 进一步还可以考<code>this</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">20</span>,</span><br><span class="line">    getA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">1</span> ; i &lt; <span class="number">5</span>; i++) &#123;    <span class="comment">// let变为var的话是4个5</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i)</span><br><span class="line">        &#125;, <span class="number">1000</span>*i)    <span class="comment">// 注意这里不是1000, 改成1000的话会一秒后直接输出4个5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getA();</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这道题我觉得应该首先看<a href="/2018/12/28/从输入URL到页面加载发生了什么/" title="从输入URL到页面加载发生了什么">从输入URL到页面加载发生了什么</a> 中多<strong>进程浏览器</strong>,和<strong>多线程内核</strong>, <code>event loop</code>. <a href="/2019/02/17/js立即执行函数/" title="js立即执行函数">js立即执行函数</a>(来形成作用域块)</p>
<p>尤其是内核和<code>event loop</code>, js引擎和计时器是不同的线程, js引擎是单线程的哦. 这样你就懂了为啥会这么输出.</p>
<p>在4个循环下, 在js栈中就会触发4次计时器, 等同步的执行完, 再会执行事件队列中的, 而各个计时器线程又不打扰. 所以栈中for执行完后, 等事件队列, 事件队列都是1秒后执行完. 然而这时的i就是5, 所以大家都输出5</p>
<p>解法是用<br><a href="https://blog.csdn.net/X_Jagger/article/details/64584335" target="_blank" rel="noopener">setTimeout 循环闭包的经典面试题 解法与探究</a></p>
<p><a href="https://www.jianshu.com/p/e5225ba4a025" target="_blank" rel="noopener">setTimeout函数之循环和闭包 6还可以</a><br><a href="https://www.jianshu.com/p/9b4a54a98660" target="_blank" rel="noopener">图例详解那道setTimeout与循环闭包的经典面试题 666</a><br><a href="https://www.jeffjade.com/2016/01/10/2016-01-10-javacript-setTimeout/#2-setTimeout%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">你所不知道的setTimeout</a></p>
<h2 id="JavaScript-的词法作用域"><a href="#JavaScript-的词法作用域" class="headerlink" title="JavaScript 的词法作用域"></a>JavaScript 的词法作用域</h2><p>看完闭包后要看这个链接巩固, 在整体回顾.</p>
<p><a href="https://www.css88.com/archives/7300" target="_blank" rel="noopener">实例分析 JavaScript 作用域</a></p>
<p>上面这个链接讲了 <strong>JavaScript 的词法作用域</strong></p>
<p>简要说下:</p>
<p>如果一个文档流中包含多个script代码段（用script标签分隔的js代码或引入的js文件），它们的运行顺序是：</p>
<ol>
<li>读入第一个代码段（js执行引擎并非一行一行地分析程序，而是一段一段地分析执行的）</li>
<li>做<strong>词法分析</strong>，有错则报语法错误（比如括号不匹配等），并跳转到步骤5</li>
<li>对<code>var</code>变量和<code>function</code>定义做“<strong>预解析</strong>“（永远不会报错的，因为只解析正确的声明）</li>
<li>执行代码段，有错则报错（比如变量未定义）</li>
<li>如果还有下一个代码段，则读入下一个代码段，重复步骤2</li>
<li>完成</li>
</ol>
<h3 id="JavaScript-解析过程"><a href="#JavaScript-解析过程" class="headerlink" title="JavaScript 解析过程"></a>JavaScript 解析过程</h3><blockquote>
<p>从前面的<strong>例子add()</strong>回顾下</p>
</blockquote>
<p><code>JavaScript</code> 中每个函数都都表示为一个函数对象（函数实例），函数对象有一个仅供 <code>JavaScript</code> 引擎使用的<code>[[scope]]</code> 属性。<strong>通过语法分析和预解析</strong>，将<code>[[scope]]</code> 属性指向<strong>函数定义时</strong>作用域中的所有对象集合。这个集合被称为函数的作用域链（<code>scope chain</code>），包含函数<strong>定义时</strong>作用域中所有可访问的数据。</p>
<p>对应的图是:</p>
<p><img src="scope1.jpg" alt="scope1.jpg"></p>
<h3 id="JavaScript-执行过程"><a href="#JavaScript-执行过程" class="headerlink" title="JavaScript 执行过程"></a>JavaScript 执行过程</h3><p><strong>执行</strong>具体的某个函数时，JS引擎在执行每个函数实例时，都会创建一个<code>执行期上下文（Execution Context</code>）和<code>激活对象（active Object</code>）（它们<strong>属于<code>宿主对象</code></strong>，与函数实例执行的生命周期保持一致，也就是函数执行完成，这些对象也就被销毁了，闭包例外。）</p>
<p>执行期上下文（<code>Execution Context</code>）定义了一个函数<strong>正在执行时</strong>的作用域环境。它使用函数<code>[[scope]]</code>属性进行<strong>初始化</strong>。</p>
<p>随后，执行期上下文 <code>顶部</code> 的会创建一个<code>激活对象（active Object）</code>，这个激活对象保存了函数中的<code>所有形参</code>，<code>实参</code>，<code>局部变量</code>，<code>this</code> 指针等函数执行时<strong>函数内部</strong>的数据情况。这个时候激活对象中的那些属性<strong>并没有被赋值</strong>，执行函数内的赋值语句，这才会对变量集合中的变量进行赋值处理。也就是说 激活对象是一个<strong>可变对象</strong>，里面的数据随着函数执行时的数据变化而变化。</p>
<p>🌰<br>考虑一下下图中的代码：</p>
<p><img src="lizi.png" alt="lizi.png"></p>
<p>分析过程：</p>
<ul>
<li>作用域1 (绿色) ：即全局作用域，包含变量<code>foo</code>;</li>
<li>作用域2 (黄色) ：<code>foo</code>函数的作用域，包含变量<code>a</code>,<code>bar</code>,<code>b</code></li>
<li>作用域3 (蓝色) ：<code>bar</code>函数的作用域，包含变量<code>c</code></li>
</ul>
<p><code>bar</code> 作用域里完整的包含了 <code>foo</code> 的作用域, 因为 <code>bar</code> 是定义在 <code>foo</code> 中的，产生<strong>嵌套作用域</strong>。值得注意的是，一个函数作用域只有可能存在于一个父级作用域中，不会同时存在两个父级作用域。还有诸如<code>this</code> , <code>window</code> , <code>document</code>等全局对象这里就不说了，避免混乱。</p>
<p>执行过程：</p>
<ul>
<li>语句<code>console.log</code>寻找变量<code>a</code>,<code>b</code>,<code>c</code>;</li>
<li>其中<code>c</code>在自己的作用域中找到，</li>
<li><code>a</code>，<code>b</code>在自己的作用域中找不到，于是向上级作用域中查找，在<code>foo</code>的作用域中找到，并且调用。</li>
</ul>
<p><strong>函数在执行时</strong>，每遇到一个变量，都会去<strong>执行期上下文</strong>的作用域链的顶部，也就是<strong>执行函数</strong>的<strong>激活对象</strong>开始搜索，如果在第一个作用域链（即，<code>Activation Object</code> 激活对象）中找到了，那么就返回这个变量。如果没有找到，那么继续向下查找，直到找到为止。如果在整个执行期上下文中都没有找到这个变量，在这种情况下，该变量被认为是未定义的。也就是说如果<code>foo</code>的作用域中也定义了<code>c</code>，但<code>bar</code>函数只调用自己作用域里的<code>c</code>。这就是我们说的变量取值。</p>
<h4 id="关于形参-实参-同名局部变量的关系"><a href="#关于形参-实参-同名局部变量的关系" class="headerlink" title="关于形参, 实参, 同名局部变量的关系"></a>关于形参, 实参, 同名局部变量的关系</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params">a,b,c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(one.length);<span class="comment">//形参数量  3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params">a,b,c,d,e,f,g</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);<span class="comment">//实参数量  1</span></span><br><span class="line">&#125;</span><br><span class="line">one(<span class="number">1</span>)</span><br><span class="line">two(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoSomething</span>(<span class="params">a</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">DoSomething( <span class="number">1</span> );</span><br></pre></td></tr></table></figure>
<p>打印的结果是<code>1,1,2,2</code>。从上面的代码可以看到，参数<code>a</code>和局部变量<code>a</code>值是<strong>完全相同</strong>的，即使是局部变量<code>a</code>重新定义和赋值之后。这样就好理解了，<strong>参数和同名变量</strong>之间是 “<strong>引用</strong>” 关系，也就是说 <code>JavaScript</code> 引擎的处理参数和同名局部变量是都引用同一个内存地址。所以示例5中修改局部变量会影响到<code>arguments</code>的情况出现。</p>
<h2 id="再展开-execution-context中有什么"><a href="#再展开-execution-context中有什么" class="headerlink" title="再展开, execution context中有什么"></a>再展开, execution context中有什么</h2><p>看这个链接中的东西<br><a href="https://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/" target="_blank" rel="noopener">了解JavaScript的执行上下文</a><br><a href="https://juejin.im/post/5a5ee28f6fb9a01cbe655860" target="_blank" rel="noopener">由变量提升谈谈 JavaScript Execution Context</a></p>
<h3 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h3><p>让我们将术语<code>执行上下文</code>想象为当前被执行代码的<code>环境/作用域</code>。说的够多了，现在让我们看一个包含<strong>全局<code>global context</code>和函数上下文<code>execution context</code></strong>的代码例子</p>
<p><img src="global_context.jpg" alt="global_context.jpg"></p>
<p>很简单的例子，我们有一个被<strong>紫色边框圈</strong>起来的<strong>全局上下文</strong>和三个分别被<strong>绿色，蓝色和橘色</strong>框起来的<strong>不同函数执行上下文</strong>。只有全局上下文（的变量）能被其他任何上下文访问。</p>
<p>你可以有任意多个函数上下文，<strong>每次调用函数创建一个新的上下文</strong>，会创建一个<strong>私有作用域</strong>，函数内部声明的任何变量都不能在当前函数作用域外部直接访问。在上面的例子中，函数能访问当前上下文外面的变量声明，但在外部上下文不能访问内部的变量/函数声明。</p>
<h3 id="执行上下文堆栈-这个看链接-也可以看那个event-loop"><a href="#执行上下文堆栈-这个看链接-也可以看那个event-loop" class="headerlink" title="执行上下文堆栈 这个看链接, 也可以看那个event loop"></a>执行上下文堆栈 这个看链接, 也可以看那个event loop</h3><p><strong>浏览器</strong>里的<code>JavaScript</code>解释器被实现为<strong>单线程</strong>。这意味着同一时间只能发生一件事情，其他的行文或事件将会被放在叫做执行栈里面排队。下面的图是单线程栈的抽象视图：</p>
<p><img src="stack1.jpg" alt="stack1.jpg"></p>
<p>有5个需要记住的关键点，<strong>关于执行栈（调用栈）</strong>：</p>
<ul>
<li>单线程。</li>
<li>同步执行。</li>
<li>一个全局上下文。</li>
<li>无限制函数上下文。</li>
<li>每次函数被调用创建新的执行上下文，包括调用自己。</li>
</ul>
<h3 id="执行上下文的细节"><a href="#执行上下文的细节" class="headerlink" title="执行上下文的细节"></a>执行上下文的细节</h3><p>我们现在已经知道每次调用函数，都会创建新的执行上下文。然而，在JavaScript解释器内部，每次调用执行上下文，分为两个阶段：</p>
<ol>
<li><strong>创建阶段</strong>【当函数被调用，但未执行任何其内部代码之前】：<ul>
<li>创建作用域链（<code>Scope Chain</code>）</li>
<li>创建变量对象<code>VO</code>，内对应的variables, functions和arguments。</li>
<li>求”<code>this</code>“的值。 <a href="/2018/11/26/javascript中this指向由函数调用方式决定/" title="javascript中this指向由函数调用方式决定">javascript中this指向由函数调用方式决定</a></li>
</ul>
</li>
<li>激活/<strong>代码执行</strong>阶段：<ul>
<li>重新扫描一次代码，给变量赋值，然后执行代码。。</li>
</ul>
</li>
</ol>
<p>可以将每个执行上下文抽象为一个对象并有三个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">executionContextObj = &#123;</span><br><span class="line">    <span class="string">'scopeChain'</span>: &#123; <span class="comment">/* variableObject + all parent execution context's variableObject */</span> &#125;,</span><br><span class="line">    <span class="string">'variableObject'</span>: &#123; <span class="comment">/* function arguments / parameters(函数实参/形参), inner variable and function declarations */</span> &#125;,</span><br><span class="line">    <span class="string">'this'</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>executionContextObj</code>由函数<strong>调用时运行前</strong>创建，<strong>创建阶段</strong><code>arguments</code>的参数会直接传入，函数<strong>内部定义的变量</strong>会初始化为<code>undefined</code>。<strong>执行阶段</strong>重新扫描一次代码，给变量赋值，然后执行代码。</p>
<h4 id="下面是执行上下文期间JS引擎执行伪代码"><a href="#下面是执行上下文期间JS引擎执行伪代码" class="headerlink" title="下面是执行上下文期间JS引擎执行伪代码"></a>下面是执行上下文期间JS引擎执行伪代码</h4><blockquote>
<p>这里和定义时(预处理时)的函数对象的属性<code>[[scope]]</code>不同哦</p>
</blockquote>
<ol>
<li>找到调用函数</li>
<li>执行函数代码前，创建<code>execution context</code></li>
<li>进行<strong>创建阶段</strong>：<ul>
<li>初始化作用域链 <code>Scope Chain</code></li>
<li>创建 <code>variable object</code>：(全局下就是全局变量, 没有arguments, <code>AO</code>下就是4种:函数的形参实参, 函数内声明的函数和变量)<ul>
<li>创建<code>arguments</code>对象，初始化该入参变量名和值(<strong>这个函数有, 全局的没有</strong>)</li>
<li>扫描该执行上下文中声明的函数： (其实就是<code>host提升</code>, 看<a href="/2019/01/10/js作用域链和闭包/" title="js作用域链和闭包">js作用域链和闭包</a>中的提升)<ul>
<li>对于声明的函数，<code>variable object</code>中创建对应的变量名，其值指向该函数（函数是存在<code>heap</code>中的）</li>
<li>如果函数名已经存在，用新的引用值<strong>覆盖</strong>已有的</li>
</ul>
</li>
<li>扫描上下文中声明的变量：(即:<strong>变量声明不会干扰<code>VO</code>中已经存在的同名函数声明或形式参数声明</strong>)<ul>
<li>对于变量的声明，同样在<code>variable object</code>中创建对应的变量名，其值初始化<code>为undefined</code></li>
<li>如果变量的名字已经存在，则直接略过继续扫描</li>
</ul>
</li>
</ul>
</li>
<li><strong>决定</strong>上下文<code>this</code>的指向, <strong>不要和作用域链, <code>VO</code>搞混</strong><ul>
<li><blockquote>
<p>用<code>this</code>的时候下一步就是用<code>VO</code>或<code>scope chain</code>中的变量咯</p>
</blockquote>
</li>
<li><blockquote>
<p>调用的时候才确定<code>this</code> <a href="/2018/11/26/javascript中this指向由函数调用方式决定/" title="javascript中this指向由函数调用方式决定">javascript中this指向由函数调用方式决定</a></p>
</blockquote>
</li>
<li><blockquote>
<p>4种: 直接调用(<code>window</code>或<code>global</code>), 方法调用(那个<code>obj</code>, 注意指向全局的那种调用方式, 从作用域链来看没错), <code>new</code>调用(就是创建的那个), 箭头(没有绑定<code>this</code>, 但使用<code>this</code>的话就是包含它的那个函数或表达式, 外面的父的<code>this</code>)</p>
</blockquote>
</li>
<li><blockquote>
<p>即: <code>this</code> 永远指向最后调用它的那个对象</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>代码执行阶段：<ul>
<li>执行函数内的代码并给对应变量进行赋值（创建阶段为<code>undefined</code>的变量）</li>
</ul>
</li>
</ol>
<p><code>this</code>结合上下文接着看<br><a href="http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html" target="_blank" rel="noopener">深入理解JavaScript系列（13）：This? Yes,this! 666666</a><br><a href="https://www.jianshu.com/p/d647aa6d1ae6" target="_blank" rel="noopener">前端基础进阶（五）：全方位解读this 666</a></p>
<p><a href="http://www.admin10000.com/document/6711.html" target="_blank" rel="noopener">深入浅出 妙用Javascript中apply、call、bind 6666</a></p>
<p>JavaScript 的一大特点是，函数存在「<strong>定义时上下文</strong>」和「<strong>运行时上下文</strong>」以及「<strong>上下文是可以改变的</strong>」这样的概念。</p>
<p>JavaScript 中，某些函数的参数数量是不固定的，因此要说适用条件的话，<br>当你的参数是<strong>明确知道</strong>数量时用 <code>call</code> 。而<strong>不确定</strong>的时候用 <code>apply</code>，然后把参数 <code>push</code> 进数组传递进去。当参数数量不确定时，函数内部也可以通过 <code>arguments</code> 这个数组来遍历所有的参数。</p>
<p>常用来转化为数组:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<p><strong>一个简单例子如下</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">22</span>))</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">'hello world'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> <span class="title">privateB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提升后是如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提升函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> <span class="title">privateB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提升变量的</span></span><br><span class="line"><span class="keyword">var</span> x</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">22</span>))</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line">x = <span class="string">'hello world'</span>;</span><br></pre></td></tr></table></figure>
<p>(a)：代码首先进入到<code>全局上下文</code>的<strong>创建阶段</strong>。</p>
<ol>
<li>初始化作用域链 <code>Scope Chain</code></li>
<li>创建 <code>variable object</code><ol>
<li>创建<code>arguments</code>对象，初始化该入参变量名和值(这个函数有, 全局的没有)</li>
<li>函数声明和变量声明提升</li>
</ol>
</li>
<li>决定上下文<code>this</code>的指向</li>
</ol>
<p>得到如下的<code>ExecutionContextGlobal</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContextGlobal = &#123;</span><br><span class="line">  scopeChain: &#123;...&#125;,  <span class="comment">// 当成[]更贴切点</span></span><br><span class="line">  variableObject: &#123;</span><br><span class="line">      x: <span class="literal">undefined</span>,</span><br><span class="line">      foo: pointer to <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  &#125;,</span></span><br><span class="line"><span class="function">  <span class="title">this</span>: </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(b): 然后进入<code>全局执行上下文</code>的<strong>执行阶段</strong>。</p>
<p>这一阶段从上至下逐条执行代码，运行到<code>console.log(foo(22))</code>该行时，<strong>创建阶段</strong>已经为<code>variableObject</code>中的<code>foo</code>赋值了，因此执行时会执行<code>foo(22)</code>函数。<br>当执行<code>foo(22)</code>函数时，又将进入<code>foo()</code>的执行上下文，详见(c)阶段。<br>当执行到<code>console.log(x)</code>时，此时<code>x</code>在<code>variableObject</code>中赋值为<code>undefined</code>，因此打印出<code>undefined</code>，这也正是<strong>变量提升产生</strong>的结果。<br>当执行到<code>var x = &#39;hello world&#39;;</code>，<code>variableObject</code>中的x被赋值为<code>hello world</code>。<br>继续往下是<code>foo</code>函数的声明，因此什么也不做，执行阶段结束。下面是执行阶段完成后的<code>ExecutionContextGlobal</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContextGlobal = &#123;</span><br><span class="line">  scopeChain: &#123;...&#125;,  <span class="comment">// 当成[]更贴切点</span></span><br><span class="line">  variableObject: &#123;</span><br><span class="line">      x: <span class="string">'hello world'</span>,</span><br><span class="line">      foo: pointer to <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  &#125;,</span></span><br><span class="line"><span class="function">  <span class="title">this</span>: </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(c): 当js调用<code>foo(22)</code>时，进入到<code>foo()</code>函数的<code>执行上下文</code>，首先进行该上下文的<strong>创建阶段</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContextFoo = &#123;</span><br><span class="line">    scopeChain: &#123;...&#125;,  <span class="comment">// 当成[]更贴切点</span></span><br><span class="line">    variableObject: &#123;</span><br><span class="line">      <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">22</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      i: <span class="number">22</span>,</span><br><span class="line">      c: pointer to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">      <span class="title">a</span>: <span class="title">undefined</span>,</span></span><br><span class="line"><span class="function">      <span class="title">b</span>: <span class="title">undefined</span></span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function">    <span class="title">this</span>: </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<strong>执行阶段</strong>运行完后，<code>ExecutionContextFoo</code>如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fooExecutionContext = &#123;</span><br><span class="line">    scopeChain: &#123; ... &#125;,  <span class="comment">// 当成[]更贴切点</span></span><br><span class="line">    variableObject: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="number">22</span>,</span><br><span class="line">            length: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        i: <span class="number">22</span>,</span><br><span class="line">        c: pointer to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        <span class="title">a</span>: '<span class="title">hello</span>',</span></span><br><span class="line"><span class="function">        <span class="title">b</span>: <span class="title">pointer</span> <span class="title">to</span> <span class="title">function</span> <span class="title">privateB</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function">    <span class="title">this</span>: </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理清了JS中的<code>执行上下文</code>，就很容易明白<strong>变量提升</strong>具体是怎么回事了。<br>在<strong>代码执行前</strong>，执行上下文已经给对应的声明赋值，只不过<strong>变量是赋值</strong>为<code>undefined</code>，<strong>函数赋值</strong>为对应的引用，<br>而后在<strong>执行阶段</strong>再将对应值<strong>赋值</strong>给变量。</p>
<blockquote>
<p><strong>区分函数声明和函数表达式</strong>, 这个不再多说</p>
</blockquote>
<p>在前面看到<code>execution context</code>中的是<code>VO</code>, 然后 <code>AO</code>是啥</p>
<p><code>Variable object(VO)</code> ：在<strong>全局作用域</strong>就是<strong>全局对象</strong>，而在<strong>其他作用域</strong>是<code>活动对象AO</code>。<br><code>Activation object(AO)</code> ：包含：函数的<code>形式参数</code>，函数的<code>arguments</code>对象，<code>函数内声明的变量</code>和<code>内部函数</code> <strong>4种(函数的形参实参, 函数内声明的函数和变量)</strong>。</p>
<blockquote>
<p><strong>其实<code>AO</code>是<code>VO</code>的一种情况</strong>。<code>全局下是没有</code><strong>arguments</strong>这个对象的，所以<strong>全局对象不能称为活动对象</strong>。</p>
</blockquote>
<p>未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p>
<h3 id="全局上下文的变量对象"><a href="#全局上下文的变量对象" class="headerlink" title="全局上下文的变量对象"></a>全局上下文的变量对象</h3><p>以浏览器中为例，全局对象为<code>window</code>。<br>全局上下文有一个特殊的地方，它的变量对象，就是<code>window</code>对象。而这个特殊，在<code>this</code>指向上也同样适用，<code>this</code>也是指向<code>window</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以浏览器中为例，全局对象为window</span></span><br><span class="line"><span class="comment">// 全局上下文</span></span><br><span class="line">windowEC = &#123;</span><br><span class="line">    VO: Window,</span><br><span class="line">    scopeChain: &#123;&#125;,  <span class="comment">// 当成[]更贴切点</span></span><br><span class="line">    <span class="keyword">this</span>: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。</p>
<h3 id="另一种VO不是this"><a href="#另一种VO不是this" class="headerlink" title="另一种VO不是this"></a>另一种VO不是this</h3><p><a href="https://www.zhihu.com/question/51336888" target="_blank" rel="noopener">js中 执行环境(execution context) 和 作用域(scope) 的区别在哪里?</a></p>
<p>执行环境（<code>Execution Context</code>，简称<code>Context</code>）只是一个<strong>抽象概念</strong>，在具体<code>JS Engine</code>实现中，<strong>它对应很多内容</strong>，变量对象（<code>Variable Object</code>，简写<code>VO</code>）是其一，还有<code>Scope Chain</code>，<code>this</code>等，这些<strong>共同组成</strong>了执行环境这个概念。</p>
<p><code>VO</code>不是指具体某个<code>Object</code>，而是<strong>指一类<code>Object</code></strong>，所以也具有一定程度的<strong>抽象</strong>。</p>
<blockquote>
<p><code>VO</code>是<code>JS Engine</code><strong>内部实现</strong>，用于<code>identifier resolution</code>，<strong>JS代码层面是接触不到的</strong>, <strong>但<code>this</code>是执行环境的一部分</strong>，所以不要与<code>VO</code>搞混.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//color, anotherColor, and tempColor are all accessible here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//color and anotherColor are accessible here, but not tempColor</span></span><br><span class="line">    swapColors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//only color is accessible here</span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
<p>书上（《Javascript高级程序设计(第三版)》）的代码（如下）说得很清楚：<strong><code>global context</code>对应一个<code>VO</code>（就是<code>window</code>!!）</strong>, <code>changeColor</code>的<code>local context</code>对应一个<code>VO</code>，<code>swapColors</code>的<code>local context</code>对应一个<code>VO</code>。所以每个context都对应了一个<code>VO</code>。</p>
<p>如上所说，<strong><code>this</code>也是执行环境的一部分</strong>，所以不要与<code>VO</code>搞混，<code>VO</code>是<code>JS Engine</code><strong>内部实现</strong>，用于<code>identifier resolution</code>，<strong>JS代码层面是接触不到的</strong>。参见ES2016规范：(<strong>而我们这里要访问到<code>VO</code>是通过<code>this</code>或者<code>window</code>来, 而不是直接访问<code>VO</code></strong>)</p>
<blockquote>
<p>Lexical Environments and Environment Record values are purely specification mechanisms and need not correspond to any specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to directly access or manipulate such values.</p>
</blockquote>
<p>当然如果你这个<code>VO</code>是<code>global</code>的话，比较特殊一点：</p>
<blockquote>
<p>A global environment’s Environment Record may be prepopulated with identifier bindings and includes an associated global object whose properties provide some of the global environment’s identifier bindings. As ECMAScript code is executed, additional properties may be added to the global object and the initial properties may be modified.</p>
</blockquote>
<p>这也是为什么前面提到说<code>global context</code>对应<code>window</code>。</p>
<p>同一本书专门讲Function一章有这样一句话：</p>
<blockquote>
<p>The this object is bound at runtime based on the context in which a function is executed: when used inside global functions, this is equal to window in nonstrict mode and undefined in strict mode, whereas this is equal to the object when called as an object method.</p>
</blockquote>
<p>简言之，<code>this</code>只是存了一个地址，要么指向<code>window</code>，要么指向<strong>调用该方法</strong>的那个<code>object</code>。<br>把上面代码改一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>: <span class="string">"black"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">        <span class="built_in">console</span>.log(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swapColors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor(); <span class="comment">// Output: true, true, undefined, red</span></span><br><span class="line">o.changeColor = changeColor;</span><br><span class="line">o.changeColor(); <span class="comment">// Output: false, true, undefined, red</span></span><br></pre></td></tr></table></figure>
<p><code>swapColors</code>里的<code>this</code>，和<code>swapColors</code>的<code>context</code>对应的<code>VO</code>没什么关系，而是指向<code>window</code>。</p>
<h3 id="说下全局上下文"><a href="#说下全局上下文" class="headerlink" title="说下全局上下文"></a>说下全局上下文</h3><p><a href="https://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html" target="_blank" rel="noopener">深入理解JavaScript系列（12）：变量对象（Variable Object）66666 看全局上下文中的变量对象这段</a></p>
<p>首先，我们要<strong>给<code>全局对象</code>一个明确的定义</strong>：</p>
<ul>
<li>全局对象(<code>Global object</code>) 是在<strong>进入任何执行上下文</strong>之前就已经创建了的对象；</li>
<li>这个对象只存在一份，它的属性在程序中任何地方都可以访问，全局对象的生命周期终止于程序退出那一刻。</li>
</ul>
<p>全局对象<strong>初始创建阶段</strong>将<code>Math、String、Date、parseInt</code>作为自身<strong>属性</strong>，等属性初始化，同样也可以有额外创建的其它对象作为属性（其可以指向到全局对象自身）。例如，在<code>DOM</code>中，全局对象的<code>window属性</code>就可以<strong>引用全局对象自身</strong>(当然，并不是所有的具体实现都是这样)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">global = &#123;</span><br><span class="line">  <span class="built_in">Math</span>: <span class="xml"><span class="tag">&lt;<span class="name">...</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  String: <span class="tag">&lt;<span class="name">...</span>&gt;</span></span></span><br><span class="line"><span class="xml">  ...</span></span><br><span class="line"><span class="xml">  ...</span></span><br><span class="line"><span class="xml">  window: global //引用自身, 就是上面的那个例如</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>当访问<strong>全局对象的属性时</strong>通常会<strong>忽略掉前缀</strong>(<code>global</code>)，这是因为全局对象是<strong>不能通过名称直接访问</strong>的。不过我们依然可以通过<strong>全局上下文</strong>的<code>this</code>来访问全局对象，同样<strong>也可以递归引用自身</strong>。例如，<code>DOM</code>中的<code>window</code>, <code>nodejs</code>中的<code>global</code>。综上所述，代码可以简写为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="number">10</span>); <span class="comment">// 就是global.String(10);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有前缀</span></span><br><span class="line"><span class="keyword">this</span>.b = <span class="number">20</span>; <span class="comment">// global.b = 20;  //通过this</span></span><br><span class="line"><span class="built_in">window</span>.a = <span class="number">10</span>; <span class="comment">// === global.window.a = 10 === global.a = 10; // 通过递归引用自身</span></span><br></pre></td></tr></table></figure>
<p>因此，回到全局上下文中的变量对象——在这里，变量对象就是全局对象自己：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VO(globalContext) === global;</span><br></pre></td></tr></table></figure>
<p><strong>非常有必要要理解上述结论</strong>，基于这个原理，在全局上下文中声明的对应，我们才可以<strong>间接通过</strong><code>全局对象的属性</code>来访问它（例如，事先不知道变量名称）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line">alert(a); <span class="comment">// 直接访问，在VO(globalContext)里找到："test"</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">window</span>[<span class="string">'a'</span>]); <span class="comment">// 间接通过global访问：global === VO(globalContext): "test"</span></span><br><span class="line">alert(a === <span class="keyword">this</span>.a); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aKey = <span class="string">'a'</span>;</span><br><span class="line">alert(<span class="built_in">window</span>[aKey]); <span class="comment">// 间接通过动态属性名称访问："test"</span></span><br></pre></td></tr></table></figure>
<h3 id="函数上下文中的变量对象"><a href="#函数上下文中的变量对象" class="headerlink" title="函数上下文中的变量对象"></a>函数上下文中的变量对象</h3><p>在函数执行上下文中，<code>VO</code>是<strong>不能直接访问的</strong>，此时由活动对象(<code>activation object</code>,缩写为AO)扮演<code>VO</code>的角色。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VO(functionContext) === AO;</span><br></pre></td></tr></table></figure>
<p>活动对象是在<strong>进入函数上下文时</strong>刻被<strong>创建</strong>的，它通过函数的<code>arguments</code>属性<strong>初始化</strong>。<code>arguments</code>属性的值是<code>Arguments</code>对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">  <span class="built_in">arguments</span>: <span class="xml"><span class="tag">&lt;<span class="name">ArgO</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
<p><code>Arguments</code>对象是活动对象的一个<strong>属性</strong>，它包括如下属性：</p>
<ol>
<li><code>callee</code> — 指向当前函数的引用</li>
<li><code>length</code> — 真正传递的参数个数</li>
<li><code>properties-indexes</code> (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 <code>properties-indexes</code>内部元素的个数等于<code>arguments.length</code>. <code>properties-indexes</code> 的值和实际传递进来的参数之间是共享的。<br>例如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 形参, 声明的函数参数数量arguments (x, y, z)</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实参, 真正传进来的参数个数(only x, y)</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数的callee是函数自身</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee === foo); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 形参实参, 参数共享. 还有同名形参和函数内变量这个看变量提升, 就是忽略</span></span><br><span class="line">  <span class="built_in">console</span>.log(x === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">  x = <span class="number">30</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不过，没有传进来的参数z，和参数的第3个索引值是不共享的</span></span><br><span class="line">  z = <span class="number">40</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">50</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(z); <span class="comment">// 40</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子的代码，在当前版本(71.0.3578.98 (Official Build) (64-bit))的<code>Google Chrome</code>浏览器里有一个bug  — 即使没有传递参数<code>z</code>，<code>z</code>和<code>arguments[2]</code>仍然是共享的。</p>
<h3 id="处理上下文代码的2个阶段"><a href="#处理上下文代码的2个阶段" class="headerlink" title="处理上下文代码的2个阶段"></a>处理上下文代码的2个阶段</h3><p>现在我们终于到了本文的核心点了。执行上下文的代码被分成两个基本的阶段来处理：</p>
<ol>
<li>进入执行上下文</li>
<li>执行代码</li>
</ol>
<p><strong>变量对象</strong>的修改变化与这两个阶段紧密相关。</p>
<p>注：这2个阶段的处理是一般行为，和上下文的类型无关（也就是说，<strong>在全局上下文和函数上下文中的表现是一样的</strong>）。</p>
<h3 id="这里说下变量-以前认知中有个错误概念"><a href="#这里说下变量-以前认知中有个错误概念" class="headerlink" title="这里说下变量(以前认知中有个错误概念)"></a>这里说下变量(以前认知中有个错误概念)</h3><p>通常，各类文章和JavaScript相关的书籍都声称：“不管是使用<code>var</code>关键字(在全局上下文)<strong>还是不使用<code>var</code>关键字(在任何地方)</strong>，都可以声明一个变量”。请记住，<strong>这是错误的概念</strong>：</p>
<p><strong>任何时候，<code>变量</code>只能通过使用<code>var</code>关键字才能声明</strong>。</p>
<p>赋值语句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这仅仅是给<code>全局对象</code>创建了一个<strong>新属性(但它不是变量)</strong>。“不是变量”并不是说它不能被改变，而是<strong>指它不符合<code>ECMAScript</code>规范中的变量概念</strong>，所以它“不是变量”(它<strong>之所以能成为全局对象的属性</strong>，完全是因为<code>VO(globalContext) === global</code>，大家还记得这个吧？, 忽略了前缀)。</p>
<p>让我们通过下面的实例看看具体的区别吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>所有根源仍然是<code>VO</code>和<strong>进入上下文阶段</strong>和<strong>代码执行阶段</strong>：</p>
<p>进入上下文阶段：是这样的, 如果<code>b</code>是变量的话那么它也应该在<code>VO</code>中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VO = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 如果b是变量  那么也会存在 b: undefined, 但实际上报错, 所以并不存在这个变量b</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，因为“<code>b</code>”不是一个变量，所以在这个阶段根本就没有“<code>b</code>”，“<code>b</code>”将只在<strong>代码执行阶段</strong>才会出现(但是在我们这个例子里，还没有到那就已经出错了)。</p>
<p>让我们改变一下例子代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined, 这个大家都知道，</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 10, 代码执行阶段创建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 20, 代码执行阶段修改</span></span><br></pre></td></tr></table></figure>
<p>关于变量，还有一个重要的知识点。<strong>变量相对于简单属性来说</strong>，变量有一个特性(<code>attribute</code>)：{<code>DontDelete</code>},这个特性的含义就是不能用<code>delete</code>操作符直接删除变量属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> a); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> b); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// still 20</span></span><br></pre></td></tr></table></figure>
<p>但是这个规则在<strong>有个上下文里不起</strong>作用，那就是<code>eval</code>上下文，变量没有{<code>DontDelete</code>}特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'var a = 10;'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> a); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>使用一些调试工具(例如：<code>Firebug</code>)的控制台测试该实例时，请注意，<code>Firebug</code>同样是使用<code>eval</code>来执行控制台里你的代码。因此，变量属性同样没有{<code>DontDelete</code>}特性，可以被删除。</p>
<h3 id="特殊实现-parent-属性"><a href="#特殊实现-parent-属性" class="headerlink" title="特殊实现: __parent__ 属性"></a>特殊实现: <code>__parent__</code> 属性</h3><p>前面已经提到过，<strong>按标准规范，活动对象是不可能被直接访问到的</strong>。但是，<code>一些具体实现</code>并没有完全遵守这个规定，例如<code>SpiderMonkey</code>和<code>Rhino</code>；的实现中，函数有一个特殊的属性 <code>__parent__</code>，通过这个属性<strong>可以直接引用到活动对象</strong>（或全局变量对象），在此对象里创建了函数。</p>
<p>例如 (<code>SpiderMonkey</code>, <code>Rhino</code>)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.__parent__); <span class="comment">// global</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> VO = foo.__parent__;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(VO.a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(VO === global); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中我们可以看到，函数<code>foo</code>是在全局上下文中创建的，所以属性<code>__parent__</code> 指向全局上下文的变量对象，即全局对象。</p>
<p>然而，在<code>SpiderMonkey</code>中用同样的方式访问活动对象是不可能的：在不同版本的<code>SpiderMonkey</code>中，内部函数的<code>__parent__</code> 有时指向<code>null</code> ，有时指向<code>全局对象</code>。</p>
<p>在<code>Rhino</code>中，用同样的方式访问活动对象是完全可以的。</p>
<p>例如 (<code>Rhino</code>)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// "foo"上下文里的活动对象</span></span><br><span class="line">  <span class="keyword">var</span> AO = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).__parent__;</span><br><span class="line"></span><br><span class="line">  print(AO.y); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前活动对象的__parent__ 是已经存在的全局对象</span></span><br><span class="line">  <span class="comment">// 变量对象的特殊链形成了</span></span><br><span class="line">  <span class="comment">// 所以我们叫做作用域链</span></span><br><span class="line">  print(AO.__parent__ === global); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  print(AO.__parent__.x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="再说下作用域与执行上下文"><a href="#再说下作用域与执行上下文" class="headerlink" title="再说下作用域与执行上下文"></a>再说下作用域与执行上下文</h3><p>JavaScript代码的整个执行过程，分为两个阶段，<strong>代码编译阶段与代码执行阶段</strong>。<br><strong>编译阶段</strong>由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。<br><strong>执行阶段</strong>由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</p>
<p><img src="process.webp" alt="process.webp"></p>
<p>然后是前面说的<code>执行上下文</code>的<strong>生命周期</strong></p>
<p><img src="execution_context.webp" alt="execution_context.webp"></p>
<p>下面的链接更详细分为4个阶段, 整合了从<code>global context</code>开始</p>
<p><a href="https://segmentfault.com/a/1190000011504517" target="_blank" rel="noopener">图解JS闭包形成的原因 666</a></p>
<h4 id="程序执行的四个阶段"><a href="#程序执行的四个阶段" class="headerlink" title="程序执行的四个阶段"></a>程序执行的四个阶段</h4><p>我以下面一段代码解释一下程序执行的几个阶段</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="string">"21"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span>;</span><br><span class="line">    age++;</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">myAge();</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br></pre></td></tr></table></figure>
<p><strong>第一阶段</strong>：在内存中创建执行执行环境栈、把全局对象<code>window</code>压入栈底、在<code>window</code>中声明变量</p>
<p><img src="step1.jpeg" alt="step1.jpeg"></p>
<p><strong>第二阶段：函数调用时</strong><br>在执行环境中添加当前函数调用、为本次函数调用创建<code>活动对象AO</code>、根据<code>scope</code>指定运行期活动对象AO的<code>上下文内部对象</code></p>
<p><img src="step2.jpeg" alt="step2.jpeg"></p>
<p><strong>第三阶段：函数调用后</strong><br>函数调用从执行环境栈中出栈、函数作用域AO释放、函数作用域AO中的局部变量也一同被释放</p>
<p><img src="step3.jpeg" alt="step3.jpeg"></p>
<h3 id="函数调用栈与作用域链"><a href="#函数调用栈与作用域链" class="headerlink" title="函数调用栈与作用域链"></a>函数调用栈与作用域链</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innnerFoo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(c); <span class="comment">// 在这里，试图访问函数bar中的c变量，会抛出错误</span></span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    fn = innnerFoo; <span class="comment">// 将 innnerFoo的引用，赋值给全局变量中的fn</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">100</span>;</span><br><span class="line">    fn(); <span class="comment">// 此处的保留的innerFoo的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<p>这里打印<code>c</code>要看你的作用域链上能不能找到<code>c</code>,而不是说调用的时候, 前面有个<code>c</code>用过.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.menvscode.com/detail/599fd4673bb2bd430d7a7e01" target="_blank" rel="noopener">《高性能JavaScript》第2章</a></p>
<p><strong>重点是这4篇文章, 然后看完就看下浏览器的机制, 再看下执行上下文的结构</strong><br><a href="https://www.css88.com/archives/7262" target="_blank" rel="noopener">JavaScript 核心概念之作用域和闭包 666</a><br><a href="https://www.css88.com/archives/7255" target="_blank" rel="noopener">深入理解JavaScript中的作用域和上下文 666</a><br><a href="https://www.css88.com/archives/7300" target="_blank" rel="noopener">实例分析 JavaScript 作用域 6666</a><br><a href="https://www.css88.com/archives/7924" target="_blank" rel="noopener">JavaScript 中的 Hoisting (变量提升和函数声明提升) 666</a></p>
<a href="/2018/12/28/从输入URL到页面加载发生了什么/" title="从输入URL到页面加载发生了什么">从输入URL到页面加载发生了什么</a>
<p><a href="https://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/" target="_blank" rel="noopener">了解JavaScript的执行上下文</a><br><a href="https://juejin.im/post/5a5ee28f6fb9a01cbe655860" target="_blank" rel="noopener">由变量提升谈谈 JavaScript Execution Context</a></p>
<p><a href="https://www.zhihu.com/question/51336888" target="_blank" rel="noopener">js中 执行环境(execution context) 和 作用域(scope) 的区别在哪里?</a><br><a href="https://www.zhihu.com/question/36393048" target="_blank" rel="noopener">js 中的活动对象 与 变量对象 什么区别？</a></p>
<p><a href="https://segmentfault.com/a/1190000014980841" target="_blank" rel="noopener">讲清楚之javascript作用域 6</a><br><a href="https://github.com/creeperyang/blog/issues/16" target="_blank" rel="noopener">深入理解JS中声明提升、作用域（链）和<code>this</code>关键字</a><br><a href="https://segmentfault.com/a/1190000011504517" target="_blank" rel="noopener">图解JS闭包形成的原因 666</a><br><a href="https://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html" target="_blank" rel="noopener">深入理解JavaScript系列（12）：变量对象（Variable Object）666666</a><br><a href="http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html" target="_blank" rel="noopener">深入理解JavaScript系列（13）：This? Yes,this! 666666</a><br><a href="http://www.admin10000.com/document/6711.html" target="_blank" rel="noopener">深入浅出 妙用Javascript中apply、call、bind 6666</a><br><a href="https://juejin.im/entry/5aca253e5188255c5668b7bb" target="_blank" rel="noopener">闭包，是真的美 666</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/YAML语言入门/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/YAML语言入门/" itemprop="url">YAML语言入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T11:37:53+08:00">2019-02-12</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/YAML/" itemprop="url" rel="index"><span itemprop="name">YAML</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="YAML语言入门"><a href="#YAML语言入门" class="headerlink" title="YAML语言入门"></a>YAML语言入门</h1><p>YAML 是专门用来<strong>写配置文件</strong>的语言，非常简洁和强大，远比 <code>JSON</code> 格式方便。</p>
<h2 id="二-对象"><a href="#二-对象" class="headerlink" title="二 对象"></a>二 对象</h2><p>对象的一组键值对，使用冒号结构表示。(<strong>记住这个是基本的结构</strong>)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">pets</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">animal</span>: <span class="string">'pets'</span> &#125;</span><br></pre></td></tr></table></figure>
<p><code>Yaml</code> 也允许另一种写法，将所有键值对写成一个行内对象。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hash:</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">Steve,</span> <span class="attr">foo:</span> <span class="string">bar</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">hash</span>: &#123; <span class="attr">name</span>: <span class="string">'Steve'</span>, <span class="attr">foo</span>: <span class="string">'bar'</span> &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>然后是多个的</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">YAML:</span> <span class="string">yaml.org</span></span><br><span class="line"><span class="attr">Ruby:</span> <span class="string">ruby-lang.org</span></span><br><span class="line"><span class="attr">Python:</span> <span class="string">python.org</span></span><br><span class="line"><span class="attr">Perl:</span> <span class="string">use.perl.org</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    YAML: <span class="string">'yaml.org'</span>,</span><br><span class="line">    Ruby: <span class="string">'ruby-lang.org'</span>,</span><br><span class="line">    Python: <span class="string">'python.org'</span>,</span><br><span class="line">    Perl: <span class="string">'use.perl.org'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-数组"><a href="#三-数组" class="headerlink" title="三 数组"></a>三 数组</h2><p>一组连词线开头的行，构成一个数组。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span> ]</span><br></pre></td></tr></table></figure>
<p>数据结构的子成员是一个数组，则可以在该项下面<strong>缩进一个空格</strong>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ [ <span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span> ] ]</span><br></pre></td></tr></table></figure>
<p>数组也可以采用行内表示法。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">[Cat,</span> <span class="string">Dog]</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">animal</span>: [ <span class="string">'Cat'</span>, <span class="string">'Dog'</span> ] &#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、复合结构"><a href="#四、复合结构" class="headerlink" title="四、复合结构"></a>四、复合结构</h2><p>对象和数组可以结合使用，形成复合结构。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">languages:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Ruby</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Perl</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Python</span></span><br><span class="line"><span class="attr">websites:</span></span><br><span class="line"><span class="attr"> YAML:</span> <span class="string">yaml.org</span></span><br><span class="line"><span class="attr"> Ruby:</span> <span class="string">ruby-lang.org</span></span><br><span class="line"><span class="attr"> Python:</span> <span class="string">python.org</span></span><br><span class="line"><span class="attr"> Perl:</span> <span class="string">use.perl.org</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">languages</span>: [ <span class="string">'Ruby'</span>, <span class="string">'Perl'</span>, <span class="string">'Python'</span> ],</span><br><span class="line">  websites:</span><br><span class="line">   &#123; <span class="attr">YAML</span>: <span class="string">'yaml.org'</span>,</span><br><span class="line">     Ruby: <span class="string">'ruby-lang.org'</span>,</span><br><span class="line">     Python: <span class="string">'python.org'</span>,</span><br><span class="line">     Perl: <span class="string">'use.perl.org'</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面可以得出写法, <strong>从最里层往外看</strong>,就可以转成<code>JavaScript</code>的写法</p>
</blockquote>
<h2 id="五、纯量"><a href="#五、纯量" class="headerlink" title="五、纯量"></a>五、纯量</h2><p>纯量是最基本的、不可再分的值。以下数据类型都属于 <code>JavaScript</code> 的纯量。</p>
<ul>
<li>字符串</li>
<li>布尔值</li>
<li>整数</li>
<li>浮点数</li>
<li>Null</li>
<li>时间</li>
<li>日期</li>
</ul>
<p><code>null</code>用<code>~</code>表示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">parent:</span> <span class="string">~</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">parent</span>: <span class="literal">null</span> &#125;</span><br></pre></td></tr></table></figure>
<p>时间采用 <code>ISO8601</code> 格式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iso8601: <span class="number">2001</span><span class="number">-12</span><span class="number">-14</span>t21:<span class="number">59</span>:<span class="number">43.10</span><span class="number">-05</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">iso8601</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2001-12-14t21:59:43.10-05:00'</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>日期采用复合 <code>iso8601</code> 格式的年、月、日表示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">date:</span> <span class="number">1976</span><span class="bullet">-07</span><span class="bullet">-31</span></span><br></pre></td></tr></table></figure>
<p>转为 <code>JavaScript</code> 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1976-07-31'</span>) &#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">YAML 语言教程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/31/url的组成/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/31/url的组成/" itemprop="url">url的组成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-31T20:09:33+08:00">2019-01-31</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/网络/" itemprop="url" rel="index"><span itemprop="name">网络</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="url的组成"><a href="#url的组成" class="headerlink" title="url的组成"></a>url的组成</h1><h2 id="whatwg标准"><a href="#whatwg标准" class="headerlink" title="whatwg标准"></a>whatwg标准</h2><p><a href="https://url.spec.whatwg.org/" target="_blank" rel="noopener">whatwg</a></p>
<p>WHATWG 的 <code>API</code> 与遗留的 <code>API</code> 的区别如下。 在下图中，URL <code>&#39;http://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash&#39;</code> 上方的是遗留的 <code>url.parse()</code> 返回的对象的属性。 下方的则是 <code>WHATWG</code> 的 URL 对象的属性。</p>
<p>WHATWG 的 <code>origin</code> 属性包括 <code>protocol</code> 和 <code>host</code>，但<strong>不包括</strong> <code>username</code> 或 <code>password</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                                              href                                              │</span><br><span class="line">├──────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬───────┤</span><br><span class="line">│ protocol │  │        auth         │          host          │           path            │ hash  │</span><br><span class="line">│          │  │                     ├─────────────────┬──────┼──────────┬────────────────┤       │</span><br><span class="line">│          │  │                     │    hostname     │ port │ pathname │     search     │       │</span><br><span class="line">│          │  │                     │                 │      │          ├─┬──────────────┤       │</span><br><span class="line">│          │  │                     │                 │      │          │ │    query     │       │</span><br><span class="line"><span class="string">"  https:   //    user   :   pass   @ sub.example.com : 8080   /p/a/t/h  ?  query=string   #hash "</span></span><br><span class="line">│          │  │          │          │    hostname     │ port │          │                │       │</span><br><span class="line">│          │  │          │          ├─────────────────┴──────┤          │                │       │</span><br><span class="line">│ protocol │  │ username │ password │          host          │          │                │       │</span><br><span class="line">├──────────┴──┼──────────┴──────────┼────────────────────────┤          │                │       │</span><br><span class="line">│   origin    │                     │         origin         │ pathname │     search     │ hash  │</span><br><span class="line">├─────────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴───────┤</span><br><span class="line">│                                              href                                              │</span><br><span class="line">└────────────────────────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>host是hostname + port<br>origin是protocol(这个有个<code>:</code>) + host<br>然后后面是pathname(这个有<code>/</code>), search(这个有<code>?</code>), hash(这个有<code>#</code>)</p>
<p>username:password这个是用来保护url的, 而不是用来登录的.</p>
<p>比如在ftp中, 你的浏览器登录后会使用<code>anonymous</code>, 所以你可以指定某一个<code>username</code>来, 只不过对于<code>password</code>不建议使用. 会被窃听到的, 况且还有https这个呢.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://nodejs.cn/api/url.html#url_url_strings_and_url_objects" target="_blank" rel="noopener">nodejs中 URL 字符串与 URL 对象</a><br><a href="https://www.cs.rutgers.edu/~watrous/user-pass-url.html" target="_blank" rel="noopener">Specifying username/password in a URL</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/13/静态作用域与动态作用域/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/13/静态作用域与动态作用域/" itemprop="url">静态作用域与动态作用域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-13T15:44:24+08:00">2019-01-13</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h1><p>作用域有两种常见的模型：词法作用域(<code>Lexical Scope</code>，通常也叫做 静态作用域) 和 动态作用域(<code>Dynamic Scope</code>)。其中词法作用域更常见，被 <code>JavaScript</code> 等大多数语言采用。（愚人码头注：这里避开了with和eval特殊语句，不再做介绍）。</p>
<p><strong>静态作用域与动态作用域</strong>:</p>
<ul>
<li><p>词法作用域：词法作用域是指<strong>在词法分析阶段</strong>就确定了，不会改变。变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。</p>
</li>
<li><p>动态作用域：动态作用域是在<strong>运行时</strong>根据程序的流程信息来动态确定的，而不是在写代码时进行静态确定的。 动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们在何处调用。</p>
</li>
</ul>
<p><strong>JavaScript的词法作用域</strong>:</p>
<p>如果一个文档流中包含多个script代码段（用script标签分隔的js代码或引入的js文件），它们的运行顺序是：</p>
<ol>
<li>读入第一个代码段（js执行引擎并非一行一行地分析程序，而是一段一段地分析执行的）</li>
<li>做词法分析，有错则报语法错误（比如括号不匹配等），并跳转到步骤5</li>
<li>对var变量和function定义做“预解析“（永远不会报错的，因为只解析正确的声明）</li>
<li>执行代码段，有错则报错（比如变量未定义）</li>
<li>如果还有下一个代码段，则读入下一个代码段，重复步骤2</li>
<li>完成</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"><span class="comment">// 结果是 ???</span></span><br></pre></td></tr></table></figure>
<p>假设JavaScript采用<strong>静态作用域</strong>，让我们分析下执行过程：(这部分要结合作用域链看)</p>
<p>执行 <code>foo</code> 函数，先从 <code>foo</code> 函数局部作用域中查找是否有变量 <code>value</code>，如果没有，就从全局作用域中查找变量<code>value</code>的值，所以结果会打印 1。</p>
<p>假设JavaScript采用<strong>动态作用域</strong>，让我们分析下执行过程：</p>
<p>执行 <code>foo</code> 函数，依然是从 <code>foo</code> 函数内部查找是否有局部变量 <code>value</code>。如果没有，就从调用函数的作用域，也就是 <code>bar</code> 函数内部查找 <code>value</code> 变量，所以结果会打印 2。</p>
<p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.css88.com/archives/7300" target="_blank" rel="noopener">实例分析 JavaScript 作用域, 同时讲了形参, 实参, 同名局部变量</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/js作用域链和闭包/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/10/js作用域链和闭包/" itemprop="url">js作用域链和闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-10T19:15:16+08:00">2019-01-10</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/javascript教程/" itemprop="url" rel="index"><span itemprop="name">javascript教程</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="js作用域链和闭包"><a href="#js作用域链和闭包" class="headerlink" title="js作用域链和闭包"></a>js作用域链和闭包</h1><h2 id="1-执行环境-execution-context"><a href="#1-执行环境-execution-context" class="headerlink" title="1.执行环境(execution context)"></a>1.执行环境(execution context)</h2><blockquote>
<p>执行环境<code>execution context</code>和环境<code>context</code>不一样, 后面有介绍</p>
</blockquote>
<p>执行环境定义了<strong>变量和函数有权访问的其他数据</strong>，决定了他们各自的行为。每个执行环境都有与之对应的<strong>变量对象</strong>（<code>variable object</code>）</p>
<blockquote>
<p><code>变量对象</code>就是执行环境中定义的变量和函数，<code>活动对象</code>是函数执行的时候被创建的，是属于某个函数的<br><strong>保存着该环境中定义的所有变量和函数</strong>。我们无法通过代码来访问变量对象，但是<strong>解析器</strong>在处理数据时会在后台使用到它。<br>执行环境有<strong>全局执行环境</strong>（也称全局环境）和<strong>函数执行环境</strong>之分。执行环境如其名是在运行和执行代码的时候才存在的，所以我们<strong>运行浏览器的时候</strong>会创建全局的执行环境，在<strong>调用函数</strong>时，会创建函数执行环境。</p>
</blockquote>
<h3 id="1-1-全局执行环境"><a href="#1-1-全局执行环境" class="headerlink" title="1.1 全局执行环境"></a>1.1 全局执行环境</h3><p>全局执行环境是<strong>最外围的一个执行环境</strong>，在web浏览器中，我们可以认为他是<strong>window对象</strong>，因此所有的全局变量和函数都是作为<code>window</code>对象的<strong>属性和方法</strong>创建的。代码载入浏览器时，全局环境被创建，关闭网页或者关闭浏览时全局环境被销毁。</p>
<h3 id="1-2-函数执行环境"><a href="#1-2-函数执行环境" class="headerlink" title="1.2 函数执行环境"></a>1.2 函数执行环境</h3><p>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被<strong>推入一个环境栈</strong>中，当函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>
<h2 id="2-作用域、作用域链"><a href="#2-作用域、作用域链" class="headerlink" title="2 作用域、作用域链"></a>2 作用域、作用域链</h2><h3 id="2-1作用域-Scope"><a href="#2-1作用域-Scope" class="headerlink" title="2.1作用域(Scope)"></a>2.1作用域(Scope)</h3><p>作用域概念是理解<code>JavaScript</code>的关键所在，不仅仅从性能角度，还包括从功能角度。<strong>作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期</strong>，换句话说，作用域决定了代码区块中变量和其他资源的可见性。在<code>JavaScript</code>中变量的作用域有全局作用域和局部作用域。<code>JavaScript</code>采用词法作用域(<code>lexical scoping</code>)，也就是<strong>静态作用域</strong>。</p>
<a href="/2019/01/13/静态作用域与动态作用域/" title="静态作用域与动态作用域">静态作用域与动态作用域</a>
<blockquote>
<p>在下面的图中, <code>AO</code>就是一个作用域, <code>Global object</code>也是一个作用域<code>scope</code>, 他们串一起就是<code>scope chain</code>咯</p>
</blockquote>
<h4 id="2-1-全局作用域（globe-scope）和局部作用域（local-scope）和块级作用域"><a href="#2-1-全局作用域（globe-scope）和局部作用域（local-scope）和块级作用域" class="headerlink" title="2.1 全局作用域（globe scope）和局部作用域（local scope）和块级作用域"></a>2.1 全局作用域（globe scope）和局部作用域（local scope）和块级作用域</h4><p>在<code>ECMAScript 5</code>（包括ECMAScript 5）之前的版本中，作用域只有全局作用域和局部作用域，不存在块级作用域；<code>ECMAScript 6</code>引入了<code>let</code>和<code>const</code>关键字，利用<code>let</code>和<code>const</code>可以形成块级作用域。(<strong>和c go那样的在<code>{}</code>里面表示块,不需要结合<code>if for</code>一起用才能形成块</strong>)</p>
<p><strong>1、全局作用域</strong>:</p>
<p>在代码中任何地方都能访问到的<strong>对象</strong>拥有全局作用域。全局作用域的变量是<strong>全局对象</strong>的属性，不论在什么函数中都可以直接访问，而不需要通过全局对象，但加上全局对象，可以提供搜索效率。</p>
<blockquote>
<p>a、没有用var声明的变量（除去函数的参数）都具有全局作用域，成为全局变量，所以声明<strong>局部变量</strong>必须要用var。<br>b、<code>window</code>的所有属性都具有全局作用域<br>c、最外层<strong>函数体外声明的变量</strong>也具有全局作用域</p>
</blockquote>
<p>2、局部作用域</p>
<p>局部变量的优先级高于全局变量。</p>
<blockquote>
<p>a、函数体内用var声明的变量具有局部作用域，成为局部变量<br>b、<strong>函数的参数</strong>也具有局部作用域</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">3</span>; <span class="comment">// a全局变量  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">b</span>)</span>&#123; <span class="comment">// fn全局变量 b局部变量  </span></span><br><span class="line"> c=<span class="number">2</span>; <span class="comment">// c全局变量  </span></span><br><span class="line"> <span class="keyword">var</span> d=<span class="number">5</span>; <span class="comment">// d局部变量  </span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">subFn</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// subFn局部变量</span></span><br><span class="line">    <span class="keyword">var</span> e=d; <span class="comment">// 父函数的局部变量对子函数可见  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;  </span><br><span class="line">      <span class="built_in">console</span>.write(i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    alert(i);<span class="comment">// 3, 在for循环内声明，循环外function内仍然可见，没有块作用域  </span></span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">alert(c); <span class="comment">// 在function内声明但不带var修饰，仍然是全局变量</span></span><br></pre></td></tr></table></figure>
<p><strong>3、块级作用域</strong>:</p>
<p>使用let和const关键字声明的变量，会在形成块级作用域。常见的是在<code>if</code>和<code>for</code>的<code>{}</code>语句块里面用, 可以单独使用<code>{}</code>作为块作用域哦</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="comment">// 'if' 条件语句块不会创建一个新的作用域</span></span><br><span class="line">   <span class="comment">// name 在全局作用域中，因为通过 'var' 关键字定义</span></span><br><span class="line">   <span class="keyword">var</span> name = <span class="string">'Hammad'</span>;</span><br><span class="line">   <span class="comment">// likes 在局部（本地）作用域中，因为通过 'let' 关键字定义</span></span><br><span class="line">   <span class="keyword">let</span> likes = <span class="string">'Coding'</span>;</span><br><span class="line">   <span class="comment">// skills 在局部（本地）作用域中，因为通过 'const' 关键字定义</span></span><br><span class="line">   <span class="keyword">const</span> skills = <span class="string">'JavaScript and PHP'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// logs 'Hammad'</span></span><br><span class="line"><span class="built_in">console</span>.log(likes); <span class="comment">// Uncaught ReferenceError: likes is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(skills); <span class="comment">// Uncaught ReferenceError: skills is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<h3 id="上下文-context-不是执行上下文-execution-scope"><a href="#上下文-context-不是执行上下文-execution-scope" class="headerlink" title="上下文(context)不是执行上下文(execution scope)"></a>上下文(context)不是执行上下文(execution scope)</h3><p>许多开发人员经常混淆作用域(<code>scope</code>)和上下文(<code>context</code>)，很多误解为它们是相同的概念。但事实并非如此。作用域(<code>scope</code>)我们上面已经讨论过了，而上下文(<code>context</code>)是用来指定代码某些特定部分中<code>this</code>的值。<br>作用域(<code>scope</code>) 是指<strong>变量的可访问性</strong>，上下文(<code>context</code>)是指<code>this</code>在<strong>同一作用域内的值</strong>。<br>我们也可以使用<code>call()</code>、<code>apply()</code>、<code>bind()</code>、<code>箭头函数</code>等改变上下文。<br>在浏览器中在全局作用域(<code>scope</code>)中上下文中始终是<code>Window对象</code>。在Node.js中在全局作用域(<code>scope</code>)中上下文中始终是<code>Global</code> 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Cherry"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  <span class="comment">// windowsName</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"inner:"</span> + <span class="keyword">this</span>);<span class="comment">// inner: Window</span></span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outer:"</span> + <span class="keyword">this</span>) <span class="comment">// outer: Window</span></span><br></pre></td></tr></table></figure>
<p>上下文始终坚持一个原理：<code>this</code> <strong>永远指向最后调用它的那个对象</strong>参考<a href="/2018/11/26/javascript中this指向由函数调用方式决定/" title="javascript中this指向由函数调用方式决定">javascript中this指向由函数调用方式决定</a>，上例中调用<code>a</code>函数的是<code>window</code>，所以a函数中的<code>this</code>指向<code>window</code>对象。关于<code>this</code>以及改变<code>this</code>的指向，可以参考<a href="https://juejin.im/post/59bfe84351882531b730bac2" target="_blank" rel="noopener">this、apply、call、bind</a></p>
<h3 id="2-2-作用域链（scope-chain）"><a href="#2-2-作用域链（scope-chain）" class="headerlink" title="2.2 作用域链（scope chain）"></a>2.2 作用域链（scope chain）</h3><p><code>JavaScript</code> 中每个函数都都表示为一个<strong>函数对象</strong>（函数实例），函数对象有一个仅供 <code>JavaScript</code> 引擎使用的<code>[[scope]]</code> 属性。通过<strong>语法分析和预解析</strong>，将<code>[[scope]]</code> 属性<strong>指向函数定义时</strong>作用域中的<strong>所有对象集合</strong>。这个<strong>集合</strong>被称为函数的<strong>作用域链</strong>（<code>scope chain</code>），包含函数定义时作用域中所有可访问的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<strong>定义</strong> <code>add</code> 函数后，<strong>其作用域链就创建了</strong>。函数所在的全局作用域的全局对象被放置到 <code>add</code> 函数作用域链（<code>[[scope]]</code> 属性）中。我们可以从下图中看到作用域链的<strong>第一个对象保存的是全局对象</strong>，全局对象中保存了诸如 <code>this</code> , <code>window</code> , <code>document</code> 以及全局对象中的 <code>add</code> 函数，也就是他自己。这也就是我们可以在全局作用域下的函数中访问 <code>window(this)</code>，<strong>访问全局变量</strong>，<strong>访问函数自身</strong>的原因。全局上下文中的变量对象(<code>Variable object，VO</code>)就是全局对象。</p>
<p><img src="scopechain1.png" alt="scopechain1.png"></p>
<p>全局作用域和局部作用域中<strong>变量的访问权限</strong>，其实是<strong>由作用域链决定的</strong>。</p>
<p>每次进入一个新的执行环境(<strong>这里就表示程序执行起来了</strong>)，都会创建一个用于<strong>搜索变量和函数的作用域链</strong>。作用域链是函数被创建的作用域中对象的<strong>集合</strong>。作用域链可以保证对执行环境有权访问的所有变量和函数的有序访问。</p>
<p><strong>作用域链的最前端始终是当前执行的代码所在环境的变量对象</strong>（如果该环境是函数，则将其<strong>活动对象</strong>作为变量对象），下一个变量对象来自包含环境（包含当前还行环境的环境），下一个变量对象来自包含环境的包含环境，依次往上，直到全局执行环境的变量对象。全局执行环境的变量对象始终是作用域链中的最后一个对象。</p>
<p><strong>标识符解析</strong>是沿着作用域一级一级的向上搜索标识符的过程。搜索过程始终是从作用域的前端逐地向后回溯，直到找到标识符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">"foo"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar=<span class="string">"bar"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(foo);<span class="comment">//foo</span></span><br><span class="line">        <span class="built_in">console</span>.log(bar);<span class="comment">//bar</span></span><br><span class="line">        <span class="keyword">var</span> tName=<span class="string">"tName"</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(tName);<span class="comment">//tName</span></span><br><span class="line">    &#125;</span><br><span class="line">    bName();</span><br><span class="line">&#125;</span><br><span class="line">fName();</span><br></pre></td></tr></table></figure>
<p>上述代码中，一共有<strong>三个执行环境</strong>：<code>全局环境</code>、<code>fName()</code>的局部环境和 <code>sName()</code> 的局部环境。所以，</p>
<ol>
<li>函数 <code>sName()</code>的作用域链包含三个对象：自己的变量对象——-&gt;<code>fName()</code>局部环境的变量对象 ——-&gt;全局环境的变量对象。</li>
<li>函数 <code>fName()</code>的作用域链包含两个对象：自己的变量对象——-&gt;全局环境的变量对象。</li>
</ol>
<p>就上述程序中出现的变量和函数来讲（不考虑隐形变量）：</p>
<ol>
<li><code>sName()</code> 局部环境的变量对象中存放变量 <code>tName</code>；</li>
<li><code>fName()</code> 局部环境的变量对象中存放变量 <code>bar</code> 和 函数<code>sName()</code>；</li>
<li>全局环境的变量对象中存放变量 <code>foo</code> 、函数<code>fName()</code>;</li>
</ol>
<p><img src="scope1.gif" alt="scope1.gif"></p>
<p>作用域链相关知识的总结：</p>
<ol>
<li>执行环境决定了变量的生命周期，以及哪部分代码可以访问其中变量和函数</li>
<li>执行环境有全局执行环境（全局环境）和局部执行环境之分。</li>
<li>每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链</li>
<li>函数的局部环境可以访问函数作用域中的变量和函数，也可以访问其父环境，乃至全局环境中的变量和环境。</li>
<li>全局环境只能访问全局环境中定义的变量和函数，不能直接访问局部环境中的任何数据。</li>
<li>变量的执行环境有助于确定应该合适释放内存。</li>
</ol>
<h3 id="execution-context-scope-chain-scope三者关系"><a href="#execution-context-scope-chain-scope三者关系" class="headerlink" title="execution context, scope chain, scope三者关系"></a>execution context, scope chain, scope三者关系</h3><p>看闭包那个图图可以知道, 最左边的是<code>execution context</code>, 中间的是<code>scope chain</code>, 最右边的是<code>scope</code></p>
<h3 id="再说下执行器上下文-execution-context"><a href="#再说下执行器上下文-execution-context" class="headerlink" title="再说下执行器上下文(execution context)"></a>再说下执行器上下文(execution context)</h3><p><strong>执行具体的某个函数时</strong>，JS引擎在执行每个函数实例时，都会创建一个执行期上下文（<code>Execution Context</code>）和激活对象（<code>active Object</code>）（它们<strong>属于宿主对象</strong>，与函数实例执行的生命周期保持一致，也就是函数执行完成，这些对象也就被销毁了，闭包例外。）</p>
<p>假设我们运行以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = add(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>执行该函数创建一个<strong>内部对象</strong>，称为 <code>Execution Context</code>（执行期上下文）。执行期上下文<strong>定义了一个函数正在执行时的作用域环境</strong>。</p>
<blockquote>
<p>特别注意，<strong>执行期上下文<code>execution context</code>和我们平常说的上下文<code>context</code>不同</strong>，执行期上下文指的是<strong>作用域<code>[[scope]]</code></strong>??。平常说的上下文是<code>this</code>的取值指向。</p>
</blockquote>
<p><strong>执行期上下文</strong>和<strong>函数创建时</strong>的作用域链对象 <code>[[scope]]</code> 区分，<strong>这是两个不同的作用域链对象</strong>。分开的原因很简单，函数定义时的作用域链对象 <code>[[scope]]</code> 是固定的，而 执行期上下文 会<strong>根据不同的运行时环境变化</strong>。而且该函数每执行一次，都会创建单独的 执行期上下文，因此对同一函数调用多次，会导致创建多个执行期上下文。一旦函数执行完成，执行期上下文将被销毁。</p>
<p>执行期上下文对象有自己的作用域链，当创建执期行上下文时，其作用域链将使用执行函数<code>[[scope]]</code>属性所包含的对象（即，函数定义时的作用域链对象）进行初始化。<strong>这些值按照它们在函数中出现的顺序复制到执行期上下文作用域链中</strong>。(所以要注意闭包的产生)</p>
<p>无论有多少个函数上下文，但是全局上下文只有一个。<strong>执行期上下文有创建和代码执行的两个阶段</strong>。</p>
<p>下面链接讲了函数定义时的作用域链,以及函数运行时的执行上下文的区别.<br><a href="https://www.css88.com/archives/7262" target="_blank" rel="noopener">JavaScript 核心概念之作用域和闭包</a><br><a href="https://www.jianshu.com/p/21a16d44f150" target="_blank" rel="noopener">前端基础进阶（四）：详细图解作用域链与闭包</a></p>
<blockquote>
<p>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段<strong>作用域规则</strong>会确定。执行阶段由引擎完成，主要任务是执行可执行代码，<strong>执行上下文</strong>在这个阶段创建。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第一阶段：创建阶段"><a href="#第一阶段：创建阶段" class="headerlink" title="第一阶段：创建阶段"></a>第一阶段：创建阶段</h4><p>当一个<strong>函数被调用但是其代码还没有被执行</strong>的时候。在创建阶段主要做的三件事情是：</p>
<ol>
<li>创建变量（激活）对象（<code>VO == AO</code>) <strong>详看变量对象干了啥</strong>: <a href="https://www.jianshu.com/p/330b1505e41d" target="_blank" rel="noopener">前端基础进阶（三）：变量对象详解</a></li>
<li>创建作用域链</li>
<li>设置上下文(<code>context</code>)的值（ <code>this</code> ）</li>
</ol>
<p><strong>激活对象(<code>Activation Object，AO</code>)</strong></p>
<p>当一个函数被调用但是其代码还没有被执行的时，在执行其上下文中创建一个名为 <code>Activation Object</code>（激活对象）的<strong>新对象</strong>。这个激活对象保存了函数中的<strong>所有形参，实参，局部变量</strong>，<code>this</code> 指针等函数执行时函数内部的数据情况。然后将这个激活对象推送到执行其上下文作用域链的顶部。</p>
<ol>
<li>函数参数(若未传入，初始化该参数值为<code>undefined</code>)</li>
<li>函数声明(若发生命名冲突，会覆盖)</li>
<li>变量声明(初始化变量值为<code>undefined</code>，若发生命名冲突，会忽略。)</li>
</ol>
<p>例如: <code>add</code>函数被调用，但是还未执行时的VO(变量对象)==AO(激活对象)是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO(add) = &#123;</span><br><span class="line">  <span class="built_in">arguments</span>: &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">10</span></span><br><span class="line">    length: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  num1: <span class="number">5</span>,  </span><br><span class="line">  num2: <span class="number">10</span>,  </span><br><span class="line">  sum: <span class="literal">undefined</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码是不是少了<code>this</code>的值, 调用的时候<code>this</code>就可以确定了的啊, 图中就有<code>this</code></p>
</blockquote>
<p><strong>激活对象AO是一个可变对象</strong>，里面的数据随着函数执行时的数据的变化而变化(比如进行赋值)，当函数执行结束之后，执行期上下文将被销毁。也就会销毁<code>Execution Context</code>的作用域链，激活对象也同样被销毁。<strong>但如果存在闭包</strong>，激活对象就会以另外一种方式存在，这也是<strong>闭包产生的真正原因</strong>，具体的我们稍后讨论。下图显示了执行上下文及其作用域链：</p>
<p><img src="execution_scope1.png" alt="execution_scope1.png"></p>
<p>从左往右看，<strong>第一部分</strong>是函数执行时创建的执行期上下文，它有自己的作用域链，<strong>第二部分</strong>是作用域链中的对象，<strong>索引为1</strong>的对象是从<code>[[scope]]</code>作用域链中<strong>复制</strong>过来的，<strong>索引为0</strong>的对象是在函数执行时<strong>创建</strong>的激活对象，<strong>第三部分</strong>是作用域链中的对象的内容<code>Activation Object</code>(激活对象)和<code>Global Object</code>(全局对象)。</p>
<p><strong>函数在执行时，每遇到一个变量，都会去执行期上下文的作用域链的顶部，执行函数的激活对象开始向下搜索</strong>，如果在第一个作用域链（即，<code>Activation Object</code> 激活对象）中找到了，那么就返回这个变量。如果没有找到，那么继续向下查找，直到找到为止。如果在整个执行期上下文中都没有找到这个变量，在这种情况下，该变量被认为是未定义的。这也就是为什么函数可以访问全局变量，当局部变量和全局变量同名时，会使用局部变量而不使用全局变量，以及 <code>JavaScript</code> 中各种看似怪异的、有趣的作用域问题的答案。</p>
<h4 id="第二阶段：代码执行"><a href="#第二阶段：代码执行" class="headerlink" title="第二阶段：代码执行"></a>第二阶段：代码执行</h4><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值，并最终执行代码(这里只是变化变量的值, 但<code>this</code>是一直在的)。当代码执行完后，这时候的 AO 是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO(add) = &#123;</span><br><span class="line">  <span class="built_in">arguments</span>: &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">10</span></span><br><span class="line">    length: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  num1: <span class="number">5</span>,  </span><br><span class="line">  num2: <span class="number">10</span>,  </span><br><span class="line">  sum: <span class="number">15</span>       <span class="comment">// sum有了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="闭包Closure-重点看这里-前面讲的不怎么细"><a href="#闭包Closure-重点看这里-前面讲的不怎么细" class="headerlink" title="闭包Closure 重点看这里, 前面讲的不怎么细"></a>闭包Closure 重点看这里, 前面讲的不怎么细</h2><blockquote>
<p>前面讲的不怎么细, 这里重新开始把在函数定义时产生的<code>scope chain</code>和<code>函数调用但未执行时</code>和<code>函数执行时</code>的各个情况画图</p>
</blockquote>
<p>闭包（<code>Closure</code>）是 <code>JavaScript</code> 最强大的特性之一，它允许函数访问局部作用域之外的数据。闭包在日常编码工作中非常常见。但是，它会对性能造成影响。了解闭包我们使用以下示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignEvents</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="string">"666677"</span>;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"save-btn"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        saveDocument(id);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>闭包是一种特殊的对象。<br>它由两部分组成。执行上下文(代号A)，以及在该执行上下文中创建的函数（代号B）。<br>当B执行时，<strong>如果访问了A中变量对象中的值(不访问当然不产生闭包)</strong>，那么闭包就会产生。<br>在大多数理解中，包括许多著名的书籍，文章里都<strong>以函数B</strong>的名字代指这里生成的<strong>闭包</strong>。而在<code>chrome</code>中，则以<strong>执行上下文A的函数名</strong>代指<strong>闭包</strong>。</p>
</blockquote>
<p><code>assignEvents</code> 函数为DOM元素分配一个事件处理程序。这个处理函数就是一个闭包。为了使该闭包访问id变量，必须创建一个特定的作用域链。</p>
<p><strong>我们一起来从作用域的角度分析一下闭包的形成过程</strong>：</p>
<p><code>assignEvents</code> 函数创建并且词法解析后，函数对象<code>assignEvents</code>的<code>[[scope]]</code>属性被初始化，作用域链形成，作用域链中包含了全局对象的所有属性和方法（<strong>注意，此时因为 <code>assignEvents</code> 函数还未被执行，所以闭包函数并没有被解析</strong>）。</p>
<p>类似这图:<br><img src="scopechain1.png" alt="scopechain1.png"></p>
<p><code>assignEvents</code> 开始执行时，创建 <code>Execution Context</code>（执行期上下文），在执行期上下文的作用域链中创建 <code>Activation Object</code>(激活对象)，并将 <code>Activation Object</code>(激活对象) 推送到作用域链顶部，在其中保存了函数执行时所有可访问函数内部的数据。激活对象包含 id 变量。</p>
<p>类似这图:<br><img src="execution_scope1.png" alt="execution_scope1.png"></p>
<p>当执行到闭包时，<code>JavaScript</code> 引擎发现了闭包函数的存在，按照通常的手法，将闭包函数解析，为闭包函数对象创建 <code>[[scope]]</code> 属性，初始化作用域链。特别注意的是，这个时候，闭包函数对象的作用域链中有两个对象，一个是 <code>assignEvents</code> 函数执行时的 <code>Activation Object</code>(激活对象) ，还有一个是全局对象，如下图</p>
<p><img src="closure1.png" alt="closure1.png"></p>
<p>我们看到图中闭包函数对象的作用域链和 <code>assignEvents</code> 函数的执行期上下文的作用域链是相同的。为什么相同呢？我们来分析一下，闭包函数是在 <code>assignEvents</code> 函数执行的过程中被定义并且解析的，而函数执行时的作用域是 <code>Activation Object</code>(激活对象) ，闭包函数被解析的时候它的作用域正是 <code>assignEvents</code> 作用域链中的第一个作用域对象 <code>Activation Object</code>(激活对象) ，当然，由于作用域链的关系，全局对象作用域也被引入到闭包函数的作用域链中。</p>
<p>在词法分析的时候闭包函数的 <code>[[scope]]</code> 属性 就已经在作用域链中保存了对 <code>assignEvents</code> 函数的 <code>Activation Object</code>(激活对象) 的引用，所以当 <code>assignEvents</code> 函数执行完毕之后，<strong>闭包函数虽然还没有开始执行(执行后是另一个作用域链)</strong>，但依然可以访问 <code>assignEvents</code> 的局部数据，并不是因为闭包函数要访问 <code>assignEvents</code> 的局部变量<code>id</code>，所以当 <code>assignEvents</code> 函数执行完毕之后依然保持了对局部变量<code>id</code>的引用。而是不管是否存在变量引用，都会保存对 <code>assignEvents</code> 的 <code>Activation Object</code>(激活对象)作用域对象的引用。因为在词法分析时，闭包函数没有执行，函数内部根本就不知道是否要对 <code>assignEvents</code> 的局部变量进行访问和操作，所以只能先把 <code>assignEvents</code> 的 <code>Activation Object</code>(激活对象) 作用域对象保存起来，当闭包函数执行时，如果需要访问 <code>assignEvents</code> 的局部变量，那么再去作用域链中查找。</p>
<p>也正是因为这种引用，造成了一个<strong>副作用</strong>。通常，当执行期上下文被销毁时，函数的激活对象也就被销毁了。当有闭包引用时，激活对象就不会被销毁，因为他仍然被引用。这意味着闭包比非隔离的函数需要更多的内存。</p>
<p><strong>闭包函数</strong>执行时创建了自己的 <code>Execution Context</code>（执行期上下文），其作用域链使用了 <code>[[scope]]</code> 属性，其引用了 <code>assignEvents</code> 函数的 <code>Activation Object</code>(激活对象) 和 全局对象。然后为闭包本身创建一个新的 <code>Activation Object</code>(激活对象)。 所以在闭包函数的执行期上下文的作用域链中保存了自己的 <code>Activation Object</code>(激活对象)，外层函数 <code>assignEvents</code> <code>Execution Context</code>（执行期上下文）的 <code>Activation Object</code>(激活对象)，以及 <code>Global Object</code>(全局对象)，如图：</p>
<p><img src="closure2.png" alt="closure2.png"></p>
<h2 id="3-提升（hoisting）"><a href="#3-提升（hoisting）" class="headerlink" title="3.提升（hoisting）"></a>3.提升（hoisting）</h2><p><strong>提升有变量提升和函数提升之分, 先提升函数声明, 在提升变量声明</strong>.</p>
<p><a href="https://www.css88.com/archives/7924" target="_blank" rel="noopener">JavaScript 中的 Hoisting (变量提升和函数声明提升)</a></p>
<p><strong>规则</strong>:</p>
<ol>
<li>扫描当前<strong>函数声明</strong>中的代码。<strong>函数表达式和箭头函数</strong>会被跳过。对于每个被发现的函数，<strong>都会创建一个新的函数</strong>，并使用函数名称将其绑定到环境中。如果标识符的名称已经存在，那么它的值就会被<strong>覆盖</strong>。</li>
<li>然后扫描当前环境的<strong>变量</strong>。找到使用 <code>var</code> 定义的变量和放置在其他函数之外的变量，并注册一个标识符，其值初始化为 <code>undefined</code> 。<strong>如果存在标识符，则该值将保持不变(就是忽略后面的生命, 反正都是<code>undefined</code>)</strong>。</li>
</ol>
<blockquote>
<p>注意：用 <code>let</code> 和 <code>const</code> 定义的是块变量，与 <code>var</code> 的处理稍微不同, <strong>不能重复定义</strong>。</p>
</blockquote>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/4" target="_blank" rel="noopener">JavaScript深入之执行上下文栈</a></p>
<blockquote>
<p>javascript 函数声明和变量声明会被解释器提升到最顶端，但是<strong>变量的初始化不会被提升</strong>  因为<code>var foo = &quot;变量&quot;</code>; <code>foo</code>被初始化了<br>其实主要是<code>var foo</code>;并不会覆盖之前的变量</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">"function"</span>;</span><br><span class="line"><span class="keyword">var</span> foo;<span class="comment">//它只是定义，全不会覆盖变量</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);<span class="comment">//返回 function</span></span><br></pre></td></tr></table></figure>
<p><strong>例子</strong>: 如果先提升函数声明,在提升变量声明, 那么结果怎么不打印<code>变量</code>,而是函数. (<strong>注意只是提升声明而已, 不是提升变量的初始化</strong>)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);   <span class="comment">// 这边是执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"函数声明"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">"变量"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>解答</strong>:</p>
<p>函数提升优先级比变量提升要高，<strong>且不会被变量声明覆盖</strong>，<strong>但是会被变量赋值覆盖</strong>，所以你上面的代码实际上是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;             <span class="comment">// 函数声明提前了</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"函数声明"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo;                    <span class="comment">// 然后是变量声明再提前</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);           <span class="comment">// 执行在这里哦, 执行的语句不会提, 还是在原来的位置</span></span><br><span class="line">foo = <span class="string">"变量"</span>;</span><br></pre></td></tr></table></figure>
<p>在最后再加上打印就能看到函数已经被覆盖了。<br>注：初始化变量不会把值也提上上去，只会提升变量的声明。(<strong>只是提升声明, 运行还是在那行运行的</strong>)</p>
<p><strong>再比如</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 ???  1</span></span><br></pre></td></tr></table></figure>
<p>提升后的结果是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value;</span><br><span class="line">value = <span class="number">1</span>;  <span class="comment">// 注意这里条赋值语句之前都是提升, 然后这行开始运行, 赋值了,</span></span><br><span class="line"></span><br><span class="line">bar();      <span class="comment">// 这边的bar()是执行前面声明过的函数, 运行前value的值就是1了, 所以最后打印1</span></span><br></pre></td></tr></table></figure>
<p>这里注意作用域链</p>
<h3 id="3-1-变量提升（variable-hoisting）"><a href="#3-1-变量提升（variable-hoisting）" class="headerlink" title="3.1 变量提升（variable hoisting）"></a>3.1 变量提升（variable hoisting）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"foo"</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line">     <span class="keyword">var</span> name=<span class="string">"bar"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> fName();</span><br><span class="line"> <span class="built_in">console</span>.log(name); <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<p>输出结果结果分别是 <code>undefined</code> 和 <code>foo</code>。为什么是<code>undefined</code>？</p>
<p>那我们先来分析一下代码 函数<code>fName()</code>的作用域链： 自己的变量对象 ——-&gt; 全局变量对象。解析器在函数执行环境中发现变量 <code>name</code>，因此不会再向全局环境的变量对象中寻找。但是大家要注意的是，解析器在解析第3句代码时，<strong>还不知道变量<code>name</code>的值</strong>，也就是说只知道有变量<code>name</code>，但是不知道它具体的值（因为还没有执行第4句代码），因此输出是 <code>undefined</code>，第7行输出<code>foo</code>大家应该都理解把（作用域问题）。所以上述代码可以写成下面的形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"foo"</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> name;</span><br><span class="line">     <span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line">     name=<span class="string">"bar"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> fName();</span><br><span class="line"> <span class="built_in">console</span>.log(name); <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<p>这个现象就是<strong>变量提升</strong>！</p>
<p>变量提升，就是把变量提升到函数的顶部，需要注意的是，<strong>变量提升只是提升变量的声明，不会把变量的值也提升上来</strong></p>
<h3 id="3-2-函数提升"><a href="#3-2-函数提升" class="headerlink" title="3.2 函数提升"></a>3.2 函数提升</h3><p>函数提升就是把函数提升到前面。</p>
<p>在<code>JavaScript</code>中函数的创建方式有三种：函数声明（静态的）、函数表达式（函数字面量）、函数构造法（动态的，匿名的）。</p>
<p>函数声明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n1,n2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//function body;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数表达式的形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params">n1,n2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//function body;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数构造法构造函数的形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func2 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"para1"</span>,<span class="string">"para2"</span>,...,<span class="string">"function body"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="总结下"><a href="#总结下" class="headerlink" title="总结下"></a>总结下</h2><a href="/2019/02/12/再谈js作用域/" title="再谈js作用域">再谈js作用域</a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/buchongming/p/5858026.html" target="_blank" rel="noopener">JavaScript中作用域和作用域链的简单理解（变量提升）</a><br><a href="https://blog.csdn.net/qq_27626333/article/details/78463565" target="_blank" rel="noopener">JavaScript作用域、上下文、执行期上下文、作用域链、闭包 666</a><br><a href="https://www.css88.com/archives/7300" target="_blank" rel="noopener">实例分析 JavaScript 作用域, 同时讲了形参, 实参, 同名局部变量 666</a></p>
<p>4个一起看<br><a href="https://www.css88.com/archives/7262" target="_blank" rel="noopener">JavaScript 核心概念之作用域和闭包 666</a><br><a href="https://www.css88.com/archives/7255" target="_blank" rel="noopener">深入理解JavaScript中的作用域和上下文 666</a><br><a href="https://www.css88.com/archives/7300" target="_blank" rel="noopener">实例分析 JavaScript 作用域</a><br><a href="https://www.css88.com/archives/7924" target="_blank" rel="noopener">JavaScript 中的 Hoisting (变量提升和函数声明提升) 666</a></p>
<p><a href="https://www.jianshu.com/p/21a16d44f150" target="_blank" rel="noopener">前端基础进阶（四）：详细图解作用域链与闭包</a><br><a href="https://www.jianshu.com/p/cd3fee40ef59" target="_blank" rel="noopener">前端基础进阶系列 贼6</a></p>
<p><a href="http://www.menvscode.com/detail/599fd4673bb2bd430d7a7e01" target="_blank" rel="noopener">《高性能JavaScript》第2章</a><br><a href="https://juejin.im/entry/5aca253e5188255c5668b7bb" target="_blank" rel="noopener">闭包，是真的美 666</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatarMogu.jpg" alt="Henry x">
            
              <p class="site-author-name" itemprop="name">Henry x</p>
              <p class="site-description motion-element" itemprop="description">this is description</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">81</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">92</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="weibo" target="_blank">weibo</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Henry x</span>

  

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.1"></script>



  



	





  





  










  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  

</body>
</html>
