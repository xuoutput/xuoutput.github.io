<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.1',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  
  <meta name="keywords" content="vue-router,vuejs,">


<meta name="description" content="vue-route(这货是个插件)主要想整理的是这个配合v-for一起用 vue-router官网的介绍 使用vue-cli来构建路由 先说下3个基本概念：route, routes, router详解vue-router基本使用 1， route，它是一条路由，是单数。Home按钮  =&amp;gt; home内容， 这是一条route,about按钮 =&amp;gt; about 内容， 这是另一条路由。">
<meta name="keywords" content="vue-router,vuejs">
<meta property="og:type" content="article">
<meta property="og:title" content="vue-router使用总结">
<meta property="og:url" content="http://yoursite.com/2018/02/03/vue-router使用总结/index.html">
<meta property="og:site_name" content="Little H title">
<meta property="og:description" content="vue-route(这货是个插件)主要想整理的是这个配合v-for一起用 vue-router官网的介绍 使用vue-cli来构建路由 先说下3个基本概念：route, routes, router详解vue-router基本使用 1， route，它是一条路由，是单数。Home按钮  =&amp;gt; home内容， 这是一条route,about按钮 =&amp;gt; about 内容， 这是另一条路由。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-11-16T12:50:23.564Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="vue-router使用总结">
<meta name="twitter:description" content="vue-route(这货是个插件)主要想整理的是这个配合v-for一起用 vue-router官网的介绍 使用vue-cli来构建路由 先说下3个基本概念：route, routes, router详解vue-router基本使用 1， route，它是一条路由，是单数。Home按钮  =&amp;gt; home内容， 这是一条route,about按钮 =&amp;gt; about 内容， 这是另一条路由。">






  <link rel="canonical" href="http://yoursite.com/2018/02/03/vue-router使用总结/">


  <title>vue-router使用总结 | Little H title</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Little H title</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">this is subtitle</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益404</a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/03/vue-router使用总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">vue-router使用总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T14:48:00+08:00">2018-02-03</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="vue-route-这货是个插件"><a href="#vue-route-这货是个插件" class="headerlink" title="vue-route(这货是个插件)"></a>vue-route(这货是个插件)</h1><p>主要想整理的是这个配合v-for一起用</p>
<p><a href="https://router.vuejs.org/zh-cn/essentials/getting-started.html" target="_blank" rel="noopener">vue-router官网的介绍</a></p>
<p><strong>使用vue-cli来构建路由</strong></p>
<p>先说下3个基本概念：route, routes, router<br><a href="http://www.jb51.net/article/111499.htm" target="_blank" rel="noopener">详解vue-router基本使用</a></p>
<p>1， route，它是一条路由，是单数。<br>Home按钮  =&gt; home内容， 这是一条route,<br>about按钮 =&gt; about 内容， 这是另一条路由。</p>
<p>2， routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。<br>[<br>    {home 按钮 =&gt;home内容 }，<br>    { about按钮 =&gt; about 内容}<br>]</p>
<p>3， router 是一个机制，相当于一个<strong>管理者</strong>，它来管理路由。<br>因为routes 只是定义了一组路由放在那里，是静止的，当有请求时，怎么找到对应的那条route呢？ 比如当用户点击home 按钮的时候，怎么知道跳转到home页面？这时router 就起作用了，它到routes 中去查找，去找到对应的route(home页面)，所以页面中就显示了home 内容。</p>
<p>4，客户端中的路由，实际上就是dom 元素的显示和隐藏。当页面中显示home 内容的时候，about 中的内容全部隐藏，反之也是一样。<br>客户端路由有两种实现方式：基于hash 和基于html5 history api.</p>
<h2 id="基本的路由-静态路由"><a href="#基本的路由-静态路由" class="headerlink" title="基本的路由(静态路由)"></a>基本的路由(静态路由)</h2><p><strong>下面开始</strong><br>官网一个基本的例子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue-router/dist/vue-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 router-link 组件来导航. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当 &lt;router-link&gt; 对应的路由匹配成功，将自动设置 class 属性值 .router-link-active --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/bar"</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">JavaScript</span><br><span class="line">// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">// 1. 定义（路由）组件。</span><br><span class="line">// 可以从其他文件 import 进来</span><br><span class="line">const Foo = &#123; template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span>' &#125;</span><br><span class="line">const Bar = &#123; template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">div</span>&gt;</span>' &#125;</span><br><span class="line"></span><br><span class="line">// 2. 定义路由</span><br><span class="line">// 每个路由应该映射一个组件。 其中"component" 可以是</span><br><span class="line">// 通过 Vue.extend() 创建的组件构造器，</span><br><span class="line">// 或者，只是一个组件配置对象。</span><br><span class="line">// 我们晚点再讨论嵌套路由(就是放在children中)。</span><br><span class="line">const routes = [</span><br><span class="line">  &#123; path: '/foo', component: Foo &#125;,</span><br><span class="line">  &#123; path: '/bar', component: Bar &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 3. 创建 router 实例，然后传 `routes` 配置</span><br><span class="line">// 你还可以传别的配置参数, 不过先这么简单着吧。</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes // （缩写）相当于 routes: routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 4. 创建和挂载根实例。</span><br><span class="line">// 记得要通过 router 配置参数注入路由，</span><br><span class="line">// 从而让整个应用都有路由功能</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount('#app')</span><br><span class="line"></span><br><span class="line">// 现在，应用已经启动了！</span><br></pre></td></tr></table></figure>
<p>可以看到html中只用了2个标签<br><code>&lt;router-link&gt;</code> <code>&lt;router-view&gt;</code></p>
<p><code>&lt;router-view&gt;</code>反正是显示路由内容的，<br>功能都在<code>&lt;router-link&gt;</code>，它定义了to那个路由 。</p>
<p>javascript页面<br>可以简单的理解为就是定义了一组routers，然后通过vue的vuerouter来管理</p>
<h2 id="动态路由（也就是把routers中的path改了-多对一，传参而已。另外注意watch和beforeRouteUpdate）"><a href="#动态路由（也就是把routers中的path改了-多对一，传参而已。另外注意watch和beforeRouteUpdate）" class="headerlink" title="动态路由（也就是把routers中的path改了: 多对一，传参而已。另外注意watch和beforeRouteUpdate）"></a>动态路由（也就是把routers中的path改了: 多对一，传参而已。另外注意watch和beforeRouteUpdate）</h2><p><strong>除了这个传参，还有url 这个query传参</strong><br><strong>上面的例子中router里面都是静态的,一一对应</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/bar"</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">const routes = [</span><br><span class="line">  &#123; path: '/foo', component: Foo &#125;,</span><br><span class="line">  &#123; path: '/bar', component: Bar &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>我们来看下动态路由，然后比较他们的区别</strong></p>
<p>我们经常需要把某种模式匹配到的所有路由，<strong>全都映射到同个组件(组件复用)</strong>。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用『动态路径参数』（dynamic segment）来达到这个效果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//这还是原来的User组件</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">//动态路由下复用这个User组件，改为</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    // 动态路径参数 以冒号开头</span><br><span class="line">    &#123; path: '/user/:id', component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性，<strong>使用 props</strong> 将组件和路由解耦，<strong>详见路由组件传参</strong></p>
</blockquote>
<p>现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。</p>
<p>一个『路径参数』使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。于是，我们可以更新 User 的模板，输出当前用户的 ID：</p>
<p>这里如果你看<code>&lt;router-link&gt;</code>这个to还是不动的，该foo该bar。只是routes和组件内变化(毕竟动态)</p>
<blockquote>
<p>把这个当做函数的传参记，比如<code>&lt;router-link to=&quot;/ser/foo&quot;&gt;</code>这个to中传过来一个foo,(这里的话还是和静态一样，只是routes变了，组件复用当然也给改，就是拿出参数问题)<br>然后再routers中的{ path: ‘/user/:id’, component: User } 匹配到了这个id，成了这么一个对象{id：foo}<br>最后去User组件中用$route.params这个对象可以拿出来用，毕竟就是传过来用的<br>还有就是beforeRouteUpdate的用处</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:center">匹配路径</th>
<th style="text-align:center">$route.params</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/user/:username</td>
<td style="text-align:center">/user/evan</td>
<td style="text-align:center">{ username: ‘evan’ }</td>
</tr>
<tr>
<td style="text-align:left">/user/:username/post/:post_id</td>
<td style="text-align:center">/user/evan/post/123</td>
<td style="text-align:center">{ username: ‘evan’, post_id: 123 }</td>
</tr>
</tbody>
</table>
</div>
<p><strong>响应路由参数的变化</strong><br>提醒一下，当使用路由参数时，例如从 /user/foo 导航到 /user/bar，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会再被调用</strong>。</p>
<p>复用组件时，想对路由参数的变化作出响应的话，你可以简单地 <strong>watch（监测变化） $route 对象</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: '...',</span><br><span class="line">  watch: &#123;</span><br><span class="line">    '$route' (to, from) &#123;</span><br><span class="line">      // 对路由变化作出响应...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者使用 2.2 中引入的 beforeRouteUpdate 守卫：</span><br><span class="line"></span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '...',</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    // react to route changes...</span><br><span class="line">    // don't forget to call next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>匹配优先级</strong><br>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p>
<h2 id="嵌套路由-就是一个套一个，在-lt-router-view-gt-中套，在routes中套children-同级的呢，命名看命名视图"><a href="#嵌套路由-就是一个套一个，在-lt-router-view-gt-中套，在routes中套children-同级的呢，命名看命名视图" class="headerlink" title="嵌套路由 (就是一个套一个，在&lt;router-view&gt;中套，在routes中套children)(同级的呢，命名看命名视图)"></a>嵌套路由 (就是一个套一个，在<code>&lt;router-view&gt;</code>中套，在routes中套children)(同级的呢，命名看命名视图)</h2><p>前面的例子并没有嵌套，现在搞下嵌套</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//这个是默认app挂在的地方，看到app了么</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//这是User组件</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">//配置哦</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: '/user/:id', component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在app中的 <code>&lt;router-view&gt;</code>是最顶层的出口，渲染最高级路由匹配到的组件。同样地，一个被渲染组件同样可以包含自己的嵌套 <router-view>。例如，在 User 组件的模板添加一个 <router-view>：</router-view></router-view></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//这是User组件，现在就有两层了</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//要在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置(上面嵌套了2层，**想一下再往下呢，就是再放一个children咯**)：</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: '/user/:id', component: User,</span><br><span class="line">      children: [   //要再嵌套可以在放一个children</span><br><span class="line">        &#123;</span><br><span class="line">          // 当 /user/:id/profile 匹配成功，</span><br><span class="line">          // UserProfile 会被渲染在 User 的 <span class="tag">&lt;<span class="name">router-view</span>&gt;</span> 中</span><br><span class="line">          path: 'profile',    //可以注意这里是相对路径哦</span><br><span class="line">          component: UserProfile</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          // 当 /user/:id/posts 匹配成功</span><br><span class="line">          // UserPosts 会被渲染在 User 的 <span class="tag">&lt;<span class="name">router-view</span>&gt;</span> 中</span><br><span class="line">          path: 'posts',</span><br><span class="line">          component: UserPosts</span><br><span class="line">        &#125;,</span><br><span class="line">        // 这是一个当做默认路由的，空路由</span><br><span class="line">        // 当 /user/:id 匹配成功，</span><br><span class="line">        // UserHome 会被渲染在 User 的 <span class="tag">&lt;<span class="name">router-view</span>&gt;</span> 中</span><br><span class="line">        &#123; path: '', component: UserHome &#125;,</span><br><span class="line"></span><br><span class="line">        // ...其他子路由</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>问题</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//嵌套不是这样嵌套，</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//也不是这样哦。  嵌套是一对一啊，这个user套在app去，同理 你要多层的嵌套就再导入一个组件呗，在那个组件里写router-view</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span> <span class="comment">&lt;!-- 不报错，不过反正是丢弃 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//还有既然这样不行，那么直接在router-view写东西怎么样，和slot一回事么</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span></span><br><span class="line">    在这写东西怎么处理的？<span class="comment">&lt;!-- 这个直接丢弃了 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>有时候，通过一个<strong>名称来标识(name)</strong>一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。(只要先记住name好了，下面的编程式路由接着往下看)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: '/user/:userId',</span><br><span class="line">      name: 'user',   //就多了这个name</span><br><span class="line">      component: User</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>要链接到一个命名路由，可以给 <code>&lt;router-link&gt;</code>的 <strong>to 属性</strong>传一个<strong>对象</strong>：(这块往下看)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这跟代码调用 router.push() 是一回事(就是编程式路由一回事)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>这两种方式都会把路由导航到 /user/123 路径。</p>
<h2 id="编程式的导航-借助-router-的实例方法，通过编写代码来实现，重要的是学to的参数用法"><a href="#编程式的导航-借助-router-的实例方法，通过编写代码来实现，重要的是学to的参数用法" class="headerlink" title="编程式的导航(借助 router 的实例方法，通过编写代码来实现，重要的是学to的参数用法)"></a>编程式的导航(借助 router 的<strong>实例方法</strong>，通过编写代码来实现，重要的是学to的参数用法)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.push(location, onComplete?, onAbort?)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 2.2.0+，可选的在 router.push 或 router.replace 中提供 onComplete 和 onAbort 回调作为第二个和第三个参数。这些回调将会在导航<strong>成功完成</strong> (在所有的异步钩子被解析之后) 或<strong>终止</strong> (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。</p>
<p>注意：如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 /users/1 -&gt; /users/2)，你需要使用 <strong>beforeRouteUpdate</strong> 来响应这个变化 (比如抓取用户信息) (就是前面的动态路由 组件复用)。</p>
</blockquote>
<p>注意：在 <strong>Vue 实例内部</strong>，你可以通过 $router 访问路由实例。因此你可以调用 <strong>this.$router.push</strong>。</p>
<p>想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p>
<p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code>(看到这个用了v-bind哦动态) 等同于调用 router.push(…)。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">声明式</th>
<th style="text-align:center">编程式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>
<td style="text-align:center">router.push(…)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>上面没啥，下面重要来了，to的参数</strong><br><strong>同样的规则也适用于 router-link 组件的 to 属性。</strong></p>
<p>该方法的参数可以是一个<strong>字符串路径</strong>，或者一个描述地址的<strong>对象</strong>。例如：</p>
<p><strong>(3种传参，[path]/[name params]/[path/name+query])</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">router.push('home')</span><br><span class="line"></span><br><span class="line">// 对象</span><br><span class="line">router.push(&#123; path: 'home' &#125;)</span><br><span class="line"></span><br><span class="line">// 命名的路由</span><br><span class="line">router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;)</span><br><span class="line"></span><br><span class="line">// 带查询参数，变成 /register?plan=private</span><br><span class="line">router.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Get请求传参, 看最后一个带查询参数<br>这个明明实在不好形容啊。不过真的是和Get请求一样。你完全可以在链接后加上?进行传参。<br>样例：<a href="http://localhost:8080/linkParamsQuestion?age=18" target="_blank" rel="noopener">http://localhost:8080/linkParamsQuestion?age=18</a><br>项目里获取：<br><code>let age = this.$route.query.age;</code> //问号后面参数会被封装进 this.$route.query;</p>
</blockquote>
<p>注意：<strong>如果提供了 path，params 会被忽略(毕竟路径就代表参数)</strong>，上述例子中的 <strong>query 并不属于这种情况</strong>。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const userId = 123</span><br><span class="line">router.push(&#123; name: 'user', params: &#123; userId &#125;&#125;) // -&gt; /user/123</span><br><span class="line">router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123  es6写法</span><br><span class="line">// 这里的 params 不生效</span><br><span class="line">router.push(&#123; path: '/user', params: &#123; userId &#125;&#125;) // -&gt; /user</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>router.replace(location, onComplete?, onAbort?)</strong></p>
<p>跟 router.push 很像，唯一的不同就是，<strong>它不会向 history 添加新记录</strong>，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">声明式</th>
<th style="text-align:center">编程式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>
<td style="text-align:center">router.replace(…)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>router.go(n)</strong><br>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。</p>
<p>例子<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在浏览器记录中前进一步，等同于 history.forward()</span><br><span class="line">router.go(1)</span><br><span class="line"></span><br><span class="line">// 后退一步记录，等同于 history.back()</span><br><span class="line">router.go(-1)</span><br><span class="line"></span><br><span class="line">// 前进 3 步记录</span><br><span class="line">router.go(3)</span><br><span class="line"></span><br><span class="line">// 如果 history 记录不够用，那就默默地失败呗</span><br><span class="line">router.go(-100)</span><br><span class="line">router.go(100)</span><br></pre></td></tr></table></figure></p>
<p><strong>操作 History(我怎么觉得这东西都不用了)</strong><br>你也许注意到 router.push、 router.replace 和 router.go 跟 window.history.pushState、 window.history.replaceState 和 window.history.go好像， 实际上它们确实是效仿 window.history API 的。</p>
<p>因此，如果你已经熟悉 Browser History APIs，那么在 vue-router 中操作 history 就是超级简单的。</p>
<p>还有值得提及的，vue-router 的导航方法 （push、 replace、 go） 在各类路由模式（history、 hash 和 abstract）下表现一致。</p>
<h2 id="命名视图-同级的视图view，前面讲过嵌套的"><a href="#命名视图-同级的视图view，前面讲过嵌套的" class="headerlink" title="命名视图(同级的视图view，前面讲过嵌套的)"></a>命名视图(同级的视图view，前面讲过嵌套的)</h2><p>有时候想同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 <strong>sidebar（侧导航） 和 main（主内容） 两个视图</strong>，这个时候命名视图就派上用场了。你可以在界面中<strong>拥有多个单独命名的视图</strong>，而不是只有一个单独的出口。如果 router-view <strong>没有设置名字</strong>，那么<strong>默认为 default</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view one"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view two"</span> <span class="attr">name</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view three"</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个视图使用一个组件渲染，因此对于同个路由，<strong>多个视图就需要多个组件</strong>。确保正确使用 <strong>components 配置（带上 s）</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: '/',</span><br><span class="line">      components: &#123;</span><br><span class="line">        default: Foo,</span><br><span class="line">        a: Bar,</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>嵌套命名视图(厉害了，嵌套，同级的合在一起)</strong></p>
<p>重点记住这个就好了<br>我们也有可能使用命名视图创建嵌套视图的复杂布局。这时你也需要命名用到的嵌套 router-view 组件。我们以一个设置面板为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/settings/emails                                       /settings/profile</span><br><span class="line">+-----------------------------------+                  +------------------------------+</span><br><span class="line">| UserSettings                      |                  | UserSettings                 |</span><br><span class="line">| +-----+-------------------------+ |                  | +-----+--------------------+ |</span><br><span class="line">| | Nav | UserEmailsSubscriptions | |  +------------&gt;  | | Nav | UserProfile        | |</span><br><span class="line">| |     +-------------------------+ |                  | |     +--------------------+ |</span><br><span class="line">| |     |                         | |                  | |     | UserProfilePreview | |</span><br><span class="line">| +-----+-------------------------+ |                  | +-----+--------------------+ |</span><br><span class="line">+-----------------------------------+                  +------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>UserSettings 是一个视图组件。</li>
<li>Nav 只是一个常规组件。</li>
<li>UserEmailsSubscriptions、UserProfile、UserProfilePreview 是嵌套的视图组件。</li>
</ul>
<p>就是UserSettings下有左右两块，右边那块又有嵌套。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- UserSettings.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>User Settings<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">NavBar</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"helper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  path: '/settings',</span><br><span class="line">  // 你也可以在顶级路由就配置命名视图</span><br><span class="line">  component: UserSettings,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    path: 'emails',</span><br><span class="line">    component: UserEmailsSubscriptions</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: 'profile',</span><br><span class="line">    components: &#123;</span><br><span class="line">      default: UserProfile,</span><br><span class="line">      helper: UserProfilePreview</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重定向-和-别名"><a href="#重定向-和-别名" class="headerlink" title="重定向 和 别名"></a>重定向 和 别名</h2><p><strong>重定向(一对一，有3种: ‘’, name, =&gt;)</strong></p>
<p>重定向也是通过 <strong>routes 配置</strong>来完成，下面例子是从 /a 重定向到 /b：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/a',</span><br><span class="line">      redirect: '/b'  //就加了这么一条redirect</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>重定向的目标也可以是一个<strong>命名的路由(和编程式to的 name写法一样)</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/a', </span><br><span class="line">      redirect: &#123; name: 'foo' &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>甚至是一个<strong>方法(es6的箭头函数)</strong>，动态返回重定向目标：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/a', </span><br><span class="line">      redirect: to =&gt; &#123;</span><br><span class="line">      // 方法接收 目标路由 作为参数</span><br><span class="line">      // return 重定向的 字符串路径/路径对象</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意<strong>导航守卫并没有应用在跳转路由上</strong>，而仅仅应用在其目标上。在下面这个例子中，为 /a 路由添加一个 beforeEach 或 beforeLeave 守卫并不会有任何效果。</p>
<p><strong>别名(一对多)</strong><br>『<strong>重定向</strong>』的意思是，当用户访问 /a时，URL 将会被<strong>替换成 /b</strong>，然后匹配路由为 /b，那么『别名』又是什么呢？</p>
<p>/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。</p>
<p>上面对应的路由配置为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/a', </span><br><span class="line">      component: A, </span><br><span class="line">      alias: '/b' </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>『别名』的功能让你可以自由地将 UI 结构<strong>映射到任意的 URL</strong>，而<strong>不是受限于配置的嵌套路由结构</strong>。</p>
<h2 id="路由组件传参-props-也有3种模式-布尔，对象，函数"><a href="#路由组件传参-props-也有3种模式-布尔，对象，函数" class="headerlink" title="路由组件传参(props 也有3种模式: 布尔，对象，函数)"></a>路由组件传参(props 也有3种模式: 布尔，对象，函数)</h2><p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。</p>
<p><strong>使用 props 将组件和路由解耦，取代与 $route 的耦合</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//这是动态路由那块的东西</span><br><span class="line">const User = &#123;</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: '/user/:id', component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>通过 props 解耦</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  props: ['id'],</span><br><span class="line">  template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>User &#123;&#123; id &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: '/user/:id', component: User, props: true &#125;,</span><br><span class="line"></span><br><span class="line">    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span><br><span class="line">    &#123;</span><br><span class="line">      path: '/user/:id',</span><br><span class="line">      components: &#123; default: User, sidebar: Sidebar &#125;,</span><br><span class="line">      props: &#123; default: true, sidebar: false &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>布尔模式</strong><br>如果 props 被设置为 true，route.params 将会被设置为组件属性。</p>
<p><strong>对象模式</strong><br>如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/promotion/from-newsletter', </span><br><span class="line">      component: Promotion, </span><br><span class="line">      props: &#123; newsletterPopup: false &#125; <span class="comment">&lt;!-- 这个newsletterPopup是name么？和布尔模式啥区别，就是同级的用命名视图解耦用么？ --&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>函数模式</strong><br>你可以创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: '/search', </span><br><span class="line">      component: SearchUser, </span><br><span class="line">      props: (route) =&gt; (&#123; query: route.query.q &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>URL /search?q=vue 会将 {query: ‘vue’} 作为属性传递给 SearchUser 组件。</p>
<p><strong>请尽可能保持 props 函数为无状态的</strong>，因为它只会在路由发生变化时起作用。如果你需要状态来定义 props，请使用包装组件，这样 Vue 才可以对状态变化做出反应。</p>
<h2 id="HTML5-History-模式-暂时不知道"><a href="#HTML5-History-模式-暂时不知道" class="headerlink" title="HTML5 History 模式(暂时不知道)"></a>HTML5 History 模式(暂时不知道)</h2><hr>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="导航守卫（『导航』表示路由正在发生改变。暂时用全局的）"><a href="#导航守卫（『导航』表示路由正在发生改变。暂时用全局的）" class="headerlink" title="导航守卫（『导航』表示路由正在发生改变。暂时用全局的）"></a>导航守卫（『导航』表示路由正在发生改变。暂时用全局的）</h2><p><strong>(做登录拦截 或 loading)</strong></p>
<p>正如其名，vue-router 提供的导航守卫主要用来<strong>通过跳转或取消的方式守卫导航</strong>。有多种机会植入路由导航过程中：<strong>全局的, 单个路由独享的, 或者组件级的。</strong><br>记住<strong>参数或查询的改变并不会触发进入/离开的导航守卫</strong>。你可以通过观察(watch) $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。</p>
<h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><p>你可以使用 <strong>router.beforeEach</strong> 注册一个全局前置守卫：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当一个导航触发时，全局前置守卫<strong>按照创建顺序调用</strong>。守卫是<strong>异步</strong>解析执行，此时导航在所有守卫 <strong>resolve 完之前一直处于 等待</strong>中。</p>
<p>每个守卫方法接收<strong>三个参数</strong>：</p>
<p>to: Route: 即将要进入的目标 路由对象</p>
<p>from: Route: 当前导航正要离开的路由</p>
<p>next: Function: 一定要<strong>调用该方法来 resolve</strong> 这个钩子。执行<strong>效果依赖 next 方法</strong>的调用参数。</p>
<ul>
<li><p>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。</p>
</li>
<li><p>next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。</p>
</li>
<li><p>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。</p>
</li>
<li><p>next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</p>
</li>
</ul>
<p><strong>确保要调用 next 方法，否则钩子就不会被 resolved。</strong></p>
<h3 id="全局解析守卫（router-beforeResolve）"><a href="#全局解析守卫（router-beforeResolve）" class="headerlink" title="全局解析守卫（router.beforeResolve）"></a>全局解析守卫（router.beforeResolve）</h3><p>2.5.0 新增</p>
<p>在 2.5.0+ 你可以用 <strong>router.beforeResolve</strong> 注册一个<strong>全局守卫</strong>。这和 router.beforeEach 类似，<strong>区别</strong>是在导航被确认之前，<strong>同时</strong>在<strong>所有</strong>组件内守卫和异步路由组件<strong>被解析之后</strong>，解析守卫就被调用。</p>
<h3 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h3><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子<strong>不会接受 next 函数也不会改变导航本身</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="组件内的守卫-3个"><a href="#组件内的守卫-3个" class="headerlink" title="组件内的守卫(3个)"></a>组件内的守卫(3个)</h3><p>最后，你可以在路由组件内直接定义以下路由导航守卫：</p>
<p>beforeRouteEnter<br>beforeRouteUpdate (2.2 新增)<br>beforeRouteLeave</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const Foo = &#123;</span><br><span class="line">  template: `...`,</span><br><span class="line">  beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">    // 不！能！获取组件实例 `this`</span><br><span class="line">    // 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br><span class="line">    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">    // 可以访问组件实例 `this`</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">    // 导航离开该组件的对应路由时调用</span><br><span class="line">    // 可以访问组件实例 `this`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>beforeRouteEnter 守卫 <strong>不能访问 this</strong>，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</p>
<p>不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">  next(vm =&gt; &#123;</span><br><span class="line">    // 通过 `vm` 访问组件实例</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 beforeRouteEnter <strong>是支持给 next 传递回调的唯一守卫</strong>。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">  // just use `this`</span><br><span class="line">  this.name = to.params.name</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave (to, from , next) &#123;</span><br><span class="line">  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')</span><br><span class="line">  if (answer) &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next(false)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ol>
<h2 id="路由元信息-可以用来搞允许登录页面"><a href="#路由元信息-可以用来搞允许登录页面" class="headerlink" title="路由元信息(可以用来搞允许登录页面)"></a>路由元信息(可以用来搞允许登录页面)</h2><p>定义路由的时候可以配置 meta 字段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: '/foo',</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: 'bar',</span><br><span class="line">          component: Bar,</span><br><span class="line">          // a meta field 和props挺像的啊</span><br><span class="line">          //设置一个允不允许登录的标志</span><br><span class="line">          meta: &#123; requiresAuth: true &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>那么<strong>如何访问</strong>这个 meta 字段呢？</p>
<p><strong>用处</strong></p>
<p>首先，我们称呼 routes 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录</p>
<p>例如，根据上面的路由配置，/foo/bar 这个 URL 将会<strong>匹配父路由记录以及子路由记录</strong>。</p>
<p>一个路由匹配到的所有路由记录会暴露为 $route 对象（还有在导航守卫中的路由对象）的 <strong>$route.matched</strong> 数组。因此，我们需要遍历 $route.matched 来检查路由记录中的 meta 字段。</p>
<p>下面例子展示在<strong>全局导航守卫中检查</strong>元字段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//全局导航守卫</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  //这个就难懂了</span><br><span class="line">  if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123;</span><br><span class="line">    // this route requires auth, check if logged in</span><br><span class="line">    // if not, redirect to login page 登录页.</span><br><span class="line">    //这个auth.loggedIn 方法是外部引入的，你可以先写好一个校验是否登录的方法，再import进 router.js中去判断</span><br><span class="line">    if (!auth.loggedIn()) &#123;</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: '/login',</span><br><span class="line">        query: &#123; redirect: to.fullPath &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next() // 确保一定要调用 next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="过渡效果-暂时不管"><a href="#过渡效果-暂时不管" class="headerlink" title="过渡效果(暂时不管)"></a>过渡效果(暂时不管)</h2><h2 id="数据获取（这里有渲染导航，还有获取数据两块的）"><a href="#数据获取（这里有渲染导航，还有获取数据两块的）" class="headerlink" title="数据获取（这里有渲染导航，还有获取数据两块的）"></a>数据获取（这里有渲染导航，还有获取数据两块的）</h2><p>有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：</p>
<ul>
<li><p><strong>导航完成之后</strong>获取：先完成导航，然后在接下来的<strong>组件生命周期钩子</strong>中获取数据。在<strong>数据获取期间显示『加载中』之类</strong>的指示。</p>
</li>
<li><p>导航完成<strong>之前</strong>获取：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。</p>
</li>
</ul>
<p>从技术角度讲，两种方式都不错(我喜欢之后的) —— 就看你想要的用户体验是哪种。</p>
<h3 id="导航完成后获取数据"><a href="#导航完成后获取数据" class="headerlink" title="导航完成后获取数据"></a>导航完成后获取数据</h3><p>当你使用这种方式时，我们会<strong>马上导航和渲染组件</strong>，然后在组件的<strong>created 钩子中获取数据</strong>。这让我们有机会在数据获取期间展示<strong>一个 loading 状态</strong>，还可以在<strong>不同视图间展示不同的 loading</strong> 状态。</p>
<p>假设我们有一个 Post 组件，需要基于 $route.params.id 获取文章数据：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading"</span> <span class="attr">v-if</span>=<span class="string">"loading"</span>&gt;</span></span><br><span class="line">      Loading...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"error"</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line">      &#123;&#123; error &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"post"</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; post.title &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; post.body &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      loading: false,</span><br><span class="line">      post: null,</span><br><span class="line">      error: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    // 组件创建完后获取数据，</span><br><span class="line">    // 此时 data 已经被 observed 了</span><br><span class="line">    this.fetchData()</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    // 如果路由有变化，会再次执行该方法</span><br><span class="line">    '$route': 'fetchData'</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fetchData () &#123;</span><br><span class="line">      this.error = this.post = null</span><br><span class="line">      this.loading = true</span><br><span class="line">      // replace getPost with your data fetching util / API wrapper</span><br><span class="line">      getPost(this.$route.params.id, (err, post) =&gt; &#123;</span><br><span class="line">        this.loading = false</span><br><span class="line">        if (err) &#123;</span><br><span class="line">          this.error = err.toString()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.post = post</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在导航完成前获取数据"><a href="#在导航完成前获取数据" class="headerlink" title="在导航完成前获取数据"></a>在导航完成前获取数据</h3><p>通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 <strong>beforeRouteEnter</strong> 守卫中获取数据，当数据获取成功后只调用 next 方法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      post: null,</span><br><span class="line">      error: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class="line">      next(vm =&gt; vm.setData(err, post))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 路由改变前，组件就已经渲染完了</span><br><span class="line">  // 逻辑稍稍不同</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    this.post = null</span><br><span class="line">    getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class="line">      this.setData(err, post)</span><br><span class="line">      next()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    setData (err, post) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        this.error = err.toString()</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.post = post</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，<strong>显示一些进度条或者别的指示</strong>。如果数据获取失败，同样有必要展示一些全局的错误提醒。</p>
<h3 id="滚动行为-就是跳转后滚动条位置确定-用scrollBehavior方法"><a href="#滚动行为-就是跳转后滚动条位置确定-用scrollBehavior方法" class="headerlink" title="滚动行为(就是跳转后滚动条位置确定, 用scrollBehavior方法)"></a>滚动行为(就是跳转后滚动条位置确定, 用scrollBehavior方法)</h3><p>使用前端路由，当<strong>切换到新路由</strong>时，想要页面滚到<strong>顶部</strong>，或者是保持<strong>原先</strong>的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p>
<p><strong>注意: 这个功能只在支持 history.pushState 的浏览器中可用。</strong></p>
<p>当创建一个 Router 实例，你可以提供一个 <strong>scrollBehavior</strong> 方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [...],</span><br><span class="line">  scrollBehavior (to, from, savedPosition) &#123;  </span><br><span class="line">    // return 期望滚动到哪个的位置</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>scrollBehavior 方法<strong>接收 to 和 from 路由对象</strong>。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。</p>
<p>这个方法返回滚动位置的对象信息，长这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; x: number, y: number &#125;</span><br><span class="line">&#123; selector: string, offset? : &#123; x: number, y: number &#125;&#125; (offset 只在 2.6.0+ 支持)</span><br></pre></td></tr></table></figure>
<p>如果返回一个 falsy (译者注：falsy 不是 false，参考这里)的值，或者是一个空对象，那么不会发生滚动。</p>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">  return &#123; x: 0, y: 0 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于所有路由导航，简单地让页面滚动到顶部<br>返回 savedPosition，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">  if (savedPosition) &#123;</span><br><span class="line">    return savedPosition</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &#123; x: 0, y: 0 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你要模拟『<strong>滚动到锚点</strong>』的行为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">  if (to.hash) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      selector: to.hash</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="路由懒加载-路由不用变，变的是webpack配置，和我想的有点不一样"><a href="#路由懒加载-路由不用变，变的是webpack配置，和我想的有点不一样" class="headerlink" title="路由懒加载(路由不用变，变的是webpack配置，和我想的有点不一样)"></a>路由懒加载(路由不用变，变的是webpack配置，和我想的有点不一样)</h3><h2 id="Router-构造配置"><a href="#Router-构造配置" class="headerlink" title="Router 构造配置"></a>Router 构造配置</h2><p><strong>routes</strong>(<strong>一看感觉都见过了，确实</strong>)<br>类型: Array<routeconfig></routeconfig></p>
<p>RouteConfig 的类型定义：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">declare type RouteConfig = &#123;</span><br><span class="line">  path: string;</span><br><span class="line">  component?: Component;</span><br><span class="line">  name?: string; // 命名路由</span><br><span class="line">  components?: &#123; [name: string]: Component &#125;; // 命名视图组件</span><br><span class="line">  redirect?: string | Location | Function;</span><br><span class="line">  props?: boolean | string | Function;</span><br><span class="line">  alias?: string | Array<span class="tag">&lt;<span class="name">string</span>&gt;</span>;</span><br><span class="line">  children?: Array<span class="tag">&lt;<span class="name">RouteConfig</span>&gt;</span>; // 嵌套路由</span><br><span class="line">  beforeEnter?: (to: Route, from: Route, next: Function) =&gt; void;</span><br><span class="line">  meta?: any;</span><br><span class="line"></span><br><span class="line">  // 2.6.0+</span><br><span class="line">  caseSensitive?: boolean; // 匹配规则是否大小写敏感？(默认值：false)</span><br><span class="line">  pathToRegexpOptions?: Object; // 编译正则的选项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>mode(一种hash， 一种history)</strong><br>类型: string</p>
<p>默认值: “hash” (浏览器环境) | “abstract” (Node.js 环境)</p>
<p>可选值: “hash” | “history” | “abstract”</p>
<p>配置路由模式:</p>
<p>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。</p>
<p>history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</p>
<p>abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。</p>
<p><strong>base</strong><br>类型: string</p>
<p>默认值: “/“</p>
<p><strong>应用的基路径</strong>。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 “/app/“。<br>一般写成 <strong>__dirname</strong>，在<strong>webpack</strong>中有配置。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/vue-router/" rel="tag"># vue-router</a>
          
            <a href="/tags/vuejs/" rel="tag"># vuejs</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/31/vue2getstart/" rel="next" title="vue2getstart">
                <i class="fa fa-chevron-left"></i> vue2getstart
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/04/vuex使用总结/" rel="prev" title="vuex使用总结">
                vuex使用总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatarMogu.jpg" alt="Henry x">
            
              <p class="site-author-name" itemprop="name">Henry x</p>
              <p class="site-description motion-element" itemprop="description">this is description</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">65</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="weibo" target="_blank">weibo</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#vue-route-这货是个插件"><span class="nav-number">1.</span> <span class="nav-text">vue-route(这货是个插件)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本的路由-静态路由"><span class="nav-number">1.1.</span> <span class="nav-text">基本的路由(静态路由)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态路由（也就是把routers中的path改了-多对一，传参而已。另外注意watch和beforeRouteUpdate）"><span class="nav-number">1.2.</span> <span class="nav-text">动态路由（也就是把routers中的path改了: 多对一，传参而已。另外注意watch和beforeRouteUpdate）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套路由-就是一个套一个，在-lt-router-view-gt-中套，在routes中套children-同级的呢，命名看命名视图"><span class="nav-number">1.3.</span> <span class="nav-text">嵌套路由 (就是一个套一个，在&lt;router-view&gt;中套，在routes中套children)(同级的呢，命名看命名视图)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名路由"><span class="nav-number">1.4.</span> <span class="nav-text">命名路由</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编程式的导航-借助-router-的实例方法，通过编写代码来实现，重要的是学to的参数用法"><span class="nav-number">1.5.</span> <span class="nav-text">编程式的导航(借助 router 的实例方法，通过编写代码来实现，重要的是学to的参数用法)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名视图-同级的视图view，前面讲过嵌套的"><span class="nav-number">1.6.</span> <span class="nav-text">命名视图(同级的视图view，前面讲过嵌套的)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重定向-和-别名"><span class="nav-number">1.7.</span> <span class="nav-text">重定向 和 别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由组件传参-props-也有3种模式-布尔，对象，函数"><span class="nav-number">1.8.</span> <span class="nav-text">路由组件传参(props 也有3种模式: 布尔，对象，函数)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML5-History-模式-暂时不知道"><span class="nav-number">1.9.</span> <span class="nav-text">HTML5 History 模式(暂时不知道)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进阶"><span class="nav-number">2.</span> <span class="nav-text">进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#导航守卫（『导航』表示路由正在发生改变。暂时用全局的）"><span class="nav-number">2.1.</span> <span class="nav-text">导航守卫（『导航』表示路由正在发生改变。暂时用全局的）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全局守卫"><span class="nav-number">2.1.1.</span> <span class="nav-text">全局守卫</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局解析守卫（router-beforeResolve）"><span class="nav-number">2.1.2.</span> <span class="nav-text">全局解析守卫（router.beforeResolve）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局后置钩子"><span class="nav-number">2.1.3.</span> <span class="nav-text">全局后置钩子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组件内的守卫-3个"><span class="nav-number">2.1.4.</span> <span class="nav-text">组件内的守卫(3个)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完整的导航解析流程"><span class="nav-number">2.1.5.</span> <span class="nav-text">完整的导航解析流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由元信息-可以用来搞允许登录页面"><span class="nav-number">2.2.</span> <span class="nav-text">路由元信息(可以用来搞允许登录页面)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过渡效果-暂时不管"><span class="nav-number">2.3.</span> <span class="nav-text">过渡效果(暂时不管)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据获取（这里有渲染导航，还有获取数据两块的）"><span class="nav-number">2.4.</span> <span class="nav-text">数据获取（这里有渲染导航，还有获取数据两块的）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#导航完成后获取数据"><span class="nav-number">2.4.1.</span> <span class="nav-text">导航完成后获取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在导航完成前获取数据"><span class="nav-number">2.4.2.</span> <span class="nav-text">在导航完成前获取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#滚动行为-就是跳转后滚动条位置确定-用scrollBehavior方法"><span class="nav-number">2.4.3.</span> <span class="nav-text">滚动行为(就是跳转后滚动条位置确定, 用scrollBehavior方法)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由懒加载-路由不用变，变的是webpack配置，和我想的有点不一样"><span class="nav-number">2.4.4.</span> <span class="nav-text">路由懒加载(路由不用变，变的是webpack配置，和我想的有点不一样)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Router-构造配置"><span class="nav-number">2.5.</span> <span class="nav-text">Router 构造配置</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Henry x</span>

  

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.1"></script>



  



	





  





  










  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  

</body>
</html>
