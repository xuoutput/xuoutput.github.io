<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.1',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  
  <meta name="keywords" content="数据结构,">


<meta name="description" content="数据结构中的常用算法总结首先介绍4个可视化数据结构的网址,推荐度从前往后  visualgo sorting Data Structure Visualizations algo-visualizer  书籍  Algorithms, 4th Edition algorithmsSedgewick assignment   topal  排序 sort insert 折半 shell bubble">
<meta name="keywords" content="数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构中的常用算法总结">
<meta property="og:url" content="http://yoursite.com/2018/04/15/数据结构中的常用算法总结/index.html">
<meta property="og:site_name" content="Little H title">
<meta property="og:description" content="数据结构中的常用算法总结首先介绍4个可视化数据结构的网址,推荐度从前往后  visualgo sorting Data Structure Visualizations algo-visualizer  书籍  Algorithms, 4th Edition algorithmsSedgewick assignment   topal  排序 sort insert 折半 shell bubble">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-11-16T12:50:23.764Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构中的常用算法总结">
<meta name="twitter:description" content="数据结构中的常用算法总结首先介绍4个可视化数据结构的网址,推荐度从前往后  visualgo sorting Data Structure Visualizations algo-visualizer  书籍  Algorithms, 4th Edition algorithmsSedgewick assignment   topal  排序 sort insert 折半 shell bubble">






  <link rel="canonical" href="http://yoursite.com/2018/04/15/数据结构中的常用算法总结/">


  <title>数据结构中的常用算法总结 | Little H title</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Little H title</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">this is subtitle</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益404</a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/数据结构中的常用算法总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry x">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatarMogu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little H title">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据结构中的常用算法总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-15T23:18:18+08:00">2018-04-15</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="数据结构中的常用算法总结"><a href="#数据结构中的常用算法总结" class="headerlink" title="数据结构中的常用算法总结"></a>数据结构中的常用算法总结</h1><p>首先介绍4个可视化数据结构的网址,推荐度从前往后</p>
<ol>
<li><a href="https://visualgo.net/" target="_blank" rel="noopener">visualgo</a></li>
<li><a href="http://sorting.at/" target="_blank" rel="noopener">sorting</a></li>
<li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">Data Structure Visualizations</a></li>
<li><a href="http://algo-visualizer.jasonpark.me/#path=sorting/insertion/basic" target="_blank" rel="noopener">algo-visualizer</a></li>
</ol>
<p>书籍</p>
<ol>
<li><a href="https://algs4.cs.princeton.edu/home/" target="_blank" rel="noopener">Algorithms, 4th Edition</a><ul>
<li><a href="https://github.com/aistrate/AlgorithmsSedgewick" target="_blank" rel="noopener">algorithmsSedgewick</a></li>
<li><a href="https://introcs.cs.princeton.edu/java/assignments/" target="_blank" rel="noopener">assignment</a></li>
</ul>
</li>
<li><a href="https://www.toptal.com/developers/sorting-algorithms/" target="_blank" rel="noopener">topal</a></li>
</ol>
<h1 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序 sort"></a>排序 sort</h1><ol>
<li>insert</li>
<li>折半</li>
<li>shell</li>
<li>bubble</li>
<li>quick</li>
<li>select</li>
<li>heap</li>
<li>merge</li>
<li>基数</li>
</ol>
<h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h2><h3 id="ALGORITHM"><a href="#ALGORITHM" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>:n<span class="number">-1</span>,</span><br><span class="line">    <span class="keyword">for</span> (j = i; <span class="number">1</span> &lt;= j <span class="keyword">and</span> a[j<span class="number">-1</span>] &gt; a[j]; j--)</span><br><span class="line">        swap a[j<span class="number">-1</span>, j]</span><br><span class="line">    → invariant: a[<span class="number">1.</span>.i] is sorted</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>注解:</strong> 默认数组a下标就是1开始. k从i开始,例如一开始就是从第2个元素起步a[2]和第一个元素a[1]比较, 一趟比较完后k随着i++进行下一趟比较, i是用来确定一趟的最后一个元素位置. k&gt;1是说最后比较只会是a[1] a[2] 不会a[0] a[1]因为不存在a[0], 下标从1开始, 最后一趟是从a[n-1] a[n]开始比较.</p>
<p>注意这个不需要一个数组 用来特别往后移动.</p>
<blockquote>
<p>外层循环记录着每趟起始和终止位置,代表趟数;内层是比较方式. 要根据可视化的过程来决定外层怎么写. 比如select的 是小的放最前还是大的放最外层不一样.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">插入排序 </span></span><br><span class="line"><span class="comment">基本思想：将元素逐个添加到已经排好序的数组中去。 </span></span><br><span class="line"><span class="comment">平均时间复杂度O(n^2) </span></span><br><span class="line"><span class="comment">最好时间复杂度O(n) </span></span><br><span class="line"><span class="comment">最坏时间复杂度O(n^2) </span></span><br><span class="line"><span class="comment">空间复杂度O(1) </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span> <span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++)&#123;<span class="comment">//假设第0个已在正确位置，从第一个开始插入</span></span><br><span class="line">        <span class="comment">//第i趟插入需要在[0，i-1]中从后往前找到i的合适位置</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = i; <span class="number">1</span> &lt;= j &amp;&amp; a[j<span class="number">-1</span>] &gt; a[j]; j--)&#123;</span><br><span class="line">            swap(a[j<span class="number">-1</span>],a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span> <span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要进行n-1趟插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; <span class="number">0</span> &lt; j &amp;&amp; a[j<span class="number">-1</span>] &gt; a[j]; j--) &#123;  <span class="comment">// 0&lt;=j 不对哦 j是从1开始</span></span><br><span class="line">            swap(a[j<span class="number">-1</span>], a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span> <span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; <span class="number">1</span> &lt;= j &amp;&amp; a[j<span class="number">-1</span>] &lt; a[j]; j--) &#123;</span><br><span class="line">            swap(a[j<span class="number">-1</span>], a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内循环中将较大的元素一次性向右移动而不是交换两个元素，这样访问数组的次数将减半 。其代码如下：</span></span><br><span class="line">真的么?</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = data.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = data[i];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">//要插入的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; data[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                data[j] = data[j<span class="number">-1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                index = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION"><a href="#DISCUSSION" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>尽管存在最坏情况(worst-case)是O(n2), 也就是逆序(reversed)的情况下, insertion sort 在data几乎有序(这个叫adaptive)和问题size很小(这个叫low overhead 低开销)的情况下还是一个很好的选择.</p>
<p>还有他是<strong>stable</strong>的, insertion sort is often used as the <strong>recursive base case</strong> (when the problem size is <strong>small</strong>) for higher overhead 分治divide-and-conquer sorting algorithms, such as merge sort or quick sort.</p>
<h3 id="PROPERTIES"><a href="#PROPERTIES" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Stable</li>
<li>O(1) extra space</li>
<li>O(n2) comparisons and swaps</li>
<li>Adaptive: O(n) time when nearly sorted</li>
<li>Very low overhead</li>
</ul>
<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">将直接插入排序中寻找a[i]插入位置的方法改为二分查找，然后再一次性向右移动元素。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = binaryFind(a, a[i], <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        <span class="comment">//num后的元素向后移动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; num &lt; j; j--) &#123;</span><br><span class="line">           a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a[num] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出元素应在数组中插入的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binaryFind</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> temp, <span class="keyword">int</span> down, <span class="keyword">int</span> up)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(up&lt;down || up&gt;data.length || down&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"下标错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp &lt; data[down]) <span class="keyword">return</span> down;</span><br><span class="line">    <span class="keyword">if</span>(temp &gt; data[up]) <span class="keyword">return</span> up+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (up-down)/<span class="number">2</span> + down;</span><br><span class="line">    <span class="keyword">if</span>(temp == data[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp &lt; data[mid]) &#123;</span><br><span class="line">        up = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; data[mid]) &#123;</span><br><span class="line">        down = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binaryFind(data,temp, down, up);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell Sort"></a>Shell Sort</h2><h3 id="ALGORITHM-1"><a href="#ALGORITHM-1" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> h &lt; n, h = <span class="number">3</span>*h + <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> h &gt; <span class="number">0</span>,</span><br><span class="line">    h = h / <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span>:h, insertion sort a[k:h:n]</span><br><span class="line">    → invariant: each h-sub-<span class="built_in">array</span> is sorted</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>注解:</strong> 首先按n大小计算递增序列,这里是按1 4 13 40 来, 然后从最大的h开始. 注意有一步<code>h = h / 3</code> 这就是比n小的最大的h, 因为前一个while跳出就是h&gt;n的情况,还得返回去. 然后a[1,4] a[2, 5] 这样按insertion sort比较 a[k:h:n]  是从k到n以k为间隔</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">5、希尔排序 </span></span><br><span class="line"><span class="comment">基本思想：将无序数组分成若干个子序列，子序列不是逐段分割的，而是相隔特定增量。对各个子序列进行插入排序。 </span></span><br><span class="line"><span class="comment">然后再选择一个更小的增量，再将数组分割成多个子序列进行排序。最后选择增量为1，即使用直接插入排序，使最终数组成为有序数组。 </span></span><br><span class="line"><span class="comment">平均时间复杂度O(n^1.3) </span></span><br><span class="line"><span class="comment">最好时间复杂度O(n) </span></span><br><span class="line"><span class="comment">最坏时间复杂度O(n^2) </span></span><br><span class="line"><span class="comment">空间复杂度O(1) </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap;</span><br><span class="line">    <span class="keyword">for</span>( gap = n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &lt; a[j + gap]; j-=gap)&#123;<span class="comment">//每个元素与自己组内的元素进行插入排序</span></span><br><span class="line">                swap(a[j], a[j + gap]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n) &#123;</span><br><span class="line">        h = <span class="number">3</span>*h +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        h = h/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= h<span class="number">-1</span>; k++) &#123; <span class="comment">//根据增量分成若干组  每个h对应趟数</span></span><br><span class="line">            <span class="comment">// insert_sort的理解</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = k+h; i &lt;= n<span class="number">-1</span>; i=i+h)&#123;<span class="comment">//假设第0个已在正确位置，从第一个开始插入  </span></span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">int</span> j = i; k+h &lt;= j &amp;&amp; a[j-h] &gt; a[j]; j=j-h)&#123;  <span class="comment">//不能加 k&lt;= j 用k+h &lt;= j也对</span></span><br><span class="line">                    swap(a[j-h],a[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for ( int k = 0; k &lt;= h-1; k++) &#123; //根据增量分成若干组  </span></span><br><span class="line">            <span class="comment">// insert_sort()</span></span><br><span class="line">            <span class="comment">// for(int i = k+h; i &lt;= n-1; i=i+h)&#123;//假设第0个已在正确位置，从第一个开始插入  </span></span><br><span class="line">            <span class="comment">//     for ( int j = i; k &lt;= j &amp;&amp; a[j-h] &gt; a[j]; j=j-h)&#123;</span></span><br><span class="line">            <span class="comment">//         swap(a[j-h],a[j]);</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//核心算法，增量序列 1 4 13 ....（3*h+1）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h &lt; n/<span class="number">3</span>) <span class="comment">// 注意这里变了 </span></span><br><span class="line">        h = <span class="number">3</span>*h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt;= n<span class="number">-1</span>; i++) &#123; <span class="comment">//这种事按4的比完,再按5比完.而不是048这样. 8的这种后面会比到的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; h &lt;= j &amp;&amp; a[j-h] &gt; a[j]; j = j-h) &#123;</span><br><span class="line">                swap(a[j-h], a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION-1"><a href="#DISCUSSION-1" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>shell sort最坏情况时间复杂度(The worse-case time complexity)依赖于递增序列(the increment sequence). 这里所使用的the increments 1 4 13 40 121…, 时间复杂度是 O(n3/2). For other increments, time complexity is known to be O(n4/3) and even O(n·lg2(n)). 既不存在时间复杂度的紧上界，也不知道最佳增量序列。</p>
<p>Because shell sort is based on insertion sort, shell sort inherits insertion sort’s <strong>adaptive properties</strong>. The adapation is not as dramatic because shell sort requires one pass through the data for each increment, but it is significant. For the increment sequence shown above, there are log3(n) increments, so the time complexity for nearly sorted data is O(n·log3(n)).</p>
<p>Because of its <strong>low overhead, relatively simple implementation, adaptive properties, and sub-quadratic time complexity</strong>, shell sort may be a viable alternative to the O(n·lg(n)) sorting algorithms for some applications when the data to be sorted is not very large.</p>
<h3 id="PROPERTIES-1"><a href="#PROPERTIES-1" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Not stable</li>
<li>O(1) extra space</li>
<li>O(n3/2) time as shown (see below)</li>
<li>Adaptive: O(n·lg(n)) time when nearly sorted</li>
</ul>
<h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h2><h3 id="ALGORITHM-2"><a href="#ALGORITHM-2" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = n<span class="number">-1</span>:<span class="number">0</span>,</span><br><span class="line">    swapped = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span>:i; n--</span><br><span class="line">        <span class="keyword">if</span> a[j<span class="number">-1</span>] &gt; a[j],</span><br><span class="line">            swap a[j<span class="number">-1</span>,j]</span><br><span class="line">            swapped = <span class="literal">true</span></span><br><span class="line">    → invariant: a[i..n<span class="number">-1</span>] in final position</span><br><span class="line">    <span class="keyword">break</span> <span class="keyword">if</span> <span class="keyword">not</span> swapped</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> Bubble sort每趟排序完后最后一个元素到位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">冒泡排序 </span></span><br><span class="line"><span class="comment">基本思想： 不断比较相邻的两个数，让较大的数不断地往后移。经过一番比较，就选出了最大的数。经过第二轮比较，就选出了次大的数。以此类推。 </span></span><br><span class="line"><span class="comment">那么对于大小为N的数组，需要N-1轮比较。 </span></span><br><span class="line"><span class="comment">平均时间复杂度O（N^2） </span></span><br><span class="line"><span class="comment">最好情况O（N） </span></span><br><span class="line"><span class="comment">最坏情况O（N^2） </span></span><br><span class="line"><span class="comment">空间复杂度O（1） </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//要进行N-1轮比较, 这里记录趟数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n<span class="number">-2</span>; i++ )<span class="comment">//[0,n-2]恰好n-1轮比较</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> is_sorted = <span class="literal">true</span>;  <span class="comment">// 是否交换的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n<span class="number">-1</span>-i; j++)<span class="comment">//已经排好序的最后i个不用比较，要比较的数的个数为n-i个，那么需要比较的次数为n-i-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j<span class="number">-1</span>] &gt; a[j])&#123;</span><br><span class="line">                is_sorted = <span class="literal">false</span>;</span><br><span class="line">                swap(a[j<span class="number">-1</span>],a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_sorted)<span class="comment">//如果没有发生交换，说明已经排好序了，提前退出循环,所以最好情况下时间复杂度为O（N）</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; <span class="number">1</span> &lt;= i; i-- ) <span class="comment">// 这个好理解</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> is_sorted = <span class="literal">true</span>;  <span class="comment">// 是否交换的标志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j<span class="number">-1</span>] &gt; a[j])&#123;</span><br><span class="line">                is_sorted = <span class="literal">false</span>;</span><br><span class="line">                swap(a[j<span class="number">-1</span>],a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_sorted) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION-2"><a href="#DISCUSSION-2" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>Bubble sort has many of the same properties as insertion sort, but has <strong>slightly higher overhead</strong>. In the case of nearly sorted data, bubble sort takes O(n) time, but requires at least 2 passes through the data (whereas insertion sort requires something more like 1 pass).</p>
<h3 id="PROPERTIES-2"><a href="#PROPERTIES-2" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Stable</li>
<li>O(1) extra space</li>
<li>O(n2) comparisons and swaps</li>
<li>Adaptive: O(n) when nearly sorted</li>
</ul>
<h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><h3 id="ALGORITHM-3"><a href="#ALGORITHM-3" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_<span class="meta"># choose pivot_</span></span><br><span class="line">swap a[<span class="number">1</span>,rand(<span class="number">1</span>,n)]</span><br><span class="line"></span><br><span class="line">_# <span class="number">2</span>-way partition_</span><br><span class="line">k = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">2</span>:n, <span class="keyword">if</span> a[i] &lt; a[<span class="number">1</span>], swap a[++k,i]</span><br><span class="line">swap a[<span class="number">1</span>,k]</span><br><span class="line">_→ invariant: a[<span class="number">1.</span>.k<span class="number">-1</span>] &lt; a[k] &lt;= a[k+<span class="number">1.</span>.n]_</span><br><span class="line"></span><br><span class="line">_# recursive sorts_</span><br><span class="line">sort a[<span class="number">1.</span>.k<span class="number">-1</span>]</span><br><span class="line">sort a[k+<span class="number">1</span>,n]</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> Quick sort有好几种</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">3、快速排序 </span></span><br><span class="line"><span class="comment">基本思想：采用分而治之的思想，将要排序的数分成左右两部分，其中一部分的数据比key小，另一部分数据比key大。然后将所分得的两部分数据进行同样的划分。重复执行以上的划分操作。</span></span><br><span class="line"><span class="comment">平均时间复杂度O（Nlog2(N)）</span></span><br><span class="line"><span class="comment">最好情况O（Nlog2(N)）</span></span><br><span class="line"><span class="comment">最坏情况O（N^2）</span></span><br><span class="line"><span class="comment">空间复杂度O（Nlog2(N)）</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><span class="comment">//返回划分的中间值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    key = arr[low];<span class="comment">//相当于在索引low处挖坑，下一个就要找合适的据来填坑</span></span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; key &lt;= arr[high])&#123;</span><br><span class="line">            high --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">            arr[low ++] = arr[high];<span class="comment">//找到合适的数据填到了lo坑，但是形成了high坑，继续找合适的数据</span></span><br><span class="line">        <span class="keyword">while</span>( low &lt; high &amp;&amp; arr[low] &lt;= key)</span><br><span class="line">            low ++;</span><br><span class="line">        <span class="keyword">if</span>( low &lt; high)</span><br><span class="line">            arr[high --] =  arr[low];<span class="comment">//low又成了坑</span></span><br><span class="line"></span><br><span class="line">    arr[low] = key;<span class="comment">//将key填到这个坑</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        pos = partition(num, low, high);</span><br><span class="line">        quick_sort(num, low, pos<span class="number">-1</span>);</span><br><span class="line">        quick_sort(num, pos+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*快速排序非递归版*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort2</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = num[low];</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = partition(num, low, high);</span><br><span class="line">        <span class="keyword">if</span>(pos<span class="number">-1</span> &gt; low)&#123;</span><br><span class="line">            s.push(pos - <span class="number">1</span>);</span><br><span class="line">            s.push(low);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos+<span class="number">1</span> &lt; high)&#123;</span><br><span class="line">            s.push(high);</span><br><span class="line">            s.push(pos + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> l = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">int</span> r = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            pos = partition(num, l, r);</span><br><span class="line">            <span class="keyword">if</span>(pos - <span class="number">1</span> &gt; l)&#123;</span><br><span class="line">                s.push(pos - <span class="number">1</span>);</span><br><span class="line">                s.push(l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">                s.push(r);</span><br><span class="line">                s.push(pos + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=low,j=high,key=arr[low];<span class="comment">//i j 是需要的 low high用来递归 不能动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &gt; j)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &lt;= arr[j])&#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">            arr[i ++] = arr[j];<span class="comment">//找到合适的数据填到了low坑，但是形成了high坑，继续找合适的数据</span></span><br><span class="line">        <span class="keyword">while</span>( i &lt; j &amp;&amp; arr[i] &lt;= key)</span><br><span class="line">            i ++;</span><br><span class="line">        <span class="keyword">if</span>( i &lt; j)</span><br><span class="line">            arr[j --] =  arr[i];<span class="comment">//low又成了坑</span></span><br><span class="line">    &#125;</span><br><span class="line">	arr[i] = key;<span class="comment">//将key填到这个坑 一趟后</span></span><br><span class="line"></span><br><span class="line">    quick_sort(arr,low,i<span class="number">-1</span>);</span><br><span class="line">    quick_sort(arr,i+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION-3"><a href="#DISCUSSION-3" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>When carefully implemented, quick sort is <strong>robust and has low overhead</strong>. When a stable sort is not needed, quick sort is an excellent general-purpose sort – although the <strong>3-way</strong> partitioning version should always be used instead.</p>
<p>The 2-way partitioning code shown above is written for clarity rather than optimal performance; it exhibits poor locality, and, critically, exhibits O(n2) time when there are few unique keys. A more efficient and robust 2-way partitioning method is given in Quicksort is Optimal by Robert Sedgewick and Jon Bentley. The robust partitioning produces balanced recursion when there are many values equal to the pivot, yielding probabilistic guarantees of O(n·lg(n)) time and O(lg(n)) space for all inputs.</p>
<p>With both sub-sorts performed recursively, quick sort requires O(n) extra space for the recursion stack in the worst case when recursion is not balanced. This is exceedingly unlikely to occur, but it can be avoided by sorting the smaller sub-array recursively first; the second sub-array sort is a tail recursive call, which may be done with iteration instead. With this optimization, the algorithm uses O(lg(n)) extra space in the worst case.</p>
<h3 id="PROPERTIES-3"><a href="#PROPERTIES-3" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Not stable</li>
<li>O(lg(n)) extra space (see discussion)</li>
<li>O(n2) time, but typically O(n·lg(n)) time</li>
<li>Not adaptive</li>
</ul>
<h2 id="Quick-Sort-3-Way"><a href="#Quick-Sort-3-Way" class="headerlink" title="Quick Sort 3 Way"></a>Quick Sort 3 Way</h2><h3 id="ALGORITHM-4"><a href="#ALGORITHM-4" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">_<span class="meta"># choose pivot_</span></span><br><span class="line">swap a[n,rand(<span class="number">1</span>,n)]</span><br><span class="line"></span><br><span class="line">_# <span class="number">3</span>-way partition_</span><br><span class="line">i = <span class="number">1</span>, k = <span class="number">1</span>, p = n</span><br><span class="line"><span class="keyword">while</span> i &lt; p,</span><br><span class="line">  <span class="keyword">if</span> a[i] &lt; a[n], swap a[i++,k++]</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> a[i] == a[n], swap a[i,--p]</span><br><span class="line">  <span class="keyword">else</span> i++</span><br><span class="line">end</span><br><span class="line">_→ invariant: a[p..n] all equal_</span><br><span class="line">_→ invariant: a[<span class="number">1.</span>.k<span class="number">-1</span>] &lt; a[p..n] &lt; a[k..p<span class="number">-1</span>]_</span><br><span class="line"></span><br><span class="line">_# move pivots to center_</span><br><span class="line">m = min(p-k,n-p+<span class="number">1</span>)</span><br><span class="line">swap a[k..k+m<span class="number">-1</span>,n-m+<span class="number">1.</span>.n]</span><br><span class="line"></span><br><span class="line">_# recursive sorts_</span><br><span class="line">sort a[<span class="number">1.</span>.k<span class="number">-1</span>]</span><br><span class="line">sort a[n-p+k+<span class="number">1</span>,n]</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION-4"><a href="#DISCUSSION-4" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>The 3-way partition variation of quick sort has slightly higher overhead compared to the standard 2-way partition version. Both have the same best, typical, and worst case time bounds, but this version is highly adaptive in the very common case of sorting with few unique keys.</p>
<p>The 3-way partitioning code shown above is written for clarity rather than optimal performance; it exhibits poor locality, and performs more swaps than necessary. A more efficient but more elaborate 3-way partitioning method is given in Quicksort is Optimal by Robert Sedgewick and Jon Bentley.</p>
<p>When stability is not required, quick sort is the general purpose sorting algorithm of choice. Recently, a novel dual-pivot variant of 3-way partitioning has been discovered that beats the single-pivot 3-way partitioning method both in theory and in practice.</p>
<h3 id="PROPERTIES-4"><a href="#PROPERTIES-4" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Not stable</li>
<li>O(lg(n)) extra space</li>
<li>O(n2) time, but typically O(n·lg(n)) time</li>
<li>Adaptive: O(n) time when O(1) unique keys</li>
</ul>
<h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h2><h3 id="ALGORITHM-5"><a href="#ALGORITHM-5" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>:n<span class="number">-1</span>,</span><br><span class="line">    min = i</span><br><span class="line">    <span class="keyword">for</span> j = i+<span class="number">1</span>:n<span class="number">-1</span>, </span><br><span class="line">        <span class="keyword">if</span> a[min] &gt; a[j], min = j</span><br><span class="line">    → invariant: a[min] smallest of a[i..n<span class="number">-1</span>]</span><br><span class="line">    swap a[i,min]</span><br><span class="line">    → invariant: a[<span class="number">0.</span>.i] in final position</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 每一趟可以选择最小的放到最前面,也可以选最大的放最后面. k使用存放临时极小值(极大值). 最后一趟比完才最后确定.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">选择排序 </span></span><br><span class="line"><span class="comment">基本思想：首先，选出最小的数放在第一位，然后选择第二小的数，放在第二位；以此类推，直到所有的数从小到大排列. </span></span><br><span class="line"><span class="comment">那么，对于大小为N的数组需要N-1轮选择过程。第i轮选取第i小的数，请将其放在第i个位置上。</span></span><br><span class="line"><span class="comment">不稳定 </span></span><br><span class="line"><span class="comment">平均时间复杂度O（N^2）</span></span><br><span class="line"><span class="comment">最好情况O（N^2）</span></span><br><span class="line"><span class="comment">最坏情况O（N^2）</span></span><br><span class="line"><span class="comment">空间复杂度O（1）</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n<span class="number">-1</span><span class="number">-1</span>; i++)&#123;<span class="comment">//进行n-1轮选择,也就是i的取值为[0，n-2] </span></span><br><span class="line">        <span class="keyword">int</span> min_index = i;</span><br><span class="line">        <span class="comment">//记录第i小的数所在的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[min_index] &gt; a[j]) <span class="comment">//有点谐</span></span><br><span class="line">                min_index = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != min_index)&#123;<span class="comment">//根据记录的第i小的数的索引，找到了第i小的数。然后将该数放到其正确位置。也就是第i个位置。</span></span><br><span class="line">            swap(a[i] , a[min_index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[min])</span><br><span class="line">                min=j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[i], a[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION-5"><a href="#DISCUSSION-5" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>从比较结果来看, 最好不要用selection sort <strong>should never be used</strong>. It does not adapt to the data in any way (notice that the four animations above run in lock step), 运行时间一直是平方项(quadratic).</p>
<p>但是有一个优点 selection sort 可以减少交换项数目. 可以应用于交换项cost很大的的情况.</p>
<h3 id="PROPERTIES-5"><a href="#PROPERTIES-5" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Not stable</li>
<li>O(1) extra space</li>
<li>Θ(n2) comparisons</li>
<li>Θ(n) swaps</li>
<li>Not adaptive</li>
</ul>
<h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><h3 id="ALGORITHM-6"><a href="#ALGORITHM-6" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># heapify</span></span><br><span class="line"><span class="keyword">for</span> i = n/<span class="number">2</span>:<span class="number">1</span>, sink(a,i,n)</span><br><span class="line">→ invariant: a[<span class="number">1</span>,n] in heap order</span><br><span class="line"></span><br><span class="line"># sortdown</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>:n,</span><br><span class="line">    swap a[<span class="number">1</span>,n-i+<span class="number">1</span>]</span><br><span class="line">    sink(a,<span class="number">1</span>,n-i)</span><br><span class="line">    → invariant: a[n-i+<span class="number">1</span>,n] in final position</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># sink from i in a[<span class="number">1.</span>.n]</span><br><span class="line">function sink(a,i,n):</span><br><span class="line">    # &#123;lc,rc,mc&#125; = &#123;left,right,max&#125; child index</span><br><span class="line">    lc = <span class="number">2</span>*i</span><br><span class="line">    <span class="keyword">if</span> lc &gt; n, <span class="keyword">return</span> # no children</span><br><span class="line">    rc = lc + <span class="number">1</span></span><br><span class="line">    mc = (rc &gt; n) ? lc : (a[lc] &gt; a[rc]) ? lc : rc</span><br><span class="line">    <span class="keyword">if</span> a[i] &gt;= a[mc], <span class="keyword">return</span> # heap ordered</span><br><span class="line">    swap a[i,mc]</span><br><span class="line">    sink(a,mc,n)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>完全二叉, 用的是数组,首先是建堆,然后再排序.<br>建堆(heapify)中确定大顶堆还是小顶堆. 从最后一个非叶子节点(n/2)开始比较,往上比较.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序:树形选择排序，将带排序记录看成完整的二叉树，第一步：建立初堆，第二步：调整堆</span></span><br><span class="line"><span class="comment">//第二步：调整堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span>  <span class="comment">//但习惯上用大顶堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调整为小根堆，从小到大</span></span><br><span class="line">    <span class="keyword">int</span> rc=a[s];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*s;j&lt;=n;j*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;n &amp;&amp; a[j]&gt;a[j+<span class="number">1</span>])<span class="comment">//判断左右子数大小,找小的</span></span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span>(rc&lt;=a[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        a[s]=a[j]; <span class="comment">//小的放上去</span></span><br><span class="line">        s=j;</span><br><span class="line">    &#125;</span><br><span class="line">    a[s]=rc;    <span class="comment">//大的放下来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一步：建初堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatHeap</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//小根堆,从最后一个非叶子节点开始,根是1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        HeapAdjust(a,i,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CreatHeap(a,n);<span class="comment">//第一步，建立初堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=a[<span class="number">1</span>];<span class="comment">//堆顶与最后一个元素互换</span></span><br><span class="line">        a[<span class="number">1</span>]=a[i];</span><br><span class="line">        a[i]=x;</span><br><span class="line">        HeapAdjust(a,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> *a=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)<span class="comment">//注意：这里是从1开始的</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[j];</span><br><span class="line">    HeapSort(a,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i];</span><br><span class="line">    <span class="keyword">delete</span> []a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//　　创建大堆顶，i为当节点，n为堆的大小</span></span><br><span class="line"><span class="comment">//    从第一个非叶子结点i从下至上，从右至左调整结构</span></span><br><span class="line"><span class="comment">//    从两个儿子节点中选出较大的来与父亲节点进行比较</span></span><br><span class="line"><span class="comment">//    如果儿子节点比父亲节点大，则进行交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatHeap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span>  n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    注意数组是从0开始计数，所以左节点为2*i+1，右节点为2*i+2</span></span><br><span class="line">    <span class="comment">// 这里改了吧 应该从1开始好</span></span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left = i * <span class="number">2</span> + <span class="number">1</span>;    <span class="comment">//左子树节点</span></span><br><span class="line">        <span class="keyword">int</span> right = i * <span class="number">2</span> + <span class="number">2</span>;    <span class="comment">//右子树节点</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//选出左右子节点中最大的</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n) &#123;</span><br><span class="line">            a[left] &gt; a[right] ? j= left : j = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = left;</span><br><span class="line">        <span class="comment">//交换子节点与父节点</span></span><br><span class="line">        <span class="keyword">if</span> (a[j] &gt; a[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    进行堆排序，依次选出最大值放到最后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//初始化构造堆</span></span><br><span class="line">    CreatHeap(a, n/<span class="number">2</span><span class="number">-1</span>, n);</span><br><span class="line">　　<span class="comment">//交换第一个元素和最后一个元素后，堆的大小减1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后一个元素和第一个元素进行交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = j / <span class="number">2</span> - <span class="number">1</span>;  <span class="comment">//有必要-1么</span></span><br><span class="line">        CreatHeap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">10</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">14</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    HeapSort(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"排序好的数组为："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[l]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span>  <span class="comment">//但习惯上用大顶堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调整为大根堆，</span></span><br><span class="line">    <span class="keyword">int</span> rc = a[s];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>*s; j &lt;= n; j*=<span class="number">2</span>) <span class="comment">// 有左子树,</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span> (j+<span class="number">1</span> &lt;= n ) &#123;	<span class="comment">//如果右子树存在</span></span><br><span class="line">			<span class="keyword">if</span>(a[j] &lt; a[j+<span class="number">1</span>])<span class="comment">//判断左右子数大小</span></span><br><span class="line">				j++;			</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(rc &gt;= a[j]) &#123;  <span class="comment">//根和左子树比</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;    </span><br><span class="line">        a[s] = a[j]; <span class="comment">//大的放上去</span></span><br><span class="line">        s = j;		<span class="comment">// 继续往大的子树的子树找,保证当前堆是大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    a[s] = rc;    <span class="comment">//小的放下来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一步：建初堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatHeap</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//小根堆,从最后一个非叶子节点开始,根是1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        HeapAdjust(a,i,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CreatHeap(a,n);<span class="comment">//第一步，建立初堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">2</span>; i--)  <span class="comment">//这里从n-1到2就可以了</span></span><br><span class="line">    &#123;</span><br><span class="line">		swap(a[<span class="number">1</span>], a[i]);</span><br><span class="line">        HeapAdjust(a,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION-6"><a href="#DISCUSSION-6" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>Heap sort is simple to implement, performs an O(n·lg(n)) in-place sort, but is not stable.</p>
<p>The first loop, the Θ(n) “heapify” phase, puts the array into heap order. The second loop, the O(n·lg(n)) “sortdown” phase, repeatedly extracts the maximum and restores heap order.</p>
<p>The sink function is written recursively for clarity. Thus, as shown, the code requires Θ(lg(n)) space for the recursive call stack. However, the tail recursion in sink() is easily converted to iteration, which yields the O(1) space bound.</p>
<p>Both phases are slightly adaptive, though not in any particularly useful manner. In the nearly sorted case, the heapify phase destroys the original order. In the reversed case, the heapify phase is as fast as possible since the array starts in heap order, but then the sortdown phase is typical. In the few unique keys case, there is some speedup but not as much as in shell sort or 3-way quicksort.</p>
<h3 id="PROPERTIES-6"><a href="#PROPERTIES-6" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Not stable</li>
<li>O(1) extra space (see discussion)</li>
<li>O(n·lg(n)) time</li>
<li>Not really adaptive</li>
</ul>
<h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><h3 id="ALGORITHM-7"><a href="#ALGORITHM-7" class="headerlink" title="ALGORITHM"></a>ALGORITHM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># split in half</span></span><br><span class="line">m = n / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"># recursive sorts</span><br><span class="line">sort a[<span class="number">1.</span>.m]</span><br><span class="line">sort a[m+<span class="number">1.</span>.n]</span><br><span class="line"></span><br><span class="line"># merge sorted sub-arrays <span class="keyword">using</span> temp <span class="built_in">array</span></span><br><span class="line">b = copy of a[<span class="number">1.</span>.m]</span><br><span class="line">i = <span class="number">1</span>, j = m+<span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= m <span class="keyword">and</span> j &lt;= n,</span><br><span class="line">    a[k++] = (a[j] &lt; b[i]) ? a[j++] : b[i++]</span><br><span class="line">    → invariant: a[<span class="number">1.</span>.k] in final position</span><br><span class="line"><span class="keyword">while</span> i &lt;= m,</span><br><span class="line">    a[k++] = b[i++]</span><br><span class="line">    → invariant: a[<span class="number">1.</span>.k] in final position</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">6、归并排序： </span></span><br><span class="line"><span class="comment">基本思想：将待排序序列【0，n-1】看成是n个长度为1的有序序列，将相邻的有序表成对归并，得到n/2个长度为2的有序表。再次归并，得到n/4个长度为4的有序表。 </span></span><br><span class="line"><span class="comment">依次类推，最后得到长度为n的1个有序表。 </span></span><br><span class="line"><span class="comment">所以归并排序其实要做两件事： </span></span><br><span class="line"><span class="comment">1、先递归的分解数列， </span></span><br><span class="line"><span class="comment">2、再合并数列就完成了归并排序。 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">先来考虑如何合并？ </span></span><br><span class="line"><span class="comment">每次合并过程中都要对两个有序的序列段进行合并，然后排序 </span></span><br><span class="line"><span class="comment">待合并的两个有序序列段分别为 R[low, mid] 和 R[mid+1, high] </span></span><br><span class="line"><span class="comment">先将它们合并到一个暂存数组R2，合并完再将R2复制回R1中。 </span></span><br><span class="line"><span class="comment">这样一次合并排序就完成了。 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">最好、最坏和平均时间复杂度都是O(nlogn)， </span></span><br><span class="line"><span class="comment">空间复杂度是O(n) </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low ,<span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> tmp[];</span><br><span class="line">    <span class="keyword">int</span> i,j,k;  </span><br><span class="line">    i = low;  <span class="comment">//i 和 j是临时会动的 所以新定义一个变量</span></span><br><span class="line">    j = mid + <span class="number">1</span>;</span><br><span class="line">    k = <span class="number">0</span>;<span class="comment">//k是存放临时合并数组的下表</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>( i &lt;= mid &amp;&amp; j &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">if</span>( a[i] &lt; a[j])  <span class="comment">// 小的元素放tmp</span></span><br><span class="line">            tmp[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( i &lt;= mid)</span><br><span class="line">        tmp[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>( j &lt;= high)</span><br><span class="line">        tmp[k++] = a[i++];</span><br><span class="line">    <span class="comment">//最后再复制回a</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i++ )</span><br><span class="line">        a[low+i] = tmp[i];<span class="comment">//!!!!此处a是从low开始，tmp是从0开始。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上完整程序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span> <span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    sort (a, <span class="number">0</span>, a.length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span> <span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right) / <span class="number">2</span>;  <span class="comment">// (right - left)/2 + left</span></span><br><span class="line">    sort (a, left, mid);</span><br><span class="line">    sort (a, mid+<span class="number">1</span>, right);</span><br><span class="line">    merge (a, left, mid, right);</span><br><span class="line">    print(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//改进 还有换一种自底向上的</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。</span><br><span class="line">首先考虑下如何将<span class="number">2</span>个有序数列合并。这个非常简单，只要从比较<span class="number">2</span>个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。</span><br><span class="line"></span><br><span class="line"><span class="comment">//将有序数组a[]和b[]合并到c[]中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemeryArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> b[], <span class="keyword">int</span> m, <span class="keyword">int</span> c[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line"> i = j = k = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (a[i] &lt; b[j])</span><br><span class="line">         c[k++] = a[i++];</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         c[k++] = b[j++]; </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (i &lt; n)</span><br><span class="line">     c[k++] = a[i++];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (j &lt; m)</span><br><span class="line">     c[k++] = b[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DISCUSSION-7"><a href="#DISCUSSION-7" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h3><p>Merge sort is very <strong>predictable</strong>. It makes between 0.5lg(n) and lg(n) comparisons per element, and between lg(n) and 1.5lg(n) swaps per element. The minima are achieved for already sorted data; the maxima are achieved, on average, for random data. If using Θ(n) extra space is of no concern, then merge sort is <strong>an excellent choice</strong>: It is simple to implement, and it is the only stable O(n·lg(n)) sorting algorithm. Note that when sorting linked lists, merge sort requires only Θ(lg(n)) extra space (for recursion).</p>
<p>Merge sort is the algorithm of choice for a variety of situations: <strong>when stability is required, when sorting linked lists, and when random access is much more expensive than sequential access</strong> (for example, external sorting on tape).</p>
<p>There do exist linear time in-place merge algorithms for the last step of the algorithm, but they are both expensive and complex. The complexity is justified for applications such as external sorting when Θ(n) extra space is not available.</p>
<h3 id="PROPERTIES-7"><a href="#PROPERTIES-7" class="headerlink" title="PROPERTIES"></a>PROPERTIES</h3><ul>
<li>Stable</li>
<li>Θ(n) extra space for arrays (as shown)</li>
<li>Θ(lg(n)) extra space for linked lists</li>
<li>Θ(n·lg(n)) time</li>
<li>Not adaptive</li>
<li>Does not require random access to data</li>
</ul>
<hr>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h1 id="树中"><a href="#树中" class="headerlink" title="树中"></a>树中</h1><h2 id="堆说过了"><a href="#堆说过了" class="headerlink" title="堆说过了"></a>堆说过了</h2>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构/" rel="tag"># 数据结构</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/17/HaiKu-OS/" rel="next" title="HaiKu_OS">
                <i class="fa fa-chevron-left"></i> HaiKu_OS
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/18/vscode上插件/" rel="prev" title="vscode上插件">
                vscode上插件 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatarMogu.jpg" alt="Henry x">
            
              <p class="site-author-name" itemprop="name">Henry x</p>
              <p class="site-description motion-element" itemprop="description">this is description</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">117</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">121</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="weibo" target="_blank">weibo</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构中的常用算法总结"><span class="nav-number">1.</span> <span class="nav-text">数据结构中的常用算法总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序-sort"><span class="nav-number">2.</span> <span class="nav-text">排序 sort</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Insertion-Sort"><span class="nav-number">2.1.</span> <span class="nav-text">Insertion Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ALGORITHM"><span class="nav-number">2.1.1.</span> <span class="nav-text">ALGORITHM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DISCUSSION"><span class="nav-number">2.1.2.</span> <span class="nav-text">DISCUSSION</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PROPERTIES"><span class="nav-number">2.1.3.</span> <span class="nav-text">PROPERTIES</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分"><span class="nav-number">2.2.</span> <span class="nav-text">二分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shell-Sort"><span class="nav-number">2.3.</span> <span class="nav-text">Shell Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ALGORITHM-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">ALGORITHM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DISCUSSION-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">DISCUSSION</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PROPERTIES-1"><span class="nav-number">2.3.3.</span> <span class="nav-text">PROPERTIES</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bubble-Sort"><span class="nav-number">2.4.</span> <span class="nav-text">Bubble Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ALGORITHM-2"><span class="nav-number">2.4.1.</span> <span class="nav-text">ALGORITHM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DISCUSSION-2"><span class="nav-number">2.4.2.</span> <span class="nav-text">DISCUSSION</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PROPERTIES-2"><span class="nav-number">2.4.3.</span> <span class="nav-text">PROPERTIES</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Quick-Sort"><span class="nav-number">2.5.</span> <span class="nav-text">Quick Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ALGORITHM-3"><span class="nav-number">2.5.1.</span> <span class="nav-text">ALGORITHM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DISCUSSION-3"><span class="nav-number">2.5.2.</span> <span class="nav-text">DISCUSSION</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PROPERTIES-3"><span class="nav-number">2.5.3.</span> <span class="nav-text">PROPERTIES</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Quick-Sort-3-Way"><span class="nav-number">2.6.</span> <span class="nav-text">Quick Sort 3 Way</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ALGORITHM-4"><span class="nav-number">2.6.1.</span> <span class="nav-text">ALGORITHM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DISCUSSION-4"><span class="nav-number">2.6.2.</span> <span class="nav-text">DISCUSSION</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PROPERTIES-4"><span class="nav-number">2.6.3.</span> <span class="nav-text">PROPERTIES</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Selection-Sort"><span class="nav-number">2.7.</span> <span class="nav-text">Selection Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ALGORITHM-5"><span class="nav-number">2.7.1.</span> <span class="nav-text">ALGORITHM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DISCUSSION-5"><span class="nav-number">2.7.2.</span> <span class="nav-text">DISCUSSION</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PROPERTIES-5"><span class="nav-number">2.7.3.</span> <span class="nav-text">PROPERTIES</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap-Sort"><span class="nav-number">2.8.</span> <span class="nav-text">Heap Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ALGORITHM-6"><span class="nav-number">2.8.1.</span> <span class="nav-text">ALGORITHM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DISCUSSION-6"><span class="nav-number">2.8.2.</span> <span class="nav-text">DISCUSSION</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PROPERTIES-6"><span class="nav-number">2.8.3.</span> <span class="nav-text">PROPERTIES</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Merge-Sort"><span class="nav-number">2.9.</span> <span class="nav-text">Merge Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ALGORITHM-7"><span class="nav-number">2.9.1.</span> <span class="nav-text">ALGORITHM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DISCUSSION-7"><span class="nav-number">2.9.2.</span> <span class="nav-text">DISCUSSION</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PROPERTIES-7"><span class="nav-number">2.9.3.</span> <span class="nav-text">PROPERTIES</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基数排序"><span class="nav-number">2.10.</span> <span class="nav-text">基数排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#树中"><span class="nav-number">3.</span> <span class="nav-text">树中</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#堆说过了"><span class="nav-number">3.1.</span> <span class="nav-text">堆说过了</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Henry x</span>

  

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.1"></script>



  



	





  





  










  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  

</body>
</html>
